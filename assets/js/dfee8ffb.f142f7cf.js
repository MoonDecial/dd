"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[4625],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function c(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function r(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?c(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):c(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},c=Object.keys(t);for(o=0;o<c.length;o++)e=c[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(t);for(o=0;o<c.length;o++)e=c[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var a=o.createContext({}),i=function(t){var n=o.useContext(a),e=n;return t&&(e="function"==typeof t?t(n):r(r({},n),t)),e},l=function(t){var n=i(t.components);return o.createElement(a.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,c=t.originalType,a=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),u=i(e),d=p,h=u["".concat(a,".").concat(d)]||u[d]||m[d]||c;return e?o.createElement(h,r(r({ref:n},l),{},{components:e})):o.createElement(h,r({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var c=e.length,r=new Array(c);r[0]=d;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=t,s[u]="string"==typeof t?t:p,r[1]=s;for(var i=2;i<c;i++)r[i]=e[i];return o.createElement.apply(null,r)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},2432:(t,n,e)=>{e.r(n),e.d(n,{default:()=>RP});var o=e(7896),p=(e(2784),e(876));const c={toc:[]};function r(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Property decorators."))}r.isMDXComponent=!0;const s={toc:[]};function a(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscriptions and triggering of events."))}a.isMDXComponent=!0;const i={toc:[]};function l(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},i,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,p.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches an asynchronous ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}h.isMDXComponent=!0;const y={toc:[]};function k(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}k.isMDXComponent=!0;const f={toc:[]};function D(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}D.isMDXComponent=!0;const M={toc:[]};function _(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},M,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}_.isMDXComponent=!0;const X={toc:[]};function w(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},X,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}w.isMDXComponent=!0;const T={toc:[]};function C(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},T,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}C.isMDXComponent=!0;const x={toc:[]};function g(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},x,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}g.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},L,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}Z.isMDXComponent=!0;const b={toc:[]};function v(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},b,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}v.isMDXComponent=!0;const N={toc:[]};function S(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}S.isMDXComponent=!0;const A={toc:[]};function G(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}G.isMDXComponent=!0;const P={toc:[]};function R(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}R.isMDXComponent=!0;const E={toc:[]};function I(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},E,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}I.isMDXComponent=!0;const W={toc:[]};function U(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},W,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}U.isMDXComponent=!0;const j={toc:[]};function z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}z.isMDXComponent=!0;const F={toc:[]};function O(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},F,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}O.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value argument to subscribers."))}V.isMDXComponent=!0;const B={toc:[]};function H(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},B,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A base for dispatching ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,p.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}H.isMDXComponent=!0;const Y={toc:[]};function J(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}J.isMDXComponent=!0;const K={toc:[]};function Q(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},K,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Q.isMDXComponent=!0;const $={toc:[]};function tt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}pt.isMDXComponent=!0;const ct={toc:[]};function rt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}rt.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}at.isMDXComponent=!0;const it={toc:[]};function lt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},it,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,p.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,p.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}ht.isMDXComponent=!0;const yt={toc:[]};function kt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}kt.isMDXComponent=!0;const ft={toc:[]};function Dt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}Dt.isMDXComponent=!0;const Mt={toc:[]};function _t(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Are subscribers being notified?"))}_t.isMDXComponent=!0;const Xt={toc:[]};function wt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Notify all current and future subscribers."))}wt.isMDXComponent=!0;const Tt={toc:[]};function Ct(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stop notifying future subscribers."))}Ct.isMDXComponent=!0;const xt={toc:[]};function gt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}gt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}Zt.isMDXComponent=!0;const bt={toc:[]};function vt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}vt.isMDXComponent=!0;const Nt={toc:[]};function St(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}St.isMDXComponent=!0;const At={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Gt.isMDXComponent=!0;const Pt={toc:[]};function Rt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Rt.isMDXComponent=!0;const Et={toc:[]};function It(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Et,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}It.isMDXComponent=!0;const Wt={toc:[]};function Ut(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Ut.isMDXComponent=!0;const jt={toc:[]};function zt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}zt.isMDXComponent=!0;const Ft={toc:[]};function Ot(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ft,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Ot.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Vt.isMDXComponent=!0;const Bt={toc:[]};function Ht(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Ht.isMDXComponent=!0;const Yt={toc:[]};function Jt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}Jt.isMDXComponent=!0;const Kt={toc:[]};function Qt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}Qt.isMDXComponent=!0;const $t={toc:[]};function tn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$t,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}pn.isMDXComponent=!0;const cn={toc:[]};function rn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}rn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}yn.isMDXComponent=!0;const kn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}fn.isMDXComponent=!0;const Dn={toc:[]};function Mn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Mn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_n,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Xn.isMDXComponent=!0;const wn={toc:[]};function Tn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Tn.isMDXComponent=!0;const Cn={toc:[]};function xn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}xn.isMDXComponent=!0;const gn={toc:[]};function Ln(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Ln.isMDXComponent=!0;const Zn={toc:[]};function bn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}bn.isMDXComponent=!0;const vn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value."))}Nn.isMDXComponent=!0;const Sn={toc:[]};function An(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}An.isMDXComponent=!0;const Gn={toc:[]};function Pn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Pn.isMDXComponent=!0;const Rn={toc:[]};function En(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set the current value of this dispatcher."))}En.isMDXComponent=!0;const In={toc:[]};function Wn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},In,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new value."))}Wn.isMDXComponent=!0;const Un={toc:[]};function jn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}jn.isMDXComponent=!0;const zn={toc:[]};function Fn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}Fn.isMDXComponent=!0;const On={toc:[]};function qn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},On,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}qn.isMDXComponent=!0;const Vn={toc:[]};function Bn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Bn.isMDXComponent=!0;const Hn={toc:[]};function Yn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Yn.isMDXComponent=!0;const Jn={toc:[]};function Kn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Kn.isMDXComponent=!0;const Qn={toc:[]};function $n(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}$n.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}oe.isMDXComponent=!0;const pe={toc:[]};function ce(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}ce.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},re,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}se.isMDXComponent=!0;const ae={toc:[]};function ie(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ie.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}de.isMDXComponent=!0;const he={toc:[]};function ye(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ye.isMDXComponent=!0;const ke={toc:[]};function fe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ke,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}fe.isMDXComponent=!0;const De={toc:[]};function Me(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},De,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}Me.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_e,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of times the timer has ticked."))}Xe.isMDXComponent=!0;const we={toc:[]};function Te(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator responsible for running this timer."))}Te.isMDXComponent=!0;const Ce={toc:[]};function xe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ce,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the timer ticks."))}xe.isMDXComponent=!0;const ge={toc:[]};function Le(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ge,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current iteration index."))}Le.isMDXComponent=!0;const Ze={toc:[]};function be(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}be.isMDXComponent=!0;const ve={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ve,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Ne.isMDXComponent=!0;const Se={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Se,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Ae.isMDXComponent=!0;const Ge={toc:[]};function Pe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Pe.isMDXComponent=!0;const Re={toc:[]};function Ee(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Re,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Ee.isMDXComponent=!0;const Ie={toc:[]};function We(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ie,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}We.isMDXComponent=!0;const Ue={toc:[]};function je(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.corenerRadius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}je.isMDXComponent=!0;const ze={toc:[]};function Fe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run tasks one after another."))}Fe.isMDXComponent=!0;const Oe={toc:[]};function qe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}qe.isMDXComponent=!0;const Ve={toc:[]};function Be(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Be.isMDXComponent=!0;const He={toc:[]};function Ye(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Ye.isMDXComponent=!0;const Je={toc:[]};function Ke(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Je,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay in seconds"))}Ke.isMDXComponent=!0;const Qe={toc:[]};function $e(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task or callback to run after the delay."))}$e.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Call the given callback every N seconds."))}oo.isMDXComponent=!0;const po={toc:[]};function co(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interval between subsequent calls."))}co.isMDXComponent=!0;const ro={toc:[]};function so(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ro,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to be called."))}so.isMDXComponent=!0;const ao={toc:[]};function io(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each time iteration waits until the previous one is completed."))}io.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator N times."))}ho.isMDXComponent=!0;const yo={toc:[]};function ko(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of iterations."))}ko.isMDXComponent=!0;const fo={toc:[]};function Do(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}Do.isMDXComponent=!0;const Mo={toc:[]};function _o(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Do nothing."))}_o.isMDXComponent=!0;const Xo={toc:[]};function wo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}wo.isMDXComponent=!0;const To={toc:[]};function Co(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},To,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}Co.isMDXComponent=!0;const xo={toc:[]};function go(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}go.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Zo.isMDXComponent=!0;const bo={toc:[]};function vo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}vo.isMDXComponent=!0;const No={toc:[]};function So(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional name used when displaying this generator in the UI."))}So.isMDXComponent=!0;const Ao={toc:[]};function Go(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}Go.isMDXComponent=!0;const Po={toc:[]};function Ro(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Po,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ro.isMDXComponent=!0;const Eo={toc:[]};function Io(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Io.isMDXComponent=!0;const Wo={toc:[]};function Uo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Uo.isMDXComponent=!0;const jo={toc:[]};function zo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay between each of the tasks."))}zo.isMDXComponent=!0;const Fo={toc:[]};function Oo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to be run in a sequence."))}Oo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Vo.isMDXComponent=!0;const Bo={toc:[]};function Ho(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the given amount of time."))}Ho.isMDXComponent=!0;const Yo={toc:[]};function Jo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The relative time in seconds."))}Jo.isMDXComponent=!0;const Ko={toc:[]};function Qo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ko,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}Qo.isMDXComponent=!0;const $o={toc:[]};function tp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the given time event."))}pp.isMDXComponent=!0;const cp={toc:[]};function rp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the time event."))}rp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}ap.isMDXComponent=!0;const ip={toc:[]};function lp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ip,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Main Motion Canvas classes."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when a new message is logged."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the meta file of a given entity."))}hp.isMDXComponent=!0;const yp={toc:[]};function kp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when metadata changes."))}kp.isMDXComponent=!0;const fp={toc:[]};function Dp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Load new metadata from a file."))}Dp.isMDXComponent=!0;const Mp={toc:[]};function _p(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New metadata."))}_p.isMDXComponent=!0;const Xp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any possible errors will be logged to the console."))}wp.isMDXComponent=!0;const Tp={toc:[]};function Cp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set data without waiting for confirmation."))}Cp.isMDXComponent=!0;const xp={toc:[]};function gp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New data."))}gp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the data stored in the meta file."))}Zp.isMDXComponent=!0;const bp={toc:[]};function vp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,p.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}vp.isMDXComponent=!0;const Np={toc:[]};function Sp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}))}Sp.isMDXComponent=!0;const Ap={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The project configuration."))}Gp.isMDXComponent=!0;const Pp={toc:[]};function Rp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the current scene changes."))}Rp.isMDXComponent=!0;const Ep={toc:[]};function Ip(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ep,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Ip.isMDXComponent=!0;const Wp={toc:[]};function Up(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after the scenes were recalculated."))}Up.isMDXComponent=!0;const jp={toc:[]};function zp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}zp.isMDXComponent=!0;const Fp={toc:[]};function Op(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Multi-media management."))}Op.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Vp.isMDXComponent=!0;const Bp={toc:[]};function Hp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause/resume the audio."))}Hp.isMDXComponent=!0;const Yp={toc:[]};function Jp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the audio should be paused or resumed."))}Jp.isMDXComponent=!0;const Kp={toc:[]};function Qp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The absolute biggest value from the peaks array."))}Qp.isMDXComponent=!0;const $p={toc:[]};function tc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of samples taken."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Samples per seconds."))}pc.isMDXComponent=!0;const cc={toc:[]};function rc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Playback control."))}rc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Abstract scene representations and related utilities."))}ac.isMDXComponent=!0;const ic={toc:[]};function lc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ic,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Signifies the various stages of a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs after a render ends."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}hc.isMDXComponent=!0;const yc={toc:[]};function kc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,p.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}kc.isMDXComponent=!0;const fc={toc:[]};function Dc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,p.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}Dc.isMDXComponent=!0;const Mc={toc:[]};function _c(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes the state of a scene."))}_c.isMDXComponent=!0;const Xc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}wc.isMDXComponent=!0;const Tc={toc:[]};function Cc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished transitioning in."))}Cc.isMDXComponent=!0;const xc={toc:[]};function gc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}gc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene is ready to transition out."))}Zc.isMDXComponent=!0;const bc={toc:[]};function vc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoking ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}vc.isMDXComponent=!0;const Nc={toc:[]};function Sc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished."))}Sc.isMDXComponent=!0;const Ac={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has just been created/reset."))}Gc.isMDXComponent=!0;const Pc={toc:[]};function Rc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The default implementation of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,p.kt)("p",null,"Uses generators to control the animation."))}Rc.isMDXComponent=!0;const Ec={toc:[]};function Ic(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ec,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Ic.isMDXComponent=!0;const Wc={toc:[]};function Uc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Uc.isMDXComponent=!0;const jc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}zc.isMDXComponent=!0;const Fc={toc:[]};function Oc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}Oc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Vc.isMDXComponent=!0;const Bc={toc:[]};function Hc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Hc.isMDXComponent=!0;const Yc={toc:[]};function Jc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Jc.isMDXComponent=!0;const Kc={toc:[]};function Qc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Qc.isMDXComponent=!0;const $c={toc:[]};function tr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}pr.isMDXComponent=!0;const cr={toc:[]};function rr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}rr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}ar.isMDXComponent=!0;const ir={toc:[]};function lr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ir,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}hr.isMDXComponent=!0;const yr={toc:[]};function kr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}kr.isMDXComponent=!0;const fr={toc:[]};function Dr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Dr.isMDXComponent=!0;const Mr={toc:[]};function _r(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}_r.isMDXComponent=!0;const Xr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}wr.isMDXComponent=!0;const Tr={toc:[]};function Cr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Cr.isMDXComponent=!0;const xr={toc:[]};function gr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}gr.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Zr.isMDXComponent=!0;const br={toc:[]};function vr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},br,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}vr.isMDXComponent=!0;const Nr={toc:[]};function Sr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Sr.isMDXComponent=!0;const Ar={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Gr.isMDXComponent=!0;const Pr={toc:[]};function Rr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}Rr.isMDXComponent=!0;const Er={toc:[]};function Ir(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Er,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Ir.isMDXComponent=!0;const Wr={toc:[]};function Ur(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Ur.isMDXComponent=!0;const jr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}zr.isMDXComponent=!0;const Fr={toc:[]};function Or(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Or.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}Vr.isMDXComponent=!0;const Br={toc:[]};function Hr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Br,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Lifecycle events for ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Hr.isMDXComponent=!0;const Yr={toc:[]};function Jr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A random number generator based on\n",(0,p.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,p.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Jr.isMDXComponent=!0;const Kr={toc:[]};function Qr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random floats in the given range."))}Qr.isMDXComponent=!0;const $r={toc:[]};function ts(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}ps.isMDXComponent=!0;const cs={toc:[]};function rs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random integers in the given range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"}),(0,p.kt)("li",{parentName:"ul"})))}rs.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}as.isMDXComponent=!0;const is={toc:[]};function ls(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},is,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random float in the given range."))}hs.isMDXComponent=!0;const ys={toc:[]};function ks(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ys,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ks.isMDXComponent=!0;const fs={toc:[]};function Ds(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}Ds.isMDXComponent=!0;const Ms={toc:[]};function _s(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ms,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random integer in the given range."))}_s.isMDXComponent=!0;const Xs={toc:[]};function ws(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ws.isMDXComponent=!0;const Ts={toc:[]};function Cs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ts,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}Cs.isMDXComponent=!0;const xs={toc:[]};function gs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a new independent generator."))}gs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ls,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Manages time events for a given scene."))}Zs.isMDXComponent=!0;const bs={toc:[]};function vs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when time events change."))}vs.isMDXComponent=!0;const Ns={toc:[]};function Ss(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the time offset of the given event."))}Ss.isMDXComponent=!0;const As={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the event."))}Gs.isMDXComponent=!0;const Ps={toc:[]};function Rs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ps,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The time offset in seconds."))}Rs.isMDXComponent=!0;const Es={toc:[]};function Is(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Es,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}Is.isMDXComponent=!0;const Ws={toc:[]};function Us(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ws,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes cached information about the timing of a scene."))}Us.isMDXComponent=!0;const js={toc:[]};function zs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a complete scene together with the meta file."))}zs.isMDXComponent=!0;const Fs={toc:[]};function Os(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Os.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}Vs.isMDXComponent=!0;const Bs={toc:[]};function Hs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Hs.isMDXComponent=!0;const Ys={toc:[]};function Js(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ys,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Js.isMDXComponent=!0;const Ks={toc:[]};function Qs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ks,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Qs.isMDXComponent=!0;const $s={toc:[]};function ta(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for the inspected element."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element for which to draw an overlay."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}pa.isMDXComponent=!0;const ca={toc:[]};function ra(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ra.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}aa.isMDXComponent=!0;const ia={toc:[]};function la(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ia,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the attributes of the inspected element."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to inspect."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a possible element to inspect at a given position."))}ha.isMDXComponent=!0;const ya={toc:[]};function ka(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ya,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x coordinate."))}ka.isMDXComponent=!0;const fa={toc:[]};function Da(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y coordinate."))}Da.isMDXComponent=!0;const Ma={toc:[]};function _a(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ma,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}_a.isMDXComponent=!0;const Xa={toc:[]};function wa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the inspected element is still valid."))}wa.isMDXComponent=!0;const Ta={toc:[]};function Ca(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ta,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to validate."))}Ca.isMDXComponent=!0;const xa={toc:[]};function ga(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event stored in a meta file."))}ga.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},La,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Za.isMDXComponent=!0;const ba={toc:[]};function va(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ba,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main interface for scenes."))}va.isMDXComponent=!0;const Na={toc:[]};function Sa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Sa.isMDXComponent=!0;const Aa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Ga.isMDXComponent=!0;const Pa={toc:[]};function Ra(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Ra.isMDXComponent=!0;const Ea={toc:[]};function Ia(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ea,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene's ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Ia.isMDXComponent=!0;const Wa={toc:[]};function Ua(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Ua.isMDXComponent=!0;const ja={toc:[]};function za(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}za.isMDXComponent=!0;const Fa={toc:[]};function Oa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Oa.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Va.isMDXComponent=!0;const Ba={toc:[]};function Ha(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ba,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Ha.isMDXComponent=!0;const Ya={toc:[]};function Ja(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ya,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ja.isMDXComponent=!0;const Ka={toc:[]};function Qa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ka,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Qa.isMDXComponent=!0;const $a={toc:[]};function ti(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}pi.isMDXComponent=!0;const ci={toc:[]};function ri(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}ri.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ai.isMDXComponent=!0;const ii={toc:[]};function li(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ii,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}hi.isMDXComponent=!0;const yi={toc:[]};function ki(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}ki.isMDXComponent=!0;const fi={toc:[]};function Di(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Di.isMDXComponent=!0;const Mi={toc:[]};function _i(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}_i.isMDXComponent=!0;const Xi={toc:[]};function wi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}wi.isMDXComponent=!0;const Ti={toc:[]};function Ci(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ti,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Ci.isMDXComponent=!0;const xi={toc:[]};function gi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}gi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Li,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Zi.isMDXComponent=!0;const bi={toc:[]};function vi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}vi.isMDXComponent=!0;const Ni={toc:[]};function Si(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Si.isMDXComponent=!0;const Ai={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Gi.isMDXComponent=!0;const Pi={toc:[]};function Ri(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Ri.isMDXComponent=!0;const Ei={toc:[]};function Ii(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ei,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each class implementing the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Ii.isMDXComponent=!0;const Wi={toc:[]};function Ui(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constructor used when creating new scenes."))}Ui.isMDXComponent=!0;const ji={toc:[]};function zi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,p.kt)("inlineCode",{parentName:"a"},"config")),"."))}zi.isMDXComponent=!0;const Fi={toc:[]};function Oi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a scene exposed by scene files."))}Oi.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Vi.isMDXComponent=!0;const Bi={toc:[]};function Hi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}Hi.isMDXComponent=!0;const Yi={toc:[]};function Ji(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Ji.isMDXComponent=!0;const Ki={toc:[]};function Qi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ki,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}Qi.isMDXComponent=!0;const $i={toc:[]};function tl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}pl.isMDXComponent=!0;const cl={toc:[]};function rl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event at runtime."))}rl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"In other words, the moment at which ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,p.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}al.isMDXComponent=!0;const il={toc:[]};function ll(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},il,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the event."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Duration of the event in seconds."))}hl.isMDXComponent=!0;const yl={toc:[]};function kl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stack trace at the moment of registration."))}kl.isMDXComponent=!0;const fl={toc:[]};function Dl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}Dl.isMDXComponent=!0;const Ml={toc:[]};function _l(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ml,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents attributes of an inspected element."))}_l.isMDXComponent=!0;const Xl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}wl.isMDXComponent=!0;const Tl={toc:[]};function Cl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents an element to inspect."))}Cl.isMDXComponent=!0;const xl={toc:[]};function gl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}gl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ll,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Zl.isMDXComponent=!0;const bl={toc:[]};function vl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}vl.isMDXComponent=!0;const Nl={toc:[]};function Sl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Sl.isMDXComponent=!0;const Al={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Gl.isMDXComponent=!0;const Pl={toc:[]};function Rl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Rl.isMDXComponent=!0;const El={toc:[]};function Il(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},El,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Il.isMDXComponent=!0;const Wl={toc:[]};function Ul(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Ul.isMDXComponent=!0;const jl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}zl.isMDXComponent=!0;const Fl={toc:[]};function Ol(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Ol.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Vl.isMDXComponent=!0;const Bl={toc:[]};function Hl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Hl.isMDXComponent=!0;const Yl={toc:[]};function Jl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Jl.isMDXComponent=!0;const Kl={toc:[]};function Ql(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Ql.isMDXComponent=!0;const $l={toc:[]};function tu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}pu.isMDXComponent=!0;const cu={toc:[]};function ru(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}ru.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}au.isMDXComponent=!0;const iu={toc:[]};function lu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},iu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread management."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,p.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}hu.isMDXComponent=!0;const yu={toc:[]};function ku(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A class representing an individual thread."))}ku.isMDXComponent=!0;const fu={toc:[]};function Du(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}Du.isMDXComponent=!0;const Mu={toc:[]};function _u(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}_u.isMDXComponent=!0;const Xu={toc:[]};function wu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Used by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}wu.isMDXComponent=!0;const Tu={toc:[]};function Cu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current time of this thread."))}Cu.isMDXComponent=!0;const xu={toc:[]};function gu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The next value to be passed to the wrapped generator."))}gu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}Zu.isMDXComponent=!0;const bu={toc:[]};function vu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress the wrapped generator once."))}vu.isMDXComponent=!0;const Nu={toc:[]};function Su(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the thread for the next update cycle."))}Su.isMDXComponent=!0;const Au={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a normal function that returns a generator."))}Gu.isMDXComponent=!0;const Pu={toc:[]};function Ru(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,p.kt)("p",null,"Progress to the next frame:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,p.kt)("p",null,"Run another generator synchronously:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,p.kt)("p",null,"Run another generator concurrently:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,p.kt)("p",null,"Await a Promise:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Ru.isMDXComponent=!0;const Eu={toc:[]};function Iu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Iu.isMDXComponent=!0;const Wu={toc:[]};function Uu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Cancel all listed tasks."),(0,p.kt)("p",null,"Example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Uu.isMDXComponent=!0;const ju={toc:[]};function zu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to cancel."))}zu.isMDXComponent=!0;const Fu={toc:[]};function Ou(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Ou.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Vu.isMDXComponent=!0;const Bu={toc:[]};function Hu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Hu.isMDXComponent=!0;const Yu={toc:[]};function Ju(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible thread ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Ju.isMDXComponent=!0;const Ku={toc:[]};function Qu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ku,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Qu.isMDXComponent=!0;const $u={toc:[]};function tm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}pm.isMDXComponent=!0;const cm={toc:[]};function rm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until listed tasks are finished."))}rm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}am.isMDXComponent=!0;const im={toc:[]};function lm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},im,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"From the perspective of the external generator, ",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}hm.isMDXComponent=!0;const ym={toc:[]};function km(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ym,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a context in which generators can be run concurrently."))}km.isMDXComponent=!0;const fm={toc:[]};function Dm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the generator to run."))}Dm.isMDXComponent=!0;const Mm={toc:[]};function _m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}_m.isMDXComponent=!0;const Xm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transitions between scenes."))}wm.isMDXComponent=!0;const Tm={toc:[]};function Cm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Cm.isMDXComponent=!0;const xm={toc:[]};function gm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the current scene is rendered."))}gm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the previous scene is rendered."))}Zm.isMDXComponent=!0;const bm={toc:[]};function vm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolation and timing of tweens."))}vm.isMDXComponent=!0;const Nm={toc:[]};function Sm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any old key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"})))}Sm.isMDXComponent=!0;const Am={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Gm.isMDXComponent=!0;const Pm={toc:[]};function Rm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Rm.isMDXComponent=!0;const Em={toc:[]};function Im(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Em,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Im.isMDXComponent=!0;const Wm={toc:[]};function Um(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Um.isMDXComponent=!0;const jm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}zm.isMDXComponent=!0;const Fm={toc:[]};function Om(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Om.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Vm.isMDXComponent=!0;const Bm={toc:[]};function Hm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Hm.isMDXComponent=!0;const Ym={toc:[]};function Jm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ym,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Jm.isMDXComponent=!0;const Km={toc:[]};function Qm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Km,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Qm.isMDXComponent=!0;const $m={toc:[]};function td(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Complex types used in animations."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a two-dimensional vector."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}pd.isMDXComponent=!0;const cd={toc:[]};function rd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The unclipped RGB components."))}rd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}ad.isMDXComponent=!0;const id={toc:[]};function ld(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},id,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}hd.isMDXComponent=!0;const yd={toc:[]};function kd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}kd.isMDXComponent=!0;const fd={toc:[]};function Dd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Dd.isMDXComponent=!0;const Md={toc:[]};function _d(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Md,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}_d.isMDXComponent=!0;const Xd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Alias of ",(0,p.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}wd.isMDXComponent=!0;const Td={toc:[]};function Cd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Td,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Cd.isMDXComponent=!0;const xd={toc:[]};function gd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}gd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ld,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}Zd.isMDXComponent=!0;const bd={toc:[]};function vd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}vd.isMDXComponent=!0;const Nd={toc:[]};function Sd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Sd.isMDXComponent=!0;const Ad={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Gd.isMDXComponent=!0;const Pd={toc:[]};function Rd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}Rd.isMDXComponent=!0;const Ed={toc:[]};function Id(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ed,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"L"),", ",(0,p.kt)("strong",{parentName:"p"},"a"),", and ",(0,p.kt)("strong",{parentName:"p"},"b")," components."))}Id.isMDXComponent=!0;const Wd={toc:[]};function Ud(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}Ud.isMDXComponent=!0;const jd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,p.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,p.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}zd.isMDXComponent=!0;const Fd={toc:[]};function Od(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}Od.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}Vd.isMDXComponent=!0;const Bd={toc:[]};function Hd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Hd.isMDXComponent=!0;const Yd={toc:[]};function Jd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}Jd.isMDXComponent=!0;const Kd={toc:[]};function Qd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get and set the color opacity."))}Qd.isMDXComponent=!0;const $d={toc:[]};function th(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,p.kt)("code",null,"'rgb'")))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Similar to saturate, but the opposite direction."))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"set"))}ph.isMDXComponent=!0;const ch={toc:[]};function rh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a single channel value.\nAlso"))}rh.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}ah.isMDXComponent=!0;const ih={toc:[]};function lh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ih,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color as hexadecimal string."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,p.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}hh.isMDXComponent=!0;const yh={toc:[]};function kh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}kh.isMDXComponent=!0;const fh={toc:[]};function Dh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Dh.isMDXComponent=!0;const Mh={toc:[]};function _h(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}_h.isMDXComponent=!0;const Xh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}wh.isMDXComponent=!0;const Th={toc:[]};function Ch(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Th,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Ch.isMDXComponent=!0;const xh={toc:[]};function gh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}gh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}Zh.isMDXComponent=!0;const bh={toc:[]};function vh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}vh.isMDXComponent=!0;const Nh={toc:[]};function Sh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Sh.isMDXComponent=!0;const Ah={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Gh.isMDXComponent=!0;const Ph={toc:[]};function Rh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ph,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Rh.isMDXComponent=!0;const Eh={toc:[]};function Ih(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The origin to convert."))}Ih.isMDXComponent=!0;const Wh={toc:[]};function Uh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"General utilities and helper functions."))}Uh.isMDXComponent=!0;const jh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}zh.isMDXComponent=!0;const Fh={toc:[]};function Oh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Optional override for formatting stack traces"))}Oh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create .stack property on a target object"))}Vh.isMDXComponent=!0;const Bh={toc:[]};function Hh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mark the given function as deprecated."))}Hh.isMDXComponent=!0;const Yh={toc:[]};function Jh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function to deprecate."))}Jh.isMDXComponent=!0;const Kh={toc:[]};function Qh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The log message."))}Qh.isMDXComponent=!0;const $h={toc:[]};function ty(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The optional log remarks."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}py.isMDXComponent=!0;const cy={toc:[]};function ry(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The length of the array."))}ry.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}ay.isMDXComponent=!0;const iy={toc:[]};function ly(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}hy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}ky.isMDXComponent=!0;const fy={toc:[]};function Dy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context before render."))}Dy.isMDXComponent=!0;const My={toc:[]};function _y(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},My,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}_y.isMDXComponent=!0;const Xy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context after render."))}wy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ty,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current project."))}Cy.isMDXComponent=!0;const xy={toc:[]};function gy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the current scene."))}gy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the given seed."))}Zy.isMDXComponent=!0;const by={toc:[]};function vy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},by,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The seed for the generator."))}vy.isMDXComponent=!0;const Ny={toc:[]};function Sy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}Sy.isMDXComponent=!0;const Ay={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ay,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current scene."))}Gy.isMDXComponent=!0;const Py={toc:[]};function Ry(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current thread."))}Ry.isMDXComponent=!0;const Ey={toc:[]};function Iy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ey,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}Iy.isMDXComponent=!0;const Wy={toc:[]};function Uy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}Uy.isMDXComponent=!0;const jy={toc:[]};function zy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the real time since the start of the animation."))}zy.isMDXComponent=!0;const Fy={toc:[]};function Oy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Oy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Vy.isMDXComponent=!0;const By={toc:[]};function Hy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Hy.isMDXComponent=!0;const Yy={toc:[]};function Jy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Jy.isMDXComponent=!0;const Ky={toc:[]};function Qy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ky,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Qy.isMDXComponent=!0;const $y={toc:[]};function tk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}pk.isMDXComponent=!0;const ck={toc:[]};function rk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ck,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}rk.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ak.isMDXComponent=!0;const ik={toc:[]};function lk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}hk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}kk.isMDXComponent=!0;const fk={toc:[]};function Dk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Dk.isMDXComponent=!0;const Mk={toc:[]};function _k(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}_k.isMDXComponent=!0;const Xk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}wk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Ck.isMDXComponent=!0;const xk={toc:[]};function gk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}gk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Zk.isMDXComponent=!0;const bk={toc:[]};function vk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}vk.isMDXComponent=!0;const Nk={toc:[]};function Sk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Sk.isMDXComponent=!0;const Ak={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ak,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Gk.isMDXComponent=!0;const Pk={toc:[]};function Rk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Rk.isMDXComponent=!0;const Ek={toc:[]};function Ik(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ek,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Ik.isMDXComponent=!0;const Wk={toc:[]};function Uk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Uk.isMDXComponent=!0;const jk={toc:[]};function zk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}zk.isMDXComponent=!0;const Fk={toc:[]};function Ok(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Ok.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Vk.isMDXComponent=!0;const Bk={toc:[]};function Hk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Hk.isMDXComponent=!0;const Yk={toc:[]};function Jk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Jk.isMDXComponent=!0;const Kk={toc:[]};function Qk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Qk.isMDXComponent=!0;const $k={toc:[]};function tf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$k,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}pf.isMDXComponent=!0;const cf={toc:[]};function rf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}rf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}yf.isMDXComponent=!0;const kf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ff.isMDXComponent=!0;const Df={toc:[]};function Mf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Df,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Mf.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_f,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Xf.isMDXComponent=!0;const wf={toc:[]};function Tf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Tf.isMDXComponent=!0;const Cf={toc:[]};function xf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}xf.isMDXComponent=!0;const gf={toc:[]};function Lf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function bf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}bf.isMDXComponent=!0;const vf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Nf.isMDXComponent=!0;const Sf={toc:[]};function Af(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Af.isMDXComponent=!0;const Gf={toc:[]};function Pf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Pf.isMDXComponent=!0;const Rf={toc:[]};function Ef(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Ef.isMDXComponent=!0;const If={toc:[]};function Wf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},If,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Wf.isMDXComponent=!0;const Uf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}jf.isMDXComponent=!0;const zf={toc:[]};function Ff(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ff.isMDXComponent=!0;const Of={toc:[]};function qf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Of,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qf.isMDXComponent=!0;const Vf={toc:[]};function Bf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Bf.isMDXComponent=!0;const Hf={toc:[]};function Yf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Yf.isMDXComponent=!0;const Jf={toc:[]};function Kf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Kf.isMDXComponent=!0;const Qf={toc:[]};function $f(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}$f.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}oD.isMDXComponent=!0;const pD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}cD.isMDXComponent=!0;const rD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}sD.isMDXComponent=!0;const aD={toc:[]};function iD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}iD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}yD.isMDXComponent=!0;const kD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}fD.isMDXComponent=!0;const DD={toc:[]};function MD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}MD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_D,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}XD.isMDXComponent=!0;const wD={toc:[]};function TD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}TD.isMDXComponent=!0;const CD={toc:[]};function xD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xD.isMDXComponent=!0;const gD={toc:[]};function LD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}LD.isMDXComponent=!0;const ZD={toc:[]};function bD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bD.isMDXComponent=!0;const vD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}ND.isMDXComponent=!0;const SD={toc:[]};function AD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}AD.isMDXComponent=!0;const GD={toc:[]};function PD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}PD.isMDXComponent=!0;const RD={toc:[]};function ED(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ED.isMDXComponent=!0;const ID={toc:[]};function WD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ID,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}WD.isMDXComponent=!0;const UD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jD.isMDXComponent=!0;const zD={toc:[]};function FD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}FD.isMDXComponent=!0;const OD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}qD.isMDXComponent=!0;const VD={toc:[]};function BD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}BD.isMDXComponent=!0;const HD={toc:[]};function YD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}YD.isMDXComponent=!0;const JD={toc:[]};function KD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}KD.isMDXComponent=!0;const QD={toc:[]};function $D(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}$D.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}oM.isMDXComponent=!0;const pM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}cM.isMDXComponent=!0;const rM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sM.isMDXComponent=!0;const aM={toc:[]};function iM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}iM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yM.isMDXComponent=!0;const kM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}fM.isMDXComponent=!0;const DM={toc:[]};function MM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}MM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_M,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}XM.isMDXComponent=!0;const wM={toc:[]};function TM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}TM.isMDXComponent=!0;const CM={toc:[]};function xM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xM.isMDXComponent=!0;const gM={toc:[]};function LM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}LM.isMDXComponent=!0;const ZM={toc:[]};function bM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}bM.isMDXComponent=!0;const vM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}NM.isMDXComponent=!0;const SM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}AM.isMDXComponent=!0;const GM={toc:[]};function PM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}PM.isMDXComponent=!0;const RM={toc:[]};function EM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}EM.isMDXComponent=!0;const IM={toc:[]};function WM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}WM.isMDXComponent=!0;const UM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}jM.isMDXComponent=!0;const zM={toc:[]};function FM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}FM.isMDXComponent=!0;const OM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}qM.isMDXComponent=!0;const VM={toc:[]};function BM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}BM.isMDXComponent=!0;const HM={toc:[]};function YM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}YM.isMDXComponent=!0;const JM={toc:[]};function KM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}KM.isMDXComponent=!0;const QM={toc:[]};function $M(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}$M.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}o_.isMDXComponent=!0;const p_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}c_.isMDXComponent=!0;const r_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},r_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}s_.isMDXComponent=!0;const a_={toc:[]};function i_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}i_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}y_.isMDXComponent=!0;const k_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},k_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}f_.isMDXComponent=!0;const D_={toc:[]};function M_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},D_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}M_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},__,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}X_.isMDXComponent=!0;const w_={toc:[]};function T_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}T_.isMDXComponent=!0;const C_={toc:[]};function x_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},C_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}x_.isMDXComponent=!0;const g_={toc:[]};function L_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},g_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}L_.isMDXComponent=!0;const Z_={toc:[]};function b_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Z_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}b_.isMDXComponent=!0;const v_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},v_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}N_.isMDXComponent=!0;const S_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},S_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}A_.isMDXComponent=!0;const G_={toc:[]};function P_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}P_.isMDXComponent=!0;const R_={toc:[]};function E_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},R_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}E_.isMDXComponent=!0;const I_={toc:[]};function W_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},I_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}W_.isMDXComponent=!0;const U_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},U_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}j_.isMDXComponent=!0;const z_={toc:[]};function F_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}F_.isMDXComponent=!0;const O_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},O_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}q_.isMDXComponent=!0;const V_={toc:[]};function B_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}B_.isMDXComponent=!0;const H_={toc:[]};function Y_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},H_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Y_.isMDXComponent=!0;const J_={toc:[]};function K_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},J_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}K_.isMDXComponent=!0;const Q_={toc:[]};function $_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Q_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}$_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}oX.isMDXComponent=!0;const pX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}cX.isMDXComponent=!0;const rX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}sX.isMDXComponent=!0;const aX={toc:[]};function iX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}iX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}yX.isMDXComponent=!0;const kX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}fX.isMDXComponent=!0;const DX={toc:[]};function MX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}MX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_X,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}XX.isMDXComponent=!0;const wX={toc:[]};function TX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}TX.isMDXComponent=!0;const CX={toc:[]};function xX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}xX.isMDXComponent=!0;const gX={toc:[]};function LX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}LX.isMDXComponent=!0;const ZX={toc:[]};function bX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}bX.isMDXComponent=!0;const vX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}NX.isMDXComponent=!0;const SX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}AX.isMDXComponent=!0;const GX={toc:[]};function PX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}PX.isMDXComponent=!0;const RX={toc:[]};function EX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}EX.isMDXComponent=!0;const IX={toc:[]};function WX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}WX.isMDXComponent=!0;const UX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}jX.isMDXComponent=!0;const zX={toc:[]};function FX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}FX.isMDXComponent=!0;const OX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}qX.isMDXComponent=!0;const VX={toc:[]};function BX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}BX.isMDXComponent=!0;const HX={toc:[]};function YX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}YX.isMDXComponent=!0;const JX={toc:[]};function KX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}KX.isMDXComponent=!0;const QX={toc:[]};function $X(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}$X.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ow.isMDXComponent=!0;const pw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}cw.isMDXComponent=!0;const rw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}sw.isMDXComponent=!0;const aw={toc:[]};function iw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}iw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yw.isMDXComponent=!0;const kw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fw.isMDXComponent=!0;const Dw={toc:[]};function Mw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Mw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_w,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Xw.isMDXComponent=!0;const ww={toc:[]};function Tw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Tw.isMDXComponent=!0;const Cw={toc:[]};function xw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}xw.isMDXComponent=!0;const gw={toc:[]};function Lw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function bw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}bw.isMDXComponent=!0;const vw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Nw.isMDXComponent=!0;const Sw={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Aw.isMDXComponent=!0;const Gw={toc:[]};function Pw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Pw.isMDXComponent=!0;const Rw={toc:[]};function Ew(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ew.isMDXComponent=!0;const Iw={toc:[]};function Ww(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Iw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Ww.isMDXComponent=!0;const Uw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}jw.isMDXComponent=!0;const zw={toc:[]};function Fw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Fw.isMDXComponent=!0;const Ow={toc:[]};function qw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ow,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}qw.isMDXComponent=!0;const Vw={toc:[]};function Bw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Bw.isMDXComponent=!0;const Hw={toc:[]};function Yw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Yw.isMDXComponent=!0;const Jw={toc:[]};function Kw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Kw.isMDXComponent=!0;const Qw={toc:[]};function $w(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}$w.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}oT.isMDXComponent=!0;const pT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}cT.isMDXComponent=!0;const rT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}sT.isMDXComponent=!0;const aT={toc:[]};function iT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}iT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yT.isMDXComponent=!0;const kT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}fT.isMDXComponent=!0;const DT={toc:[]};function MT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}MT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_T,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}XT.isMDXComponent=!0;const wT={toc:[]};function TT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}TT.isMDXComponent=!0;const CT={toc:[]};function xT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}xT.isMDXComponent=!0;const gT={toc:[]};function LT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}LT.isMDXComponent=!0;const ZT={toc:[]};function bT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bT.isMDXComponent=!0;const vT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NT.isMDXComponent=!0;const ST={toc:[]};function AT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ST,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}AT.isMDXComponent=!0;const GT={toc:[]};function PT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}PT.isMDXComponent=!0;const RT={toc:[]};function ET(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ET.isMDXComponent=!0;const IT={toc:[]};function WT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}WT.isMDXComponent=!0;const UT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jT.isMDXComponent=!0;const zT={toc:[]};function FT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}FT.isMDXComponent=!0;const OT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}qT.isMDXComponent=!0;const VT={toc:[]};function BT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}BT.isMDXComponent=!0;const HT={toc:[]};function YT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}YT.isMDXComponent=!0;const JT={toc:[]};function KT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}KT.isMDXComponent=!0;const QT={toc:[]};function $T(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}$T.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}oC.isMDXComponent=!0;const pC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}cC.isMDXComponent=!0;const rC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}sC.isMDXComponent=!0;const aC={toc:[]};function iC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}iC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}yC.isMDXComponent=!0;const kC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}fC.isMDXComponent=!0;const DC={toc:[]};function MC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}MC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_C,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}XC.isMDXComponent=!0;const wC={toc:[]};function TC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}TC.isMDXComponent=!0;const CC={toc:[]};function xC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}xC.isMDXComponent=!0;const gC={toc:[]};function LC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}LC.isMDXComponent=!0;const ZC={toc:[]};function bC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}bC.isMDXComponent=!0;const vC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}NC.isMDXComponent=!0;const SC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}AC.isMDXComponent=!0;const GC={toc:[]};function PC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}PC.isMDXComponent=!0;const RC={toc:[]};function EC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}EC.isMDXComponent=!0;const IC={toc:[]};function WC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}WC.isMDXComponent=!0;const UC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}jC.isMDXComponent=!0;const zC={toc:[]};function FC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}FC.isMDXComponent=!0;const OC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qC.isMDXComponent=!0;const VC={toc:[]};function BC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}BC.isMDXComponent=!0;const HC={toc:[]};function YC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}YC.isMDXComponent=!0;const JC={toc:[]};function KC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}KC.isMDXComponent=!0;const QC={toc:[]};function $C(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}$C.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ox.isMDXComponent=!0;const px={toc:[]};function cx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}cx.isMDXComponent=!0;const rx={toc:[]};function sx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}sx.isMDXComponent=!0;const ax={toc:[]};function ix(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ix.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yx.isMDXComponent=!0;const kx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fx.isMDXComponent=!0;const Dx={toc:[]};function Mx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Mx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_x,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Xx.isMDXComponent=!0;const wx={toc:[]};function Tx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Tx.isMDXComponent=!0;const Cx={toc:[]};function xx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}xx.isMDXComponent=!0;const gx={toc:[]};function Lx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function bx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}bx.isMDXComponent=!0;const vx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Nx.isMDXComponent=!0;const Sx={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ax.isMDXComponent=!0;const Gx={toc:[]};function Px(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Px.isMDXComponent=!0;const Rx={toc:[]};function Ex(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ex.isMDXComponent=!0;const Ix={toc:[]};function Wx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ix,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Wx.isMDXComponent=!0;const Ux={toc:[]};function jx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ux,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}jx.isMDXComponent=!0;const zx={toc:[]};function Fx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Fx.isMDXComponent=!0;const Ox={toc:[]};function qx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ox,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}qx.isMDXComponent=!0;const Vx={toc:[]};function Bx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Bx.isMDXComponent=!0;const Hx={toc:[]};function Yx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Yx.isMDXComponent=!0;const Jx={toc:[]};function Kx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Kx.isMDXComponent=!0;const Qx={toc:[]};function $x(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}$x.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}og.isMDXComponent=!0;const pg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}cg.isMDXComponent=!0;const rg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}sg.isMDXComponent=!0;const ag={toc:[]};function ig(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}ig.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yg.isMDXComponent=!0;const kg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}fg.isMDXComponent=!0;const Dg={toc:[]};function Mg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Mg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_g,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Xg.isMDXComponent=!0;const wg={toc:[]};function Tg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Tg.isMDXComponent=!0;const Cg={toc:[]};function xg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}xg.isMDXComponent=!0;const gg={toc:[]};function Lg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function bg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bg.isMDXComponent=!0;const vg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Ng.isMDXComponent=!0;const Sg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Ag.isMDXComponent=!0;const Gg={toc:[]};function Pg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Pg.isMDXComponent=!0;const Rg={toc:[]};function Eg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Eg.isMDXComponent=!0;const Ig={toc:[]};function Wg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ig,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Wg.isMDXComponent=!0;const Ug={toc:[]};function jg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ug,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jg.isMDXComponent=!0;const zg={toc:[]};function Fg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Fg.isMDXComponent=!0;const Og={toc:[]};function qg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Og,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}qg.isMDXComponent=!0;const Vg={toc:[]};function Bg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Bg.isMDXComponent=!0;const Hg={toc:[]};function Yg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Yg.isMDXComponent=!0;const Jg={toc:[]};function Kg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Kg.isMDXComponent=!0;const Qg={toc:[]};function $g(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}$g.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}oL.isMDXComponent=!0;const pL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}cL.isMDXComponent=!0;const rL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}sL.isMDXComponent=!0;const aL={toc:[]};function iL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}iL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}yL.isMDXComponent=!0;const kL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}fL.isMDXComponent=!0;const DL={toc:[]};function ML(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ML.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_L,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}XL.isMDXComponent=!0;const wL={toc:[]};function TL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}TL.isMDXComponent=!0;const CL={toc:[]};function xL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}xL.isMDXComponent=!0;const gL={toc:[]};function LL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}LL.isMDXComponent=!0;const ZL={toc:[]};function bL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}bL.isMDXComponent=!0;const vL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}NL.isMDXComponent=!0;const SL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}AL.isMDXComponent=!0;const GL={toc:[]};function PL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}PL.isMDXComponent=!0;const RL={toc:[]};function EL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}EL.isMDXComponent=!0;const IL={toc:[]};function WL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}WL.isMDXComponent=!0;const UL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}jL.isMDXComponent=!0;const zL={toc:[]};function FL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}FL.isMDXComponent=!0;const OL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}qL.isMDXComponent=!0;const VL={toc:[]};function BL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}BL.isMDXComponent=!0;const HL={toc:[]};function YL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}YL.isMDXComponent=!0;const JL={toc:[]};function KL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}KL.isMDXComponent=!0;const QL={toc:[]};function $L(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}$L.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}cZ.isMDXComponent=!0;const rZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function iZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}iZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}yZ.isMDXComponent=!0;const kZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}fZ.isMDXComponent=!0;const DZ={toc:[]};function MZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}MZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_Z,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}XZ.isMDXComponent=!0;const wZ={toc:[]};function TZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}TZ.isMDXComponent=!0;const CZ={toc:[]};function xZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}xZ.isMDXComponent=!0;const gZ={toc:[]};function LZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function bZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}bZ.isMDXComponent=!0;const vZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}NZ.isMDXComponent=!0;const SZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}AZ.isMDXComponent=!0;const GZ={toc:[]};function PZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}PZ.isMDXComponent=!0;const RZ={toc:[]};function EZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}EZ.isMDXComponent=!0;const IZ={toc:[]};function WZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}WZ.isMDXComponent=!0;const UZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}jZ.isMDXComponent=!0;const zZ={toc:[]};function FZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}FZ.isMDXComponent=!0;const OZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function BZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}BZ.isMDXComponent=!0;const HZ={toc:[]};function YZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}YZ.isMDXComponent=!0;const JZ={toc:[]};function KZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}KZ.isMDXComponent=!0;const QZ={toc:[]};function $Z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$Z.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ob.isMDXComponent=!0;const pb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}cb.isMDXComponent=!0;const rb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}sb.isMDXComponent=!0;const ab={toc:[]};function ib(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}ib.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}yb.isMDXComponent=!0;const kb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}fb.isMDXComponent=!0;const Db={toc:[]};function Mb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Db,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Mb.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_b,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Xb.isMDXComponent=!0;const wb={toc:[]};function Tb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Tb.isMDXComponent=!0;const Cb={toc:[]};function xb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}xb.isMDXComponent=!0;const gb={toc:[]};function Lb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function bb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}bb.isMDXComponent=!0;const vb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Nb.isMDXComponent=!0;const Sb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Ab.isMDXComponent=!0;const Gb={toc:[]};function Pb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Pb.isMDXComponent=!0;const Rb={toc:[]};function Eb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Eb.isMDXComponent=!0;const Ib={toc:[]};function Wb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ib,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Wb.isMDXComponent=!0;const Ub={toc:[]};function jb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ub,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}jb.isMDXComponent=!0;const zb={toc:[]};function Fb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Fb.isMDXComponent=!0;const Ob={toc:[]};function qb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ob,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}qb.isMDXComponent=!0;const Vb={toc:[]};function Bb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Bb.isMDXComponent=!0;const Hb={toc:[]};function Yb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Yb.isMDXComponent=!0;const Jb={toc:[]};function Kb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Kb.isMDXComponent=!0;const Qb={toc:[]};function $b(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}$b.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ov.isMDXComponent=!0;const pv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}cv.isMDXComponent=!0;const rv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}sv.isMDXComponent=!0;const av={toc:[]};function iv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}yv.isMDXComponent=!0;const kv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}fv.isMDXComponent=!0;const Dv={toc:[]};function Mv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Mv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_v,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Xv.isMDXComponent=!0;const wv={toc:[]};function Tv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Tv.isMDXComponent=!0;const Cv={toc:[]};function xv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}xv.isMDXComponent=!0;const gv={toc:[]};function Lv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function bv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}bv.isMDXComponent=!0;const vv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Nv.isMDXComponent=!0;const Sv={toc:[]};function Av(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Av.isMDXComponent=!0;const Gv={toc:[]};function Pv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Pv.isMDXComponent=!0;const Rv={toc:[]};function Ev(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ev.isMDXComponent=!0;const Iv={toc:[]};function Wv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Iv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Wv.isMDXComponent=!0;const Uv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}jv.isMDXComponent=!0;const zv={toc:[]};function Fv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Fv.isMDXComponent=!0;const Ov={toc:[]};function qv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ov,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}qv.isMDXComponent=!0;const Vv={toc:[]};function Bv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Bv.isMDXComponent=!0;const Hv={toc:[]};function Yv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}Yv.isMDXComponent=!0;const Jv={toc:[]};function Kv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Kv.isMDXComponent=!0;const Qv={toc:[]};function $v(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}$v.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}oN.isMDXComponent=!0;const pN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cN.isMDXComponent=!0;const rN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}sN.isMDXComponent=!0;const aN={toc:[]};function iN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}iN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}yN.isMDXComponent=!0;const kN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fN.isMDXComponent=!0;const DN={toc:[]};function MN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}MN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_N,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XN.isMDXComponent=!0;const wN={toc:[]};function TN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}TN.isMDXComponent=!0;const CN={toc:[]};function xN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}xN.isMDXComponent=!0;const gN={toc:[]};function LN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}LN.isMDXComponent=!0;const ZN={toc:[]};function bN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}bN.isMDXComponent=!0;const vN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NN.isMDXComponent=!0;const SN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}AN.isMDXComponent=!0;const GN={toc:[]};function PN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PN.isMDXComponent=!0;const RN={toc:[]};function EN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}EN.isMDXComponent=!0;const IN={toc:[]};function WN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}WN.isMDXComponent=!0;const UN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}jN.isMDXComponent=!0;const zN={toc:[]};function FN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FN.isMDXComponent=!0;const ON={toc:[]};function qN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ON,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qN.isMDXComponent=!0;const VN={toc:[]};function BN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}BN.isMDXComponent=!0;const HN={toc:[]};function YN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}YN.isMDXComponent=!0;const JN={toc:[]};function KN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}KN.isMDXComponent=!0;const QN={toc:[]};function $N(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}$N.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}oS.isMDXComponent=!0;const pS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}cS.isMDXComponent=!0;const rS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sS.isMDXComponent=!0;const aS={toc:[]};function iS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}iS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}yS.isMDXComponent=!0;const kS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}fS.isMDXComponent=!0;const DS={toc:[]};function MS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}MS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_S,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}XS.isMDXComponent=!0;const wS={toc:[]};function TS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}TS.isMDXComponent=!0;const CS={toc:[]};function xS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}xS.isMDXComponent=!0;const gS={toc:[]};function LS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}LS.isMDXComponent=!0;const ZS={toc:[]};function bS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}bS.isMDXComponent=!0;const vS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}NS.isMDXComponent=!0;const SS={toc:[]};function AS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}AS.isMDXComponent=!0;const GS={toc:[]};function PS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}PS.isMDXComponent=!0;const RS={toc:[]};function ES(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}ES.isMDXComponent=!0;const IS={toc:[]};function WS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}WS.isMDXComponent=!0;const US={toc:[]};function jS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},US,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}jS.isMDXComponent=!0;const zS={toc:[]};function FS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}FS.isMDXComponent=!0;const OS={toc:[]};function qS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}qS.isMDXComponent=!0;const VS={toc:[]};function BS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}BS.isMDXComponent=!0;const HS={toc:[]};function YS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}YS.isMDXComponent=!0;const JS={toc:[]};function KS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}KS.isMDXComponent=!0;const QS={toc:[]};function $S(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}$S.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}oA.isMDXComponent=!0;const pA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}cA.isMDXComponent=!0;const rA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}sA.isMDXComponent=!0;const aA={toc:[]};function iA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}iA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}yA.isMDXComponent=!0;const kA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}fA.isMDXComponent=!0;const DA={toc:[]};function MA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}MA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_A,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}XA.isMDXComponent=!0;const wA={toc:[]};function TA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}TA.isMDXComponent=!0;const CA={toc:[]};function xA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xA.isMDXComponent=!0;const gA={toc:[]};function LA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}LA.isMDXComponent=!0;const ZA={toc:[]};function bA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}bA.isMDXComponent=!0;const vA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}NA.isMDXComponent=!0;const SA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}AA.isMDXComponent=!0;const GA={toc:[]};function PA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}PA.isMDXComponent=!0;const RA={toc:[]};function EA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}EA.isMDXComponent=!0;const IA={toc:[]};function WA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}WA.isMDXComponent=!0;const UA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}jA.isMDXComponent=!0;const zA={toc:[]};function FA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,p.kt)("p",null,"By default, any property is cloneable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}FA.isMDXComponent=!0;const OA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}qA.isMDXComponent=!0;const VA={toc:[]};function BA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a cloneable property decorator."))}BA.isMDXComponent=!0;const HA={toc:[]};function YA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be cloneable."))}YA.isMDXComponent=!0;const JA={toc:[]};function KA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}KA.isMDXComponent=!0;const QA={toc:[]};function $A(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}$A.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a compound property decorator."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}oG.isMDXComponent=!0;const pG={toc:[]};function cG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,p.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,p.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}cG.isMDXComponent=!0;const rG={toc:[]};function sG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a computed method decorator."))}sG.isMDXComponent=!0;const aG={toc:[]};function iG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the initial value of a property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}iG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an initial signal value decorator."))}dG.isMDXComponent=!0;const hG={toc:[]};function yG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the property."))}yG.isMDXComponent=!0;const kG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,p.kt)("p",null,"By default, any property is inspectable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}fG.isMDXComponent=!0;const DG={toc:[]};function MG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}MG.isMDXComponent=!0;const _G={toc:[]};function XG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_G,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an inspectable property decorator."))}XG.isMDXComponent=!0;const wG={toc:[]};function TG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be inspectable."))}TG.isMDXComponent=!0;const CG={toc:[]};function xG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}xG.isMDXComponent=!0;const gG={toc:[]};function LG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}LG.isMDXComponent=!0;const ZG={toc:[]};function bG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal interpolation function decorator."))}bG.isMDXComponent=!0;const vG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function for the property."))}NG.isMDXComponent=!0;const SG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,p.kt)("p",null,"If the wrapper class has a method called ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}AG.isMDXComponent=!0;const GG={toc:[]};function PG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}PG.isMDXComponent=!0;const RG={toc:[]};function EG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal parser decorator."))}EG.isMDXComponent=!0;const IG={toc:[]};function WG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}WG.isMDXComponent=!0;const UG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given property into a signal."),(0,p.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}jG.isMDXComponent=!0;const zG={toc:[]};function FG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}FG.isMDXComponent=!0;const OG={toc:[]};function qG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal decorator."))}qG.isMDXComponent=!0;const VG={toc:[]};function BG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,p.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,p.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,p.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}BG.isMDXComponent=!0;const HG={toc:[]};function YG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}YG.isMDXComponent=!0;const JG={toc:[]};function KG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal wrapper decorator."))}KG.isMDXComponent=!0;const QG={toc:[]};function $G(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}$G.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A unified abstraction for all CSS filters."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,p.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}oP.isMDXComponent=!0;const pP={toc:[]};function cP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in pixels."))}cP.isMDXComponent=!0;const rP={toc:[]};function sP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,p.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}sP.isMDXComponent=!0;const aP={toc:[]};function iP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}iP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,p.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}dP.isMDXComponent=!0;const hP={toc:[]};function yP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,p.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}yP.isMDXComponent=!0;const kP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}fP.isMDXComponent=!0;const DP={toc:[]};function MP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,p.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}MP.isMDXComponent=!0;const _P={toc:[]};function XP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_P,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in degrees."))}XP.isMDXComponent=!0;const wP={toc:[]};function TP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,p.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}TP.isMDXComponent=!0;const CP={toc:[]};function xP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}xP.isMDXComponent=!0;const gP={toc:[]};function LP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,p.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}LP.isMDXComponent=!0;const ZP={toc:[]};function bP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}bP.isMDXComponent=!0;const vP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,p.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}NP.isMDXComponent=!0;const SP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}AP.isMDXComponent=!0;const GP={toc:[]};function PP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}PP.isMDXComponent=!0;const RP={content_0_0:r,content_0_1:a,content_0_2:l,content_0_3:m,content_0_4:h,content_0_5:k,content_0_6:D,content_0_7:_,content_0_8:w,content_0_9:C,content_0_10:g,content_0_11:Z,content_0_12:v,content_0_13:S,content_0_14:G,content_0_15:R,content_0_16:I,content_0_17:U,content_0_18:z,content_0_19:O,content_0_20:V,content_0_21:H,content_0_22:J,content_0_23:Q,content_0_24:tt,content_0_25:et,content_0_26:pt,content_0_27:rt,content_0_28:at,content_0_29:lt,content_0_30:mt,content_0_31:ht,content_0_32:kt,content_0_33:Dt,content_0_34:_t,content_0_35:wt,content_0_36:Ct,content_0_37:gt,content_0_38:Zt,content_0_39:vt,content_0_40:St,content_0_41:Gt,content_0_42:Rt,content_0_43:It,content_0_44:Ut,content_0_45:zt,content_0_46:Ot,content_0_47:Vt,content_0_48:Ht,content_0_49:Jt,content_0_50:Qt,content_0_51:tn,content_0_52:en,content_0_53:pn,content_0_54:rn,content_0_55:an,content_0_56:un,content_0_57:dn,content_0_58:yn,content_0_59:fn,content_0_60:Mn,content_0_61:Xn,content_0_62:Tn,content_0_63:xn,content_0_64:Ln,content_0_65:bn,content_0_66:Nn,content_0_67:An,content_0_68:Pn,content_0_69:En,content_0_70:Wn,content_0_71:jn,content_0_72:Fn,content_0_73:qn,content_0_74:Bn,content_0_75:Yn,content_0_76:Kn,content_0_77:$n,content_0_78:ne,content_0_79:oe,content_0_80:ce,content_0_81:se,content_0_82:ie,content_0_83:ue,content_0_84:de,content_0_85:ye,content_0_86:fe,content_0_87:Me,content_0_88:Xe,content_0_89:Te,content_0_90:xe,content_0_91:Le,content_0_92:be,content_0_93:Ne,content_0_94:Ae,content_0_95:Pe,content_0_96:Ee,content_0_97:We,content_0_98:je,content_0_99:Fe,content_0_100:qe,content_0_101:Be,content_0_102:Ye,content_0_103:Ke,content_0_104:$e,content_0_105:no,content_0_106:oo,content_0_107:co,content_0_108:so,content_0_109:io,content_0_110:uo,content_0_111:ho,content_0_112:ko,content_0_113:Do,content_0_114:_o,content_0_115:wo,content_0_116:Co,content_0_117:go,content_0_118:Zo,content_0_119:vo,content_0_120:So,content_0_121:Go,content_0_122:Ro,content_0_123:Io,content_0_124:Uo,content_0_125:zo,content_0_126:Oo,content_0_127:Vo,content_0_128:Ho,content_0_129:Jo,content_0_130:Qo,content_0_131:tp,content_0_132:ep,content_0_133:pp,content_0_134:rp,content_0_135:ap,content_0_136:lp,content_0_137:mp,content_0_138:hp,content_0_139:kp,content_0_140:Dp,content_0_141:_p,content_0_142:wp,content_0_143:Cp,content_0_144:gp,content_0_145:Zp,content_0_146:vp,content_0_147:Sp,content_0_148:Gp,content_0_149:Rp,content_0_150:Ip,content_0_151:Up,content_0_152:zp,content_0_153:Op,content_0_154:Vp,content_0_155:Hp,content_0_156:Jp,content_0_157:Qp,content_0_158:tc,content_0_159:ec,content_0_160:pc,content_0_161:rc,content_0_162:ac,content_0_163:lc,content_0_164:mc,content_0_165:hc,content_0_166:kc,content_0_167:Dc,content_0_168:_c,content_0_169:wc,content_0_170:Cc,content_0_171:gc,content_0_172:Zc,content_0_173:vc,content_0_174:Sc,content_0_175:Gc,content_0_176:Rc,content_0_177:Ic,content_0_178:Uc,content_0_179:zc,content_0_180:Oc,content_0_181:Vc,content_0_182:Hc,content_0_183:Jc,content_0_184:Qc,content_0_185:tr,content_0_186:er,content_0_187:pr,content_0_188:rr,content_0_189:ar,content_0_190:lr,content_0_191:mr,content_0_192:hr,content_0_193:kr,content_0_194:Dr,content_0_195:_r,content_0_196:wr,content_0_197:Cr,content_0_198:gr,content_0_199:Zr,content_0_200:vr,content_0_201:Sr,content_0_202:Gr,content_0_203:Rr,content_0_204:Ir,content_0_205:Ur,content_0_206:zr,content_0_207:Or,content_0_208:Vr,content_0_209:Hr,content_0_210:Jr,content_0_211:Qr,content_0_212:ts,content_0_213:es,content_0_214:ps,content_0_215:rs,content_0_216:as,content_0_217:ls,content_0_218:ms,content_0_219:hs,content_0_220:ks,content_0_221:Ds,content_0_222:_s,content_0_223:ws,content_0_224:Cs,content_0_225:gs,content_0_226:Zs,content_0_227:vs,content_0_228:Ss,content_0_229:Gs,content_0_230:Rs,content_0_231:Is,content_0_232:Us,content_0_233:zs,content_0_234:Os,content_0_235:Vs,content_0_236:Hs,content_0_237:Js,content_0_238:Qs,content_0_239:ta,content_0_240:ea,content_0_241:pa,content_0_242:ra,content_0_243:aa,content_0_244:la,content_0_245:ma,content_0_246:ha,content_0_247:ka,content_0_248:Da,content_0_249:_a,content_0_250:wa,content_0_251:Ca,content_0_252:ga,content_0_253:Za,content_0_254:va,content_0_255:Sa,content_0_256:Ga,content_0_257:Ra,content_0_258:Ia,content_0_259:Ua,content_0_260:za,content_0_261:Oa,content_0_262:Va,content_0_263:Ha,content_0_264:Ja,content_0_265:Qa,content_0_266:ti,content_0_267:ei,content_0_268:pi,content_0_269:ri,content_0_270:ai,content_0_271:li,content_0_272:mi,content_0_273:hi,content_0_274:ki,content_0_275:Di,content_0_276:_i,content_0_277:wi,content_0_278:Ci,content_0_279:gi,content_0_280:Zi,content_0_281:vi,content_0_282:Si,content_0_283:Gi,content_0_284:Ri,content_0_285:Ii,content_0_286:Ui,content_0_287:zi,content_0_288:Oi,content_0_289:Vi,content_0_290:Hi,content_0_291:Ji,content_0_292:Qi,content_0_293:tl,content_0_294:el,content_0_295:pl,content_0_296:rl,content_0_297:al,content_0_298:ll,content_0_299:ml,content_0_300:hl,content_0_301:kl,content_0_302:Dl,content_0_303:_l,content_0_304:wl,content_0_305:Cl,content_0_306:gl,content_0_307:Zl,content_0_308:vl,content_0_309:Sl,content_0_310:Gl,content_0_311:Rl,content_0_312:Il,content_0_313:Ul,content_0_314:zl,content_0_315:Ol,content_0_316:Vl,content_0_317:Hl,content_0_318:Jl,content_0_319:Ql,content_0_320:tu,content_0_321:eu,content_0_322:pu,content_0_323:ru,content_0_324:au,content_0_325:lu,content_0_326:mu,content_0_327:hu,content_0_328:ku,content_0_329:Du,content_0_330:_u,content_0_331:wu,content_0_332:Cu,content_0_333:gu,content_0_334:Zu,content_0_335:vu,content_0_336:Su,content_0_337:Gu,content_0_338:Ru,content_0_339:Iu,content_0_340:Uu,content_0_341:zu,content_0_342:Ou,content_0_343:Vu,content_0_344:Hu,content_0_345:Ju,content_0_346:Qu,content_0_347:tm,content_0_348:em,content_0_349:pm,content_0_350:rm,content_0_351:am,content_0_352:lm,content_0_353:mm,content_0_354:hm,content_0_355:km,content_0_356:Dm,content_0_357:_m,content_0_358:wm,content_0_359:Cm,content_0_360:gm,content_0_361:Zm,content_0_362:vm,content_0_363:Sm,content_0_364:Gm,content_0_365:Rm,content_0_366:Im,content_0_367:Um,content_0_368:zm,content_0_369:Om,content_0_370:Vm,content_0_371:Hm,content_0_372:Jm,content_0_373:Qm,content_0_374:td,content_0_375:ed,content_0_376:pd,content_0_377:rd,content_0_378:ad,content_0_379:ld,content_0_380:md,content_0_381:hd,content_0_382:kd,content_0_383:Dd,content_0_384:_d,content_0_385:wd,content_0_386:Cd,content_0_387:gd,content_0_388:Zd,content_0_389:vd,content_0_390:Sd,content_0_391:Gd,content_0_392:Rd,content_0_393:Id,content_0_394:Ud,content_0_395:zd,content_0_396:Od,content_0_397:Vd,content_0_398:Hd,content_0_399:Jd,content_0_400:Qd,content_0_401:th,content_0_402:eh,content_0_403:ph,content_0_404:rh,content_0_405:ah,content_0_406:lh,content_0_407:mh,content_0_408:hh,content_0_409:kh,content_0_410:Dh,content_0_411:_h,content_0_412:wh,content_0_413:Ch,content_0_414:gh,content_0_415:Zh,content_0_416:vh,content_0_417:Sh,content_0_418:Gh,content_0_419:Rh,content_0_420:Ih,content_0_421:Uh,content_0_422:zh,content_0_423:Oh,content_0_424:Vh,content_0_425:Hh,content_0_426:Jh,content_0_427:Qh,content_0_428:ty,content_0_429:ey,content_0_430:py,content_0_431:ry,content_0_432:ay,content_0_433:ly,content_0_434:my,content_0_435:hy,content_0_436:ky,content_0_437:Dy,content_0_438:_y,content_0_439:wy,content_0_440:Cy,content_0_441:gy,content_0_442:Zy,content_0_443:vy,content_0_444:Sy,content_0_445:Gy,content_0_446:Ry,content_0_447:Iy,content_0_448:Uy,content_0_449:zy,content_2103_0:Oy,content_2103_1:Vy,content_2103_2:Hy,content_2103_3:Jy,content_2103_4:Qy,content_2103_5:tk,content_2103_6:ek,content_2103_7:pk,content_2103_8:rk,content_2103_9:ak,content_2103_10:lk,content_2103_11:mk,content_2103_12:hk,content_2103_13:kk,content_2103_14:Dk,content_2103_15:_k,content_2103_16:wk,content_2103_17:Ck,content_2103_18:gk,content_2103_19:Zk,content_2103_20:vk,content_2103_21:Sk,content_2103_22:Gk,content_2103_23:Rk,content_2103_24:Ik,content_2103_25:Uk,content_2103_26:zk,content_2103_27:Ok,content_2103_28:Vk,content_2103_29:Hk,content_2103_30:Jk,content_2103_31:Qk,content_2103_32:tf,content_2103_33:ef,content_2103_34:pf,content_2103_35:rf,content_2103_36:af,content_2103_37:uf,content_2103_38:df,content_2103_39:yf,content_2103_40:ff,content_2103_41:Mf,content_2103_42:Xf,content_2103_43:Tf,content_2103_44:xf,content_2103_45:Lf,content_2103_46:bf,content_2103_47:Nf,content_2103_48:Af,content_2103_49:Pf,content_2103_50:Ef,content_2103_51:Wf,content_2103_52:jf,content_2103_53:Ff,content_2103_54:qf,content_2103_55:Bf,content_2103_56:Yf,content_2103_57:Kf,content_2103_58:$f,content_2103_59:nD,content_2103_60:oD,content_2103_61:cD,content_2103_62:sD,content_2103_63:iD,content_2103_64:uD,content_2103_65:dD,content_2103_66:yD,content_2103_67:fD,content_2103_68:MD,content_2103_69:XD,content_2103_70:TD,content_2103_71:xD,content_2103_72:LD,content_2103_73:bD,content_2103_74:ND,content_2103_75:AD,content_2103_76:PD,content_2103_77:ED,content_2103_78:WD,content_2103_79:jD,content_2103_80:FD,content_2103_81:qD,content_2103_82:BD,content_2103_83:YD,content_2103_84:KD,content_2103_85:$D,content_2103_86:nM,content_2103_87:oM,content_2103_88:cM,content_2103_89:sM,content_2103_90:iM,content_2103_91:uM,content_2103_92:dM,content_2103_93:yM,content_2103_94:fM,content_2103_95:MM,content_2103_96:XM,content_2103_97:TM,content_2103_98:xM,content_2103_99:LM,content_2103_100:bM,content_2103_101:NM,content_2103_102:AM,content_2103_103:PM,content_2103_104:EM,content_2103_105:WM,content_2103_106:jM,content_2103_107:FM,content_2103_108:qM,content_2103_109:BM,content_2103_110:YM,content_2103_111:KM,content_2103_112:$M,content_2103_113:n_,content_2103_114:o_,content_2103_115:c_,content_2103_116:s_,content_2103_117:i_,content_2103_118:u_,content_2103_119:d_,content_2103_120:y_,content_2103_121:f_,content_2103_122:M_,content_2103_123:X_,content_2103_124:T_,content_2103_125:x_,content_2103_126:L_,content_2103_127:b_,content_2103_128:N_,content_2103_129:A_,content_2103_130:P_,content_2103_131:E_,content_2103_132:W_,content_2103_133:j_,content_2103_134:F_,content_2103_135:q_,content_2103_136:B_,content_2103_137:Y_,content_2103_138:K_,content_2103_139:$_,content_2103_140:nX,content_2103_141:oX,content_2103_142:cX,content_2103_143:sX,content_2103_144:iX,content_2103_145:uX,content_2103_146:dX,content_2103_147:yX,content_2103_148:fX,content_2103_149:MX,content_2103_150:XX,content_2103_151:TX,content_2103_152:xX,content_2103_153:LX,content_2103_154:bX,content_2103_155:NX,content_2103_156:AX,content_2103_157:PX,content_2103_158:EX,content_2103_159:WX,content_2103_160:jX,content_2103_161:FX,content_2103_162:qX,content_2103_163:BX,content_2103_164:YX,content_2103_165:KX,content_2103_166:$X,content_2103_167:nw,content_2103_168:ow,content_2103_169:cw,content_2103_170:sw,content_2103_171:iw,content_2103_172:uw,content_2103_173:dw,content_2103_174:yw,content_2103_175:fw,content_2103_176:Mw,content_2103_177:Xw,content_2103_178:Tw,content_2103_179:xw,content_2103_180:Lw,content_2103_181:bw,content_2103_182:Nw,content_2103_183:Aw,content_2103_184:Pw,content_2103_185:Ew,content_2103_186:Ww,content_2103_187:jw,content_2103_188:Fw,content_2103_189:qw,content_2103_190:Bw,content_2103_191:Yw,content_2103_192:Kw,content_2103_193:$w,content_2103_194:nT,content_2103_195:oT,content_2103_196:cT,content_2103_197:sT,content_2103_198:iT,content_2103_199:uT,content_2103_200:dT,content_2103_201:yT,content_2103_202:fT,content_2103_203:MT,content_2103_204:XT,content_2103_205:TT,content_2103_206:xT,content_2103_207:LT,content_2103_208:bT,content_2103_209:NT,content_2103_210:AT,content_2103_211:PT,content_2103_212:ET,content_2103_213:WT,content_2103_214:jT,content_2103_215:FT,content_2103_216:qT,content_2103_217:BT,content_2103_218:YT,content_2103_219:KT,content_2103_220:$T,content_2103_221:nC,content_2103_222:oC,content_2103_223:cC,content_2103_224:sC,content_2103_225:iC,content_2103_226:uC,content_2103_227:dC,content_2103_228:yC,content_2103_229:fC,content_2103_230:MC,content_2103_231:XC,content_2103_232:TC,content_2103_233:xC,content_2103_234:LC,content_2103_235:bC,content_2103_236:NC,content_2103_237:AC,content_2103_238:PC,content_2103_239:EC,content_2103_240:WC,content_2103_241:jC,content_2103_242:FC,content_2103_243:qC,content_2103_244:BC,content_2103_245:YC,content_2103_246:KC,content_2103_247:$C,content_2103_248:nx,content_2103_249:ox,content_2103_250:cx,content_2103_251:sx,content_2103_252:ix,content_2103_253:ux,content_2103_254:dx,content_2103_255:yx,content_2103_256:fx,content_2103_257:Mx,content_2103_258:Xx,content_2103_259:Tx,content_2103_260:xx,content_2103_261:Lx,content_2103_262:bx,content_2103_263:Nx,content_2103_264:Ax,content_2103_265:Px,content_2103_266:Ex,content_2103_267:Wx,content_2103_268:jx,content_2103_269:Fx,content_2103_270:qx,content_2103_271:Bx,content_2103_272:Yx,content_2103_273:Kx,content_2103_274:$x,content_2103_275:ng,content_2103_276:og,content_2103_277:cg,content_2103_278:sg,content_2103_279:ig,content_2103_280:ug,content_2103_281:dg,content_2103_282:yg,content_2103_283:fg,content_2103_284:Mg,content_2103_285:Xg,content_2103_286:Tg,content_2103_287:xg,content_2103_288:Lg,content_2103_289:bg,content_2103_290:Ng,content_2103_291:Ag,content_2103_292:Pg,content_2103_293:Eg,content_2103_294:Wg,content_2103_295:jg,content_2103_296:Fg,content_2103_297:qg,content_2103_298:Bg,content_2103_299:Yg,content_2103_300:Kg,content_2103_301:$g,content_2103_302:nL,content_2103_303:oL,content_2103_304:cL,content_2103_305:sL,content_2103_306:iL,content_2103_307:uL,content_2103_308:dL,content_2103_309:yL,content_2103_310:fL,content_2103_311:ML,content_2103_312:XL,content_2103_313:TL,content_2103_314:xL,content_2103_315:LL,content_2103_316:bL,content_2103_317:NL,content_2103_318:AL,content_2103_319:PL,content_2103_320:EL,content_2103_321:WL,content_2103_322:jL,content_2103_323:FL,content_2103_324:qL,content_2103_325:BL,content_2103_326:YL,content_2103_327:KL,content_2103_328:$L,content_2103_329:nZ,content_2103_330:oZ,content_2103_331:cZ,content_2103_332:sZ,content_2103_333:iZ,content_2103_334:uZ,content_2103_335:dZ,content_2103_336:yZ,content_2103_337:fZ,content_2103_338:MZ,content_2103_339:XZ,content_2103_340:TZ,content_2103_341:xZ,content_2103_342:LZ,content_2103_343:bZ,content_2103_344:NZ,content_2103_345:AZ,content_2103_346:PZ,content_2103_347:EZ,content_2103_348:WZ,content_2103_349:jZ,content_2103_350:FZ,content_2103_351:qZ,content_2103_352:BZ,content_2103_353:YZ,content_2103_354:KZ,content_2103_355:$Z,content_2103_356:nb,content_2103_357:ob,content_2103_358:cb,content_2103_359:sb,content_2103_360:ib,content_2103_361:ub,content_2103_362:db,content_2103_363:yb,content_2103_364:fb,content_2103_365:Mb,content_2103_366:Xb,content_2103_367:Tb,content_2103_368:xb,content_2103_369:Lb,content_2103_370:bb,content_2103_371:Nb,content_2103_372:Ab,content_2103_373:Pb,content_2103_374:Eb,content_2103_375:Wb,content_2103_376:jb,content_2103_377:Fb,content_2103_378:qb,content_2103_379:Bb,content_2103_380:Yb,content_2103_381:Kb,content_2103_382:$b,content_2103_383:nv,content_2103_384:ov,content_2103_385:cv,content_2103_386:sv,content_2103_387:iv,content_2103_388:uv,content_2103_389:dv,content_2103_390:yv,content_2103_391:fv,content_2103_392:Mv,content_2103_393:Xv,content_2103_394:Tv,content_2103_395:xv,content_2103_396:Lv,content_2103_397:bv,content_2103_398:Nv,content_2103_399:Av,content_2103_400:Pv,content_2103_401:Ev,content_2103_402:Wv,content_2103_403:jv,content_2103_404:Fv,content_2103_405:qv,content_2103_406:Bv,content_2103_407:Yv,content_2103_408:Kv,content_2103_409:$v,content_2103_410:nN,content_2103_411:oN,content_2103_412:cN,content_2103_413:sN,content_2103_414:iN,content_2103_415:uN,content_2103_416:dN,content_2103_417:yN,content_2103_418:fN,content_2103_419:MN,content_2103_420:XN,content_2103_421:TN,content_2103_422:xN,content_2103_423:LN,content_2103_424:bN,content_2103_425:NN,content_2103_426:AN,content_2103_427:PN,content_2103_428:EN,content_2103_429:WN,content_2103_430:jN,content_2103_431:FN,content_2103_432:qN,content_2103_433:BN,content_2103_434:YN,content_2103_435:KN,content_2103_436:$N,content_2103_437:nS,content_2103_438:oS,content_2103_439:cS,content_2103_440:sS,content_2103_441:iS,content_2103_442:uS,content_2103_443:dS,content_2103_444:yS,content_2103_445:fS,content_2103_446:MS,content_2103_447:XS,content_2103_448:TS,content_2103_449:xS,content_2103_450:LS,content_2103_451:bS,content_2103_452:NS,content_2103_453:AS,content_2103_454:PS,content_2103_455:ES,content_2103_456:WS,content_2103_457:jS,content_2103_458:FS,content_2103_459:qS,content_2103_460:BS,content_2103_461:YS,content_2103_462:KS,content_2103_463:$S,content_2103_464:nA,content_2103_465:oA,content_2103_466:cA,content_2103_467:sA,content_2103_468:iA,content_2103_469:uA,content_2103_470:dA,content_2103_471:yA,content_2103_472:fA,content_2103_473:MA,content_2103_474:XA,content_2103_475:TA,content_2103_476:xA,content_2103_477:LA,content_2103_478:bA,content_2103_479:NA,content_2103_480:AA,content_2103_481:PA,content_2103_482:EA,content_2103_483:WA,content_2103_484:jA,content_2103_485:FA,content_2103_486:qA,content_2103_487:BA,content_2103_488:YA,content_2103_489:KA,content_2103_490:$A,content_2103_491:nG,content_2103_492:oG,content_2103_493:cG,content_2103_494:sG,content_2103_495:iG,content_2103_496:uG,content_2103_497:dG,content_2103_498:yG,content_2103_499:fG,content_2103_500:MG,content_2103_501:XG,content_2103_502:TG,content_2103_503:xG,content_2103_504:LG,content_2103_505:bG,content_2103_506:NG,content_2103_507:AG,content_2103_508:PG,content_2103_509:EG,content_2103_510:WG,content_2103_511:jG,content_2103_512:FG,content_2103_513:qG,content_2103_514:BG,content_2103_515:YG,content_2103_516:KG,content_2103_517:$G,content_2103_518:nP,content_2103_519:oP,content_2103_520:cP,content_2103_521:sP,content_2103_522:iP,content_2103_523:uP,content_2103_524:dP,content_2103_525:yP,content_2103_526:fP,content_2103_527:MP,content_2103_528:XP,content_2103_529:TP,content_2103_530:xP,content_2103_531:LP,content_2103_532:bP,content_2103_533:NP,content_2103_534:AP,content_2103_535:PP}}}]);
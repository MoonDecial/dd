"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3805],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function r(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function c(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?r(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var a=o.createContext({}),i=function(t){var n=o.useContext(a),e=n;return t&&(e="function"==typeof t?t(n):c(c({},n),t)),e},l=function(t){var n=i(t.components);return o.createElement(a.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,r=t.originalType,a=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),u=i(e),d=p,h=u["".concat(a,".").concat(d)]||u[d]||m[d]||r;return e?o.createElement(h,c(c({ref:n},l),{},{components:e})):o.createElement(h,c({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var r=e.length,c=new Array(r);c[0]=d;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=t,s[u]="string"==typeof t?t:p,c[1]=s;for(var i=2;i<r;i++)c[i]=e[i];return o.createElement.apply(null,c)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},3851:(t,n,e)=>{e.d(n,{Z:()=>l});var o=e(7896),p=e(2784),r=e(6277),c=e(1077),s=e(7683);const a="anchorWithStickyNavbar_fF9Z",i="anchorWithHideOnScrollNavbar_Yh18";function l(t){let{as:n,id:e,...l}=t;const{navbar:{hideOnScroll:u}}=(0,s.L)();return"h1"!==n&&e?p.createElement(n,(0,o.Z)({},l,{className:(0,r.Z)("anchor",u?i:a),id:e}),l.children,p.createElement("a",{className:"hash-link",href:`#${e}`,title:(0,c.I)({id:"theme.common.headingLinkTitle",message:"Direct link to heading",description:"Title for link to heading"})},"\u200b")):p.createElement(n,(0,o.Z)({},l,{id:void 0}))}},2072:(t,n,e)=>{e.d(n,{Z:()=>c});var o=e(2784),p=e(8617),r=e(1836);function c(t){let{url:n}=t;const e=(0,p.rG)()(n);return o.createElement(r.Z,{reflection:e,headless:!0})}},9770:(t,n,e)=>{e.d(n,{Z:()=>t2});var o={};e.r(o),e.d(o,{content_0_0:()=>a,content_0_10:()=>w,content_0_100:()=>tn,content_0_102:()=>en,content_0_104:()=>pn,content_0_106:()=>cn,content_0_108:()=>an,content_0_110:()=>un,content_0_112:()=>dn,content_0_114:()=>kn,content_0_116:()=>fn,content_0_118:()=>Dn,content_0_12:()=>M,content_0_120:()=>_n,content_0_122:()=>gn,content_0_124:()=>Cn,content_0_126:()=>Ln,content_0_128:()=>vn,content_0_130:()=>Nn,content_0_132:()=>An,content_0_134:()=>Rn,content_0_136:()=>In,content_0_138:()=>Wn,content_0_14:()=>X,content_0_140:()=>Fn,content_0_142:()=>jn,content_0_144:()=>Vn,content_0_146:()=>Bn,content_0_148:()=>Hn,content_0_150:()=>Jn,content_0_152:()=>Qn,content_0_154:()=>ne,content_0_156:()=>oe,content_0_158:()=>re,content_0_16:()=>x,content_0_160:()=>se,content_0_162:()=>ie,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>ke,content_0_170:()=>fe,content_0_172:()=>De,content_0_174:()=>_e,content_0_176:()=>ge,content_0_178:()=>Ce,content_0_18:()=>T,content_0_180:()=>Le,content_0_182:()=>ve,content_0_184:()=>Ne,content_0_186:()=>Ae,content_0_188:()=>Re,content_0_190:()=>Ie,content_0_192:()=>We,content_0_194:()=>Fe,content_0_196:()=>je,content_0_198:()=>Ve,content_0_2:()=>l,content_0_20:()=>Z,content_0_200:()=>Be,content_0_202:()=>He,content_0_204:()=>Je,content_0_206:()=>Qe,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>so,content_0_216:()=>io,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>wo,content_0_226:()=>Mo,content_0_228:()=>Xo,content_0_230:()=>xo,content_0_232:()=>To,content_0_234:()=>Zo,content_0_236:()=>bo,content_0_238:()=>Eo,content_0_24:()=>E,content_0_240:()=>So,content_0_242:()=>zo,content_0_244:()=>Po,content_0_246:()=>Go,content_0_248:()=>Uo,content_0_250:()=>Oo,content_0_252:()=>qo,content_0_254:()=>$o,content_0_256:()=>Yo,content_0_258:()=>Ko,content_0_26:()=>S,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>cp,content_0_268:()=>ap,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>yp,content_0_278:()=>wp,content_0_28:()=>z,content_0_280:()=>Mp,content_0_282:()=>Xp,content_0_284:()=>xp,content_0_286:()=>Tp,content_0_288:()=>Zp,content_0_290:()=>bp,content_0_292:()=>Ep,content_0_294:()=>Sp,content_0_296:()=>zp,content_0_298:()=>Pp,content_0_30:()=>P,content_0_300:()=>Gp,content_0_302:()=>Up,content_0_304:()=>Op,content_0_306:()=>qp,content_0_308:()=>$p,content_0_310:()=>Yp,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>er,content_0_318:()=>pr,content_0_32:()=>G,content_0_320:()=>cr,content_0_322:()=>ar,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>yr,content_0_332:()=>wr,content_0_334:()=>Mr,content_0_336:()=>Xr,content_0_338:()=>xr,content_0_34:()=>U,content_0_340:()=>Tr,content_0_342:()=>Zr,content_0_344:()=>br,content_0_346:()=>Er,content_0_348:()=>Sr,content_0_350:()=>zr,content_0_352:()=>Pr,content_0_354:()=>Gr,content_0_356:()=>Ur,content_0_358:()=>Or,content_0_36:()=>O,content_0_360:()=>qr,content_0_362:()=>$r,content_0_364:()=>Yr,content_0_366:()=>Kr,content_0_368:()=>tc,content_0_370:()=>ec,content_0_372:()=>pc,content_0_374:()=>cc,content_0_376:()=>ac,content_0_378:()=>lc,content_0_38:()=>q,content_0_380:()=>mc,content_0_382:()=>hc,content_0_384:()=>yc,content_0_386:()=>wc,content_0_388:()=>Mc,content_0_390:()=>Xc,content_0_392:()=>xc,content_0_394:()=>Tc,content_0_396:()=>Zc,content_0_398:()=>bc,content_0_4:()=>m,content_0_40:()=>$,content_0_400:()=>Ec,content_0_402:()=>Sc,content_0_404:()=>zc,content_0_406:()=>Pc,content_0_408:()=>Gc,content_0_410:()=>Uc,content_0_412:()=>Oc,content_0_414:()=>qc,content_0_416:()=>$c,content_0_418:()=>Yc,content_0_42:()=>Y,content_0_420:()=>Kc,content_0_422:()=>ts,content_0_424:()=>es,content_0_426:()=>ps,content_0_428:()=>cs,content_0_430:()=>as,content_0_432:()=>ls,content_0_434:()=>ms,content_0_436:()=>hs,content_0_438:()=>ys,content_0_44:()=>K,content_0_440:()=>ws,content_0_442:()=>Ms,content_0_444:()=>Xs,content_0_446:()=>xs,content_0_448:()=>Ts,content_0_450:()=>Zs,content_0_452:()=>bs,content_0_454:()=>Es,content_0_456:()=>Ss,content_0_458:()=>zs,content_0_46:()=>tt,content_0_460:()=>Ps,content_0_462:()=>Gs,content_0_464:()=>Us,content_0_466:()=>Os,content_0_468:()=>qs,content_0_470:()=>$s,content_0_472:()=>Ys,content_0_474:()=>Ks,content_0_476:()=>ta,content_0_478:()=>ea,content_0_48:()=>et,content_0_480:()=>pa,content_0_482:()=>ca,content_0_484:()=>aa,content_0_486:()=>la,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>ya,content_0_494:()=>wa,content_0_496:()=>Ma,content_0_498:()=>Xa,content_0_50:()=>pt,content_0_500:()=>xa,content_0_502:()=>Ta,content_0_504:()=>Za,content_0_506:()=>ba,content_0_508:()=>Ea,content_0_510:()=>Sa,content_0_512:()=>za,content_0_514:()=>Pa,content_0_516:()=>Ga,content_0_518:()=>Ua,content_0_52:()=>ct,content_0_520:()=>Oa,content_0_522:()=>qa,content_0_524:()=>$a,content_0_526:()=>Ya,content_0_528:()=>Ka,content_0_530:()=>ti,content_0_532:()=>ei,content_0_534:()=>pi,content_0_536:()=>ci,content_0_538:()=>ai,content_0_54:()=>at,content_0_540:()=>li,content_0_542:()=>mi,content_0_544:()=>hi,content_0_546:()=>yi,content_0_548:()=>wi,content_0_550:()=>Mi,content_0_552:()=>Xi,content_0_554:()=>xi,content_0_556:()=>Ti,content_0_558:()=>Zi,content_0_56:()=>lt,content_0_560:()=>bi,content_0_562:()=>Ei,content_0_564:()=>Si,content_0_566:()=>zi,content_0_568:()=>Pi,content_0_570:()=>Gi,content_0_572:()=>Ui,content_0_574:()=>Oi,content_0_576:()=>qi,content_0_578:()=>$i,content_0_58:()=>mt,content_0_580:()=>Yi,content_0_582:()=>Ki,content_0_584:()=>tl,content_0_586:()=>el,content_0_588:()=>pl,content_0_590:()=>cl,content_0_592:()=>al,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yl,content_0_602:()=>wl,content_0_604:()=>Ml,content_0_606:()=>Xl,content_0_608:()=>xl,content_0_610:()=>Tl,content_0_612:()=>Zl,content_0_614:()=>bl,content_0_616:()=>El,content_0_618:()=>Sl,content_0_62:()=>yt,content_0_620:()=>zl,content_0_622:()=>Pl,content_0_624:()=>Gl,content_0_626:()=>Ul,content_0_628:()=>Ol,content_0_630:()=>ql,content_0_632:()=>$l,content_0_634:()=>Yl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>wt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>cu,content_0_646:()=>au,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>wu,content_0_658:()=>Mu,content_0_66:()=>Mt,content_0_660:()=>Xu,content_0_662:()=>xu,content_0_664:()=>Tu,content_0_666:()=>Zu,content_0_668:()=>bu,content_0_670:()=>Eu,content_0_672:()=>Su,content_0_674:()=>zu,content_0_676:()=>Pu,content_0_678:()=>Gu,content_0_68:()=>Xt,content_0_680:()=>Uu,content_0_682:()=>Ou,content_0_684:()=>qu,content_0_686:()=>$u,content_0_688:()=>Yu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>cm,content_0_70:()=>xt,content_0_700:()=>am,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>wm,content_0_712:()=>Mm,content_0_714:()=>Xm,content_0_716:()=>xm,content_0_718:()=>Tm,content_0_72:()=>Tt,content_0_720:()=>Zm,content_0_722:()=>bm,content_0_724:()=>Em,content_0_726:()=>Sm,content_0_728:()=>zm,content_0_730:()=>Pm,content_0_732:()=>Gm,content_0_734:()=>Um,content_0_736:()=>Om,content_0_738:()=>qm,content_0_74:()=>Zt,content_0_740:()=>$m,content_0_742:()=>Ym,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>cd,content_0_754:()=>ad,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>wd,content_0_766:()=>Md,content_0_768:()=>Xd,content_0_770:()=>xd,content_0_772:()=>Td,content_0_774:()=>Zd,content_0_776:()=>bd,content_0_778:()=>Ed,content_0_78:()=>Et,content_0_780:()=>Sd,content_0_782:()=>zd,content_0_784:()=>Pd,content_0_786:()=>Gd,content_0_788:()=>Ud,content_0_790:()=>Od,content_0_792:()=>qd,content_0_794:()=>$d,content_0_796:()=>Yd,content_0_798:()=>Kd,content_0_8:()=>y,content_0_80:()=>St,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>ch,content_0_808:()=>ah,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>wh,content_0_82:()=>zt,content_0_820:()=>Mh,content_0_822:()=>Xh,content_0_824:()=>xh,content_0_826:()=>Th,content_0_828:()=>Zh,content_0_830:()=>bh,content_0_832:()=>Eh,content_0_834:()=>Sh,content_0_836:()=>zh,content_0_838:()=>Ph,content_0_84:()=>Pt,content_0_840:()=>Gh,content_0_842:()=>Uh,content_0_844:()=>Oh,content_0_846:()=>qh,content_0_848:()=>$h,content_0_850:()=>Yh,content_0_852:()=>Kh,content_0_854:()=>tk,content_0_856:()=>ek,content_0_858:()=>pk,content_0_86:()=>Gt,content_0_860:()=>ck,content_0_862:()=>ak,content_0_864:()=>lk,content_0_866:()=>mk,content_0_868:()=>hk,content_0_870:()=>yk,content_0_872:()=>wk,content_0_874:()=>Mk,content_0_876:()=>Xk,content_0_878:()=>xk,content_0_88:()=>Ut,content_0_880:()=>Tk,content_0_882:()=>Zk,content_0_884:()=>bk,content_0_886:()=>Ek,content_0_888:()=>Sk,content_0_890:()=>zk,content_0_892:()=>Pk,content_0_894:()=>Gk,content_0_896:()=>Uk,content_0_898:()=>Ok,content_0_90:()=>Ot,content_0_900:()=>qk,content_0_902:()=>$k,content_0_904:()=>Yk,content_0_906:()=>Kk,content_0_908:()=>ty,content_0_910:()=>ey,content_0_912:()=>py,content_0_914:()=>cy,content_0_916:()=>ay,content_0_918:()=>ly,content_0_92:()=>qt,content_0_920:()=>my,content_0_922:()=>hy,content_0_924:()=>yy,content_0_94:()=>$t,content_0_96:()=>Yt,content_0_98:()=>Kt,content_2133_0:()=>wy,content_2133_10:()=>Zy,content_2133_100:()=>uw,content_2133_1000:()=>BS,content_2133_1002:()=>HS,content_2133_1004:()=>JS,content_2133_1006:()=>QS,content_2133_1008:()=>nR,content_2133_1010:()=>oR,content_2133_1012:()=>rR,content_2133_1014:()=>sR,content_2133_1016:()=>iR,content_2133_1018:()=>uR,content_2133_102:()=>dw,content_2133_1020:()=>dR,content_2133_1022:()=>kR,content_2133_1024:()=>fR,content_2133_1026:()=>DR,content_2133_1028:()=>_R,content_2133_1030:()=>gR,content_2133_1032:()=>CR,content_2133_1034:()=>LR,content_2133_1036:()=>vR,content_2133_1038:()=>NR,content_2133_104:()=>kw,content_2133_1040:()=>AR,content_2133_1042:()=>RR,content_2133_1044:()=>IR,content_2133_1046:()=>WR,content_2133_1048:()=>FR,content_2133_1050:()=>jR,content_2133_1052:()=>VR,content_2133_1054:()=>BR,content_2133_1056:()=>HR,content_2133_1058:()=>JR,content_2133_106:()=>fw,content_2133_1060:()=>QR,content_2133_1062:()=>nz,content_2133_1064:()=>oz,content_2133_1066:()=>rz,content_2133_1068:()=>sz,content_2133_1070:()=>iz,content_2133_1072:()=>uz,content_2133_1074:()=>dz,content_2133_1076:()=>kz,content_2133_1078:()=>fz,content_2133_108:()=>Dw,content_2133_1080:()=>Dz,content_2133_1082:()=>_z,content_2133_1084:()=>gz,content_2133_1086:()=>Cz,content_2133_1088:()=>Lz,content_2133_1090:()=>vz,content_2133_1092:()=>Nz,content_2133_1094:()=>Az,content_2133_1096:()=>Rz,content_2133_1098:()=>Iz,content_2133_110:()=>_w,content_2133_1100:()=>Wz,content_2133_1102:()=>Fz,content_2133_1104:()=>jz,content_2133_1106:()=>Vz,content_2133_1108:()=>Bz,content_2133_1110:()=>Hz,content_2133_1112:()=>Jz,content_2133_1114:()=>Qz,content_2133_1116:()=>nI,content_2133_1118:()=>oI,content_2133_112:()=>gw,content_2133_1120:()=>rI,content_2133_1122:()=>sI,content_2133_1124:()=>iI,content_2133_1126:()=>uI,content_2133_1128:()=>dI,content_2133_1130:()=>kI,content_2133_1132:()=>fI,content_2133_1134:()=>DI,content_2133_1136:()=>_I,content_2133_1138:()=>gI,content_2133_114:()=>Cw,content_2133_1140:()=>CI,content_2133_1142:()=>LI,content_2133_1144:()=>vI,content_2133_1146:()=>NI,content_2133_1148:()=>AI,content_2133_1150:()=>RI,content_2133_1152:()=>II,content_2133_1154:()=>WI,content_2133_1156:()=>FI,content_2133_1158:()=>jI,content_2133_116:()=>Lw,content_2133_1160:()=>VI,content_2133_1162:()=>BI,content_2133_1164:()=>HI,content_2133_1166:()=>JI,content_2133_1168:()=>QI,content_2133_1170:()=>nP,content_2133_1172:()=>oP,content_2133_1174:()=>rP,content_2133_1176:()=>sP,content_2133_1178:()=>iP,content_2133_118:()=>vw,content_2133_1180:()=>uP,content_2133_1182:()=>dP,content_2133_1184:()=>kP,content_2133_1186:()=>fP,content_2133_1188:()=>DP,content_2133_1190:()=>_P,content_2133_1192:()=>gP,content_2133_1194:()=>CP,content_2133_1196:()=>LP,content_2133_1198:()=>vP,content_2133_12:()=>by,content_2133_120:()=>Nw,content_2133_1200:()=>NP,content_2133_1202:()=>AP,content_2133_1204:()=>RP,content_2133_1206:()=>IP,content_2133_1208:()=>WP,content_2133_1210:()=>FP,content_2133_1212:()=>jP,content_2133_1214:()=>VP,content_2133_1216:()=>BP,content_2133_1218:()=>HP,content_2133_122:()=>Aw,content_2133_1220:()=>JP,content_2133_1222:()=>QP,content_2133_1224:()=>nW,content_2133_1226:()=>oW,content_2133_1228:()=>rW,content_2133_1230:()=>sW,content_2133_1232:()=>iW,content_2133_1234:()=>uW,content_2133_1236:()=>dW,content_2133_1238:()=>kW,content_2133_124:()=>Rw,content_2133_1240:()=>fW,content_2133_1242:()=>DW,content_2133_1244:()=>_W,content_2133_1246:()=>gW,content_2133_1248:()=>CW,content_2133_1250:()=>LW,content_2133_1252:()=>vW,content_2133_1254:()=>NW,content_2133_1256:()=>AW,content_2133_1258:()=>RW,content_2133_126:()=>Iw,content_2133_1260:()=>IW,content_2133_1262:()=>WW,content_2133_1264:()=>FW,content_2133_1266:()=>jW,content_2133_1268:()=>VW,content_2133_1270:()=>BW,content_2133_1272:()=>HW,content_2133_1274:()=>JW,content_2133_1276:()=>QW,content_2133_1278:()=>nG,content_2133_128:()=>Ww,content_2133_1280:()=>oG,content_2133_1282:()=>rG,content_2133_1284:()=>sG,content_2133_1286:()=>iG,content_2133_1288:()=>uG,content_2133_1290:()=>dG,content_2133_1292:()=>kG,content_2133_1294:()=>fG,content_2133_1296:()=>DG,content_2133_1298:()=>_G,content_2133_130:()=>Fw,content_2133_1300:()=>gG,content_2133_1302:()=>CG,content_2133_1304:()=>LG,content_2133_1306:()=>vG,content_2133_1308:()=>NG,content_2133_1310:()=>AG,content_2133_1312:()=>RG,content_2133_1314:()=>IG,content_2133_1316:()=>WG,content_2133_1318:()=>FG,content_2133_132:()=>jw,content_2133_1320:()=>jG,content_2133_1322:()=>VG,content_2133_1324:()=>BG,content_2133_1326:()=>HG,content_2133_1328:()=>JG,content_2133_1330:()=>QG,content_2133_1332:()=>nF,content_2133_1334:()=>oF,content_2133_1336:()=>rF,content_2133_1338:()=>sF,content_2133_134:()=>Vw,content_2133_1340:()=>iF,content_2133_1342:()=>uF,content_2133_1344:()=>dF,content_2133_1346:()=>kF,content_2133_1348:()=>fF,content_2133_1350:()=>DF,content_2133_1352:()=>_F,content_2133_1354:()=>gF,content_2133_1356:()=>CF,content_2133_1358:()=>LF,content_2133_136:()=>Bw,content_2133_1360:()=>vF,content_2133_1362:()=>NF,content_2133_1364:()=>AF,content_2133_1366:()=>RF,content_2133_1368:()=>IF,content_2133_1370:()=>WF,content_2133_1372:()=>FF,content_2133_1374:()=>jF,content_2133_1376:()=>VF,content_2133_1378:()=>BF,content_2133_138:()=>Hw,content_2133_1380:()=>HF,content_2133_1382:()=>JF,content_2133_1384:()=>QF,content_2133_1386:()=>nU,content_2133_1388:()=>oU,content_2133_1390:()=>rU,content_2133_1392:()=>sU,content_2133_1394:()=>iU,content_2133_1396:()=>uU,content_2133_1398:()=>dU,content_2133_14:()=>Ey,content_2133_140:()=>Jw,content_2133_1400:()=>kU,content_2133_1402:()=>fU,content_2133_1404:()=>DU,content_2133_1406:()=>_U,content_2133_1408:()=>gU,content_2133_1410:()=>CU,content_2133_1412:()=>LU,content_2133_1414:()=>vU,content_2133_1416:()=>NU,content_2133_1418:()=>AU,content_2133_142:()=>Qw,content_2133_1420:()=>RU,content_2133_1422:()=>IU,content_2133_1424:()=>WU,content_2133_1426:()=>FU,content_2133_1428:()=>jU,content_2133_1430:()=>VU,content_2133_1432:()=>BU,content_2133_1434:()=>HU,content_2133_1436:()=>JU,content_2133_1438:()=>QU,content_2133_144:()=>nD,content_2133_1440:()=>nj,content_2133_1442:()=>oj,content_2133_1444:()=>rj,content_2133_1446:()=>sj,content_2133_1448:()=>ij,content_2133_1450:()=>uj,content_2133_1452:()=>dj,content_2133_1454:()=>kj,content_2133_1456:()=>fj,content_2133_1458:()=>Dj,content_2133_146:()=>oD,content_2133_1460:()=>_j,content_2133_1462:()=>gj,content_2133_1464:()=>Cj,content_2133_1466:()=>Lj,content_2133_1468:()=>vj,content_2133_1470:()=>Nj,content_2133_1472:()=>Aj,content_2133_1474:()=>Rj,content_2133_1476:()=>Ij,content_2133_1478:()=>Wj,content_2133_148:()=>rD,content_2133_1480:()=>Fj,content_2133_1482:()=>jj,content_2133_1484:()=>Vj,content_2133_1486:()=>Bj,content_2133_1488:()=>Hj,content_2133_1490:()=>Jj,content_2133_1492:()=>Qj,content_2133_1494:()=>nO,content_2133_1496:()=>oO,content_2133_1498:()=>rO,content_2133_150:()=>sD,content_2133_1500:()=>sO,content_2133_1502:()=>iO,content_2133_1504:()=>uO,content_2133_1506:()=>dO,content_2133_1508:()=>kO,content_2133_1510:()=>fO,content_2133_1512:()=>DO,content_2133_1514:()=>_O,content_2133_1516:()=>gO,content_2133_1518:()=>CO,content_2133_152:()=>iD,content_2133_1520:()=>LO,content_2133_1522:()=>vO,content_2133_1524:()=>NO,content_2133_1526:()=>AO,content_2133_1528:()=>RO,content_2133_1530:()=>IO,content_2133_1532:()=>WO,content_2133_1534:()=>FO,content_2133_1536:()=>jO,content_2133_1538:()=>VO,content_2133_154:()=>uD,content_2133_1540:()=>BO,content_2133_1542:()=>HO,content_2133_1544:()=>JO,content_2133_1546:()=>QO,content_2133_1548:()=>nV,content_2133_1550:()=>oV,content_2133_1552:()=>rV,content_2133_1554:()=>sV,content_2133_1556:()=>iV,content_2133_1558:()=>uV,content_2133_156:()=>dD,content_2133_1560:()=>dV,content_2133_1562:()=>kV,content_2133_1564:()=>fV,content_2133_1566:()=>DV,content_2133_1568:()=>_V,content_2133_1570:()=>gV,content_2133_1572:()=>CV,content_2133_1574:()=>LV,content_2133_1576:()=>vV,content_2133_1578:()=>NV,content_2133_158:()=>kD,content_2133_1580:()=>AV,content_2133_1582:()=>RV,content_2133_1584:()=>IV,content_2133_1586:()=>WV,content_2133_1588:()=>FV,content_2133_1590:()=>jV,content_2133_1592:()=>VV,content_2133_1594:()=>BV,content_2133_1596:()=>HV,content_2133_1598:()=>JV,content_2133_16:()=>Sy,content_2133_160:()=>fD,content_2133_1600:()=>QV,content_2133_1602:()=>nq,content_2133_1604:()=>oq,content_2133_1606:()=>rq,content_2133_1608:()=>sq,content_2133_1610:()=>iq,content_2133_1612:()=>uq,content_2133_1614:()=>dq,content_2133_1616:()=>kq,content_2133_1618:()=>fq,content_2133_162:()=>DD,content_2133_1620:()=>Dq,content_2133_1622:()=>_q,content_2133_1624:()=>gq,content_2133_1626:()=>Cq,content_2133_1628:()=>Lq,content_2133_1630:()=>vq,content_2133_1632:()=>Nq,content_2133_1634:()=>Aq,content_2133_1636:()=>Rq,content_2133_1638:()=>Iq,content_2133_164:()=>_D,content_2133_1640:()=>Wq,content_2133_1642:()=>Fq,content_2133_1644:()=>jq,content_2133_1646:()=>Vq,content_2133_1648:()=>Bq,content_2133_1650:()=>Hq,content_2133_1652:()=>Jq,content_2133_1654:()=>Qq,content_2133_1656:()=>nB,content_2133_1658:()=>oB,content_2133_166:()=>gD,content_2133_1660:()=>rB,content_2133_1662:()=>sB,content_2133_1664:()=>iB,content_2133_1666:()=>uB,content_2133_1668:()=>dB,content_2133_1670:()=>kB,content_2133_1672:()=>fB,content_2133_1674:()=>DB,content_2133_1676:()=>_B,content_2133_1678:()=>gB,content_2133_168:()=>CD,content_2133_1680:()=>CB,content_2133_1682:()=>LB,content_2133_1684:()=>vB,content_2133_1686:()=>NB,content_2133_1688:()=>AB,content_2133_1690:()=>RB,content_2133_1692:()=>IB,content_2133_1694:()=>WB,content_2133_1696:()=>FB,content_2133_1698:()=>jB,content_2133_170:()=>LD,content_2133_1700:()=>VB,content_2133_1702:()=>BB,content_2133_1704:()=>HB,content_2133_1706:()=>JB,content_2133_1708:()=>QB,content_2133_1710:()=>n$,content_2133_1712:()=>o$,content_2133_1714:()=>r$,content_2133_1716:()=>s$,content_2133_1718:()=>i$,content_2133_172:()=>vD,content_2133_1720:()=>u$,content_2133_1722:()=>d$,content_2133_1724:()=>k$,content_2133_1726:()=>f$,content_2133_1728:()=>D$,content_2133_1730:()=>_$,content_2133_1732:()=>g$,content_2133_1734:()=>C$,content_2133_1736:()=>L$,content_2133_1738:()=>v$,content_2133_174:()=>ND,content_2133_1740:()=>N$,content_2133_1742:()=>A$,content_2133_1744:()=>R$,content_2133_1746:()=>I$,content_2133_1748:()=>W$,content_2133_1750:()=>F$,content_2133_1752:()=>j$,content_2133_1754:()=>V$,content_2133_1756:()=>B$,content_2133_1758:()=>H$,content_2133_176:()=>AD,content_2133_1760:()=>J$,content_2133_1762:()=>Q$,content_2133_1764:()=>nH,content_2133_1766:()=>oH,content_2133_1768:()=>rH,content_2133_1770:()=>sH,content_2133_1772:()=>iH,content_2133_1774:()=>uH,content_2133_1776:()=>dH,content_2133_1778:()=>kH,content_2133_178:()=>RD,content_2133_1780:()=>fH,content_2133_1782:()=>DH,content_2133_1784:()=>_H,content_2133_1786:()=>gH,content_2133_1788:()=>CH,content_2133_1790:()=>LH,content_2133_1792:()=>vH,content_2133_1794:()=>NH,content_2133_1796:()=>AH,content_2133_1798:()=>RH,content_2133_18:()=>zy,content_2133_180:()=>ID,content_2133_1800:()=>IH,content_2133_1802:()=>WH,content_2133_1804:()=>FH,content_2133_1806:()=>jH,content_2133_1808:()=>VH,content_2133_1810:()=>BH,content_2133_1812:()=>HH,content_2133_1814:()=>JH,content_2133_1816:()=>QH,content_2133_1818:()=>nY,content_2133_182:()=>WD,content_2133_1820:()=>oY,content_2133_1822:()=>rY,content_2133_1824:()=>sY,content_2133_1826:()=>iY,content_2133_1828:()=>uY,content_2133_1830:()=>dY,content_2133_1832:()=>kY,content_2133_1834:()=>fY,content_2133_1836:()=>DY,content_2133_1838:()=>_Y,content_2133_184:()=>FD,content_2133_1840:()=>gY,content_2133_1842:()=>CY,content_2133_1844:()=>LY,content_2133_1846:()=>vY,content_2133_1848:()=>NY,content_2133_1850:()=>AY,content_2133_1852:()=>RY,content_2133_1854:()=>IY,content_2133_1856:()=>WY,content_2133_1858:()=>FY,content_2133_186:()=>jD,content_2133_1860:()=>jY,content_2133_1862:()=>VY,content_2133_1864:()=>BY,content_2133_1866:()=>HY,content_2133_1868:()=>JY,content_2133_1870:()=>QY,content_2133_1872:()=>nJ,content_2133_1874:()=>oJ,content_2133_1876:()=>rJ,content_2133_1878:()=>sJ,content_2133_188:()=>VD,content_2133_1880:()=>iJ,content_2133_1882:()=>uJ,content_2133_1884:()=>dJ,content_2133_1886:()=>kJ,content_2133_1888:()=>fJ,content_2133_1890:()=>DJ,content_2133_1892:()=>_J,content_2133_1894:()=>gJ,content_2133_1896:()=>CJ,content_2133_1898:()=>LJ,content_2133_190:()=>BD,content_2133_1900:()=>vJ,content_2133_1902:()=>NJ,content_2133_1904:()=>AJ,content_2133_1906:()=>RJ,content_2133_1908:()=>IJ,content_2133_1910:()=>WJ,content_2133_1912:()=>FJ,content_2133_1914:()=>jJ,content_2133_1916:()=>VJ,content_2133_1918:()=>BJ,content_2133_192:()=>HD,content_2133_1920:()=>HJ,content_2133_1922:()=>JJ,content_2133_1924:()=>QJ,content_2133_1926:()=>nK,content_2133_1928:()=>oK,content_2133_1930:()=>rK,content_2133_1932:()=>sK,content_2133_1934:()=>iK,content_2133_1936:()=>uK,content_2133_1938:()=>dK,content_2133_194:()=>JD,content_2133_1940:()=>kK,content_2133_1942:()=>fK,content_2133_1944:()=>DK,content_2133_1946:()=>_K,content_2133_1948:()=>gK,content_2133_1950:()=>CK,content_2133_1952:()=>LK,content_2133_1954:()=>vK,content_2133_1956:()=>NK,content_2133_1958:()=>AK,content_2133_196:()=>QD,content_2133_1960:()=>RK,content_2133_1962:()=>IK,content_2133_1964:()=>WK,content_2133_1966:()=>FK,content_2133_1968:()=>jK,content_2133_1970:()=>VK,content_2133_1972:()=>BK,content_2133_1974:()=>HK,content_2133_1976:()=>JK,content_2133_1978:()=>QK,content_2133_198:()=>nM,content_2133_1980:()=>nQ,content_2133_1982:()=>oQ,content_2133_1984:()=>rQ,content_2133_1986:()=>sQ,content_2133_1988:()=>iQ,content_2133_1990:()=>uQ,content_2133_1992:()=>dQ,content_2133_1994:()=>kQ,content_2133_1996:()=>fQ,content_2133_1998:()=>DQ,content_2133_2:()=>My,content_2133_20:()=>Py,content_2133_200:()=>oM,content_2133_2000:()=>_Q,content_2133_2002:()=>gQ,content_2133_2004:()=>CQ,content_2133_2006:()=>LQ,content_2133_2008:()=>vQ,content_2133_2010:()=>NQ,content_2133_2012:()=>AQ,content_2133_2014:()=>RQ,content_2133_2016:()=>IQ,content_2133_2018:()=>WQ,content_2133_202:()=>rM,content_2133_2020:()=>FQ,content_2133_2022:()=>jQ,content_2133_2024:()=>VQ,content_2133_2026:()=>BQ,content_2133_2028:()=>HQ,content_2133_2030:()=>JQ,content_2133_2032:()=>QQ,content_2133_2034:()=>n0,content_2133_2036:()=>o0,content_2133_2038:()=>r0,content_2133_204:()=>sM,content_2133_2040:()=>s0,content_2133_2042:()=>i0,content_2133_2044:()=>u0,content_2133_2046:()=>d0,content_2133_2048:()=>k0,content_2133_2050:()=>f0,content_2133_2052:()=>D0,content_2133_2054:()=>_0,content_2133_2056:()=>g0,content_2133_2058:()=>C0,content_2133_206:()=>iM,content_2133_2060:()=>L0,content_2133_2062:()=>v0,content_2133_2064:()=>N0,content_2133_2066:()=>A0,content_2133_2068:()=>R0,content_2133_2070:()=>I0,content_2133_2072:()=>W0,content_2133_2074:()=>F0,content_2133_2076:()=>j0,content_2133_2078:()=>V0,content_2133_208:()=>uM,content_2133_2080:()=>B0,content_2133_2082:()=>H0,content_2133_2084:()=>J0,content_2133_2086:()=>Q0,content_2133_2088:()=>n3,content_2133_2090:()=>o3,content_2133_2092:()=>r3,content_2133_2094:()=>s3,content_2133_2096:()=>i3,content_2133_2098:()=>u3,content_2133_210:()=>dM,content_2133_2100:()=>d3,content_2133_2102:()=>k3,content_2133_2104:()=>f3,content_2133_2106:()=>D3,content_2133_2108:()=>_3,content_2133_2110:()=>g3,content_2133_2112:()=>C3,content_2133_2114:()=>L3,content_2133_2116:()=>v3,content_2133_2118:()=>N3,content_2133_212:()=>kM,content_2133_2120:()=>A3,content_2133_2122:()=>R3,content_2133_2124:()=>I3,content_2133_2126:()=>W3,content_2133_2128:()=>F3,content_2133_2130:()=>j3,content_2133_2132:()=>V3,content_2133_2134:()=>B3,content_2133_2136:()=>H3,content_2133_2138:()=>J3,content_2133_214:()=>fM,content_2133_2140:()=>Q3,content_2133_2142:()=>n1,content_2133_2144:()=>o1,content_2133_2146:()=>r1,content_2133_2148:()=>s1,content_2133_2150:()=>i1,content_2133_2152:()=>u1,content_2133_2154:()=>d1,content_2133_2156:()=>k1,content_2133_2158:()=>f1,content_2133_216:()=>DM,content_2133_2160:()=>D1,content_2133_2162:()=>_1,content_2133_2164:()=>g1,content_2133_2166:()=>C1,content_2133_2168:()=>L1,content_2133_2170:()=>v1,content_2133_2172:()=>N1,content_2133_2174:()=>A1,content_2133_2176:()=>R1,content_2133_2178:()=>I1,content_2133_218:()=>_M,content_2133_2180:()=>W1,content_2133_2182:()=>F1,content_2133_2184:()=>j1,content_2133_2186:()=>V1,content_2133_2188:()=>B1,content_2133_2190:()=>H1,content_2133_2192:()=>J1,content_2133_2194:()=>Q1,content_2133_22:()=>Gy,content_2133_220:()=>gM,content_2133_222:()=>CM,content_2133_224:()=>LM,content_2133_226:()=>vM,content_2133_228:()=>NM,content_2133_230:()=>AM,content_2133_232:()=>RM,content_2133_234:()=>IM,content_2133_236:()=>WM,content_2133_238:()=>FM,content_2133_24:()=>Uy,content_2133_240:()=>jM,content_2133_242:()=>VM,content_2133_244:()=>BM,content_2133_246:()=>HM,content_2133_248:()=>JM,content_2133_250:()=>QM,content_2133_252:()=>n_,content_2133_254:()=>o_,content_2133_256:()=>r_,content_2133_258:()=>s_,content_2133_26:()=>Oy,content_2133_260:()=>i_,content_2133_262:()=>u_,content_2133_264:()=>d_,content_2133_266:()=>k_,content_2133_268:()=>f_,content_2133_270:()=>D_,content_2133_272:()=>__,content_2133_274:()=>g_,content_2133_276:()=>C_,content_2133_278:()=>L_,content_2133_28:()=>qy,content_2133_280:()=>v_,content_2133_282:()=>N_,content_2133_284:()=>A_,content_2133_286:()=>R_,content_2133_288:()=>I_,content_2133_290:()=>W_,content_2133_292:()=>F_,content_2133_294:()=>j_,content_2133_296:()=>V_,content_2133_298:()=>B_,content_2133_30:()=>$y,content_2133_300:()=>H_,content_2133_302:()=>J_,content_2133_304:()=>Q_,content_2133_306:()=>nX,content_2133_308:()=>oX,content_2133_310:()=>rX,content_2133_312:()=>sX,content_2133_314:()=>iX,content_2133_316:()=>uX,content_2133_318:()=>dX,content_2133_32:()=>Yy,content_2133_320:()=>kX,content_2133_322:()=>fX,content_2133_324:()=>DX,content_2133_326:()=>_X,content_2133_328:()=>gX,content_2133_330:()=>CX,content_2133_332:()=>LX,content_2133_334:()=>vX,content_2133_336:()=>NX,content_2133_338:()=>AX,content_2133_34:()=>Ky,content_2133_340:()=>RX,content_2133_342:()=>IX,content_2133_344:()=>WX,content_2133_346:()=>FX,content_2133_348:()=>jX,content_2133_350:()=>VX,content_2133_352:()=>BX,content_2133_354:()=>HX,content_2133_356:()=>JX,content_2133_358:()=>QX,content_2133_36:()=>tf,content_2133_360:()=>ng,content_2133_362:()=>og,content_2133_364:()=>rg,content_2133_366:()=>sg,content_2133_368:()=>ig,content_2133_370:()=>ug,content_2133_372:()=>dg,content_2133_374:()=>kg,content_2133_376:()=>fg,content_2133_378:()=>Dg,content_2133_38:()=>ef,content_2133_380:()=>_g,content_2133_382:()=>gg,content_2133_384:()=>Cg,content_2133_386:()=>Lg,content_2133_388:()=>vg,content_2133_390:()=>Ng,content_2133_392:()=>Ag,content_2133_394:()=>Rg,content_2133_396:()=>Ig,content_2133_398:()=>Wg,content_2133_4:()=>Xy,content_2133_40:()=>pf,content_2133_400:()=>Fg,content_2133_402:()=>jg,content_2133_404:()=>Vg,content_2133_406:()=>Bg,content_2133_408:()=>Hg,content_2133_410:()=>Jg,content_2133_412:()=>Qg,content_2133_414:()=>nx,content_2133_416:()=>ox,content_2133_418:()=>rx,content_2133_42:()=>cf,content_2133_420:()=>sx,content_2133_422:()=>ix,content_2133_424:()=>ux,content_2133_426:()=>dx,content_2133_428:()=>kx,content_2133_430:()=>fx,content_2133_432:()=>Dx,content_2133_434:()=>_x,content_2133_436:()=>gx,content_2133_438:()=>Cx,content_2133_44:()=>af,content_2133_440:()=>Lx,content_2133_442:()=>vx,content_2133_444:()=>Nx,content_2133_446:()=>Ax,content_2133_448:()=>Rx,content_2133_450:()=>Ix,content_2133_452:()=>Wx,content_2133_454:()=>Fx,content_2133_456:()=>jx,content_2133_458:()=>Vx,content_2133_46:()=>uf,content_2133_460:()=>Bx,content_2133_462:()=>Hx,content_2133_464:()=>Jx,content_2133_466:()=>Qx,content_2133_468:()=>nC,content_2133_470:()=>oC,content_2133_472:()=>rC,content_2133_474:()=>sC,content_2133_476:()=>iC,content_2133_478:()=>uC,content_2133_48:()=>df,content_2133_480:()=>dC,content_2133_482:()=>kC,content_2133_484:()=>fC,content_2133_486:()=>DC,content_2133_488:()=>_C,content_2133_490:()=>gC,content_2133_492:()=>CC,content_2133_494:()=>LC,content_2133_496:()=>vC,content_2133_498:()=>NC,content_2133_50:()=>kf,content_2133_500:()=>AC,content_2133_502:()=>RC,content_2133_504:()=>IC,content_2133_506:()=>WC,content_2133_508:()=>FC,content_2133_510:()=>jC,content_2133_512:()=>VC,content_2133_514:()=>BC,content_2133_516:()=>HC,content_2133_518:()=>JC,content_2133_52:()=>ff,content_2133_520:()=>QC,content_2133_522:()=>nT,content_2133_524:()=>oT,content_2133_526:()=>rT,content_2133_528:()=>sT,content_2133_530:()=>iT,content_2133_532:()=>uT,content_2133_534:()=>dT,content_2133_536:()=>kT,content_2133_538:()=>fT,content_2133_54:()=>Df,content_2133_540:()=>DT,content_2133_542:()=>_T,content_2133_544:()=>gT,content_2133_546:()=>CT,content_2133_548:()=>LT,content_2133_550:()=>vT,content_2133_552:()=>NT,content_2133_554:()=>AT,content_2133_556:()=>RT,content_2133_558:()=>IT,content_2133_56:()=>_f,content_2133_560:()=>WT,content_2133_562:()=>FT,content_2133_564:()=>jT,content_2133_566:()=>VT,content_2133_568:()=>BT,content_2133_570:()=>HT,content_2133_572:()=>JT,content_2133_574:()=>QT,content_2133_576:()=>nL,content_2133_578:()=>oL,content_2133_58:()=>gf,content_2133_580:()=>rL,content_2133_582:()=>sL,content_2133_584:()=>iL,content_2133_586:()=>uL,content_2133_588:()=>dL,content_2133_590:()=>kL,content_2133_592:()=>fL,content_2133_594:()=>DL,content_2133_596:()=>_L,content_2133_598:()=>gL,content_2133_6:()=>xy,content_2133_60:()=>Cf,content_2133_600:()=>CL,content_2133_602:()=>LL,content_2133_604:()=>vL,content_2133_606:()=>NL,content_2133_608:()=>AL,content_2133_610:()=>RL,content_2133_612:()=>IL,content_2133_614:()=>WL,content_2133_616:()=>FL,content_2133_618:()=>jL,content_2133_62:()=>Lf,content_2133_620:()=>VL,content_2133_622:()=>BL,content_2133_624:()=>HL,content_2133_626:()=>JL,content_2133_628:()=>QL,content_2133_630:()=>nZ,content_2133_632:()=>oZ,content_2133_634:()=>rZ,content_2133_636:()=>sZ,content_2133_638:()=>iZ,content_2133_64:()=>vf,content_2133_640:()=>uZ,content_2133_642:()=>dZ,content_2133_644:()=>kZ,content_2133_646:()=>fZ,content_2133_648:()=>DZ,content_2133_650:()=>_Z,content_2133_652:()=>gZ,content_2133_654:()=>CZ,content_2133_656:()=>LZ,content_2133_658:()=>vZ,content_2133_66:()=>Nf,content_2133_660:()=>NZ,content_2133_662:()=>AZ,content_2133_664:()=>RZ,content_2133_666:()=>IZ,content_2133_668:()=>WZ,content_2133_670:()=>FZ,content_2133_672:()=>jZ,content_2133_674:()=>VZ,content_2133_676:()=>BZ,content_2133_678:()=>HZ,content_2133_68:()=>Af,content_2133_680:()=>JZ,content_2133_682:()=>QZ,content_2133_684:()=>nv,content_2133_686:()=>ov,content_2133_688:()=>rv,content_2133_690:()=>sv,content_2133_692:()=>iv,content_2133_694:()=>uv,content_2133_696:()=>dv,content_2133_698:()=>kv,content_2133_70:()=>Rf,content_2133_700:()=>fv,content_2133_702:()=>Dv,content_2133_704:()=>_v,content_2133_706:()=>gv,content_2133_708:()=>Cv,content_2133_710:()=>Lv,content_2133_712:()=>vv,content_2133_714:()=>Nv,content_2133_716:()=>Av,content_2133_718:()=>Rv,content_2133_72:()=>If,content_2133_720:()=>Iv,content_2133_722:()=>Wv,content_2133_724:()=>Fv,content_2133_726:()=>jv,content_2133_728:()=>Vv,content_2133_730:()=>Bv,content_2133_732:()=>Hv,content_2133_734:()=>Jv,content_2133_736:()=>Qv,content_2133_738:()=>nb,content_2133_74:()=>Wf,content_2133_740:()=>ob,content_2133_742:()=>rb,content_2133_744:()=>sb,content_2133_746:()=>ib,content_2133_748:()=>ub,content_2133_750:()=>db,content_2133_752:()=>kb,content_2133_754:()=>fb,content_2133_756:()=>Db,content_2133_758:()=>_b,content_2133_76:()=>Ff,content_2133_760:()=>gb,content_2133_762:()=>Cb,content_2133_764:()=>Lb,content_2133_766:()=>vb,content_2133_768:()=>Nb,content_2133_770:()=>Ab,content_2133_772:()=>Rb,content_2133_774:()=>Ib,content_2133_776:()=>Wb,content_2133_778:()=>Fb,content_2133_78:()=>jf,content_2133_780:()=>jb,content_2133_782:()=>Vb,content_2133_784:()=>Bb,content_2133_786:()=>Hb,content_2133_788:()=>Jb,content_2133_790:()=>Qb,content_2133_792:()=>nN,content_2133_794:()=>oN,content_2133_796:()=>rN,content_2133_798:()=>sN,content_2133_8:()=>Ty,content_2133_80:()=>Vf,content_2133_800:()=>iN,content_2133_802:()=>uN,content_2133_804:()=>dN,content_2133_806:()=>kN,content_2133_808:()=>fN,content_2133_810:()=>DN,content_2133_812:()=>_N,content_2133_814:()=>gN,content_2133_816:()=>CN,content_2133_818:()=>LN,content_2133_82:()=>Bf,content_2133_820:()=>vN,content_2133_822:()=>NN,content_2133_824:()=>AN,content_2133_826:()=>RN,content_2133_828:()=>IN,content_2133_830:()=>WN,content_2133_832:()=>FN,content_2133_834:()=>jN,content_2133_836:()=>VN,content_2133_838:()=>BN,content_2133_84:()=>Hf,content_2133_840:()=>HN,content_2133_842:()=>JN,content_2133_844:()=>QN,content_2133_846:()=>nE,content_2133_848:()=>oE,content_2133_850:()=>rE,content_2133_852:()=>sE,content_2133_854:()=>iE,content_2133_856:()=>uE,content_2133_858:()=>dE,content_2133_86:()=>Jf,content_2133_860:()=>kE,content_2133_862:()=>fE,content_2133_864:()=>DE,content_2133_866:()=>_E,content_2133_868:()=>gE,content_2133_870:()=>CE,content_2133_872:()=>LE,content_2133_874:()=>vE,content_2133_876:()=>NE,content_2133_878:()=>AE,content_2133_88:()=>Qf,content_2133_880:()=>RE,content_2133_882:()=>IE,content_2133_884:()=>WE,content_2133_886:()=>FE,content_2133_888:()=>jE,content_2133_890:()=>VE,content_2133_892:()=>BE,content_2133_894:()=>HE,content_2133_896:()=>JE,content_2133_898:()=>QE,content_2133_90:()=>nw,content_2133_900:()=>nA,content_2133_902:()=>oA,content_2133_904:()=>rA,content_2133_906:()=>sA,content_2133_908:()=>iA,content_2133_910:()=>uA,content_2133_912:()=>dA,content_2133_914:()=>kA,content_2133_916:()=>fA,content_2133_918:()=>DA,content_2133_92:()=>ow,content_2133_920:()=>_A,content_2133_922:()=>gA,content_2133_924:()=>CA,content_2133_926:()=>LA,content_2133_928:()=>vA,content_2133_930:()=>NA,content_2133_932:()=>AA,content_2133_934:()=>RA,content_2133_936:()=>IA,content_2133_938:()=>WA,content_2133_94:()=>rw,content_2133_940:()=>FA,content_2133_942:()=>jA,content_2133_944:()=>VA,content_2133_946:()=>BA,content_2133_948:()=>HA,content_2133_950:()=>JA,content_2133_952:()=>QA,content_2133_954:()=>nS,content_2133_956:()=>oS,content_2133_958:()=>rS,content_2133_96:()=>sw,content_2133_960:()=>sS,content_2133_962:()=>iS,content_2133_964:()=>uS,content_2133_966:()=>dS,content_2133_968:()=>kS,content_2133_970:()=>fS,content_2133_972:()=>DS,content_2133_974:()=>_S,content_2133_976:()=>gS,content_2133_978:()=>CS,content_2133_98:()=>iw,content_2133_980:()=>LS,content_2133_982:()=>vS,content_2133_984:()=>NS,content_2133_986:()=>AS,content_2133_988:()=>RS,content_2133_990:()=>IS,content_2133_992:()=>WS,content_2133_994:()=>FS,content_2133_996:()=>jS,content_2133_998:()=>VS});var p=e(2784),r=e(7896),c=e(876);const s={toc:[]};function a(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const i={toc:[]};function l(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},i,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscriptions and triggering of events."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,c.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}h.isMDXComponent=!0;const k={toc:[]};function y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches an asynchronous ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}y.isMDXComponent=!0;const f={toc:[]};function w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}w.isMDXComponent=!0;const D={toc:[]};function M(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}M.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}X.isMDXComponent=!0;const g={toc:[]};function x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}x.isMDXComponent=!0;const C={toc:[]};function T(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}T.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}Z.isMDXComponent=!0;const v={toc:[]};function b(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},v,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}b.isMDXComponent=!0;const N={toc:[]};function E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}E.isMDXComponent=!0;const A={toc:[]};function S(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}S.isMDXComponent=!0;const R={toc:[]};function z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}z.isMDXComponent=!0;const I={toc:[]};function P(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},I,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}P.isMDXComponent=!0;const W={toc:[]};function G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}G.isMDXComponent=!0;const F={toc:[]};function U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},F,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}U.isMDXComponent=!0;const j={toc:[]};function O(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}O.isMDXComponent=!0;const V={toc:[]};function q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},V,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}q.isMDXComponent=!0;const B={toc:[]};function $(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value argument to subscribers."))}$.isMDXComponent=!0;const H={toc:[]};function Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A base for dispatching ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,c.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Y.isMDXComponent=!0;const J={toc:[]};function K(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},J,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}K.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Q,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}pt.isMDXComponent=!0;const rt={toc:[]};function ct(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}ct.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}at.isMDXComponent=!0;const it={toc:[]};function lt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},it,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the callback function."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,c.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,c.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}ht.isMDXComponent=!0;const kt={toc:[]};function yt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}yt.isMDXComponent=!0;const ft={toc:[]};function wt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}wt.isMDXComponent=!0;const Dt={toc:[]};function Mt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}Mt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_t,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Are subscribers being notified?"))}Xt.isMDXComponent=!0;const gt={toc:[]};function xt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Notify all current and future subscribers."))}xt.isMDXComponent=!0;const Ct={toc:[]};function Tt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ct,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Stop notifying future subscribers."))}Tt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}Zt.isMDXComponent=!0;const vt={toc:[]};function bt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}bt.isMDXComponent=!0;const Nt={toc:[]};function Et(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}Et.isMDXComponent=!0;const At={toc:[]};function St(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}St.isMDXComponent=!0;const Rt={toc:[]};function zt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}zt.isMDXComponent=!0;const It={toc:[]};function Pt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},It,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Pt.isMDXComponent=!0;const Wt={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,c.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Gt.isMDXComponent=!0;const Ft={toc:[]};function Ut(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ft,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}Ut.isMDXComponent=!0;const jt={toc:[]};function Ot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}Ot.isMDXComponent=!0;const Vt={toc:[]};function qt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}qt.isMDXComponent=!0;const Bt={toc:[]};function $t(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}$t.isMDXComponent=!0;const Ht={toc:[]};function Yt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ht,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}Yt.isMDXComponent=!0;const Jt={toc:[]};function Kt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}Kt.isMDXComponent=!0;const Qt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the callback function."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}pn.isMDXComponent=!0;const rn={toc:[]};function cn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the most recent value of this dispatcher."))}cn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}dn.isMDXComponent=!0;const hn={toc:[]};function kn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}kn.isMDXComponent=!0;const yn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}fn.isMDXComponent=!0;const wn={toc:[]};function Dn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Dn.isMDXComponent=!0;const Mn={toc:[]};function _n(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}gn.isMDXComponent=!0;const xn={toc:[]};function Cn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value passed to subscribers."))}Cn.isMDXComponent=!0;const Tn={toc:[]};function Ln(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function vn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}vn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Nn.isMDXComponent=!0;const En={toc:[]};function An(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},En,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The initial value."))}An.isMDXComponent=!0;const Sn={toc:[]};function Rn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the most recent value of this dispatcher."))}Rn.isMDXComponent=!0;const zn={toc:[]};function In(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Setting the value will immediately notify all subscribers."))}In.isMDXComponent=!0;const Pn={toc:[]};function Wn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set the current value of this dispatcher."))}Wn.isMDXComponent=!0;const Gn={toc:[]};function Fn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new value."))}Fn.isMDXComponent=!0;const Un={toc:[]};function jn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}jn.isMDXComponent=!0;const On={toc:[]};function Vn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},On,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}Vn.isMDXComponent=!0;const qn={toc:[]};function Bn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Bn.isMDXComponent=!0;const $n={toc:[]};function Hn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$n,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}Hn.isMDXComponent=!0;const Yn={toc:[]};function Jn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Jn.isMDXComponent=!0;const Kn={toc:[]};function Qn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}Qn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value passed to subscribers."))}oe.isMDXComponent=!0;const pe={toc:[]};function re(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}re.isMDXComponent=!0;const ce={toc:[]};function se(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ce,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}se.isMDXComponent=!0;const ae={toc:[]};function ie(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}ie.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}de.isMDXComponent=!0;const he={toc:[]};function ke(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}ke.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ye,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fe.isMDXComponent=!0;const we={toc:[]};function De(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}De.isMDXComponent=!0;const Me={toc:[]};function _e(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Me,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}_e.isMDXComponent=!0;const Xe={toc:[]};function ge(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The amount of times the timer has ticked."))}ge.isMDXComponent=!0;const xe={toc:[]};function Ce(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator responsible for running this timer."))}Ce.isMDXComponent=!0;const Te={toc:[]};function Le(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait until the timer ticks."))}Le.isMDXComponent=!0;const Ze={toc:[]};function ve(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The current iteration index."))}ve.isMDXComponent=!0;const be={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},be,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Ne.isMDXComponent=!0;const Ee={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ee,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Ae.isMDXComponent=!0;const Se={toc:[]};function Re(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Se,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Re.isMDXComponent=!0;const ze={toc:[]};function Ie(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Ie.isMDXComponent=!0;const Pe={toc:[]};function We(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}We.isMDXComponent=!0;const Ge={toc:[]};function Fe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Fe.isMDXComponent=!0;const Ue={toc:[]};function je(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,c.kt)("p",null,"Note that the same animation can be written as:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,c.kt)("p",null,"The reason ",(0,c.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.corenerRadius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}je.isMDXComponent=!0;const Oe={toc:[]};function Ve(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run tasks one after another."))}Ve.isMDXComponent=!0;const qe={toc:[]};function Be(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Be.isMDXComponent=!0;const $e={toc:[]};function He(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$e,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,c.kt)("p",null,"Note that the same animation can be written as:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,c.kt)("p",null,"The reason ",(0,c.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}He.isMDXComponent=!0;const Ye={toc:[]};function Je(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ye,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Je.isMDXComponent=!0;const Ke={toc:[]};function Qe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ke,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The delay in seconds"))}Qe.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task or callback to run after the delay."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Call the given callback every N seconds."))}ro.isMDXComponent=!0;const co={toc:[]};function so(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},co,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The interval between subsequent calls."))}so.isMDXComponent=!0;const ao={toc:[]};function io(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to be called."))}io.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Each time iteration waits until the previous one is completed."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}ho.isMDXComponent=!0;const ko={toc:[]};function yo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ko,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run the given generator N times."))}yo.isMDXComponent=!0;const fo={toc:[]};function wo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The number of iterations."))}wo.isMDXComponent=!0;const Do={toc:[]};function Mo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Do,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}Mo.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_o,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Do nothing."))}Xo.isMDXComponent=!0;const go={toc:[]};function xo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}xo.isMDXComponent=!0;const Co={toc:[]};function To(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Co,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Turn the given generator function into a threadable generator."))}To.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a factory that creates the generator."))}Zo.isMDXComponent=!0;const vo={toc:[]};function bo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}bo.isMDXComponent=!0;const No={toc:[]};function Eo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Turn the given generator function into a threadable generator."))}Eo.isMDXComponent=!0;const Ao={toc:[]};function So(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional name used when displaying this generator in the UI."))}So.isMDXComponent=!0;const Ro={toc:[]};function zo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ro,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a factory that creates the generator."))}zo.isMDXComponent=!0;const Io={toc:[]};function Po(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Io,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Po.isMDXComponent=!0;const Wo={toc:[]};function Go(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Go.isMDXComponent=!0;const Fo={toc:[]};function Uo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Uo.isMDXComponent=!0;const jo={toc:[]};function Oo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The delay between each of the tasks."))}Oo.isMDXComponent=!0;const Vo={toc:[]};function qo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to be run in a sequence."))}qo.isMDXComponent=!0;const Bo={toc:[]};function $o(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}$o.isMDXComponent=!0;const Ho={toc:[]};function Yo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ho,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for the given amount of time."))}Yo.isMDXComponent=!0;const Jo={toc:[]};function Ko(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The relative time in seconds."))}Ko.isMDXComponent=!0;const Qo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional task to be run after the function completes."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}pp.isMDXComponent=!0;const rp={toc:[]};function cp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait until the given time event."))}cp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the time event."))}ap.isMDXComponent=!0;const ip={toc:[]};function lp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ip,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional task to be run after the function completes."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Main Motion Canvas classes."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when a new message is logged."))}hp.isMDXComponent=!0;const kp={toc:[]};function yp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the meta file of a given entity."))}yp.isMDXComponent=!0;const fp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when metadata changes."))}wp.isMDXComponent=!0;const Dp={toc:[]};function Mp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Load new metadata from a file."))}Mp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_p,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"New metadata."))}Xp.isMDXComponent=!0;const gp={toc:[]};function xp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any possible errors will be logged to the console."))}xp.isMDXComponent=!0;const Cp={toc:[]};function Tp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set data without waiting for confirmation."))}Tp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"New data."))}Zp.isMDXComponent=!0;const vp={toc:[]};function bp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the data stored in the meta file."))}bp.isMDXComponent=!0;const Np={toc:[]};function Ep(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,c.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}Ep.isMDXComponent=!0;const Ap={toc:[]};function Sp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}))}Sp.isMDXComponent=!0;const Rp={toc:[]};function zp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The project configuration."))}zp.isMDXComponent=!0;const Ip={toc:[]};function Pp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ip,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the current scene changes."))}Pp.isMDXComponent=!0;const Wp={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Gp.isMDXComponent=!0;const Fp={toc:[]};function Up(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after the scenes were recalculated."))}Up.isMDXComponent=!0;const jp={toc:[]};function Op(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the contents of a meta file."))}Op.isMDXComponent=!0;const Vp={toc:[]};function qp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Multi-media management."))}qp.isMDXComponent=!0;const Bp={toc:[]};function $p(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}$p.isMDXComponent=!0;const Hp={toc:[]};function Yp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause/resume the audio."))}Yp.isMDXComponent=!0;const Jp={toc:[]};function Kp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the audio should be paused or resumed."))}Kp.isMDXComponent=!0;const Qp={toc:[]};function tr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The absolute biggest value from the peaks array."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The amount of samples taken."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}pr.isMDXComponent=!0;const rr={toc:[]};function cr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Samples per seconds."))}cr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Playback control."))}ar.isMDXComponent=!0;const ir={toc:[]};function lr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ir,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Abstract scene representations and related utilities."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Signifies the various stages of a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs after a render ends."))}hr.isMDXComponent=!0;const kr={toc:[]};function yr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}yr.isMDXComponent=!0;const fr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,c.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}wr.isMDXComponent=!0;const Dr={toc:[]};function Mr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,c.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}Mr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_r,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes the state of a scene."))}Xr.isMDXComponent=!0;const gr={toc:[]};function xr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}xr.isMDXComponent=!0;const Cr={toc:[]};function Tr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has finished transitioning in."))}Tr.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,c.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Zr.isMDXComponent=!0;const vr={toc:[]};function br(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene is ready to transition out."))}br.isMDXComponent=!0;const Nr={toc:[]};function Er(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Invoking ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,c.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Er.isMDXComponent=!0;const Ar={toc:[]};function Sr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has finished."))}Sr.isMDXComponent=!0;const Rr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has just been created/reset."))}zr.isMDXComponent=!0;const Ir={toc:[]};function Pr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ir,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The default implementation of the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,c.kt)("p",null,"Uses generators to control the animation."))}Pr.isMDXComponent=!0;const Wr={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Will be passed as the second argument to the constructor."))}Gr.isMDXComponent=!0;const Fr={toc:[]};function Ur(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the scene."))}Ur.isMDXComponent=!0;const jr={toc:[]};function Or(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reference to the project."))}Or.isMDXComponent=!0;const Vr={toc:[]};function qr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene starts."))}qr.isMDXComponent=!0;const Br={toc:[]};function $r(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Br,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene ends."))}$r.isMDXComponent=!0;const Hr={toc:[]};function Yr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the cached data changes."))}Yr.isMDXComponent=!0;const Jr={toc:[]};function Kr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after scene is recalculated."))}Kr.isMDXComponent=!0;const Qr={toc:[]};function tc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reloaded."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reset."))}pc.isMDXComponent=!0;const rc={toc:[]};function cc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the main thread changes."))}cc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ac.isMDXComponent=!0;const ic={toc:[]};function lc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ic,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hc.isMDXComponent=!0;const kc={toc:[]};function yc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the size of this scene."),(0,c.kt)("p",null,"Usually return ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}yc.isMDXComponent=!0;const fc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}wc.isMDXComponent=!0;const Dc={toc:[]};function Mc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene cached?"),(0,c.kt)("p",null,"Used only by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,c.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,c.kt)("p",null,"Should always return ",(0,c.kt)("inlineCode",{parentName:"p"},"true"),"."))}Mc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_c,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,c.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Xc.isMDXComponent=!0;const gc={toc:[]};function xc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress this scene one frame forward."))}xc.isMDXComponent=!0;const Cc={toc:[]};function Tc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,c.kt)("p",null,"At the end of execution, this method should set ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,c.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Tc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Recalculate the scene."))}Zc.isMDXComponent=!0;const vc={toc:[]};function bc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,c.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}bc.isMDXComponent=!0;const Nc={toc:[]};function Ec(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reload the scene."))}Ec.isMDXComponent=!0;const Ac={toc:[]};function Sc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, a new configuration object."))}Sc.isMDXComponent=!0;const Rc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render the scene onto a canvas."))}zc.isMDXComponent=!0;const Ic={toc:[]};function Pc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ic,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to used when rendering."))}Pc.isMDXComponent=!0;const Wc={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset this scene to its initial state."))}Gc.isMDXComponent=!0;const Fc={toc:[]};function Uc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, the previous scene."))}Uc.isMDXComponent=!0;const jc={toc:[]};function Oc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the view."),(0,c.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,c.kt)("p",null,"Can modify the state of the view."))}Oc.isMDXComponent=!0;const Vc={toc:[]};function qc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Lifecycle events for ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}qc.isMDXComponent=!0;const Bc={toc:[]};function $c(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A random number generator based on\n",(0,c.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,c.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}$c.isMDXComponent=!0;const Hc={toc:[]};function Yc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get an array filled with random floats in the given range."))}Yc.isMDXComponent=!0;const Jc={toc:[]};function Kc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The size of the array."))}Kc.isMDXComponent=!0;const Qc={toc:[]};function ts(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get an array filled with random integers in the given range."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"}),(0,c.kt)("li",{parentName:"ul"})))}ps.isMDXComponent=!0;const rs={toc:[]};function cs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The size of the array."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"})))}cs.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"})))}as.isMDXComponent=!0;const is={toc:[]};function ls(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},is,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. Exclusive."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the next random float in the given range."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}hs.isMDXComponent=!0;const ks={toc:[]};function ys(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ks,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range."))}ys.isMDXComponent=!0;const fs={toc:[]};function ws(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the next random integer in the given range."))}ws.isMDXComponent=!0;const Ds={toc:[]};function Ms(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ds,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}Ms.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. Exclusive."))}Xs.isMDXComponent=!0;const gs={toc:[]};function xs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a new independent generator."))}xs.isMDXComponent=!0;const Cs={toc:[]};function Ts(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Manages time events for a given scene."))}Ts.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ls,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when time events change."))}Zs.isMDXComponent=!0;const vs={toc:[]};function bs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the time offset of the given event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function Es(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the event."))}Es.isMDXComponent=!0;const As={toc:[]};function Ss(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The time offset in seconds."))}Ss.isMDXComponent=!0;const Rs={toc:[]};function zs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,c.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}zs.isMDXComponent=!0;const Is={toc:[]};function Ps(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Is,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes cached information about the timing of a scene."))}Ps.isMDXComponent=!0;const Ws={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ws,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes a complete scene together with the meta file."))}Gs.isMDXComponent=!0;const Fs={toc:[]};function Us(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Configuration object."))}Us.isMDXComponent=!0;const js={toc:[]};function Os(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The class used to instantiate the scene."))}Os.isMDXComponent=!0;const Vs={toc:[]};function qs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The stack trace at the moment of creation."))}qs.isMDXComponent=!0;const Bs={toc:[]};function $s(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}$s.isMDXComponent=!0;const Hs={toc:[]};function Ys(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Ys.isMDXComponent=!0;const Js={toc:[]};function Ks(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Js,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Ks.isMDXComponent=!0;const Qs={toc:[]};function ta(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for the inspected element."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element for which to draw an overlay."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}pa.isMDXComponent=!0;const ra={toc:[]};function ca(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ra,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}ca.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}aa.isMDXComponent=!0;const ia={toc:[]};function la(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ia,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Return the attributes of the inspected element."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element to inspect."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a possible element to inspect at a given position."))}ha.isMDXComponent=!0;const ka={toc:[]};function ya(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ka,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The x coordinate."))}ya.isMDXComponent=!0;const fa={toc:[]};function wa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The y coordinate."))}wa.isMDXComponent=!0;const Da={toc:[]};function Ma(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Da,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}Ma.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_a,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the inspected element is still valid."))}Xa.isMDXComponent=!0;const ga={toc:[]};function xa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element to validate."))}xa.isMDXComponent=!0;const Ca={toc:[]};function Ta(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ca,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a time event stored in a meta file."))}Ta.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},La,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,c.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Za.isMDXComponent=!0;const va={toc:[]};function ba(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The main interface for scenes."))}ba.isMDXComponent=!0;const Na={toc:[]};function Ea(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Will be passed as the second argument to the constructor."))}Ea.isMDXComponent=!0;const Aa={toc:[]};function Sa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the scene."))}Sa.isMDXComponent=!0;const Ra={toc:[]};function za(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ra,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reference to the project."))}za.isMDXComponent=!0;const Ia={toc:[]};function Pa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ia,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene's ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,c.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Pa.isMDXComponent=!0;const Wa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene starts."))}Ga.isMDXComponent=!0;const Fa={toc:[]};function Ua(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene ends."))}Ua.isMDXComponent=!0;const ja={toc:[]};function Oa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the cached data changes."))}Oa.isMDXComponent=!0;const Va={toc:[]};function qa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Va,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after scene is recalculated."))}qa.isMDXComponent=!0;const Ba={toc:[]};function $a(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ba,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reloaded."))}$a.isMDXComponent=!0;const Ha={toc:[]};function Ya(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ha,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ya.isMDXComponent=!0;const Ja={toc:[]};function Ka(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ja,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reset."))}Ka.isMDXComponent=!0;const Qa={toc:[]};function ti(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}pi.isMDXComponent=!0;const ri={toc:[]};function ci(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ri,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}ci.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the size of this scene."),(0,c.kt)("p",null,"Usually return ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ai.isMDXComponent=!0;const ii={toc:[]};function li(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ii,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene cached?"),(0,c.kt)("p",null,"Used only by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,c.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,c.kt)("p",null,"Should always return ",(0,c.kt)("inlineCode",{parentName:"p"},"true"),"."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,c.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}hi.isMDXComponent=!0;const ki={toc:[]};function yi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ki,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress this scene one frame forward."))}yi.isMDXComponent=!0;const fi={toc:[]};function wi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,c.kt)("p",null,"At the end of execution, this method should set ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,c.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}wi.isMDXComponent=!0;const Di={toc:[]};function Mi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Di,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Recalculate the scene."))}Mi.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_i,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,c.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Xi.isMDXComponent=!0;const gi={toc:[]};function xi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reload the scene."))}xi.isMDXComponent=!0;const Ci={toc:[]};function Ti(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ci,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, a new configuration object."))}Ti.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Li,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render the scene onto a canvas."))}Zi.isMDXComponent=!0;const vi={toc:[]};function bi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to used when rendering."))}bi.isMDXComponent=!0;const Ni={toc:[]};function Ei(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset this scene to its initial state."))}Ei.isMDXComponent=!0;const Ai={toc:[]};function Si(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, the previous scene."))}Si.isMDXComponent=!0;const Ri={toc:[]};function zi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ri,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}zi.isMDXComponent=!0;const Ii={toc:[]};function Pi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ii,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Each class implementing the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Pi.isMDXComponent=!0;const Wi={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The constructor used when creating new scenes."))}Gi.isMDXComponent=!0;const Fi={toc:[]};function Ui(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,c.kt)("inlineCode",{parentName:"a"},"config")),"."))}Ui.isMDXComponent=!0;const ji={toc:[]};function Oi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes a scene exposed by scene files."))}Oi.isMDXComponent=!0;const Vi={toc:[]};function qi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Configuration object."))}qi.isMDXComponent=!0;const Bi={toc:[]};function $i(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The class used to instantiate the scene."))}$i.isMDXComponent=!0;const Hi={toc:[]};function Yi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The stack trace at the moment of creation."))}Yi.isMDXComponent=!0;const Ji={toc:[]};function Ki(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ji,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}Ki.isMDXComponent=!0;const Qi={toc:[]};function tl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the contents of a meta file."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}pl.isMDXComponent=!0;const rl={toc:[]};function cl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the main thread changes."))}cl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a time event at runtime."))}al.isMDXComponent=!0;const il={toc:[]};function ll(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},il,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"In other words, the moment at which ",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,c.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the event."))}hl.isMDXComponent=!0;const kl={toc:[]};function yl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Duration of the event in seconds."))}yl.isMDXComponent=!0;const fl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Stack trace at the moment of registration."))}wl.isMDXComponent=!0;const Dl={toc:[]};function Ml(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}Ml.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_l,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents attributes of an inspected element."))}Xl.isMDXComponent=!0;const gl={toc:[]};function xl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}xl.isMDXComponent=!0;const Cl={toc:[]};function Tl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents an element to inspect."))}Tl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ll,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Zl.isMDXComponent=!0;const vl={toc:[]};function bl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}bl.isMDXComponent=!0;const Nl={toc:[]};function El(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}El.isMDXComponent=!0;const Al={toc:[]};function Sl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}Sl.isMDXComponent=!0;const Rl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}zl.isMDXComponent=!0;const Il={toc:[]};function Pl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Il,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Pl.isMDXComponent=!0;const Wl={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Gl.isMDXComponent=!0;const Fl={toc:[]};function Ul(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Ul.isMDXComponent=!0;const jl={toc:[]};function Ol(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Ol.isMDXComponent=!0;const Vl={toc:[]};function ql(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}ql.isMDXComponent=!0;const Bl={toc:[]};function $l(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}$l.isMDXComponent=!0;const Hl={toc:[]};function Yl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}Yl.isMDXComponent=!0;const Jl={toc:[]};function Kl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Kl.isMDXComponent=!0;const Ql={toc:[]};function tu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ql,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}pu.isMDXComponent=!0;const ru={toc:[]};function cu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ru,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}cu.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}au.isMDXComponent=!0;const iu={toc:[]};function lu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Thread management."))}hu.isMDXComponent=!0;const ku={toc:[]};function yu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ku,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,c.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}yu.isMDXComponent=!0;const fu={toc:[]};function wu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A class representing an individual thread."))}wu.isMDXComponent=!0;const Du={toc:[]};function Mu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Du,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator wrapped by this thread."))}Mu.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator wrapped by this thread."))}Xu.isMDXComponent=!0;const gu={toc:[]};function xu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Used by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,c.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}xu.isMDXComponent=!0;const Cu={toc:[]};function Tu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The current time of this thread."))}Tu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The next value to be passed to the wrapped generator."))}Zu.isMDXComponent=!0;const vu={toc:[]};function bu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}bu.isMDXComponent=!0;const Nu={toc:[]};function Eu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress the wrapped generator once."))}Eu.isMDXComponent=!0;const Au={toc:[]};function Su(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the thread for the next update cycle."))}Su.isMDXComponent=!0;const Ru={toc:[]};function zu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ru,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a normal function that returns a generator."))}zu.isMDXComponent=!0;const Iu={toc:[]};function Pu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,c.kt)("p",null,"Progress to the next frame:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,c.kt)("p",null,"Run another generator synchronously:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,c.kt)("p",null,"Run another generator concurrently:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,c.kt)("p",null,"Await a Promise:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Pu.isMDXComponent=!0;const Wu={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Gu.isMDXComponent=!0;const Fu={toc:[]};function Uu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Cancel all listed tasks."),(0,c.kt)("p",null,"Example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Uu.isMDXComponent=!0;const ju={toc:[]};function Ou(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to cancel."))}Ou.isMDXComponent=!0;const Vu={toc:[]};function qu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}qu.isMDXComponent=!0;const Bu={toc:[]};function $u(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A possible ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}$u.isMDXComponent=!0;const Hu={toc:[]};function Yu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the given value is a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,c.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Yu.isMDXComponent=!0;const Ju={toc:[]};function Ku(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ju,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A possible thread ",(0,c.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,c.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Ku.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to join."))}pm.isMDXComponent=!0;const rm={toc:[]};function cm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}cm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause the current generator until listed tasks are finished."))}am.isMDXComponent=!0;const im={toc:[]};function lm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},im,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to join."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"From the perspective of the external generator, ",(0,c.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,c.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}hm.isMDXComponent=!0;const km={toc:[]};function ym(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},km,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}ym.isMDXComponent=!0;const fm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a context in which generators can be run concurrently."))}wm.isMDXComponent=!0;const Dm={toc:[]};function Mm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A function that returns the generator to run."))}Mm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_m,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}Xm.isMDXComponent=!0;const gm={toc:[]};function xm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Transitions between scenes."))}xm.isMDXComponent=!0;const Cm={toc:[]};function Tm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}Tm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The direction in which to slide."))}Zm.isMDXComponent=!0;const vm={toc:[]};function bm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}bm.isMDXComponent=!0;const Nm={toc:[]};function Em(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Em.isMDXComponent=!0;const Am={toc:[]};function Sm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to use before the current scene is rendered."))}Sm.isMDXComponent=!0;const Rm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to use before the previous scene is rendered."))}zm.isMDXComponent=!0;const Im={toc:[]};function Pm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Im,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}Pm.isMDXComponent=!0;const Wm={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The area on which to zoom in."))}Gm.isMDXComponent=!0;const Fm={toc:[]};function Um(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}Um.isMDXComponent=!0;const jm={toc:[]};function Om(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Om.isMDXComponent=!0;const Vm={toc:[]};function qm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The area from which to zoom out."))}qm.isMDXComponent=!0;const Bm={toc:[]};function $m(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}$m.isMDXComponent=!0;const Hm={toc:[]};function Ym(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolation and timing of tweens."))}Ym.isMDXComponent=!0;const Jm={toc:[]};function Km(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any old key that is missing in ",(0,c.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,c.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,c.kt)("ol",null,(0,c.kt)("li",{parentName:"ol"})))}Km.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A value matching the structure of from and to."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 0."))}pd.isMDXComponent=!0;const rd={toc:[]};function cd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 1."))}cd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}ad.isMDXComponent=!0;const id={toc:[]};function ld(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},id,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A value matching the structure of from and to."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 0."))}hd.isMDXComponent=!0;const kd={toc:[]};function yd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 1."))}yd.isMDXComponent=!0;const fd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}wd.isMDXComponent=!0;const Dd={toc:[]};function Md(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Complex types used in animations."))}Md.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a two-dimensional vector."))}Xd.isMDXComponent=!0;const gd={toc:[]};function xd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}xd.isMDXComponent=!0;const Cd={toc:[]};function Td(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The unclipped RGB components."))}Td.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ld,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}Zd.isMDXComponent=!0;const vd={toc:[]};function bd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}bd.isMDXComponent=!0;const Nd={toc:[]};function Ed(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Ed.isMDXComponent=!0;const Ad={toc:[]};function Sd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Sd.isMDXComponent=!0;const Rd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}zd.isMDXComponent=!0;const Id={toc:[]};function Pd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Id,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Pd.isMDXComponent=!0;const Wd={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}Gd.isMDXComponent=!0;const Fd={toc:[]};function Ud(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Alias of ",(0,c.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Ud.isMDXComponent=!0;const jd={toc:[]};function Od(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Od.isMDXComponent=!0;const Vd={toc:[]};function qd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}qd.isMDXComponent=!0;const Bd={toc:[]};function $d(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}$d.isMDXComponent=!0;const Hd={toc:[]};function Yd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,c.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,c.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Yd.isMDXComponent=!0;const Jd={toc:[]};function Kd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Kd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,c.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,c.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("strong",{parentName:"p"},"L"),", ",(0,c.kt)("strong",{parentName:"p"},"a"),", and ",(0,c.kt)("strong",{parentName:"p"},"b")," components."))}ph.isMDXComponent=!0;const rh={toc:[]};function ch(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}ch.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,c.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,c.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}ah.isMDXComponent=!0;const ih={toc:[]};function lh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ih,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}hh.isMDXComponent=!0;const kh={toc:[]};function yh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}yh.isMDXComponent=!0;const fh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get and set the color opacity."))}wh.isMDXComponent=!0;const Dh={toc:[]};function Mh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,c.kt)("code",null,"'rgb'")))}Mh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_h,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Similar to saturate, but the opposite direction."))}Xh.isMDXComponent=!0;const gh={toc:[]};function xh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"set"))}xh.isMDXComponent=!0;const Ch={toc:[]};function Th(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ch,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns a single channel value.\nAlso"))}Th.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}Zh.isMDXComponent=!0;const vh={toc:[]};function bh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color as hexadecimal string."))}bh.isMDXComponent=!0;const Nh={toc:[]};function Eh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,c.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,c.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Eh.isMDXComponent=!0;const Ah={toc:[]};function Sh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,c.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Sh.isMDXComponent=!0;const Rh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}zh.isMDXComponent=!0;const Ih={toc:[]};function Ph(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ih,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Ph.isMDXComponent=!0;const Wh={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Gh.isMDXComponent=!0;const Fh={toc:[]};function Uh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Uh.isMDXComponent=!0;const jh={toc:[]};function Oh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Oh.isMDXComponent=!0;const Vh={toc:[]};function qh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}qh.isMDXComponent=!0;const Bh={toc:[]};function $h(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}$h.isMDXComponent=!0;const Hh={toc:[]};function Yh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Yh.isMDXComponent=!0;const Jh={toc:[]};function Kh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Kh.isMDXComponent=!0;const Qh={toc:[]};function tk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Convert the given origin to a vector representing its offset."))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The origin to convert."))}pk.isMDXComponent=!0;const rk={toc:[]};function ck(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"General utilities and helper functions."))}ck.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}ak.isMDXComponent=!0;const ik={toc:[]};function lk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Optional override for formatting stack traces"))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create .stack property on a target object"))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Invoke the reference instead."))}hk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}))}yk.isMDXComponent=!0;const fk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Mark the given function as deprecated."))}wk.isMDXComponent=!0;const Dk={toc:[]};function Mk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function to deprecate."))}Mk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_k,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The log message."))}Xk.isMDXComponent=!0;const gk={toc:[]};function xk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The optional log remarks."))}xk.isMDXComponent=!0;const Ck={toc:[]};function Tk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ck,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Tk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Mark the current scene as ready to transition out."))}Zk.isMDXComponent=!0;const vk={toc:[]};function bk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}bk.isMDXComponent=!0;const Nk={toc:[]};function Ek(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an array containing a range of numbers."))}Ek.isMDXComponent=!0;const Ak={toc:[]};function Sk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ak,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The length of the array."))}Sk.isMDXComponent=!0;const Rk={toc:[]};function zk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}zk.isMDXComponent=!0;const Ik={toc:[]};function Pk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ik,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an array containing a range of numbers."))}Pk.isMDXComponent=!0;const Wk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}Gk.isMDXComponent=!0;const Fk={toc:[]};function Uk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. ",(0,c.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Uk.isMDXComponent=!0;const jk={toc:[]};function Ok(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}Ok.isMDXComponent=!0;const Vk={toc:[]};function qk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function that will be provided the context before render."))}qk.isMDXComponent=!0;const Bk={toc:[]};function $k(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}$k.isMDXComponent=!0;const Hk={toc:[]};function Yk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function that will be provided the context after render."))}Yk.isMDXComponent=!0;const Jk={toc:[]};function Kk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current project."))}Kk.isMDXComponent=!0;const Qk={toc:[]};function ty(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the random number generator for the current scene."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the random number generator for the given seed."))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The seed for the generator."))}py.isMDXComponent=!0;const ry={toc:[]};function cy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ry,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}cy.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current scene."))}ay.isMDXComponent=!0;const iy={toc:[]};function ly(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current thread."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,c.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}hy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ky,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the real time since the start of the animation."))}yy.isMDXComponent=!0;const fy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}wy.isMDXComponent=!0;const Dy={toc:[]};function My(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}My.isMDXComponent=!0;const _y={toc:[]};function Xy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_y,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Xy.isMDXComponent=!0;const gy={toc:[]};function xy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}xy.isMDXComponent=!0;const Cy={toc:[]};function Ty(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ty.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}Zy.isMDXComponent=!0;const vy={toc:[]};function by(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}by.isMDXComponent=!0;const Ny={toc:[]};function Ey(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}Ey.isMDXComponent=!0;const Ay={toc:[]};function Sy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ay,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Sy.isMDXComponent=!0;const Ry={toc:[]};function zy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ry,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}zy.isMDXComponent=!0;const Iy={toc:[]};function Py(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Py.isMDXComponent=!0;const Wy={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Gy.isMDXComponent=!0;const Fy={toc:[]};function Uy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Uy.isMDXComponent=!0;const jy={toc:[]};function Oy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Oy.isMDXComponent=!0;const Vy={toc:[]};function qy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qy.isMDXComponent=!0;const By={toc:[]};function $y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}$y.isMDXComponent=!0;const Hy={toc:[]};function Yy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}Yy.isMDXComponent=!0;const Jy={toc:[]};function Ky(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ky.isMDXComponent=!0;const Qy={toc:[]};function tf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}pf.isMDXComponent=!0;const rf={toc:[]};function cf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}df.isMDXComponent=!0;const hf={toc:[]};function kf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}kf.isMDXComponent=!0;const yf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}ff.isMDXComponent=!0;const wf={toc:[]};function Df(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Df.isMDXComponent=!0;const Mf={toc:[]};function _f(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gf.isMDXComponent=!0;const xf={toc:[]};function Cf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}Cf.isMDXComponent=!0;const Tf={toc:[]};function Lf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function vf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}vf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}Nf.isMDXComponent=!0;const Ef={toc:[]};function Af(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ef,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Af.isMDXComponent=!0;const Sf={toc:[]};function Rf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}Rf.isMDXComponent=!0;const zf={toc:[]};function If(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}If.isMDXComponent=!0;const Pf={toc:[]};function Wf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Wf.isMDXComponent=!0;const Gf={toc:[]};function Ff(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Ff.isMDXComponent=!0;const Uf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}jf.isMDXComponent=!0;const Of={toc:[]};function Vf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Of,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}Vf.isMDXComponent=!0;const qf={toc:[]};function Bf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}Bf.isMDXComponent=!0;const $f={toc:[]};function Hf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$f,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Hf.isMDXComponent=!0;const Yf={toc:[]};function Jf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Jf.isMDXComponent=!0;const Kf={toc:[]};function Qf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}Qf.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}rw.isMDXComponent=!0;const cw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}sw.isMDXComponent=!0;const aw={toc:[]};function iw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}iw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}dw.isMDXComponent=!0;const hw={toc:[]};function kw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}kw.isMDXComponent=!0;const yw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}fw.isMDXComponent=!0;const ww={toc:[]};function Dw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}Dw.isMDXComponent=!0;const Mw={toc:[]};function _w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}gw.isMDXComponent=!0;const xw={toc:[]};function Cw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}Cw.isMDXComponent=!0;const Tw={toc:[]};function Lw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function vw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}vw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Nw.isMDXComponent=!0;const Ew={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ew,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}Aw.isMDXComponent=!0;const Sw={toc:[]};function Rw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Rw.isMDXComponent=!0;const zw={toc:[]};function Iw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Iw.isMDXComponent=!0;const Pw={toc:[]};function Ww(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Ww.isMDXComponent=!0;const Gw={toc:[]};function Fw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}Fw.isMDXComponent=!0;const Uw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jw.isMDXComponent=!0;const Ow={toc:[]};function Vw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ow,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}Vw.isMDXComponent=!0;const qw={toc:[]};function Bw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Bw.isMDXComponent=!0;const $w={toc:[]};function Hw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$w,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}Hw.isMDXComponent=!0;const Yw={toc:[]};function Jw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Jw.isMDXComponent=!0;const Kw={toc:[]};function Qw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}Qw.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}rD.isMDXComponent=!0;const cD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sD.isMDXComponent=!0;const aD={toc:[]};function iD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}iD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}dD.isMDXComponent=!0;const hD={toc:[]};function kD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}kD.isMDXComponent=!0;const yD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}fD.isMDXComponent=!0;const wD={toc:[]};function DD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DD.isMDXComponent=!0;const MD={toc:[]};function _D(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}gD.isMDXComponent=!0;const xD={toc:[]};function CD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CD.isMDXComponent=!0;const TD={toc:[]};function LD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}LD.isMDXComponent=!0;const ZD={toc:[]};function vD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}vD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ND.isMDXComponent=!0;const ED={toc:[]};function AD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ED,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}AD.isMDXComponent=!0;const SD={toc:[]};function RD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}RD.isMDXComponent=!0;const zD={toc:[]};function ID(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ID.isMDXComponent=!0;const PD={toc:[]};function WD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}WD.isMDXComponent=!0;const GD={toc:[]};function FD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}FD.isMDXComponent=!0;const UD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jD.isMDXComponent=!0;const OD={toc:[]};function VD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}VD.isMDXComponent=!0;const qD={toc:[]};function BD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}BD.isMDXComponent=!0;const $D={toc:[]};function HD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$D,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}HD.isMDXComponent=!0;const YD={toc:[]};function JD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}JD.isMDXComponent=!0;const KD={toc:[]};function QD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}QD.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}rM.isMDXComponent=!0;const cM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}sM.isMDXComponent=!0;const aM={toc:[]};function iM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}iM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dM.isMDXComponent=!0;const hM={toc:[]};function kM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kM.isMDXComponent=!0;const yM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}fM.isMDXComponent=!0;const wM={toc:[]};function DM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}DM.isMDXComponent=!0;const MM={toc:[]};function _M(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}gM.isMDXComponent=!0;const xM={toc:[]};function CM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}CM.isMDXComponent=!0;const TM={toc:[]};function LM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}LM.isMDXComponent=!0;const ZM={toc:[]};function vM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}vM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}NM.isMDXComponent=!0;const EM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}AM.isMDXComponent=!0;const SM={toc:[]};function RM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}RM.isMDXComponent=!0;const zM={toc:[]};function IM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}IM.isMDXComponent=!0;const PM={toc:[]};function WM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}WM.isMDXComponent=!0;const GM={toc:[]};function FM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}FM.isMDXComponent=!0;const UM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}jM.isMDXComponent=!0;const OM={toc:[]};function VM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}VM.isMDXComponent=!0;const qM={toc:[]};function BM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}BM.isMDXComponent=!0;const $M={toc:[]};function HM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$M,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}HM.isMDXComponent=!0;const YM={toc:[]};function JM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}JM.isMDXComponent=!0;const KM={toc:[]};function QM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}QM.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}r_.isMDXComponent=!0;const c_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}s_.isMDXComponent=!0;const a_={toc:[]};function i_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}i_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}d_.isMDXComponent=!0;const h_={toc:[]};function k_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}k_.isMDXComponent=!0;const y_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}f_.isMDXComponent=!0;const w_={toc:[]};function D_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}D_.isMDXComponent=!0;const M_={toc:[]};function __(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}g_.isMDXComponent=!0;const x_={toc:[]};function C_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}C_.isMDXComponent=!0;const T_={toc:[]};function L_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}L_.isMDXComponent=!0;const Z_={toc:[]};function v_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}v_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}N_.isMDXComponent=!0;const E_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}A_.isMDXComponent=!0;const S_={toc:[]};function R_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}R_.isMDXComponent=!0;const z_={toc:[]};function I_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}I_.isMDXComponent=!0;const P_={toc:[]};function W_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}W_.isMDXComponent=!0;const G_={toc:[]};function F_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}F_.isMDXComponent=!0;const U_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}j_.isMDXComponent=!0;const O_={toc:[]};function V_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}V_.isMDXComponent=!0;const q_={toc:[]};function B_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}B_.isMDXComponent=!0;const $_={toc:[]};function H_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}H_.isMDXComponent=!0;const Y_={toc:[]};function J_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}J_.isMDXComponent=!0;const K_={toc:[]};function Q_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}Q_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}rX.isMDXComponent=!0;const cX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}sX.isMDXComponent=!0;const aX={toc:[]};function iX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}iX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}dX.isMDXComponent=!0;const hX={toc:[]};function kX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}kX.isMDXComponent=!0;const yX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}fX.isMDXComponent=!0;const wX={toc:[]};function DX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}DX.isMDXComponent=!0;const MX={toc:[]};function _X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}gX.isMDXComponent=!0;const xX={toc:[]};function CX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}CX.isMDXComponent=!0;const TX={toc:[]};function LX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}LX.isMDXComponent=!0;const ZX={toc:[]};function vX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}vX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}NX.isMDXComponent=!0;const EX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}AX.isMDXComponent=!0;const SX={toc:[]};function RX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}RX.isMDXComponent=!0;const zX={toc:[]};function IX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}IX.isMDXComponent=!0;const PX={toc:[]};function WX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}WX.isMDXComponent=!0;const GX={toc:[]};function FX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}FX.isMDXComponent=!0;const UX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}jX.isMDXComponent=!0;const OX={toc:[]};function VX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}VX.isMDXComponent=!0;const qX={toc:[]};function BX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}BX.isMDXComponent=!0;const $X={toc:[]};function HX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$X,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}HX.isMDXComponent=!0;const YX={toc:[]};function JX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}JX.isMDXComponent=!0;const KX={toc:[]};function QX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QX.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rg.isMDXComponent=!0;const cg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sg.isMDXComponent=!0;const ag={toc:[]};function ig(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}ig.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}dg.isMDXComponent=!0;const hg={toc:[]};function kg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}kg.isMDXComponent=!0;const yg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}fg.isMDXComponent=!0;const wg={toc:[]};function Dg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}Dg.isMDXComponent=!0;const Mg={toc:[]};function _g(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}gg.isMDXComponent=!0;const xg={toc:[]};function Cg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Cg.isMDXComponent=!0;const Tg={toc:[]};function Lg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function vg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}vg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}Ng.isMDXComponent=!0;const Eg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ag.isMDXComponent=!0;const Sg={toc:[]};function Rg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}Rg.isMDXComponent=!0;const zg={toc:[]};function Ig(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ig.isMDXComponent=!0;const Pg={toc:[]};function Wg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}Wg.isMDXComponent=!0;const Gg={toc:[]};function Fg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Fg.isMDXComponent=!0;const Ug={toc:[]};function jg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ug,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}jg.isMDXComponent=!0;const Og={toc:[]};function Vg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Og,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Vg.isMDXComponent=!0;const qg={toc:[]};function Bg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Bg.isMDXComponent=!0;const $g={toc:[]};function Hg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$g,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Hg.isMDXComponent=!0;const Yg={toc:[]};function Jg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}Jg.isMDXComponent=!0;const Kg={toc:[]};function Qg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}Qg.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}rx.isMDXComponent=!0;const cx={toc:[]};function sx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}sx.isMDXComponent=!0;const ax={toc:[]};function ix(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ix.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}dx.isMDXComponent=!0;const hx={toc:[]};function kx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}kx.isMDXComponent=!0;const yx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}fx.isMDXComponent=!0;const wx={toc:[]};function Dx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}Dx.isMDXComponent=!0;const Mx={toc:[]};function _x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}gx.isMDXComponent=!0;const xx={toc:[]};function Cx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Cx.isMDXComponent=!0;const Tx={toc:[]};function Lx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function vx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}vx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Nx.isMDXComponent=!0;const Ex={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ex,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}Ax.isMDXComponent=!0;const Sx={toc:[]};function Rx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Rx.isMDXComponent=!0;const zx={toc:[]};function Ix(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}Ix.isMDXComponent=!0;const Px={toc:[]};function Wx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Px,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Wx.isMDXComponent=!0;const Gx={toc:[]};function Fx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Fx.isMDXComponent=!0;const Ux={toc:[]};function jx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ux,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}jx.isMDXComponent=!0;const Ox={toc:[]};function Vx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ox,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Vx.isMDXComponent=!0;const qx={toc:[]};function Bx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given position."))}Bx.isMDXComponent=!0;const $x={toc:[]};function Hx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$x,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The position in local space at which to sample the color."))}Hx.isMDXComponent=!0;const Yx={toc:[]};function Jx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given pixel."))}Jx.isMDXComponent=!0;const Kx={toc:[]};function Qx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The pixel's position."))}Qx.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}rC.isMDXComponent=!0;const cC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sC.isMDXComponent=!0;const aC={toc:[]};function iC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}iC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}dC.isMDXComponent=!0;const hC={toc:[]};function kC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}kC.isMDXComponent=!0;const yC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}fC.isMDXComponent=!0;const wC={toc:[]};function DC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}DC.isMDXComponent=!0;const MC={toc:[]};function _C(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}gC.isMDXComponent=!0;const xC={toc:[]};function CC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}CC.isMDXComponent=!0;const TC={toc:[]};function LC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}LC.isMDXComponent=!0;const ZC={toc:[]};function vC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}vC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}NC.isMDXComponent=!0;const EC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}AC.isMDXComponent=!0;const SC={toc:[]};function RC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}RC.isMDXComponent=!0;const zC={toc:[]};function IC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}IC.isMDXComponent=!0;const PC={toc:[]};function WC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}WC.isMDXComponent=!0;const GC={toc:[]};function FC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}FC.isMDXComponent=!0;const UC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}jC.isMDXComponent=!0;const OC={toc:[]};function VC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}VC.isMDXComponent=!0;const qC={toc:[]};function BC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}BC.isMDXComponent=!0;const $C={toc:[]};function HC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$C,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}HC.isMDXComponent=!0;const YC={toc:[]};function JC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}JC.isMDXComponent=!0;const KC={toc:[]};function QC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}QC.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}rT.isMDXComponent=!0;const cT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}sT.isMDXComponent=!0;const aT={toc:[]};function iT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}iT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}dT.isMDXComponent=!0;const hT={toc:[]};function kT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}kT.isMDXComponent=!0;const yT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}fT.isMDXComponent=!0;const wT={toc:[]};function DT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}DT.isMDXComponent=!0;const MT={toc:[]};function _T(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gT.isMDXComponent=!0;const xT={toc:[]};function CT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}CT.isMDXComponent=!0;const TT={toc:[]};function LT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}LT.isMDXComponent=!0;const ZT={toc:[]};function vT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}vT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NT.isMDXComponent=!0;const ET={toc:[]};function AT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ET,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}AT.isMDXComponent=!0;const ST={toc:[]};function RT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ST,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}RT.isMDXComponent=!0;const zT={toc:[]};function IT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}IT.isMDXComponent=!0;const PT={toc:[]};function WT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}WT.isMDXComponent=!0;const GT={toc:[]};function FT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FT.isMDXComponent=!0;const UT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}jT.isMDXComponent=!0;const OT={toc:[]};function VT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}VT.isMDXComponent=!0;const qT={toc:[]};function BT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}BT.isMDXComponent=!0;const $T={toc:[]};function HT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$T,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}HT.isMDXComponent=!0;const YT={toc:[]};function JT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}JT.isMDXComponent=!0;const KT={toc:[]};function QT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}QT.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}rL.isMDXComponent=!0;const cL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}sL.isMDXComponent=!0;const aL={toc:[]};function iL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}iL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}dL.isMDXComponent=!0;const hL={toc:[]};function kL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kL.isMDXComponent=!0;const yL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}fL.isMDXComponent=!0;const wL={toc:[]};function DL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}DL.isMDXComponent=!0;const ML={toc:[]};function _L(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ML,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}gL.isMDXComponent=!0;const xL={toc:[]};function CL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}CL.isMDXComponent=!0;const TL={toc:[]};function LL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}LL.isMDXComponent=!0;const ZL={toc:[]};function vL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}vL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}NL.isMDXComponent=!0;const EL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}AL.isMDXComponent=!0;const SL={toc:[]};function RL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}RL.isMDXComponent=!0;const zL={toc:[]};function IL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}IL.isMDXComponent=!0;const PL={toc:[]};function WL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}WL.isMDXComponent=!0;const GL={toc:[]};function FL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}FL.isMDXComponent=!0;const UL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}jL.isMDXComponent=!0;const OL={toc:[]};function VL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}VL.isMDXComponent=!0;const qL={toc:[]};function BL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}BL.isMDXComponent=!0;const $L={toc:[]};function HL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$L,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}HL.isMDXComponent=!0;const YL={toc:[]};function JL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}JL.isMDXComponent=!0;const KL={toc:[]};function QL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}QL.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}rZ.isMDXComponent=!0;const cZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function iZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}iZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function kZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}kZ.isMDXComponent=!0;const yZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}fZ.isMDXComponent=!0;const wZ={toc:[]};function DZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}DZ.isMDXComponent=!0;const MZ={toc:[]};function _Z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}gZ.isMDXComponent=!0;const xZ={toc:[]};function CZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}CZ.isMDXComponent=!0;const TZ={toc:[]};function LZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function vZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}vZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}NZ.isMDXComponent=!0;const EZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}AZ.isMDXComponent=!0;const SZ={toc:[]};function RZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}RZ.isMDXComponent=!0;const zZ={toc:[]};function IZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}IZ.isMDXComponent=!0;const PZ={toc:[]};function WZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}WZ.isMDXComponent=!0;const GZ={toc:[]};function FZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}FZ.isMDXComponent=!0;const UZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}jZ.isMDXComponent=!0;const OZ={toc:[]};function VZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}VZ.isMDXComponent=!0;const qZ={toc:[]};function BZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}BZ.isMDXComponent=!0;const $Z={toc:[]};function HZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$Z,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}HZ.isMDXComponent=!0;const YZ={toc:[]};function JZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}JZ.isMDXComponent=!0;const KZ={toc:[]};function QZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}QZ.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}rv.isMDXComponent=!0;const cv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}sv.isMDXComponent=!0;const av={toc:[]};function iv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}iv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}dv.isMDXComponent=!0;const hv={toc:[]};function kv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kv.isMDXComponent=!0;const yv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}fv.isMDXComponent=!0;const wv={toc:[]};function Dv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Dv.isMDXComponent=!0;const Mv={toc:[]};function _v(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gv.isMDXComponent=!0;const xv={toc:[]};function Cv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}Cv.isMDXComponent=!0;const Tv={toc:[]};function Lv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function vv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}vv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Nv.isMDXComponent=!0;const Ev={toc:[]};function Av(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ev,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}Av.isMDXComponent=!0;const Sv={toc:[]};function Rv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Rv.isMDXComponent=!0;const zv={toc:[]};function Iv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}Iv.isMDXComponent=!0;const Pv={toc:[]};function Wv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}Wv.isMDXComponent=!0;const Gv={toc:[]};function Fv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}Fv.isMDXComponent=!0;const Uv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}jv.isMDXComponent=!0;const Ov={toc:[]};function Vv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ov,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Vv.isMDXComponent=!0;const qv={toc:[]};function Bv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Bv.isMDXComponent=!0;const $v={toc:[]};function Hv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$v,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}Hv.isMDXComponent=!0;const Yv={toc:[]};function Jv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Jv.isMDXComponent=!0;const Kv={toc:[]};function Qv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Qv.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rb.isMDXComponent=!0;const cb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}sb.isMDXComponent=!0;const ab={toc:[]};function ib(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ib.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}db.isMDXComponent=!0;const hb={toc:[]};function kb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kb.isMDXComponent=!0;const yb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fb.isMDXComponent=!0;const wb={toc:[]};function Db(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}Db.isMDXComponent=!0;const Mb={toc:[]};function _b(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gb.isMDXComponent=!0;const xb={toc:[]};function Cb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}Cb.isMDXComponent=!0;const Tb={toc:[]};function Lb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function vb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}vb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nb.isMDXComponent=!0;const Eb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}Ab.isMDXComponent=!0;const Sb={toc:[]};function Rb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Rb.isMDXComponent=!0;const zb={toc:[]};function Ib(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Ib.isMDXComponent=!0;const Pb={toc:[]};function Wb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Wb.isMDXComponent=!0;const Gb={toc:[]};function Fb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}Fb.isMDXComponent=!0;const Ub={toc:[]};function jb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ub,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}jb.isMDXComponent=!0;const Ob={toc:[]};function Vb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ob,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}Vb.isMDXComponent=!0;const qb={toc:[]};function Bb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Bb.isMDXComponent=!0;const $b={toc:[]};function Hb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$b,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}Hb.isMDXComponent=!0;const Yb={toc:[]};function Jb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Jb.isMDXComponent=!0;const Kb={toc:[]};function Qb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Qb.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}rN.isMDXComponent=!0;const cN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}sN.isMDXComponent=!0;const aN={toc:[]};function iN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}iN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}dN.isMDXComponent=!0;const hN={toc:[]};function kN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}kN.isMDXComponent=!0;const yN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}fN.isMDXComponent=!0;const wN={toc:[]};function DN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DN.isMDXComponent=!0;const MN={toc:[]};function _N(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}gN.isMDXComponent=!0;const xN={toc:[]};function CN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}CN.isMDXComponent=!0;const TN={toc:[]};function LN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LN.isMDXComponent=!0;const ZN={toc:[]};function vN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}vN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}NN.isMDXComponent=!0;const EN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}AN.isMDXComponent=!0;const SN={toc:[]};function RN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}RN.isMDXComponent=!0;const zN={toc:[]};function IN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}IN.isMDXComponent=!0;const PN={toc:[]};function WN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}WN.isMDXComponent=!0;const GN={toc:[]};function FN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FN.isMDXComponent=!0;const UN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}jN.isMDXComponent=!0;const ON={toc:[]};function VN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ON,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}VN.isMDXComponent=!0;const qN={toc:[]};function BN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}BN.isMDXComponent=!0;const $N={toc:[]};function HN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$N,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}HN.isMDXComponent=!0;const YN={toc:[]};function JN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}JN.isMDXComponent=!0;const KN={toc:[]};function QN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}QN.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}rE.isMDXComponent=!0;const cE={toc:[]};function sE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sE.isMDXComponent=!0;const aE={toc:[]};function iE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}iE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}dE.isMDXComponent=!0;const hE={toc:[]};function kE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}kE.isMDXComponent=!0;const yE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}fE.isMDXComponent=!0;const wE={toc:[]};function DE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}DE.isMDXComponent=!0;const ME={toc:[]};function _E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ME,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gE.isMDXComponent=!0;const xE={toc:[]};function CE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}CE.isMDXComponent=!0;const TE={toc:[]};function LE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}LE.isMDXComponent=!0;const ZE={toc:[]};function vE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}vE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}NE.isMDXComponent=!0;const EE={toc:[]};function AE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}AE.isMDXComponent=!0;const SE={toc:[]};function RE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}RE.isMDXComponent=!0;const zE={toc:[]};function IE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}IE.isMDXComponent=!0;const PE={toc:[]};function WE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}WE.isMDXComponent=!0;const GE={toc:[]};function FE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}FE.isMDXComponent=!0;const UE={toc:[]};function jE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}jE.isMDXComponent=!0;const OE={toc:[]};function VE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}VE.isMDXComponent=!0;const qE={toc:[]};function BE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}BE.isMDXComponent=!0;const $E={toc:[]};function HE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$E,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}HE.isMDXComponent=!0;const YE={toc:[]};function JE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}JE.isMDXComponent=!0;const KE={toc:[]};function QE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}QE.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}rA.isMDXComponent=!0;const cA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}sA.isMDXComponent=!0;const aA={toc:[]};function iA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}iA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}dA.isMDXComponent=!0;const hA={toc:[]};function kA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}kA.isMDXComponent=!0;const yA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}fA.isMDXComponent=!0;const wA={toc:[]};function DA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}DA.isMDXComponent=!0;const MA={toc:[]};function _A(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}gA.isMDXComponent=!0;const xA={toc:[]};function CA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}CA.isMDXComponent=!0;const TA={toc:[]};function LA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LA.isMDXComponent=!0;const ZA={toc:[]};function vA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}vA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}NA.isMDXComponent=!0;const EA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}AA.isMDXComponent=!0;const SA={toc:[]};function RA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}RA.isMDXComponent=!0;const zA={toc:[]};function IA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}IA.isMDXComponent=!0;const PA={toc:[]};function WA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}WA.isMDXComponent=!0;const GA={toc:[]};function FA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}FA.isMDXComponent=!0;const UA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}jA.isMDXComponent=!0;const OA={toc:[]};function VA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}VA.isMDXComponent=!0;const qA={toc:[]};function BA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}BA.isMDXComponent=!0;const $A={toc:[]};function HA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$A,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}HA.isMDXComponent=!0;const YA={toc:[]};function JA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}JA.isMDXComponent=!0;const KA={toc:[]};function QA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}QA.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}rS.isMDXComponent=!0;const cS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}sS.isMDXComponent=!0;const aS={toc:[]};function iS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}iS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}dS.isMDXComponent=!0;const hS={toc:[]};function kS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}kS.isMDXComponent=!0;const yS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}fS.isMDXComponent=!0;const wS={toc:[]};function DS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}DS.isMDXComponent=!0;const MS={toc:[]};function _S(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}gS.isMDXComponent=!0;const xS={toc:[]};function CS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}CS.isMDXComponent=!0;const TS={toc:[]};function LS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}LS.isMDXComponent=!0;const ZS={toc:[]};function vS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}NS.isMDXComponent=!0;const ES={toc:[]};function AS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ES,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}AS.isMDXComponent=!0;const SS={toc:[]};function RS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}RS.isMDXComponent=!0;const zS={toc:[]};function IS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}IS.isMDXComponent=!0;const PS={toc:[]};function WS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}WS.isMDXComponent=!0;const GS={toc:[]};function FS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}FS.isMDXComponent=!0;const US={toc:[]};function jS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},US,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}jS.isMDXComponent=!0;const OS={toc:[]};function VS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}VS.isMDXComponent=!0;const qS={toc:[]};function BS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}BS.isMDXComponent=!0;const $S={toc:[]};function HS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$S,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}HS.isMDXComponent=!0;const YS={toc:[]};function JS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}JS.isMDXComponent=!0;const KS={toc:[]};function QS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}QS.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}rR.isMDXComponent=!0;const cR={toc:[]};function sR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}sR.isMDXComponent=!0;const aR={toc:[]};function iR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}iR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}dR.isMDXComponent=!0;const hR={toc:[]};function kR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}kR.isMDXComponent=!0;const yR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}fR.isMDXComponent=!0;const wR={toc:[]};function DR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}DR.isMDXComponent=!0;const MR={toc:[]};function _R(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}gR.isMDXComponent=!0;const xR={toc:[]};function CR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}CR.isMDXComponent=!0;const TR={toc:[]};function LR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}LR.isMDXComponent=!0;const ZR={toc:[]};function vR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}vR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}NR.isMDXComponent=!0;const ER={toc:[]};function AR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ER,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}AR.isMDXComponent=!0;const SR={toc:[]};function RR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}RR.isMDXComponent=!0;const zR={toc:[]};function IR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}IR.isMDXComponent=!0;const PR={toc:[]};function WR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}WR.isMDXComponent=!0;const GR={toc:[]};function FR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}FR.isMDXComponent=!0;const UR={toc:[]};function jR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}jR.isMDXComponent=!0;const OR={toc:[]};function VR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}VR.isMDXComponent=!0;const qR={toc:[]};function BR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}BR.isMDXComponent=!0;const $R={toc:[]};function HR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$R,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}HR.isMDXComponent=!0;const YR={toc:[]};function JR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}JR.isMDXComponent=!0;const KR={toc:[]};function QR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}QR.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}rz.isMDXComponent=!0;const cz={toc:[]};function sz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sz.isMDXComponent=!0;const az={toc:[]};function iz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},az,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}iz.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}dz.isMDXComponent=!0;const hz={toc:[]};function kz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kz.isMDXComponent=!0;const yz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}fz.isMDXComponent=!0;const wz={toc:[]};function Dz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Dz.isMDXComponent=!0;const Mz={toc:[]};function _z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}gz.isMDXComponent=!0;const xz={toc:[]};function Cz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}Cz.isMDXComponent=!0;const Tz={toc:[]};function Lz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Lz.isMDXComponent=!0;const Zz={toc:[]};function vz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}vz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Nz.isMDXComponent=!0;const Ez={toc:[]};function Az(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ez,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}Az.isMDXComponent=!0;const Sz={toc:[]};function Rz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}Rz.isMDXComponent=!0;const zz={toc:[]};function Iz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Iz.isMDXComponent=!0;const Pz={toc:[]};function Wz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Wz.isMDXComponent=!0;const Gz={toc:[]};function Fz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}Fz.isMDXComponent=!0;const Uz={toc:[]};function jz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jz.isMDXComponent=!0;const Oz={toc:[]};function Vz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Vz.isMDXComponent=!0;const qz={toc:[]};function Bz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Bz.isMDXComponent=!0;const $z={toc:[]};function Hz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$z,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Hz.isMDXComponent=!0;const Yz={toc:[]};function Jz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Jz.isMDXComponent=!0;const Kz={toc:[]};function Qz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Qz.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}rI.isMDXComponent=!0;const cI={toc:[]};function sI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}sI.isMDXComponent=!0;const aI={toc:[]};function iI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}iI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}dI.isMDXComponent=!0;const hI={toc:[]};function kI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}kI.isMDXComponent=!0;const yI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}fI.isMDXComponent=!0;const wI={toc:[]};function DI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}DI.isMDXComponent=!0;const MI={toc:[]};function _I(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}gI.isMDXComponent=!0;const xI={toc:[]};function CI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}CI.isMDXComponent=!0;const TI={toc:[]};function LI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}LI.isMDXComponent=!0;const ZI={toc:[]};function vI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NI.isMDXComponent=!0;const EI={toc:[]};function AI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}AI.isMDXComponent=!0;const SI={toc:[]};function RI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}RI.isMDXComponent=!0;const zI={toc:[]};function II(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}II.isMDXComponent=!0;const PI={toc:[]};function WI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}WI.isMDXComponent=!0;const GI={toc:[]};function FI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}FI.isMDXComponent=!0;const UI={toc:[]};function jI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jI.isMDXComponent=!0;const OI={toc:[]};function VI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}VI.isMDXComponent=!0;const qI={toc:[]};function BI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}BI.isMDXComponent=!0;const $I={toc:[]};function HI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$I,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}HI.isMDXComponent=!0;const YI={toc:[]};function JI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}JI.isMDXComponent=!0;const KI={toc:[]};function QI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}QI.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}rP.isMDXComponent=!0;const cP={toc:[]};function sP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}sP.isMDXComponent=!0;const aP={toc:[]};function iP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}iP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dP.isMDXComponent=!0;const hP={toc:[]};function kP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}kP.isMDXComponent=!0;const yP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}fP.isMDXComponent=!0;const wP={toc:[]};function DP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}DP.isMDXComponent=!0;const MP={toc:[]};function _P(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}gP.isMDXComponent=!0;const xP={toc:[]};function CP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}CP.isMDXComponent=!0;const TP={toc:[]};function LP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}LP.isMDXComponent=!0;const ZP={toc:[]};function vP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}vP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}NP.isMDXComponent=!0;const EP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}AP.isMDXComponent=!0;const SP={toc:[]};function RP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}RP.isMDXComponent=!0;const zP={toc:[]};function IP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}IP.isMDXComponent=!0;const PP={toc:[]};function WP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}WP.isMDXComponent=!0;const GP={toc:[]};function FP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}FP.isMDXComponent=!0;const UP={toc:[]};function jP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}jP.isMDXComponent=!0;const OP={toc:[]};function VP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}VP.isMDXComponent=!0;const qP={toc:[]};function BP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}BP.isMDXComponent=!0;const $P={toc:[]};function HP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$P,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}HP.isMDXComponent=!0;const YP={toc:[]};function JP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}JP.isMDXComponent=!0;const KP={toc:[]};function QP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}QP.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}rW.isMDXComponent=!0;const cW={toc:[]};function sW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sW.isMDXComponent=!0;const aW={toc:[]};function iW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}iW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}dW.isMDXComponent=!0;const hW={toc:[]};function kW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}kW.isMDXComponent=!0;const yW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}fW.isMDXComponent=!0;const wW={toc:[]};function DW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}DW.isMDXComponent=!0;const MW={toc:[]};function _W(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}gW.isMDXComponent=!0;const xW={toc:[]};function CW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}CW.isMDXComponent=!0;const TW={toc:[]};function LW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}LW.isMDXComponent=!0;const ZW={toc:[]};function vW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}NW.isMDXComponent=!0;const EW={toc:[]};function AW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}AW.isMDXComponent=!0;const SW={toc:[]};function RW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}RW.isMDXComponent=!0;const zW={toc:[]};function IW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}IW.isMDXComponent=!0;const PW={toc:[]};function WW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}WW.isMDXComponent=!0;const GW={toc:[]};function FW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}FW.isMDXComponent=!0;const UW={toc:[]};function jW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}jW.isMDXComponent=!0;const OW={toc:[]};function VW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}VW.isMDXComponent=!0;const qW={toc:[]};function BW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}BW.isMDXComponent=!0;const $W={toc:[]};function HW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$W,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}HW.isMDXComponent=!0;const YW={toc:[]};function JW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}JW.isMDXComponent=!0;const KW={toc:[]};function QW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}QW.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}rG.isMDXComponent=!0;const cG={toc:[]};function sG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}sG.isMDXComponent=!0;const aG={toc:[]};function iG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}iG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}dG.isMDXComponent=!0;const hG={toc:[]};function kG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}kG.isMDXComponent=!0;const yG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}fG.isMDXComponent=!0;const wG={toc:[]};function DG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}DG.isMDXComponent=!0;const MG={toc:[]};function _G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}gG.isMDXComponent=!0;const xG={toc:[]};function CG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}CG.isMDXComponent=!0;const TG={toc:[]};function LG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}LG.isMDXComponent=!0;const ZG={toc:[]};function vG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}NG.isMDXComponent=!0;const EG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}AG.isMDXComponent=!0;const SG={toc:[]};function RG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}RG.isMDXComponent=!0;const zG={toc:[]};function IG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}IG.isMDXComponent=!0;const PG={toc:[]};function WG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}WG.isMDXComponent=!0;const GG={toc:[]};function FG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}FG.isMDXComponent=!0;const UG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}jG.isMDXComponent=!0;const OG={toc:[]};function VG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}VG.isMDXComponent=!0;const qG={toc:[]};function BG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}BG.isMDXComponent=!0;const $G={toc:[]};function HG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$G,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}HG.isMDXComponent=!0;const YG={toc:[]};function JG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}JG.isMDXComponent=!0;const KG={toc:[]};function QG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}QG.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}rF.isMDXComponent=!0;const cF={toc:[]};function sF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sF.isMDXComponent=!0;const aF={toc:[]};function iF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}iF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}dF.isMDXComponent=!0;const hF={toc:[]};function kF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}kF.isMDXComponent=!0;const yF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}fF.isMDXComponent=!0;const wF={toc:[]};function DF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}DF.isMDXComponent=!0;const MF={toc:[]};function _F(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}gF.isMDXComponent=!0;const xF={toc:[]};function CF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}CF.isMDXComponent=!0;const TF={toc:[]};function LF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}LF.isMDXComponent=!0;const ZF={toc:[]};function vF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}vF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}NF.isMDXComponent=!0;const EF={toc:[]};function AF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}AF.isMDXComponent=!0;const SF={toc:[]};function RF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}RF.isMDXComponent=!0;const zF={toc:[]};function IF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}IF.isMDXComponent=!0;const PF={toc:[]};function WF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}WF.isMDXComponent=!0;const GF={toc:[]};function FF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}FF.isMDXComponent=!0;const UF={toc:[]};function jF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}jF.isMDXComponent=!0;const OF={toc:[]};function VF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}VF.isMDXComponent=!0;const qF={toc:[]};function BF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}BF.isMDXComponent=!0;const $F={toc:[]};function HF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$F,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}HF.isMDXComponent=!0;const YF={toc:[]};function JF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}JF.isMDXComponent=!0;const KF={toc:[]};function QF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}QF.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}rU.isMDXComponent=!0;const cU={toc:[]};function sU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}sU.isMDXComponent=!0;const aU={toc:[]};function iU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}iU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dU.isMDXComponent=!0;const hU={toc:[]};function kU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}kU.isMDXComponent=!0;const yU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}fU.isMDXComponent=!0;const wU={toc:[]};function DU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}DU.isMDXComponent=!0;const MU={toc:[]};function _U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}gU.isMDXComponent=!0;const xU={toc:[]};function CU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}CU.isMDXComponent=!0;const TU={toc:[]};function LU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}LU.isMDXComponent=!0;const ZU={toc:[]};function vU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}vU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}NU.isMDXComponent=!0;const EU={toc:[]};function AU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}AU.isMDXComponent=!0;const SU={toc:[]};function RU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}RU.isMDXComponent=!0;const zU={toc:[]};function IU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}IU.isMDXComponent=!0;const PU={toc:[]};function WU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}WU.isMDXComponent=!0;const GU={toc:[]};function FU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}FU.isMDXComponent=!0;const UU={toc:[]};function jU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}jU.isMDXComponent=!0;const OU={toc:[]};function VU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}VU.isMDXComponent=!0;const qU={toc:[]};function BU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}BU.isMDXComponent=!0;const $U={toc:[]};function HU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$U,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}HU.isMDXComponent=!0;const YU={toc:[]};function JU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}JU.isMDXComponent=!0;const KU={toc:[]};function QU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}QU.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}rj.isMDXComponent=!0;const cj={toc:[]};function sj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}sj.isMDXComponent=!0;const aj={toc:[]};function ij(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}ij.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}dj.isMDXComponent=!0;const hj={toc:[]};function kj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}kj.isMDXComponent=!0;const yj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}fj.isMDXComponent=!0;const wj={toc:[]};function Dj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}Dj.isMDXComponent=!0;const Mj={toc:[]};function _j(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}gj.isMDXComponent=!0;const xj={toc:[]};function Cj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Cj.isMDXComponent=!0;const Tj={toc:[]};function Lj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function vj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}vj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Nj.isMDXComponent=!0;const Ej={toc:[]};function Aj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ej,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Aj.isMDXComponent=!0;const Sj={toc:[]};function Rj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}Rj.isMDXComponent=!0;const zj={toc:[]};function Ij(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ij.isMDXComponent=!0;const Pj={toc:[]};function Wj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Wj.isMDXComponent=!0;const Gj={toc:[]};function Fj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}Fj.isMDXComponent=!0;const Uj={toc:[]};function jj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jj.isMDXComponent=!0;const Oj={toc:[]};function Vj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Vj.isMDXComponent=!0;const qj={toc:[]};function Bj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Bj.isMDXComponent=!0;const $j={toc:[]};function Hj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$j,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Hj.isMDXComponent=!0;const Yj={toc:[]};function Jj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Jj.isMDXComponent=!0;const Kj={toc:[]};function Qj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}Qj.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}rO.isMDXComponent=!0;const cO={toc:[]};function sO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}sO.isMDXComponent=!0;const aO={toc:[]};function iO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}iO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}dO.isMDXComponent=!0;const hO={toc:[]};function kO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}kO.isMDXComponent=!0;const yO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}fO.isMDXComponent=!0;const wO={toc:[]};function DO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}DO.isMDXComponent=!0;const MO={toc:[]};function _O(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gO.isMDXComponent=!0;const xO={toc:[]};function CO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}CO.isMDXComponent=!0;const TO={toc:[]};function LO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}LO.isMDXComponent=!0;const ZO={toc:[]};function vO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}vO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}NO.isMDXComponent=!0;const EO={toc:[]};function AO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}AO.isMDXComponent=!0;const SO={toc:[]};function RO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}RO.isMDXComponent=!0;const zO={toc:[]};function IO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}IO.isMDXComponent=!0;const PO={toc:[]};function WO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}WO.isMDXComponent=!0;const GO={toc:[]};function FO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}FO.isMDXComponent=!0;const UO={toc:[]};function jO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}jO.isMDXComponent=!0;const OO={toc:[]};function VO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}VO.isMDXComponent=!0;const qO={toc:[]};function BO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}BO.isMDXComponent=!0;const $O={toc:[]};function HO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$O,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}HO.isMDXComponent=!0;const YO={toc:[]};function JO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}JO.isMDXComponent=!0;const KO={toc:[]};function QO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}QO.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}rV.isMDXComponent=!0;const cV={toc:[]};function sV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sV.isMDXComponent=!0;const aV={toc:[]};function iV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}iV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}dV.isMDXComponent=!0;const hV={toc:[]};function kV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}kV.isMDXComponent=!0;const yV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}fV.isMDXComponent=!0;const wV={toc:[]};function DV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}DV.isMDXComponent=!0;const MV={toc:[]};function _V(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}gV.isMDXComponent=!0;const xV={toc:[]};function CV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}CV.isMDXComponent=!0;const TV={toc:[]};function LV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}LV.isMDXComponent=!0;const ZV={toc:[]};function vV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}vV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}NV.isMDXComponent=!0;const EV={toc:[]};function AV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}AV.isMDXComponent=!0;const SV={toc:[]};function RV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}RV.isMDXComponent=!0;const zV={toc:[]};function IV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}IV.isMDXComponent=!0;const PV={toc:[]};function WV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}WV.isMDXComponent=!0;const GV={toc:[]};function FV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}FV.isMDXComponent=!0;const UV={toc:[]};function jV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}jV.isMDXComponent=!0;const OV={toc:[]};function VV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}VV.isMDXComponent=!0;const qV={toc:[]};function BV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}BV.isMDXComponent=!0;const $V={toc:[]};function HV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$V,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}HV.isMDXComponent=!0;const YV={toc:[]};function JV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}JV.isMDXComponent=!0;const KV={toc:[]};function QV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QV.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}rq.isMDXComponent=!0;const cq={toc:[]};function sq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sq.isMDXComponent=!0;const aq={toc:[]};function iq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dq.isMDXComponent=!0;const hq={toc:[]};function kq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}kq.isMDXComponent=!0;const yq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}fq.isMDXComponent=!0;const wq={toc:[]};function Dq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Dq.isMDXComponent=!0;const Mq={toc:[]};function _q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gq.isMDXComponent=!0;const xq={toc:[]};function Cq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}Cq.isMDXComponent=!0;const Tq={toc:[]};function Lq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function vq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}vq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Nq.isMDXComponent=!0;const Eq={toc:[]};function Aq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}Aq.isMDXComponent=!0;const Sq={toc:[]};function Rq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Rq.isMDXComponent=!0;const zq={toc:[]};function Iq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}Iq.isMDXComponent=!0;const Pq={toc:[]};function Wq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wq.isMDXComponent=!0;const Gq={toc:[]};function Fq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}Fq.isMDXComponent=!0;const Uq={toc:[]};function jq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}jq.isMDXComponent=!0;const Oq={toc:[]};function Vq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}Vq.isMDXComponent=!0;const qq={toc:[]};function Bq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}Bq.isMDXComponent=!0;const $q={toc:[]};function Hq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$q,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}Hq.isMDXComponent=!0;const Yq={toc:[]};function Jq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Jq.isMDXComponent=!0;const Kq={toc:[]};function Qq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Qq.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}rB.isMDXComponent=!0;const cB={toc:[]};function sB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}sB.isMDXComponent=!0;const aB={toc:[]};function iB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}iB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}dB.isMDXComponent=!0;const hB={toc:[]};function kB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}kB.isMDXComponent=!0;const yB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}fB.isMDXComponent=!0;const wB={toc:[]};function DB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}DB.isMDXComponent=!0;const MB={toc:[]};function _B(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}gB.isMDXComponent=!0;const xB={toc:[]};function CB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}CB.isMDXComponent=!0;const TB={toc:[]};function LB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}LB.isMDXComponent=!0;const ZB={toc:[]};function vB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}NB.isMDXComponent=!0;const EB={toc:[]};function AB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}AB.isMDXComponent=!0;const SB={toc:[]};function RB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}RB.isMDXComponent=!0;const zB={toc:[]};function IB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}IB.isMDXComponent=!0;const PB={toc:[]};function WB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}WB.isMDXComponent=!0;const GB={toc:[]};function FB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}FB.isMDXComponent=!0;const UB={toc:[]};function jB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}jB.isMDXComponent=!0;const OB={toc:[]};function VB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}VB.isMDXComponent=!0;const qB={toc:[]};function BB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}BB.isMDXComponent=!0;const $B={toc:[]};function HB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$B,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}HB.isMDXComponent=!0;const YB={toc:[]};function JB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}JB.isMDXComponent=!0;const KB={toc:[]};function QB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}QB.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}r$.isMDXComponent=!0;const c$={toc:[]};function s$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}s$.isMDXComponent=!0;const a$={toc:[]};function i$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}i$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}d$.isMDXComponent=!0;const h$={toc:[]};function k$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}k$.isMDXComponent=!0;const y$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}f$.isMDXComponent=!0;const w$={toc:[]};function D$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}D$.isMDXComponent=!0;const M$={toc:[]};function _$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}g$.isMDXComponent=!0;const x$={toc:[]};function C$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}C$.isMDXComponent=!0;const T$={toc:[]};function L$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}L$.isMDXComponent=!0;const Z$={toc:[]};function v$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}v$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}N$.isMDXComponent=!0;const E$={toc:[]};function A$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}A$.isMDXComponent=!0;const S$={toc:[]};function R$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}R$.isMDXComponent=!0;const z$={toc:[]};function I$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}I$.isMDXComponent=!0;const P$={toc:[]};function W$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}W$.isMDXComponent=!0;const G$={toc:[]};function F$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}F$.isMDXComponent=!0;const U$={toc:[]};function j$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}j$.isMDXComponent=!0;const O$={toc:[]};function V$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}V$.isMDXComponent=!0;const q$={toc:[]};function B$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}B$.isMDXComponent=!0;const $$={toc:[]};function H$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}H$.isMDXComponent=!0;const Y$={toc:[]};function J$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}J$.isMDXComponent=!0;const K$={toc:[]};function Q$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Q$.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}rH.isMDXComponent=!0;const cH={toc:[]};function sH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}sH.isMDXComponent=!0;const aH={toc:[]};function iH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}iH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}dH.isMDXComponent=!0;const hH={toc:[]};function kH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kH.isMDXComponent=!0;const yH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}fH.isMDXComponent=!0;const wH={toc:[]};function DH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}DH.isMDXComponent=!0;const MH={toc:[]};function _H(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}gH.isMDXComponent=!0;const xH={toc:[]};function CH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}CH.isMDXComponent=!0;const TH={toc:[]};function LH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LH.isMDXComponent=!0;const ZH={toc:[]};function vH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}vH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NH.isMDXComponent=!0;const EH={toc:[]};function AH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}AH.isMDXComponent=!0;const SH={toc:[]};function RH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}RH.isMDXComponent=!0;const zH={toc:[]};function IH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IH.isMDXComponent=!0;const PH={toc:[]};function WH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}WH.isMDXComponent=!0;const GH={toc:[]};function FH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}FH.isMDXComponent=!0;const UH={toc:[]};function jH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}jH.isMDXComponent=!0;const OH={toc:[]};function VH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}VH.isMDXComponent=!0;const qH={toc:[]};function BH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}BH.isMDXComponent=!0;const $H={toc:[]};function HH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$H,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}HH.isMDXComponent=!0;const YH={toc:[]};function JH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}JH.isMDXComponent=!0;const KH={toc:[]};function QH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}QH.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}rY.isMDXComponent=!0;const cY={toc:[]};function sY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}sY.isMDXComponent=!0;const aY={toc:[]};function iY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}iY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dY.isMDXComponent=!0;const hY={toc:[]};function kY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}kY.isMDXComponent=!0;const yY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}fY.isMDXComponent=!0;const wY={toc:[]};function DY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}DY.isMDXComponent=!0;const MY={toc:[]};function _Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}gY.isMDXComponent=!0;const xY={toc:[]};function CY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}CY.isMDXComponent=!0;const TY={toc:[]};function LY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}LY.isMDXComponent=!0;const ZY={toc:[]};function vY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}vY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}NY.isMDXComponent=!0;const EY={toc:[]};function AY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}AY.isMDXComponent=!0;const SY={toc:[]};function RY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}RY.isMDXComponent=!0;const zY={toc:[]};function IY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}IY.isMDXComponent=!0;const PY={toc:[]};function WY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}WY.isMDXComponent=!0;const GY={toc:[]};function FY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}FY.isMDXComponent=!0;const UY={toc:[]};function jY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}jY.isMDXComponent=!0;const OY={toc:[]};function VY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}VY.isMDXComponent=!0;const qY={toc:[]};function BY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}BY.isMDXComponent=!0;const $Y={toc:[]};function HY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$Y,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}HY.isMDXComponent=!0;const YY={toc:[]};function JY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}JY.isMDXComponent=!0;const KY={toc:[]};function QY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}QY.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}rJ.isMDXComponent=!0;const cJ={toc:[]};function sJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}sJ.isMDXComponent=!0;const aJ={toc:[]};function iJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}iJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function kJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}kJ.isMDXComponent=!0;const yJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}fJ.isMDXComponent=!0;const wJ={toc:[]};function DJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}DJ.isMDXComponent=!0;const MJ={toc:[]};function _J(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}gJ.isMDXComponent=!0;const xJ={toc:[]};function CJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}CJ.isMDXComponent=!0;const TJ={toc:[]};function LJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}LJ.isMDXComponent=!0;const ZJ={toc:[]};function vJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}NJ.isMDXComponent=!0;const EJ={toc:[]};function AJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}AJ.isMDXComponent=!0;const SJ={toc:[]};function RJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}RJ.isMDXComponent=!0;const zJ={toc:[]};function IJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}IJ.isMDXComponent=!0;const PJ={toc:[]};function WJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}WJ.isMDXComponent=!0;const GJ={toc:[]};function FJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}FJ.isMDXComponent=!0;const UJ={toc:[]};function jJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}jJ.isMDXComponent=!0;const OJ={toc:[]};function VJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}VJ.isMDXComponent=!0;const qJ={toc:[]};function BJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BJ.isMDXComponent=!0;const $J={toc:[]};function HJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$J,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}HJ.isMDXComponent=!0;const YJ={toc:[]};function JJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}JJ.isMDXComponent=!0;const KJ={toc:[]};function QJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}QJ.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}rK.isMDXComponent=!0;const cK={toc:[]};function sK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}sK.isMDXComponent=!0;const aK={toc:[]};function iK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}iK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dK.isMDXComponent=!0;const hK={toc:[]};function kK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}kK.isMDXComponent=!0;const yK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}fK.isMDXComponent=!0;const wK={toc:[]};function DK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}DK.isMDXComponent=!0;const MK={toc:[]};function _K(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}gK.isMDXComponent=!0;const xK={toc:[]};function CK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}CK.isMDXComponent=!0;const TK={toc:[]};function LK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}LK.isMDXComponent=!0;const ZK={toc:[]};function vK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}vK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}NK.isMDXComponent=!0;const EK={toc:[]};function AK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}AK.isMDXComponent=!0;const SK={toc:[]};function RK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}RK.isMDXComponent=!0;const zK={toc:[]};function IK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}IK.isMDXComponent=!0;const PK={toc:[]};function WK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}WK.isMDXComponent=!0;const GK={toc:[]};function FK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}FK.isMDXComponent=!0;const UK={toc:[]};function jK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jK.isMDXComponent=!0;const OK={toc:[]};function VK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}VK.isMDXComponent=!0;const qK={toc:[]};function BK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}BK.isMDXComponent=!0;const $K={toc:[]};function HK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$K,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}HK.isMDXComponent=!0;const YK={toc:[]};function JK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}JK.isMDXComponent=!0;const KK={toc:[]};function QK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}QK.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}rQ.isMDXComponent=!0;const cQ={toc:[]};function sQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}sQ.isMDXComponent=!0;const aQ={toc:[]};function iQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}iQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function kQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kQ.isMDXComponent=!0;const yQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}fQ.isMDXComponent=!0;const wQ={toc:[]};function DQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}DQ.isMDXComponent=!0;const MQ={toc:[]};function _Q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}gQ.isMDXComponent=!0;const xQ={toc:[]};function CQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}CQ.isMDXComponent=!0;const TQ={toc:[]};function LQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}LQ.isMDXComponent=!0;const ZQ={toc:[]};function vQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}vQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}NQ.isMDXComponent=!0;const EQ={toc:[]};function AQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}AQ.isMDXComponent=!0;const SQ={toc:[]};function RQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}RQ.isMDXComponent=!0;const zQ={toc:[]};function IQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}IQ.isMDXComponent=!0;const PQ={toc:[]};function WQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},PQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}WQ.isMDXComponent=!0;const GQ={toc:[]};function FQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}FQ.isMDXComponent=!0;const UQ={toc:[]};function jQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}jQ.isMDXComponent=!0;const OQ={toc:[]};function VQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}VQ.isMDXComponent=!0;const qQ={toc:[]};function BQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}BQ.isMDXComponent=!0;const $Q={toc:[]};function HQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$Q,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}HQ.isMDXComponent=!0;const YQ={toc:[]};function JQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}JQ.isMDXComponent=!0;const KQ={toc:[]};function QQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}QQ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}r0.isMDXComponent=!0;const c0={toc:[]};function s0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}s0.isMDXComponent=!0;const a0={toc:[]};function i0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}i0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}d0.isMDXComponent=!0;const h0={toc:[]};function k0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}k0.isMDXComponent=!0;const y0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}f0.isMDXComponent=!0;const w0={toc:[]};function D0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}D0.isMDXComponent=!0;const M0={toc:[]};function _0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}g0.isMDXComponent=!0;const x0={toc:[]};function C0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}C0.isMDXComponent=!0;const T0={toc:[]};function L0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}L0.isMDXComponent=!0;const Z0={toc:[]};function v0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}v0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}N0.isMDXComponent=!0;const E0={toc:[]};function A0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}A0.isMDXComponent=!0;const S0={toc:[]};function R0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}R0.isMDXComponent=!0;const z0={toc:[]};function I0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}I0.isMDXComponent=!0;const P0={toc:[]};function W0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}W0.isMDXComponent=!0;const G0={toc:[]};function F0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}F0.isMDXComponent=!0;const U0={toc:[]};function j0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}j0.isMDXComponent=!0;const O0={toc:[]};function V0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}V0.isMDXComponent=!0;const q0={toc:[]};function B0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}B0.isMDXComponent=!0;const $0={toc:[]};function H0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}H0.isMDXComponent=!0;const Y0={toc:[]};function J0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}J0.isMDXComponent=!0;const K0={toc:[]};function Q0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Q0.isMDXComponent=!0;const t3={toc:[]};function n3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}n3.isMDXComponent=!0;const e3={toc:[]};function o3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,c.kt)("p",null,"By default, any property is cloneable."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}r3.isMDXComponent=!0;const c3={toc:[]};function s3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a cloneable property decorator."))}s3.isMDXComponent=!0;const a3={toc:[]};function i3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the property should be cloneable."))}i3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}d3.isMDXComponent=!0;const h3={toc:[]};function k3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a compound property decorator."))}k3.isMDXComponent=!0;const y3={toc:[]};function f3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}f3.isMDXComponent=!0;const w3={toc:[]};function D3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,c.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,c.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}D3.isMDXComponent=!0;const M3={toc:[]};function _3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a computed method decorator."))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the initial value of a property."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}g3.isMDXComponent=!0;const x3={toc:[]};function C3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}C3.isMDXComponent=!0;const T3={toc:[]};function L3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an initial signal value decorator."))}L3.isMDXComponent=!0;const Z3={toc:[]};function v3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The initial value of the property."))}v3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,c.kt)("p",null,"By default, any property is inspectable."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}N3.isMDXComponent=!0;const E3={toc:[]};function A3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}A3.isMDXComponent=!0;const S3={toc:[]};function R3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an inspectable property decorator."))}R3.isMDXComponent=!0;const z3={toc:[]};function I3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the property should be inspectable."))}I3.isMDXComponent=!0;const P3={toc:[]};function W3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}W3.isMDXComponent=!0;const G3={toc:[]};function F3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}F3.isMDXComponent=!0;const U3={toc:[]};function j3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal interpolation function decorator."))}j3.isMDXComponent=!0;const O3={toc:[]};function V3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The interpolation function for the property."))}V3.isMDXComponent=!0;const q3={toc:[]};function B3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,c.kt)("p",null,"If the wrapper class has a method called ",(0,c.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}B3.isMDXComponent=!0;const $3={toc:[]};function H3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}H3.isMDXComponent=!0;const Y3={toc:[]};function J3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal parser decorator."))}J3.isMDXComponent=!0;const K3={toc:[]};function Q3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The wrapper class for the property."))}Q3.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns the given property into a signal."),(0,c.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal decorator."))}r1.isMDXComponent=!0;const c1={toc:[]};function s1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,c.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,c.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,c.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,c.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}s1.isMDXComponent=!0;const a1={toc:[]};function i1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}i1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal wrapper decorator."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The wrapper class for the property."))}d1.isMDXComponent=!0;const h1={toc:[]};function k1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A unified abstraction for all CSS filters."))}k1.isMDXComponent=!0;const y1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value can be either:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length (equivalent to ",(0,c.kt)("inlineCode",{parentName:"li"},"auto")," in CSS)")))}f1.isMDXComponent=!0;const w1={toc:[]};function D1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a length used by most layout properties."))}D1.isMDXComponent=!0;const M1={toc:[]};function _1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,c.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter in pixels."))}g1.isMDXComponent=!0;const x1={toc:[]};function C1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,c.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}C1.isMDXComponent=!0;const T1={toc:[]};function L1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}L1.isMDXComponent=!0;const Z1={toc:[]};function v1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,c.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}v1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}N1.isMDXComponent=!0;const E1={toc:[]};function A1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,c.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}A1.isMDXComponent=!0;const S1={toc:[]};function R1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}R1.isMDXComponent=!0;const z1={toc:[]};function I1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,c.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}I1.isMDXComponent=!0;const P1={toc:[]};function W1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter in degrees."))}W1.isMDXComponent=!0;const G1={toc:[]};function F1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,c.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}F1.isMDXComponent=!0;const U1={toc:[]};function j1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}j1.isMDXComponent=!0;const O1={toc:[]};function V1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,c.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}V1.isMDXComponent=!0;const q1={toc:[]};function B1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}B1.isMDXComponent=!0;const $1={toc:[]};function H1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,c.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}H1.isMDXComponent=!0;const Y1={toc:[]};function J1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}J1.isMDXComponent=!0;const K1={toc:[]};function Q1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the view."),(0,c.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,c.kt)("p",null,"Can modify the state of the view."))}function t2(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}Q1.isMDXComponent=!0},9322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(9770),r=e(8698);const c="toggle_S_IX",s="collapsed_wdUB",a="collapse_TjTN",i="inverse_g6vW",l="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),h=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),k=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(c,e&&s),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:a},d.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,i)})),h&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:h.contentId})),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:k.contentId})))}},1836:(t,n,e)=>{e.d(n,{Z:()=>St});var o=e(2784),p=e(7390),r=e(6835),c=e(68),s=e(6277),a=e(8569);const i={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,c.s2)();return o.createElement("div",{className:(0,s.Z)(a.Z.codeBlockContent,i.codeBlock,e&&i.highlight,p&&i.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,s.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},n)),l&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(9318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,s.Z)(i.codeBlockContainer,"language-typescript")},n)}var k=e(9817);function y(t){let{children:n,type:e,to:p,id:r,tooltip:s}=t;const a=(0,c.Ld)(e);return p?o.createElement(k.Z,(0,l.Z)({id:r,to:p,"data-tooltip":s},a),n):o.createElement("span",(0,l.Z)({id:r},a),n)}let f,w;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(w||(w={}));const D={[f.None]:i.none,[f.Angle]:i.angle,[f.Curly]:i.curly,[f.Square]:i.square,[f.Parentheses]:i.parentheses};function M(t){let{children:n,type:e,separator:p=w.Comma}=t;return o.createElement("span",{className:(0,s.Z)(i.list,D[e??f.None])},o.createElement("span",{className:(0,s.Z)(i.elements,p!==w.Comma&&i.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:i.element},t)))))}var _=e(8617);function X(t){var n;let{type:e}=t;const p=(0,_.RU)(e.project),r=null==p?void 0:p[e.id],c=e.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(y,{to:c,type:c?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(M,{type:f.Angle},e.typeArguments.map(((t,n)=>o.createElement(W,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(y,{type:"keyword"},n.name)}function x(t){let{type:n}=t;return n.elements?o.createElement(M,{type:f.Square},n.elements.map(((t,n)=>o.createElement(W,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function C(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(W,{type:n.elementType}),"[]")}function T(t){let{type:n}=t;return o.createElement(M,{type:f.Parentheses,separator:w.Pipe},n.types.map(((t,n)=>o.createElement(W,{key:n,type:t}))))}function L(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(y,{type:p},e)}function Z(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,n.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(W,{type:n.targetType}))}function v(t){let{type:n}=t;const e=(0,_.in)();return o.createElement(Y,{reflection:e(n.declaration)})}function b(t){let{type:n}=t;return o.createElement(M,{type:f.Parentheses,separator:w.Ampersand},n.types.map(((t,n)=>o.createElement(W,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(W,{key:n,type:e}),"}",o.createElement(y,{type:"string"},p))})),o.createElement(y,{type:"string"},"`"))}function E(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(W,{type:n.queryType}))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(W,{type:n.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(W,{type:n.extendsType})," ? ",o.createElement(W,{type:n.trueType})," : ",o.createElement(W,{type:n.falseType}))}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},n.name))}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(W,{type:n.objectType}),"[",o.createElement(W,{type:n.indexType}),"]")}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},n.operator," "),o.createElement(W,{type:n.target}))}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(M,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},n.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(W,{type:n.parameterType}),"]: ",o.createElement(W,{type:n.templateType}))))}function P(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(W,{type:n.element}))}function W(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return z;case"conditional":return A;case"reflection":return v;case"query":return E;case"named-tuple-member":return P;case"union":return T;case"intrinsic":return g;case"literal":return L;case"reference":return X;case"predicate":return Z;case"tuple":return x;case"array":return C;case"intersection":return b;case"inferred":return S;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function G(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function F(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(W,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},n.defaultValue)))}function U(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.varianceModifier&&o.createElement(y,{type:"keyword"},n.varianceModifier," "),o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(W,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(W,{type:n.default})))}function j(t){var n,e;let{reflection:r,flags:c}=t;const s=(0,_.in)(),a="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:c??r.flags,explicitAccessModifier:!a}),r.kind===p.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:r.overwrites.externalUrl??(0,_.Gr)(s(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},r.type.name)):a?"":o.createElement(y,{type:"function"},r.name),!(null==(n=r.typeParameter)||!n.length)&&o.createElement(M,{type:f.Angle},r.typeParameter.map((t=>o.createElement(U,{key:t.id,reflection:s(t)})))),null!=(e=r.parameters)&&e.length?o.createElement(M,{type:f.Parentheses},r.parameters.map((t=>o.createElement(F,{key:t,reflection:s(t)})))):"()",r.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(W,{type:r.type})))}function O(t){let{reflection:n}=t;return o.createElement(F,{reflection:n})}const V={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function q(t){var n,e,p;let{reflection:r}=t;const c=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:r.flags}),o.createElement(y,{type:"keyword"},V[r.kind]," "),o.createElement(y,{type:"class-name"},r.name),!(null==(n=r.typeParameters)||!n.length)&&o.createElement(M,{type:f.Angle},r.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:c(t)}))))," ",!(null==(e=r.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(M,null,r.extendedTypes.map(((t,n)=>o.createElement(W,{key:n,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(M,null,r.implementedTypes.map(((t,n)=>o.createElement(W,{key:n,type:t}))))))}function B(t){let{reflection:n}=t;const e=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},n.name),n.typeParameters&&o.createElement(M,{type:f.Angle},n.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:e(t)}))))," = ",o.createElement(W,{type:n.type}))}function $(t){let{reflection:n}=t;const e=(0,_.in)();return n.signatures?o.createElement(j,{reflection:n.signatures[0]}):n.children?o.createElement(M,{type:f.Curly},n.children.map((t=>o.createElement(Y,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function H(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(j,{reflection:p})}function Y(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return q;case p.W.Constructor:return j;case p.W.Property:return O;case p.W.Method:return H;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return $;case p.W.TypeParameter:return U;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return B;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function J(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${i.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(i.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,s.Z)(i.line,"token-line")},n),o.createElement("br",null))}var K=e(9322),Q=e(9770);function tt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(U,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(F,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const r=(0,_.in)(),c=(0,o.useMemo)((()=>n.map(r)),[n]),[s,a]=(0,o.useState)(c[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,c.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===s.id,onClick:n.length>1?()=>a(t):void 0},o.createElement(J,null,o.createElement(j,{reflection:t,flags:e})))))),o.createElement(K.Z,{comment:s.comment}),o.createElement(tt,{parameters:s.typeParameter}),o.createElement(nt,{parameters:s.parameters}))}var ot=e(7708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",ct="filters_z1iC",st="icon_ROIU";function at(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,s.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:st})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,s.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,s.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function it(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,s.Z)("row",rt)},o.createElement("div",{className:(0,s.Z)("col",ct)},o.createElement(at,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var lt=e(3181),ut=e(8963),mt=e(3851),dt=e(9741),ht=e(2244),kt=e(4126);const yt="tabList_M0Dn",ft="tabItem_ysIP";function wt(t){var n;const{lazy:e,block:p,defaultValue:r,values:c,groupId:a,className:i}=t,u=o.Children.map(t.children,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),m=c??u.map((t=>{let{props:{value:n,label:e,attributes:o}}=t;return{value:n,label:e,attributes:o}})),d=(0,ht.l)(m,((t,n)=>t.value===n.value));if(d.length>0)throw new Error(`Docusaurus error: Duplicate values "${d.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const h=null===r?r:r??(null==(n=u.find((t=>t.props.default)))?void 0:n.props.value)??u[0].props.value;if(null!==h&&!m.some((t=>t.value===h)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${h}" but none of its children has the corresponding value. Available values are: ${m.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:y}=(0,ut.U)(),[f,w]=(0,o.useState)(h),D=[],{blockElementScrollPositionUntilNextRender:M}=(0,kt.o5)();if(null!=a){const t=k[a];null!=t&&t!==f&&m.some((n=>n.value===t))&&w(t)}const _=t=>{const n=t.currentTarget,e=D.indexOf(n),o=m[e].value;o!==f&&(M(n),w(o),null!=a&&y(a,String(o)))},X=t=>{var n;let e=null;switch(t.key){case"Enter":_(t);break;case"ArrowRight":{const n=D.indexOf(t.currentTarget)+1;e=D[n]??D[0];break}case"ArrowLeft":{const n=D.indexOf(t.currentTarget)-1;e=D[n]??D[D.length-1];break}}null==(n=e)||n.focus()};return o.createElement("div",{className:(0,s.Z)("tabs-container",yt)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":p},i)},m.map((t=>{let{value:n,label:e,attributes:p}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:f===n?0:-1,"aria-selected":f===n,key:n,ref:t=>D.push(t),onKeyDown:X,onClick:_},p,{className:(0,s.Z)("tabs__item",ft,null==p?void 0:p.className,{"tabs__item--active":f===n})}),e??n)}))),e?(0,o.cloneElement)(u.filter((t=>t.props.value===f))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},u.map(((t,n)=>(0,o.cloneElement)(t,{key:n,hidden:t.props.value!==f})))))}function Dt(t){const n=(0,dt.Z)();return o.createElement(wt,(0,l.Z)({key:String(n)},t))}const Mt="tabItem_OMyP";function _t(t){let{children:n,hidden:e,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,s.Z)(Mt,p),hidden:e},n)}function Xt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(St,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(St,{reflection:t})))))}function gt(t){let{group:n,project:e}=t;const p=(0,lt.TH)(),r=(0,_.RU)(e),{setTabGroupChoices:c}=(0,ut.U)(),s=p.hash.split("-")[0].slice(1),[a]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],r=[];for(const c of t.children){const t=n[c];t&&(0,ot.It)(e,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,a))).filter((t=>!!t))),[n,r,a]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const e of i)if(e.anchors.includes(t))return void c(n.title,e.title)}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h2",id:n.title},n.title),i.length>1?o.createElement(Dt,{groupId:n.title},i.map((t=>o.createElement(_t,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Xt,{group:t}))))):o.createElement(Xt,{group:i[0]}))}function xt(t){var n,e,p,r,c;let{reflection:s}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=s.sources)||null==(e=n[0])?void 0:e.url},o.createElement(J,null,o.createElement(Y,{reflection:s})))),o.createElement(it,{kind:s.kind},o.createElement(K.Z,{comment:s.comment})),o.createElement(tt,{parameters:s.typeParameters}),(null==(p=s.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,s.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=s.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,s.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),s.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:s.signatures})),null==(c=s.groups)?void 0:c.map((t=>o.createElement(gt,{group:t,key:t.title,project:s.project}))))}function Ct(t){var n;let{reflection:e,headless:p}=t;const r=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(mt.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:r,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:e.overwrites}))))}function Tt(t){var n,e;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(mt.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement(J,null,o.createElement(O,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function Lt(t){var n,e,p;let{reflection:r}=t;const c=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=r.sources)||null==(e=n[0])?void 0:e.url},o.createElement(J,null,o.createElement(Y,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>c[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(St,{key:t.id,reflection:t})))))))}var Zt=e(8128);function vt(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(Zt.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(it,{kind:e.kind},o.createElement(K.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(gt,{group:t,key:t.title,project:e.project}))))}const bt="cardContainer_ybwo",Nt="cardTitle_Ehd1",Et="cardDescription_b6wr";function At(t){let{reflection:n}=t;const e=(0,_.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,s.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(k.Z,{href:t.href,className:(0,s.Z)("card padding--lg",bt)},o.createElement("h2",{className:(0,s.Z)("text--truncate",Nt)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,s.Z)("text--truncate",Et)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function St(t){let{reflection:n,headless:e=!1}=t;const r=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return At;case p.W.Module:return vt;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return xt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return Ct;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Tt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Lt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(r,{reflection:n,headless:e})}},7390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,n,e)=>{e.d(n,{Gr:()=>i,RU:()=>c,gs:()=>r,in:()=>s,rG:()=>a});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:n,lookup:e,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:r}},n)}function c(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function s(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function a(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function i(t){if(t)return t.href}},68:(t,n,e)=>{e.d(n,{Ld:()=>s,Y0:()=>c,s2:()=>a});var o=e(2784),p=e(822);const r=o.createContext(null);function c(t){let{children:n}=t;const e=(0,p.p)(),c=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(r.Provider,{value:c},n)}function s(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return{className:`token ${t}`,style:n[t]??n.plain}}function a(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return n[t]??n.plain}},7708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(2784),p=e(1263),r=e(9741);const c="api-filters",s=p.Z.canUseDOM?localStorage.getItem(c):null,a=s?JSON.parse(s):{inherited:!0,private:!1},i=o.createContext([a,()=>{}]);function l(t){let{children:n}=t;const[e,p]=(0,o.useState)(a),s=(0,r.Z)();return o.createElement(i.Provider,{value:[e,t=>{s&&localStorage.setItem(c,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(i)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!n.inheritedFrom;return!(!t.inherited&&r)}},5192:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>m,frontMatter:()=>c,metadata:()=>a,toc:()=>l});var o=e(7896),p=(e(2784),e(876)),r=e(2072);const c={sidebar_position:9,slug:"/transitions"},s="Transitions",a={unversionedId:"getting-started/transitions",id:"getting-started/transitions",title:"Transitions",description:"Transitions allow you to customize the way scenes transition from one into",source:"@site/docs/getting-started/transitions.mdx",sourceDirName:"getting-started",slug:"/transitions",permalink:"/docs/transitions",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/transitions.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:9,frontMatter:{sidebar_position:9,slug:"/transitions"},sidebar:"docs",previous:{title:"Time Events",permalink:"/docs/time-events"},next:{title:"Configuration",permalink:"/docs/configuration"}},i={},l=[{value:"Pre-made transitions",id:"pre-made-transitions",level:2},{value:"<code>slideTransition</code>",id:"slidetransition",level:3},{value:"<code>zoomInTransition</code>",id:"zoomintransition",level:3},{value:"<code>zoomOutTransition</code>",id:"zoomouttransition",level:3},{value:"Custom transitions",id:"custom-transitions",level:2},{value:"Animate when transitioning",id:"animate-when-transitioning",level:2}],u={toc:l};function m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"transitions"},"Transitions"),(0,p.kt)("p",null,"Transitions allow you to customize the way scenes transition from one into\nanother. A transition is an animation performed at the beginning of the scene.\nIt can modify the context of both the current and the previous scene."),(0,p.kt)("h2",{id:"pre-made-transitions"},"Pre-made transitions"),(0,p.kt)("p",null,"Motion Canvas comes with a set of common transitions in a form of easy-to-use\ngenerator. To use them, yield the transition generator at the beggining of the\nscene:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  // perform a slide transition to the left:\n  yield* slideTransition(Direction.Left);\n  // proceed with the animation\n});\n")),(0,p.kt)("p",null,"The available transitions are:"),(0,p.kt)("h3",{id:"slidetransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"slideTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#slideTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomintransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomInTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomInTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h3",{id:"zoomouttransition"},(0,p.kt)("inlineCode",{parentName:"h3"},"zoomOutTransition")),(0,p.kt)(r.Z,{url:"/api/core/transitions#zoomOutTransition",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"custom-transitions"},"Custom transitions"),(0,p.kt)("p",null,"You can use the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/transitions#useTransition"},(0,p.kt)("inlineCode",{parentName:"a"},"useTransition"))," function\nto implement custom transitions. It allows you to specify two callbacks that\nwill modify the contexts of the current and previous scene respectively. The\nvalue it returns is a callback that you need to call once you finish the\ntransition."),(0,p.kt)("p",null,"The transition template looks as follows:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// set up the transition\nconst endTransition = useTransition(\n  currentContext => {\n    // modify the context of the current scene\n  },\n  previousContext => {\n    // modify the context of the previous scene\n  },\n);\n\n// perform animations\n\n// finish the transition\nendTransition();\n")),(0,p.kt)("p",null,"Here's how you could implement a simple slide transition:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"export function* slideTransition(\n  direction: Direction = Direction.Top,\n  duration = 0.6,\n): ThreadGenerator {\n  const size = useScene().getSize();\n  const position = size.getOriginOffset(direction).scale(2);\n  const previousPosition = Vector2.createSignal();\n  const currentPosition = Vector2.createSignal(position);\n\n  // set up the transition\n  const endTransition = useTransition(\n    // modify the context of the current scene\n    ctx => ctx.translate(currentPosition.x(), currentPosition.y()),\n    // modify the context of the previous scene\n    ctx => ctx.translate(previousPosition.x(), previousPosition.y()),\n  );\n\n  // perform animations\n  yield* all(\n    previousPosition(position.scale(-1), duration),\n    currentPosition(Vector2.zero, duration),\n  );\n\n  // finish the transition\n  endTransition();\n}\n")),(0,p.kt)("h2",{id:"animate-when-transitioning"},"Animate when transitioning"),(0,p.kt)("p",null,"By default, Motion Canvas will transition to the next scene once the generator\nof the current scene has reached the end. In this case, the scene will freeze\nfor the duration of the transition. You can use the\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#finishScene"},(0,p.kt)("inlineCode",{parentName:"a"},"finishScene"))," function to trigger the transition\nearly, allowing the animation to continue while transitioning:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  yield* animationOne();\n  // trigger the transition early:\n  finishScene();\n  // continue animating:\n  yield* animationTwo();\n});\n")))}m.isMDXComponent=!0}}]);
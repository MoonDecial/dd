"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3938],{876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),f=a,m=d["".concat(s,".").concat(f)]||d[f]||p[f]||i;return n?r.createElement(m,o(o({ref:t},u),{},{components:n})):r.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},2130:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(7896),a=(n(2784),n(876));const i={sidebar_position:2},o="Animation flow",l={unversionedId:"guides/getting-started/flow",id:"guides/getting-started/flow",title:"Animation flow",description:"Motion Canvas uses generator functions to describe animations.",source:"@site/docs/guides/getting-started/flow.mdx",sourceDirName:"guides/getting-started",slug:"/guides/getting-started/flow",permalink:"/guides/getting-started/flow",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/docs/guides/getting-started/flow.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"guides",previous:{title:"Quickstart",permalink:"/guides/getting-started/quickstart"},next:{title:"Signals",permalink:"/guides/getting-started/signals"}},s={},c=[],u={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"animation-flow"},"Animation flow"),(0,a.kt)("p",null,"Motion Canvas uses generator functions to describe animations."),(0,a.kt)("p",null,"A generator function is a function that can return multiple values:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function* example() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst generator = example();\n\nconsole.log(generator.next()); // 1;\nconsole.log(generator.next()); // 2;\nconsole.log(generator.next()); // 3;\n")),(0,a.kt)("p",null,"When the ",(0,a.kt)("inlineCode",{parentName:"p"},"yield")," keyword is encountered, the execution of the function pauses,\nand resumes only when the caller requests another value.\nThis is particularly useful when declaring animations -\nusually we want to change the things on the screen in incremental steps\nto create an illusion of movement. We also want to wait a constant amount of time\nbetween these updates so that our eyes can register what's happening.\nWith generators, we can update things in-between the ",(0,a.kt)("inlineCode",{parentName:"p"},"yield")," keywords,\nand then wait for a bit whenever the function yields."),(0,a.kt)("p",null,"This is the fundamental idea of Motion Canvas.\n",(0,a.kt)("inlineCode",{parentName:"p"},"yield"),' means: "The current frame is ready, display it on the screen and come back to me later."'),(0,a.kt)("p",null,"With that in mind, we can make a circle flicker on the screen using the following code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  circle().fill('red');\n  yield;\n  circle().fill('blue');\n  yield;\n  circle().fill('red');\n  yield;\n});\n")),(0,a.kt)("p",null,"Needless to say, it would be extremely cumbersome if we had to write all animations like that.\nFortunately, JavaScript has another keyword for use within generators - ",(0,a.kt)("inlineCode",{parentName:"p"},"yield*"),".\nIt allows us to delegate the yielding to another generator."),(0,a.kt)("p",null,"For instance, we could extract the flickering code from the above example to\na separate generator and delegate our scene function to it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  yield* flicker(circle());\n});\n\nfunction* flicker(circle: Circle) {\n  circle.fill('red');\n  yield;\n  circle.fill('blue');\n  yield;\n  circle.fill('red');\n  yield;\n}\n")),(0,a.kt)("p",null,"The resulting animation is exactly the same, but now we have\na reusable function that we can use whenever we need some flickering."),(0,a.kt)("p",null,"Motion Canvas provides a lot of useful generators like this.\nYou may remember this snippet from ",(0,a.kt)("a",{parentName:"p",href:"/guides/getting-started/quickstart"},"quickstart"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"yield * myCircle().fill('#e6a700', 1);\n")),(0,a.kt)("p",null,"It animates the fill color of the circle from its current value to ",(0,a.kt)("inlineCode",{parentName:"p"},"#e6a700"),"\nover a span of one second. As you may guess, the result of calling ",(0,a.kt)("inlineCode",{parentName:"p"},"fill('#e6a700', 1)"),"\nis another generator to which we can redirect our scene function.\nGenerators like this are called tweens, because they animate be",(0,a.kt)("strong",{parentName:"p"},"tween")," two values.\nYou can read more about them in the ",(0,a.kt)("a",{parentName:"p",href:"/guides/getting-started/tweening"},"tweening")," section."),(0,a.kt)("p",null,"Another kind of generators are ",(0,a.kt)("em",{parentName:"p"},"flow generators"),". They take one or more generators as\ntheir input and combine them together. We've mentioned the ",(0,a.kt)("inlineCode",{parentName:"p"},"all()")," generator in\nthe quickstart section, but you can find them all in ",(0,a.kt)("a",{parentName:"p",href:"/api/core/flow"},"the API documentation"),"."))}d.isMDXComponent=!0}}]);
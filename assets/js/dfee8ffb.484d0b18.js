"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[4625],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function c(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function r(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?c(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):c(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},c=Object.keys(t);for(o=0;o<c.length;o++)e=c[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(t);for(o=0;o<c.length;o++)e=c[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var a=o.createContext({}),i=function(t){var n=o.useContext(a),e=n;return t&&(e="function"==typeof t?t(n):r(r({},n),t)),e},l=function(t){var n=i(t.components);return o.createElement(a.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,c=t.originalType,a=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),u=i(e),d=p,h=u["".concat(a,".").concat(d)]||u[d]||m[d]||c;return e?o.createElement(h,r(r({ref:n},l),{},{components:e})):o.createElement(h,r({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var c=e.length,r=new Array(c);r[0]=d;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=t,s[u]="string"==typeof t?t:p,r[1]=s;for(var i=2;i<c;i++)r[i]=e[i];return o.createElement.apply(null,r)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},1546:(t,n,e)=>{e.r(n),e.d(n,{default:()=>hS});var o=e(7896),p=(e(2784),e(876));const c={toc:[]};function r(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,p.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}r.isMDXComponent=!0;const s={toc:[]};function a(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}a.isMDXComponent=!0;const i={toc:[]};function l(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},i,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches an asynchronous ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}h.isMDXComponent=!0;const y={toc:[]};function k(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}k.isMDXComponent=!0;const f={toc:[]};function D(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}D.isMDXComponent=!0;const M={toc:[]};function _(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},M,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}_.isMDXComponent=!0;const X={toc:[]};function w(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},X,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}w.isMDXComponent=!0;const T={toc:[]};function C(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},T,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}C.isMDXComponent=!0;const x={toc:[]};function L(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},x,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}L.isMDXComponent=!0;const g={toc:[]};function Z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Z.isMDXComponent=!0;const b={toc:[]};function v(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},b,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}v.isMDXComponent=!0;const N={toc:[]};function A(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}A.isMDXComponent=!0;const S={toc:[]};function G(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},S,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}G.isMDXComponent=!0;const P={toc:[]};function R(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}R.isMDXComponent=!0;const E={toc:[]};function I(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},E,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}I.isMDXComponent=!0;const W={toc:[]};function j(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},W,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}j.isMDXComponent=!0;const U={toc:[]};function F(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},U,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value argument to subscribers."))}F.isMDXComponent=!0;const O={toc:[]};function z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},O,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A base for dispatching ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,p.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}z.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}V.isMDXComponent=!0;const B={toc:[]};function H(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},B,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}H.isMDXComponent=!0;const Y={toc:[]};function J(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}J.isMDXComponent=!0;const K={toc:[]};function Q(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},K,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Q.isMDXComponent=!0;const $={toc:[]};function tt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}pt.isMDXComponent=!0;const ct={toc:[]};function rt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}rt.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,p.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,p.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}at.isMDXComponent=!0;const it={toc:[]};function lt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},it,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}ht.isMDXComponent=!0;const yt={toc:[]};function kt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Are subscribers being notified?"))}kt.isMDXComponent=!0;const ft={toc:[]};function Dt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Notify all current and future subscribers."))}Dt.isMDXComponent=!0;const Mt={toc:[]};function _t(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stop notifying future subscribers."))}_t.isMDXComponent=!0;const Xt={toc:[]};function wt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}wt.isMDXComponent=!0;const Tt={toc:[]};function Ct(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}Ct.isMDXComponent=!0;const xt={toc:[]};function Lt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Lt.isMDXComponent=!0;const gt={toc:[]};function Zt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Zt.isMDXComponent=!0;const bt={toc:[]};function vt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}vt.isMDXComponent=!0;const Nt={toc:[]};function At(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}At.isMDXComponent=!0;const St={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},St,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Gt.isMDXComponent=!0;const Pt={toc:[]};function Rt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Rt.isMDXComponent=!0;const Et={toc:[]};function It(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Et,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}It.isMDXComponent=!0;const Wt={toc:[]};function jt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}jt.isMDXComponent=!0;const Ut={toc:[]};function Ft(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ut,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Ft.isMDXComponent=!0;const Ot={toc:[]};function zt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ot,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}zt.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}Vt.isMDXComponent=!0;const Bt={toc:[]};function Ht(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}Ht.isMDXComponent=!0;const Yt={toc:[]};function Jt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Jt.isMDXComponent=!0;const Kt={toc:[]};function Qt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Qt.isMDXComponent=!0;const $t={toc:[]};function tn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$t,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}pn.isMDXComponent=!0;const cn={toc:[]};function rn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}rn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}yn.isMDXComponent=!0;const kn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}fn.isMDXComponent=!0;const Dn={toc:[]};function Mn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Mn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_n,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Xn.isMDXComponent=!0;const wn={toc:[]};function Tn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Tn.isMDXComponent=!0;const Cn={toc:[]};function xn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}xn.isMDXComponent=!0;const Ln={toc:[]};function gn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ln,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value."))}gn.isMDXComponent=!0;const Zn={toc:[]};function bn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}bn.isMDXComponent=!0;const vn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Nn.isMDXComponent=!0;const An={toc:[]};function Sn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},An,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set the current value of this dispatcher."))}Sn.isMDXComponent=!0;const Gn={toc:[]};function Pn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new value."))}Pn.isMDXComponent=!0;const Rn={toc:[]};function En(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}En.isMDXComponent=!0;const In={toc:[]};function Wn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},In,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}Wn.isMDXComponent=!0;const jn={toc:[]};function Un(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Un.isMDXComponent=!0;const Fn={toc:[]};function On(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}On.isMDXComponent=!0;const zn={toc:[]};function qn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}qn.isMDXComponent=!0;const Vn={toc:[]};function Bn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Bn.isMDXComponent=!0;const Hn={toc:[]};function Yn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Yn.isMDXComponent=!0;const Jn={toc:[]};function Kn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Kn.isMDXComponent=!0;const Qn={toc:[]};function $n(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}$n.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}oe.isMDXComponent=!0;const pe={toc:[]};function ce(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ce.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},re,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}se.isMDXComponent=!0;const ae={toc:[]};function ie(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}ie.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}de.isMDXComponent=!0;const he={toc:[]};function ye(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}ye.isMDXComponent=!0;const ke={toc:[]};function fe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ke,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of times the timer has ticked."))}fe.isMDXComponent=!0;const De={toc:[]};function Me(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},De,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator responsible for running this timer."))}Me.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_e,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the timer ticks."))}Xe.isMDXComponent=!0;const we={toc:[]};function Te(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current iteration index."))}Te.isMDXComponent=!0;const Ce={toc:[]};function xe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ce,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}xe.isMDXComponent=!0;const Le={toc:[]};function ge(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Le,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}ge.isMDXComponent=!0;const Ze={toc:[]};function be(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}be.isMDXComponent=!0;const ve={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ve,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Ne.isMDXComponent=!0;const Ae={toc:[]};function Se(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ae,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Se.isMDXComponent=!0;const Ge={toc:[]};function Pe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Pe.isMDXComponent=!0;const Re={toc:[]};function Ee(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Re,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.corenerRadius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Ee.isMDXComponent=!0;const Ie={toc:[]};function We(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ie,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run tasks one after another."))}We.isMDXComponent=!0;const je={toc:[]};function Ue(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},je,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Ue.isMDXComponent=!0;const Fe={toc:[]};function Oe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Oe.isMDXComponent=!0;const ze={toc:[]};function qe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}qe.isMDXComponent=!0;const Ve={toc:[]};function Be(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay in seconds"))}Be.isMDXComponent=!0;const He={toc:[]};function Ye(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task or callback to run after the delay."))}Ye.isMDXComponent=!0;const Je={toc:[]};function Ke(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Je,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}Ke.isMDXComponent=!0;const Qe={toc:[]};function $e(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Call the given callback every N seconds."))}$e.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interval between subsequent calls."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to be called."))}oo.isMDXComponent=!0;const po={toc:[]};function co(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each time iteration waits until the previous one is completed."))}co.isMDXComponent=!0;const ro={toc:[]};function so(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ro,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}so.isMDXComponent=!0;const ao={toc:[]};function io(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator N times."))}io.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of iterations."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}ho.isMDXComponent=!0;const yo={toc:[]};function ko(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Do nothing."))}ko.isMDXComponent=!0;const fo={toc:[]};function Do(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Do.isMDXComponent=!0;const Mo={toc:[]};function _o(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}_o.isMDXComponent=!0;const Xo={toc:[]};function wo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}wo.isMDXComponent=!0;const To={toc:[]};function Co(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},To,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Co.isMDXComponent=!0;const xo={toc:[]};function Lo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}Lo.isMDXComponent=!0;const go={toc:[]};function Zo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Zo.isMDXComponent=!0;const bo={toc:[]};function vo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}vo.isMDXComponent=!0;const No={toc:[]};function Ao(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ao.isMDXComponent=!0;const So={toc:[]};function Go(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},So,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Go.isMDXComponent=!0;const Po={toc:[]};function Ro(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Po,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Ro.isMDXComponent=!0;const Eo={toc:[]};function Io(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay between each of the tasks."))}Io.isMDXComponent=!0;const Wo={toc:[]};function jo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to be run in a sequence."))}jo.isMDXComponent=!0;const Uo={toc:[]};function Fo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Fo.isMDXComponent=!0;const Oo={toc:[]};function zo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the given amount of time."))}zo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The relative time in seconds."))}Vo.isMDXComponent=!0;const Bo={toc:[]};function Ho(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}Ho.isMDXComponent=!0;const Yo={toc:[]};function Jo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}Jo.isMDXComponent=!0;const Ko={toc:[]};function Qo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ko,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}Qo.isMDXComponent=!0;const $o={toc:[]};function tp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the given time event."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the time event."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}pp.isMDXComponent=!0;const cp={toc:[]};function rp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when a new message is logged."))}rp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the meta file of a given entity."))}ap.isMDXComponent=!0;const ip={toc:[]};function lp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ip,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when metadata changes."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Load new metadata from a file."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New metadata."))}hp.isMDXComponent=!0;const yp={toc:[]};function kp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any possible errors will be logged to the console."))}kp.isMDXComponent=!0;const fp={toc:[]};function Dp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set data without waiting for confirmation."))}Dp.isMDXComponent=!0;const Mp={toc:[]};function _p(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New data."))}_p.isMDXComponent=!0;const Xp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the data stored in the meta file."))}wp.isMDXComponent=!0;const Tp={toc:[]};function Cp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the current scene changes."))}Cp.isMDXComponent=!0;const xp={toc:[]};function Lp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Lp.isMDXComponent=!0;const gp={toc:[]};function Zp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after the scenes were recalculated."))}Zp.isMDXComponent=!0;const bp={toc:[]};function vp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}vp.isMDXComponent=!0;const Np={toc:[]};function Ap(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Ap.isMDXComponent=!0;const Sp={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause/resume the audio."))}Gp.isMDXComponent=!0;const Pp={toc:[]};function Rp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the audio should be paused or resumed."))}Rp.isMDXComponent=!0;const Ep={toc:[]};function Ip(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ep,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The absolute biggest value from the peaks array."))}Ip.isMDXComponent=!0;const Wp={toc:[]};function jp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of samples taken."))}jp.isMDXComponent=!0;const Up={toc:[]};function Fp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Up,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Fp.isMDXComponent=!0;const Op={toc:[]};function zp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Op,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Samples per seconds."))}zp.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Signifies the various stages of a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Vp.isMDXComponent=!0;const Bp={toc:[]};function Hp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs after a render ends."))}Hp.isMDXComponent=!0;const Yp={toc:[]};function Jp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Jp.isMDXComponent=!0;const Kp={toc:[]};function Qp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,p.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Qp.isMDXComponent=!0;const $p={toc:[]};function tc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,p.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes the state of a scene."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}pc.isMDXComponent=!0;const cc={toc:[]};function rc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished transitioning in."))}rc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}ac.isMDXComponent=!0;const ic={toc:[]};function lc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ic,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene is ready to transition out."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoking ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished."))}hc.isMDXComponent=!0;const yc={toc:[]};function kc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has just been created/reset."))}kc.isMDXComponent=!0;const fc={toc:[]};function Dc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The default implementation of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,p.kt)("p",null,"Uses generators to control the animation."))}Dc.isMDXComponent=!0;const Mc={toc:[]};function _c(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}_c.isMDXComponent=!0;const Xc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}wc.isMDXComponent=!0;const Tc={toc:[]};function Cc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Cc.isMDXComponent=!0;const xc={toc:[]};function Lc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}Lc.isMDXComponent=!0;const gc={toc:[]};function Zc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Zc.isMDXComponent=!0;const bc={toc:[]};function vc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}vc.isMDXComponent=!0;const Nc={toc:[]};function Ac(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Ac.isMDXComponent=!0;const Sc={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Gc.isMDXComponent=!0;const Pc={toc:[]};function Rc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Rc.isMDXComponent=!0;const Ec={toc:[]};function Ic(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ec,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}Ic.isMDXComponent=!0;const Wc={toc:[]};function jc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}jc.isMDXComponent=!0;const Uc={toc:[]};function Fc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Fc.isMDXComponent=!0;const Oc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}zc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Vc.isMDXComponent=!0;const Bc={toc:[]};function Hc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Hc.isMDXComponent=!0;const Yc={toc:[]};function Jc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Jc.isMDXComponent=!0;const Kc={toc:[]};function Qc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Qc.isMDXComponent=!0;const $c={toc:[]};function tr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}pr.isMDXComponent=!0;const cr={toc:[]};function rr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}rr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}ar.isMDXComponent=!0;const ir={toc:[]};function lr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ir,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}hr.isMDXComponent=!0;const yr={toc:[]};function kr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}kr.isMDXComponent=!0;const fr={toc:[]};function Dr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}Dr.isMDXComponent=!0;const Mr={toc:[]};function _r(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}_r.isMDXComponent=!0;const Xr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}wr.isMDXComponent=!0;const Tr={toc:[]};function Cr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Cr.isMDXComponent=!0;const xr={toc:[]};function Lr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Lr.isMDXComponent=!0;const gr={toc:[]};function Zr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}Zr.isMDXComponent=!0;const br={toc:[]};function vr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},br,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Lifecycle events for ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}vr.isMDXComponent=!0;const Nr={toc:[]};function Ar(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Manages time events for a given scene."))}Ar.isMDXComponent=!0;const Sr={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when time events change."))}Gr.isMDXComponent=!0;const Pr={toc:[]};function Rr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the time offset of the given event."))}Rr.isMDXComponent=!0;const Er={toc:[]};function Ir(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Er,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the event."))}Ir.isMDXComponent=!0;const Wr={toc:[]};function jr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The time offset in seconds."))}jr.isMDXComponent=!0;const Ur={toc:[]};function Fr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ur,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}Fr.isMDXComponent=!0;const Or={toc:[]};function zr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Or,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes cached information about the timing of a scene."))}zr.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Vr.isMDXComponent=!0;const Br={toc:[]};function Hr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Br,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Hr.isMDXComponent=!0;const Yr={toc:[]};function Jr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for the inspected element."))}Jr.isMDXComponent=!0;const Kr={toc:[]};function Qr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element for which to draw an overlay."))}Qr.isMDXComponent=!0;const $r={toc:[]};function ts(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}ps.isMDXComponent=!0;const cs={toc:[]};function rs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the attributes of the inspected element."))}rs.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to inspect."))}as.isMDXComponent=!0;const is={toc:[]};function ls(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},is,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a possible element to inspect at a given position."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x coordinate."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y coordinate."))}hs.isMDXComponent=!0;const ys={toc:[]};function ks(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ys,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}ks.isMDXComponent=!0;const fs={toc:[]};function Ds(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the inspected element is still valid."))}Ds.isMDXComponent=!0;const Ms={toc:[]};function _s(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ms,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to validate."))}_s.isMDXComponent=!0;const Xs={toc:[]};function ws(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event stored in a meta file."))}ws.isMDXComponent=!0;const Ts={toc:[]};function Cs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ts,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Cs.isMDXComponent=!0;const xs={toc:[]};function Ls(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main interface for scenes."))}Ls.isMDXComponent=!0;const gs={toc:[]};function Zs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Zs.isMDXComponent=!0;const bs={toc:[]};function vs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}vs.isMDXComponent=!0;const Ns={toc:[]};function As(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}As.isMDXComponent=!0;const Ss={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ss,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene's ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Gs.isMDXComponent=!0;const Ps={toc:[]};function Rs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ps,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Rs.isMDXComponent=!0;const Es={toc:[]};function Is(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Es,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}Is.isMDXComponent=!0;const Ws={toc:[]};function js(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ws,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}js.isMDXComponent=!0;const Us={toc:[]};function Fs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Us,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Fs.isMDXComponent=!0;const Os={toc:[]};function zs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Os,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}zs.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Vs.isMDXComponent=!0;const Bs={toc:[]};function Hs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Hs.isMDXComponent=!0;const Ys={toc:[]};function Js(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ys,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Js.isMDXComponent=!0;const Ks={toc:[]};function Qs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ks,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Qs.isMDXComponent=!0;const $s={toc:[]};function ta(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}pa.isMDXComponent=!0;const ca={toc:[]};function ra(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ra.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}aa.isMDXComponent=!0;const ia={toc:[]};function la(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ia,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}ha.isMDXComponent=!0;const ya={toc:[]};function ka(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ya,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}ka.isMDXComponent=!0;const fa={toc:[]};function Da(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Da.isMDXComponent=!0;const Ma={toc:[]};function _a(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ma,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}_a.isMDXComponent=!0;const Xa={toc:[]};function wa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}wa.isMDXComponent=!0;const Ta={toc:[]};function Ca(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ta,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Ca.isMDXComponent=!0;const xa={toc:[]};function La(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}La.isMDXComponent=!0;const ga={toc:[]};function Za(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Za.isMDXComponent=!0;const ba={toc:[]};function va(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ba,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}va.isMDXComponent=!0;const Na={toc:[]};function Aa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Aa.isMDXComponent=!0;const Sa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each class implementing the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Ga.isMDXComponent=!0;const Pa={toc:[]};function Ra(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constructor used when creating new scenes."))}Ra.isMDXComponent=!0;const Ea={toc:[]};function Ia(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ea,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,p.kt)("inlineCode",{parentName:"a"},"config")),"."))}Ia.isMDXComponent=!0;const Wa={toc:[]};function ja(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a scene exposed by a ",(0,p.kt)("inlineCode",{parentName:"p"},"*.scene.tsx")," file."))}ja.isMDXComponent=!0;const Ua={toc:[]};function Fa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ua,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Fa.isMDXComponent=!0;const Oa={toc:[]};function za(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}za.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Va.isMDXComponent=!0;const Ba={toc:[]};function Ha(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ba,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}Ha.isMDXComponent=!0;const Ya={toc:[]};function Ja(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ya,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}Ja.isMDXComponent=!0;const Ka={toc:[]};function Qa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ka,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}Qa.isMDXComponent=!0;const $a={toc:[]};function ti(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event at runtime."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"In other words, the moment at which ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,p.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}pi.isMDXComponent=!0;const ci={toc:[]};function ri(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}ri.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the event."))}ai.isMDXComponent=!0;const ii={toc:[]};function li(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ii,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Duration of the event in seconds."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stack trace at the moment of registration."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}hi.isMDXComponent=!0;const yi={toc:[]};function ki(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents attributes of an inspected element."))}ki.isMDXComponent=!0;const fi={toc:[]};function Di(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Di.isMDXComponent=!0;const Mi={toc:[]};function _i(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents an element to inspect."))}_i.isMDXComponent=!0;const Xi={toc:[]};function wi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread management."))}wi.isMDXComponent=!0;const Ti={toc:[]};function Ci(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ti,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,p.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}Ci.isMDXComponent=!0;const xi={toc:[]};function Li(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A class representing an individual thread."))}Li.isMDXComponent=!0;const gi={toc:[]};function Zi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}Zi.isMDXComponent=!0;const bi={toc:[]};function vi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}vi.isMDXComponent=!0;const Ni={toc:[]};function Ai(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Used by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}Ai.isMDXComponent=!0;const Si={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Si,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current time of this thread."))}Gi.isMDXComponent=!0;const Pi={toc:[]};function Ri(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The next value to be passed to the wrapped generator."))}Ri.isMDXComponent=!0;const Ei={toc:[]};function Ii(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ei,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}Ii.isMDXComponent=!0;const Wi={toc:[]};function ji(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress the wrapped generator once."))}ji.isMDXComponent=!0;const Ui={toc:[]};function Fi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ui,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the thread for the next update cycle."))}Fi.isMDXComponent=!0;const Oi={toc:[]};function zi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a normal function that returns a generator."))}zi.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,p.kt)("p",null,"Progress to the next frame:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,p.kt)("p",null,"Run another generator synchronously:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,p.kt)("p",null,"Run another generator concurrently:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,p.kt)("p",null,"Await a Promise:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Vi.isMDXComponent=!0;const Bi={toc:[]};function Hi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Hi.isMDXComponent=!0;const Yi={toc:[]};function Ji(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Cancel all listed tasks."),(0,p.kt)("p",null,"Example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Ji.isMDXComponent=!0;const Ki={toc:[]};function Qi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ki,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to cancel."))}Qi.isMDXComponent=!0;const $i={toc:[]};function tl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}pl.isMDXComponent=!0;const cl={toc:[]};function rl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible thread ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}rl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}al.isMDXComponent=!0;const il={toc:[]};function ll(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},il,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}hl.isMDXComponent=!0;const yl={toc:[]};function kl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until listed tasks are finished."))}kl.isMDXComponent=!0;const fl={toc:[]};function Dl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Dl.isMDXComponent=!0;const Ml={toc:[]};function _l(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ml,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}_l.isMDXComponent=!0;const Xl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"From the perspective of the external generator, ",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}wl.isMDXComponent=!0;const Tl={toc:[]};function Cl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}Cl.isMDXComponent=!0;const xl={toc:[]};function Ll(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a context in which generators can be run concurrently."))}Ll.isMDXComponent=!0;const gl={toc:[]};function Zl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the generator to run."))}Zl.isMDXComponent=!0;const bl={toc:[]};function vl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}vl.isMDXComponent=!0;const Nl={toc:[]};function Al(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Al.isMDXComponent=!0;const Sl={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the current scene is rendered."))}Gl.isMDXComponent=!0;const Pl={toc:[]};function Rl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the previous scene is rendered."))}Rl.isMDXComponent=!0;const El={toc:[]};function Il(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},El,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any old key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"})))}Il.isMDXComponent=!0;const Wl={toc:[]};function jl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}jl.isMDXComponent=!0;const Ul={toc:[]};function Fl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ul,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Fl.isMDXComponent=!0;const Ol={toc:[]};function zl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ol,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}zl.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Vl.isMDXComponent=!0;const Bl={toc:[]};function Hl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Hl.isMDXComponent=!0;const Yl={toc:[]};function Jl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Jl.isMDXComponent=!0;const Kl={toc:[]};function Ql(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Ql.isMDXComponent=!0;const $l={toc:[]};function tu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}pu.isMDXComponent=!0;const cu={toc:[]};function ru(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a two-dimensional vector."))}ru.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}au.isMDXComponent=!0;const iu={toc:[]};function lu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},iu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The unclipped RGB components."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}hu.isMDXComponent=!0;const yu={toc:[]};function ku(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}ku.isMDXComponent=!0;const fu={toc:[]};function Du(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Du.isMDXComponent=!0;const Mu={toc:[]};function _u(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}_u.isMDXComponent=!0;const Xu={toc:[]};function wu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}wu.isMDXComponent=!0;const Tu={toc:[]};function Cu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}Cu.isMDXComponent=!0;const xu={toc:[]};function Lu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Alias of ",(0,p.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Lu.isMDXComponent=!0;const gu={toc:[]};function Zu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Zu.isMDXComponent=!0;const bu={toc:[]};function vu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}vu.isMDXComponent=!0;const Nu={toc:[]};function Au(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}Au.isMDXComponent=!0;const Su={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Su,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Gu.isMDXComponent=!0;const Pu={toc:[]};function Ru(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Ru.isMDXComponent=!0;const Eu={toc:[]};function Iu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Iu.isMDXComponent=!0;const Wu={toc:[]};function ju(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}ju.isMDXComponent=!0;const Uu={toc:[]};function Fu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"L"),", ",(0,p.kt)("strong",{parentName:"p"},"a"),", and ",(0,p.kt)("strong",{parentName:"p"},"b")," components."))}Fu.isMDXComponent=!0;const Ou={toc:[]};function zu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ou,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}zu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,p.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,p.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}Vu.isMDXComponent=!0;const Bu={toc:[]};function Hu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}Hu.isMDXComponent=!0;const Yu={toc:[]};function Ju(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}Ju.isMDXComponent=!0;const Ku={toc:[]};function Qu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ku,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Qu.isMDXComponent=!0;const $u={toc:[]};function tm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get and set the color opacity."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,p.kt)("code",null,"'rgb'")))}pm.isMDXComponent=!0;const cm={toc:[]};function rm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Similar to saturate, but the opposite direction."))}rm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"set"))}am.isMDXComponent=!0;const im={toc:[]};function lm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},im,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a single channel value.\nAlso"))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color as hexadecimal string."))}hm.isMDXComponent=!0;const ym={toc:[]};function km(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ym,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}km.isMDXComponent=!0;const fm={toc:[]};function Dm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,p.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Dm.isMDXComponent=!0;const Mm={toc:[]};function _m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}_m.isMDXComponent=!0;const Xm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}wm.isMDXComponent=!0;const Tm={toc:[]};function Cm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Cm.isMDXComponent=!0;const xm={toc:[]};function Lm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Lm.isMDXComponent=!0;const gm={toc:[]};function Zm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Zm.isMDXComponent=!0;const bm={toc:[]};function vm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}vm.isMDXComponent=!0;const Nm={toc:[]};function Am(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}Am.isMDXComponent=!0;const Sm={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Gm.isMDXComponent=!0;const Pm={toc:[]};function Rm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Rm.isMDXComponent=!0;const Em={toc:[]};function Im(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Em,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Im.isMDXComponent=!0;const Wm={toc:[]};function jm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert the given origin to a vector representing its offset."))}jm.isMDXComponent=!0;const Um={toc:[]};function Fm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Um,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The origin to convert."))}Fm.isMDXComponent=!0;const Om={toc:[]};function zm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Om,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}zm.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Vm.isMDXComponent=!0;const Bm={toc:[]};function Hm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Hm.isMDXComponent=!0;const Ym={toc:[]};function Jm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ym,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Jm.isMDXComponent=!0;const Km={toc:[]};function Qm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Km,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Qm.isMDXComponent=!0;const $m={toc:[]};function td(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}pd.isMDXComponent=!0;const cd={toc:[]};function rd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}rd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}ad.isMDXComponent=!0;const id={toc:[]};function ld(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},id,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}hd.isMDXComponent=!0;const yd={toc:[]};function kd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}kd.isMDXComponent=!0;const fd={toc:[]};function Dd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Dd.isMDXComponent=!0;const Md={toc:[]};function _d(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Md,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}_d.isMDXComponent=!0;const Xd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}wd.isMDXComponent=!0;const Td={toc:[]};function Cd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Td,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}Cd.isMDXComponent=!0;const xd={toc:[]};function Ld(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The length of the array."))}Ld.isMDXComponent=!0;const gd={toc:[]};function Zd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}Zd.isMDXComponent=!0;const bd={toc:[]};function vd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}vd.isMDXComponent=!0;const Nd={toc:[]};function Ad(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}Ad.isMDXComponent=!0;const Sd={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Gd.isMDXComponent=!0;const Pd={toc:[]};function Rd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}Rd.isMDXComponent=!0;const Ed={toc:[]};function Id(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ed,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context before render."))}Id.isMDXComponent=!0;const Wd={toc:[]};function jd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}jd.isMDXComponent=!0;const Ud={toc:[]};function Fd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ud,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context after render."))}Fd.isMDXComponent=!0;const Od={toc:[]};function zd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Od,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current project."))}zd.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current scene."))}Vd.isMDXComponent=!0;const Bd={toc:[]};function Hd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current thread."))}Hd.isMDXComponent=!0;const Yd={toc:[]};function Jd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}Jd.isMDXComponent=!0;const Kd={toc:[]};function Qd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}Qd.isMDXComponent=!0;const $d={toc:[]};function th(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the real time since the start of the animation."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ph.isMDXComponent=!0;const ch={toc:[]};function rh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}rh.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ah.isMDXComponent=!0;const ih={toc:[]};function lh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ih,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}hh.isMDXComponent=!0;const yh={toc:[]};function kh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}kh.isMDXComponent=!0;const fh={toc:[]};function Dh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Dh.isMDXComponent=!0;const Mh={toc:[]};function _h(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}_h.isMDXComponent=!0;const Xh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}wh.isMDXComponent=!0;const Th={toc:[]};function Ch(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Th,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Ch.isMDXComponent=!0;const xh={toc:[]};function Lh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Lh.isMDXComponent=!0;const gh={toc:[]};function Zh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Zh.isMDXComponent=!0;const bh={toc:[]};function vh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}vh.isMDXComponent=!0;const Nh={toc:[]};function Ah(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Ah.isMDXComponent=!0;const Sh={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Gh.isMDXComponent=!0;const Ph={toc:[]};function Rh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ph,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Rh.isMDXComponent=!0;const Eh={toc:[]};function Ih(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}Ih.isMDXComponent=!0;const Wh={toc:[]};function jh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}jh.isMDXComponent=!0;const Uh={toc:[]};function Fh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Fh.isMDXComponent=!0;const Oh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}zh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Vh.isMDXComponent=!0;const Bh={toc:[]};function Hh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Hh.isMDXComponent=!0;const Yh={toc:[]};function Jh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Jh.isMDXComponent=!0;const Kh={toc:[]};function Qh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Qh.isMDXComponent=!0;const $h={toc:[]};function ty(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}py.isMDXComponent=!0;const cy={toc:[]};function ry(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ry.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}ay.isMDXComponent=!0;const iy={toc:[]};function ly(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}hy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}ky.isMDXComponent=!0;const fy={toc:[]};function Dy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Dy.isMDXComponent=!0;const My={toc:[]};function _y(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},My,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_y.isMDXComponent=!0;const Xy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}wy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ty,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Cy.isMDXComponent=!0;const xy={toc:[]};function Ly(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Ly.isMDXComponent=!0;const gy={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Zy.isMDXComponent=!0;const by={toc:[]};function vy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},by,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}vy.isMDXComponent=!0;const Ny={toc:[]};function Ay(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ay.isMDXComponent=!0;const Sy={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Gy.isMDXComponent=!0;const Py={toc:[]};function Ry(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Ry.isMDXComponent=!0;const Ey={toc:[]};function Iy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ey,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Iy.isMDXComponent=!0;const Wy={toc:[]};function jy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}jy.isMDXComponent=!0;const Uy={toc:[]};function Fy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Fy.isMDXComponent=!0;const Oy={toc:[]};function zy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}zy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Vy.isMDXComponent=!0;const By={toc:[]};function Hy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Hy.isMDXComponent=!0;const Yy={toc:[]};function Jy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Jy.isMDXComponent=!0;const Ky={toc:[]};function Qy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ky,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Qy.isMDXComponent=!0;const $y={toc:[]};function tk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}pk.isMDXComponent=!0;const ck={toc:[]};function rk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ck,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}rk.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}ak.isMDXComponent=!0;const ik={toc:[]};function lk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}hk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}kk.isMDXComponent=!0;const fk={toc:[]};function Dk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}Dk.isMDXComponent=!0;const Mk={toc:[]};function _k(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}_k.isMDXComponent=!0;const Xk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}wk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Ck.isMDXComponent=!0;const xk={toc:[]};function Lk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Lk.isMDXComponent=!0;const gk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Zk.isMDXComponent=!0;const bk={toc:[]};function vk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}vk.isMDXComponent=!0;const Nk={toc:[]};function Ak(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ak.isMDXComponent=!0;const Sk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Gk.isMDXComponent=!0;const Pk={toc:[]};function Rk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Rk.isMDXComponent=!0;const Ek={toc:[]};function Ik(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ek,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Ik.isMDXComponent=!0;const Wk={toc:[]};function jk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}jk.isMDXComponent=!0;const Uk={toc:[]};function Fk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Fk.isMDXComponent=!0;const Ok={toc:[]};function zk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ok,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}zk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Vk.isMDXComponent=!0;const Bk={toc:[]};function Hk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Hk.isMDXComponent=!0;const Yk={toc:[]};function Jk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Jk.isMDXComponent=!0;const Kk={toc:[]};function Qk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Qk.isMDXComponent=!0;const $k={toc:[]};function tf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$k,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}pf.isMDXComponent=!0;const cf={toc:[]};function rf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}rf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}yf.isMDXComponent=!0;const kf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}ff.isMDXComponent=!0;const Df={toc:[]};function Mf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Df,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Mf.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_f,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Xf.isMDXComponent=!0;const wf={toc:[]};function Tf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Tf.isMDXComponent=!0;const Cf={toc:[]};function xf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}xf.isMDXComponent=!0;const Lf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}gf.isMDXComponent=!0;const Zf={toc:[]};function bf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}bf.isMDXComponent=!0;const vf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Nf.isMDXComponent=!0;const Af={toc:[]};function Sf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Af,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Sf.isMDXComponent=!0;const Gf={toc:[]};function Pf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Pf.isMDXComponent=!0;const Rf={toc:[]};function Ef(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Ef.isMDXComponent=!0;const If={toc:[]};function Wf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},If,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Wf.isMDXComponent=!0;const jf={toc:[]};function Uf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Uf.isMDXComponent=!0;const Ff={toc:[]};function Of(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ff,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Of.isMDXComponent=!0;const zf={toc:[]};function qf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}qf.isMDXComponent=!0;const Vf={toc:[]};function Bf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Bf.isMDXComponent=!0;const Hf={toc:[]};function Yf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Yf.isMDXComponent=!0;const Jf={toc:[]};function Kf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Kf.isMDXComponent=!0;const Qf={toc:[]};function $f(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}$f.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}oD.isMDXComponent=!0;const pD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}cD.isMDXComponent=!0;const rD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}sD.isMDXComponent=!0;const aD={toc:[]};function iD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}iD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}yD.isMDXComponent=!0;const kD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}fD.isMDXComponent=!0;const DD={toc:[]};function MD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}MD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_D,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}XD.isMDXComponent=!0;const wD={toc:[]};function TD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}TD.isMDXComponent=!0;const CD={toc:[]};function xD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}xD.isMDXComponent=!0;const LD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},LD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gD.isMDXComponent=!0;const ZD={toc:[]};function bD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bD.isMDXComponent=!0;const vD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}ND.isMDXComponent=!0;const AD={toc:[]};function SD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}SD.isMDXComponent=!0;const GD={toc:[]};function PD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}PD.isMDXComponent=!0;const RD={toc:[]};function ED(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}ED.isMDXComponent=!0;const ID={toc:[]};function WD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ID,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}WD.isMDXComponent=!0;const jD={toc:[]};function UD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}UD.isMDXComponent=!0;const FD={toc:[]};function OD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}OD.isMDXComponent=!0;const zD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}qD.isMDXComponent=!0;const VD={toc:[]};function BD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}BD.isMDXComponent=!0;const HD={toc:[]};function YD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}YD.isMDXComponent=!0;const JD={toc:[]};function KD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}KD.isMDXComponent=!0;const QD={toc:[]};function $D(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$D.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oM.isMDXComponent=!0;const pM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}cM.isMDXComponent=!0;const rM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sM.isMDXComponent=!0;const aM={toc:[]};function iM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}iM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yM.isMDXComponent=!0;const kM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}fM.isMDXComponent=!0;const DM={toc:[]};function MM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}MM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_M,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XM.isMDXComponent=!0;const wM={toc:[]};function TM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}TM.isMDXComponent=!0;const CM={toc:[]};function xM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}xM.isMDXComponent=!0;const LM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},LM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}gM.isMDXComponent=!0;const ZM={toc:[]};function bM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}bM.isMDXComponent=!0;const vM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}NM.isMDXComponent=!0;const AM={toc:[]};function SM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}SM.isMDXComponent=!0;const GM={toc:[]};function PM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}PM.isMDXComponent=!0;const RM={toc:[]};function EM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}EM.isMDXComponent=!0;const IM={toc:[]};function WM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}WM.isMDXComponent=!0;const jM={toc:[]};function UM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}UM.isMDXComponent=!0;const FM={toc:[]};function OM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}OM.isMDXComponent=!0;const zM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}qM.isMDXComponent=!0;const VM={toc:[]};function BM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}BM.isMDXComponent=!0;const HM={toc:[]};function YM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}YM.isMDXComponent=!0;const JM={toc:[]};function KM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}KM.isMDXComponent=!0;const QM={toc:[]};function $M(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}$M.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}o_.isMDXComponent=!0;const p_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}c_.isMDXComponent=!0;const r_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},r_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}s_.isMDXComponent=!0;const a_={toc:[]};function i_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}i_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}y_.isMDXComponent=!0;const k_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},k_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}f_.isMDXComponent=!0;const D_={toc:[]};function M_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},D_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}M_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},__,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}X_.isMDXComponent=!0;const w_={toc:[]};function T_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}T_.isMDXComponent=!0;const C_={toc:[]};function x_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},C_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}x_.isMDXComponent=!0;const L_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},L_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}g_.isMDXComponent=!0;const Z_={toc:[]};function b_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Z_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}b_.isMDXComponent=!0;const v_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},v_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}N_.isMDXComponent=!0;const A_={toc:[]};function S_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},A_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}S_.isMDXComponent=!0;const G_={toc:[]};function P_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}P_.isMDXComponent=!0;const R_={toc:[]};function E_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},R_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}E_.isMDXComponent=!0;const I_={toc:[]};function W_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},I_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}W_.isMDXComponent=!0;const j_={toc:[]};function U_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},j_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}U_.isMDXComponent=!0;const F_={toc:[]};function O_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},F_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}O_.isMDXComponent=!0;const z_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}q_.isMDXComponent=!0;const V_={toc:[]};function B_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}B_.isMDXComponent=!0;const H_={toc:[]};function Y_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},H_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Y_.isMDXComponent=!0;const J_={toc:[]};function K_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},J_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}K_.isMDXComponent=!0;const Q_={toc:[]};function $_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Q_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}$_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}oX.isMDXComponent=!0;const pX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}cX.isMDXComponent=!0;const rX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}sX.isMDXComponent=!0;const aX={toc:[]};function iX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}iX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}yX.isMDXComponent=!0;const kX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}fX.isMDXComponent=!0;const DX={toc:[]};function MX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}MX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_X,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}XX.isMDXComponent=!0;const wX={toc:[]};function TX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}TX.isMDXComponent=!0;const CX={toc:[]};function xX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}xX.isMDXComponent=!0;const LX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},LX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gX.isMDXComponent=!0;const ZX={toc:[]};function bX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}bX.isMDXComponent=!0;const vX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NX.isMDXComponent=!0;const AX={toc:[]};function SX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}SX.isMDXComponent=!0;const GX={toc:[]};function PX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}PX.isMDXComponent=!0;const RX={toc:[]};function EX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}EX.isMDXComponent=!0;const IX={toc:[]};function WX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}WX.isMDXComponent=!0;const jX={toc:[]};function UX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}UX.isMDXComponent=!0;const FX={toc:[]};function OX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}OX.isMDXComponent=!0;const zX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}qX.isMDXComponent=!0;const VX={toc:[]};function BX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}BX.isMDXComponent=!0;const HX={toc:[]};function YX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}YX.isMDXComponent=!0;const JX={toc:[]};function KX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}KX.isMDXComponent=!0;const QX={toc:[]};function $X(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$X.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ow.isMDXComponent=!0;const pw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}cw.isMDXComponent=!0;const rw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sw.isMDXComponent=!0;const aw={toc:[]};function iw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}iw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}yw.isMDXComponent=!0;const kw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fw.isMDXComponent=!0;const Dw={toc:[]};function Mw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_w,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Xw.isMDXComponent=!0;const ww={toc:[]};function Tw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Tw.isMDXComponent=!0;const Cw={toc:[]};function xw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xw.isMDXComponent=!0;const Lw={toc:[]};function gw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}gw.isMDXComponent=!0;const Zw={toc:[]};function bw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}bw.isMDXComponent=!0;const vw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Nw.isMDXComponent=!0;const Aw={toc:[]};function Sw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Aw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Sw.isMDXComponent=!0;const Gw={toc:[]};function Pw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Pw.isMDXComponent=!0;const Rw={toc:[]};function Ew(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Ew.isMDXComponent=!0;const Iw={toc:[]};function Ww(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Iw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Ww.isMDXComponent=!0;const jw={toc:[]};function Uw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Uw.isMDXComponent=!0;const Fw={toc:[]};function Ow(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Ow.isMDXComponent=!0;const zw={toc:[]};function qw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}qw.isMDXComponent=!0;const Vw={toc:[]};function Bw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}Bw.isMDXComponent=!0;const Hw={toc:[]};function Yw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Yw.isMDXComponent=!0;const Jw={toc:[]};function Kw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Kw.isMDXComponent=!0;const Qw={toc:[]};function $w(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}$w.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}oT.isMDXComponent=!0;const pT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}cT.isMDXComponent=!0;const rT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}sT.isMDXComponent=!0;const aT={toc:[]};function iT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}iT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}yT.isMDXComponent=!0;const kT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}fT.isMDXComponent=!0;const DT={toc:[]};function MT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}MT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_T,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}XT.isMDXComponent=!0;const wT={toc:[]};function TT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}TT.isMDXComponent=!0;const CT={toc:[]};function xT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}xT.isMDXComponent=!0;const LT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},LT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}gT.isMDXComponent=!0;const ZT={toc:[]};function bT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bT.isMDXComponent=!0;const vT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}NT.isMDXComponent=!0;const AT={toc:[]};function ST(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ST.isMDXComponent=!0;const GT={toc:[]};function PT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}PT.isMDXComponent=!0;const RT={toc:[]};function ET(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ET.isMDXComponent=!0;const IT={toc:[]};function WT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}WT.isMDXComponent=!0;const jT={toc:[]};function UT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}UT.isMDXComponent=!0;const FT={toc:[]};function OT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}OT.isMDXComponent=!0;const zT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qT.isMDXComponent=!0;const VT={toc:[]};function BT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}BT.isMDXComponent=!0;const HT={toc:[]};function YT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}YT.isMDXComponent=!0;const JT={toc:[]};function KT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KT.isMDXComponent=!0;const QT={toc:[]};function $T(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}$T.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}oC.isMDXComponent=!0;const pC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}cC.isMDXComponent=!0;const rC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}sC.isMDXComponent=!0;const aC={toc:[]};function iC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}iC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}yC.isMDXComponent=!0;const kC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}fC.isMDXComponent=!0;const DC={toc:[]};function MC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}MC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_C,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}XC.isMDXComponent=!0;const wC={toc:[]};function TC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}TC.isMDXComponent=!0;const CC={toc:[]};function xC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}xC.isMDXComponent=!0;const LC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},LC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gC.isMDXComponent=!0;const ZC={toc:[]};function bC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}bC.isMDXComponent=!0;const vC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NC.isMDXComponent=!0;const AC={toc:[]};function SC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}SC.isMDXComponent=!0;const GC={toc:[]};function PC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}PC.isMDXComponent=!0;const RC={toc:[]};function EC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}EC.isMDXComponent=!0;const IC={toc:[]};function WC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}WC.isMDXComponent=!0;const jC={toc:[]};function UC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}UC.isMDXComponent=!0;const FC={toc:[]};function OC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}OC.isMDXComponent=!0;const zC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}qC.isMDXComponent=!0;const VC={toc:[]};function BC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}BC.isMDXComponent=!0;const HC={toc:[]};function YC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}YC.isMDXComponent=!0;const JC={toc:[]};function KC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}KC.isMDXComponent=!0;const QC={toc:[]};function $C(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$C.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ox.isMDXComponent=!0;const px={toc:[]};function cx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}cx.isMDXComponent=!0;const rx={toc:[]};function sx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sx.isMDXComponent=!0;const ax={toc:[]};function ix(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ix.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}yx.isMDXComponent=!0;const kx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fx.isMDXComponent=!0;const Dx={toc:[]};function Mx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_x,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Xx.isMDXComponent=!0;const wx={toc:[]};function Tx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Tx.isMDXComponent=!0;const Cx={toc:[]};function xx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xx.isMDXComponent=!0;const Lx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}gx.isMDXComponent=!0;const Zx={toc:[]};function bx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}bx.isMDXComponent=!0;const vx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Nx.isMDXComponent=!0;const Ax={toc:[]};function Sx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ax,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Sx.isMDXComponent=!0;const Gx={toc:[]};function Px(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Px.isMDXComponent=!0;const Rx={toc:[]};function Ex(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Ex.isMDXComponent=!0;const Ix={toc:[]};function Wx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ix,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Wx.isMDXComponent=!0;const jx={toc:[]};function Ux(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Ux.isMDXComponent=!0;const Fx={toc:[]};function Ox(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Ox.isMDXComponent=!0;const zx={toc:[]};function qx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}qx.isMDXComponent=!0;const Vx={toc:[]};function Bx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}Bx.isMDXComponent=!0;const Hx={toc:[]};function Yx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Yx.isMDXComponent=!0;const Jx={toc:[]};function Kx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Kx.isMDXComponent=!0;const Qx={toc:[]};function $x(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}$x.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}oL.isMDXComponent=!0;const pL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}cL.isMDXComponent=!0;const rL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}sL.isMDXComponent=!0;const aL={toc:[]};function iL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}iL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}yL.isMDXComponent=!0;const kL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}fL.isMDXComponent=!0;const DL={toc:[]};function ML(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ML.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_L,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}XL.isMDXComponent=!0;const wL={toc:[]};function TL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}TL.isMDXComponent=!0;const CL={toc:[]};function xL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}xL.isMDXComponent=!0;const LL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},LL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gL.isMDXComponent=!0;const ZL={toc:[]};function bL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}bL.isMDXComponent=!0;const vL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}NL.isMDXComponent=!0;const AL={toc:[]};function SL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}SL.isMDXComponent=!0;const GL={toc:[]};function PL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}PL.isMDXComponent=!0;const RL={toc:[]};function EL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}EL.isMDXComponent=!0;const IL={toc:[]};function WL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}WL.isMDXComponent=!0;const jL={toc:[]};function UL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}UL.isMDXComponent=!0;const FL={toc:[]};function OL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}OL.isMDXComponent=!0;const zL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}qL.isMDXComponent=!0;const VL={toc:[]};function BL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}BL.isMDXComponent=!0;const HL={toc:[]};function YL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}YL.isMDXComponent=!0;const JL={toc:[]};function KL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}KL.isMDXComponent=!0;const QL={toc:[]};function $L(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}$L.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}og.isMDXComponent=!0;const pg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cg.isMDXComponent=!0;const rg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}sg.isMDXComponent=!0;const ag={toc:[]};function ig(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ig.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yg.isMDXComponent=!0;const kg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}fg.isMDXComponent=!0;const Dg={toc:[]};function Mg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Mg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_g,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Xg.isMDXComponent=!0;const wg={toc:[]};function Tg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Tg.isMDXComponent=!0;const Cg={toc:[]};function xg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}xg.isMDXComponent=!0;const Lg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}gg.isMDXComponent=!0;const Zg={toc:[]};function bg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}bg.isMDXComponent=!0;const vg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Ng.isMDXComponent=!0;const Ag={toc:[]};function Sg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ag,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Sg.isMDXComponent=!0;const Gg={toc:[]};function Pg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Pg.isMDXComponent=!0;const Rg={toc:[]};function Eg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Eg.isMDXComponent=!0;const Ig={toc:[]};function Wg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ig,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Wg.isMDXComponent=!0;const jg={toc:[]};function Ug(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ug.isMDXComponent=!0;const Fg={toc:[]};function Og(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Og.isMDXComponent=!0;const zg={toc:[]};function qg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qg.isMDXComponent=!0;const Vg={toc:[]};function Bg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Bg.isMDXComponent=!0;const Hg={toc:[]};function Yg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Yg.isMDXComponent=!0;const Jg={toc:[]};function Kg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Kg.isMDXComponent=!0;const Qg={toc:[]};function $g(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}$g.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}cZ.isMDXComponent=!0;const rZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function iZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}yZ.isMDXComponent=!0;const kZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fZ.isMDXComponent=!0;const DZ={toc:[]};function MZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}MZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_Z,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}XZ.isMDXComponent=!0;const wZ={toc:[]};function TZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}TZ.isMDXComponent=!0;const CZ={toc:[]};function xZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}xZ.isMDXComponent=!0;const LZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},LZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gZ.isMDXComponent=!0;const ZZ={toc:[]};function bZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}bZ.isMDXComponent=!0;const vZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}NZ.isMDXComponent=!0;const AZ={toc:[]};function SZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}SZ.isMDXComponent=!0;const GZ={toc:[]};function PZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}PZ.isMDXComponent=!0;const RZ={toc:[]};function EZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}EZ.isMDXComponent=!0;const IZ={toc:[]};function WZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}WZ.isMDXComponent=!0;const jZ={toc:[]};function UZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}UZ.isMDXComponent=!0;const FZ={toc:[]};function OZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}OZ.isMDXComponent=!0;const zZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function BZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}BZ.isMDXComponent=!0;const HZ={toc:[]};function YZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}YZ.isMDXComponent=!0;const JZ={toc:[]};function KZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}KZ.isMDXComponent=!0;const QZ={toc:[]};function $Z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}$Z.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}ob.isMDXComponent=!0;const pb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}cb.isMDXComponent=!0;const rb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}sb.isMDXComponent=!0;const ab={toc:[]};function ib(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}ib.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}yb.isMDXComponent=!0;const kb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}fb.isMDXComponent=!0;const Db={toc:[]};function Mb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Db,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Mb.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_b,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Xb.isMDXComponent=!0;const wb={toc:[]};function Tb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Tb.isMDXComponent=!0;const Cb={toc:[]};function xb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xb.isMDXComponent=!0;const Lb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}gb.isMDXComponent=!0;const Zb={toc:[]};function bb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bb.isMDXComponent=!0;const vb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Nb.isMDXComponent=!0;const Ab={toc:[]};function Sb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ab,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Sb.isMDXComponent=!0;const Gb={toc:[]};function Pb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Pb.isMDXComponent=!0;const Rb={toc:[]};function Eb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Eb.isMDXComponent=!0;const Ib={toc:[]};function Wb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ib,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Wb.isMDXComponent=!0;const jb={toc:[]};function Ub(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ub.isMDXComponent=!0;const Fb={toc:[]};function Ob(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Ob.isMDXComponent=!0;const zb={toc:[]};function qb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}qb.isMDXComponent=!0;const Vb={toc:[]};function Bb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Bb.isMDXComponent=!0;const Hb={toc:[]};function Yb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Yb.isMDXComponent=!0;const Jb={toc:[]};function Kb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Kb.isMDXComponent=!0;const Qb={toc:[]};function $b(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}$b.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ov.isMDXComponent=!0;const pv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}cv.isMDXComponent=!0;const rv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sv.isMDXComponent=!0;const av={toc:[]};function iv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}iv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yv.isMDXComponent=!0;const kv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}fv.isMDXComponent=!0;const Dv={toc:[]};function Mv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Mv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_v,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Xv.isMDXComponent=!0;const wv={toc:[]};function Tv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Tv.isMDXComponent=!0;const Cv={toc:[]};function xv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xv.isMDXComponent=!0;const Lv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}gv.isMDXComponent=!0;const Zv={toc:[]};function bv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}bv.isMDXComponent=!0;const vv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Nv.isMDXComponent=!0;const Av={toc:[]};function Sv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Av,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Sv.isMDXComponent=!0;const Gv={toc:[]};function Pv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Pv.isMDXComponent=!0;const Rv={toc:[]};function Ev(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Ev.isMDXComponent=!0;const Iv={toc:[]};function Wv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Iv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Wv.isMDXComponent=!0;const jv={toc:[]};function Uv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}Uv.isMDXComponent=!0;const Fv={toc:[]};function Ov(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Ov.isMDXComponent=!0;const zv={toc:[]};function qv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}qv.isMDXComponent=!0;const Vv={toc:[]};function Bv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Bv.isMDXComponent=!0;const Hv={toc:[]};function Yv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Yv.isMDXComponent=!0;const Jv={toc:[]};function Kv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Kv.isMDXComponent=!0;const Qv={toc:[]};function $v(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}$v.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}oN.isMDXComponent=!0;const pN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}cN.isMDXComponent=!0;const rN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}sN.isMDXComponent=!0;const aN={toc:[]};function iN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}iN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}yN.isMDXComponent=!0;const kN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}fN.isMDXComponent=!0;const DN={toc:[]};function MN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}MN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_N,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}XN.isMDXComponent=!0;const wN={toc:[]};function TN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}TN.isMDXComponent=!0;const CN={toc:[]};function xN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}xN.isMDXComponent=!0;const LN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},LN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gN.isMDXComponent=!0;const ZN={toc:[]};function bN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}bN.isMDXComponent=!0;const vN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}NN.isMDXComponent=!0;const AN={toc:[]};function SN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}SN.isMDXComponent=!0;const GN={toc:[]};function PN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}PN.isMDXComponent=!0;const RN={toc:[]};function EN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}EN.isMDXComponent=!0;const IN={toc:[]};function WN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}WN.isMDXComponent=!0;const jN={toc:[]};function UN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}UN.isMDXComponent=!0;const FN={toc:[]};function ON(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}ON.isMDXComponent=!0;const zN={toc:[]};function qN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}qN.isMDXComponent=!0;const VN={toc:[]};function BN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}BN.isMDXComponent=!0;const HN={toc:[]};function YN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}YN.isMDXComponent=!0;const JN={toc:[]};function KN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}KN.isMDXComponent=!0;const QN={toc:[]};function $N(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}$N.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,p.kt)("p",null,"By default, any property is cloneable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}oA.isMDXComponent=!0;const pA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a cloneable property decorator."))}cA.isMDXComponent=!0;const rA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be cloneable."))}sA.isMDXComponent=!0;const aA={toc:[]};function iA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}iA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a compound property decorator."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}yA.isMDXComponent=!0;const kA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#createComputed"},(0,p.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}fA.isMDXComponent=!0;const DA={toc:[]};function MA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a computed method decorator."))}MA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_A,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the initial value of a property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}XA.isMDXComponent=!0;const wA={toc:[]};function TA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}TA.isMDXComponent=!0;const CA={toc:[]};function xA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an initial property value decorator."))}xA.isMDXComponent=!0;const LA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},LA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the property."))}gA.isMDXComponent=!0;const ZA={toc:[]};function bA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,p.kt)("p",null,"By default, any property is inspectable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}bA.isMDXComponent=!0;const vA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}NA.isMDXComponent=!0;const AA={toc:[]};function SA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an inspectable property decorator."))}SA.isMDXComponent=!0;const GA={toc:[]};function PA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be inspectable."))}PA.isMDXComponent=!0;const RA={toc:[]};function EA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}EA.isMDXComponent=!0;const IA={toc:[]};function WA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}WA.isMDXComponent=!0;const jA={toc:[]};function UA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a property interpolation function decorator."))}UA.isMDXComponent=!0;const FA={toc:[]};function OA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function for the property."))}OA.isMDXComponent=!0;const zA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,p.kt)("p",null,"If the wrapper class has a method called ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}qA.isMDXComponent=!0;const VA={toc:[]};function BA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}BA.isMDXComponent=!0;const HA={toc:[]};function YA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a property parser decorator."))}YA.isMDXComponent=!0;const JA={toc:[]};function KA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}KA.isMDXComponent=!0;const QA={toc:[]};function $A(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given property into a signal."),(0,p.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")),(0,p.kt)("p",null,"See the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#PropertyOwner"},(0,p.kt)("inlineCode",{parentName:"a"},"PropertyOwner"))," type for more detailed method signatures."))}$A.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal property decorator."))}oS.isMDXComponent=!0;const pS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,p.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,p.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,p.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}cS.isMDXComponent=!0;const rS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}sS.isMDXComponent=!0;const aS={toc:[]};function iS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a property wrapper decorator."))}iS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}dS.isMDXComponent=!0;const hS={content_0_0:r,content_0_1:a,content_0_2:l,content_0_3:m,content_0_4:h,content_0_5:k,content_0_6:D,content_0_7:_,content_0_8:w,content_0_9:C,content_0_10:L,content_0_11:Z,content_0_12:v,content_0_13:A,content_0_14:G,content_0_15:R,content_0_16:I,content_0_17:j,content_0_18:F,content_0_19:z,content_0_20:V,content_0_21:H,content_0_22:J,content_0_23:Q,content_0_24:tt,content_0_25:et,content_0_26:pt,content_0_27:rt,content_0_28:at,content_0_29:lt,content_0_30:mt,content_0_31:ht,content_0_32:kt,content_0_33:Dt,content_0_34:_t,content_0_35:wt,content_0_36:Ct,content_0_37:Lt,content_0_38:Zt,content_0_39:vt,content_0_40:At,content_0_41:Gt,content_0_42:Rt,content_0_43:It,content_0_44:jt,content_0_45:Ft,content_0_46:zt,content_0_47:Vt,content_0_48:Ht,content_0_49:Jt,content_0_50:Qt,content_0_51:tn,content_0_52:en,content_0_53:pn,content_0_54:rn,content_0_55:an,content_0_56:un,content_0_57:dn,content_0_58:yn,content_0_59:fn,content_0_60:Mn,content_0_61:Xn,content_0_62:Tn,content_0_63:xn,content_0_64:gn,content_0_65:bn,content_0_66:Nn,content_0_67:Sn,content_0_68:Pn,content_0_69:En,content_0_70:Wn,content_0_71:Un,content_0_72:On,content_0_73:qn,content_0_74:Bn,content_0_75:Yn,content_0_76:Kn,content_0_77:$n,content_0_78:ne,content_0_79:oe,content_0_80:ce,content_0_81:se,content_0_82:ie,content_0_83:ue,content_0_84:de,content_0_85:ye,content_0_86:fe,content_0_87:Me,content_0_88:Xe,content_0_89:Te,content_0_90:xe,content_0_91:ge,content_0_92:be,content_0_93:Ne,content_0_94:Se,content_0_95:Pe,content_0_96:Ee,content_0_97:We,content_0_98:Ue,content_0_99:Oe,content_0_100:qe,content_0_101:Be,content_0_102:Ye,content_0_103:Ke,content_0_104:$e,content_0_105:no,content_0_106:oo,content_0_107:co,content_0_108:so,content_0_109:io,content_0_110:uo,content_0_111:ho,content_0_112:ko,content_0_113:Do,content_0_114:_o,content_0_115:wo,content_0_116:Co,content_0_117:Lo,content_0_118:Zo,content_0_119:vo,content_0_120:Ao,content_0_121:Go,content_0_122:Ro,content_0_123:Io,content_0_124:jo,content_0_125:Fo,content_0_126:zo,content_0_127:Vo,content_0_128:Ho,content_0_129:Jo,content_0_130:Qo,content_0_131:tp,content_0_132:ep,content_0_133:pp,content_0_134:rp,content_0_135:ap,content_0_136:lp,content_0_137:mp,content_0_138:hp,content_0_139:kp,content_0_140:Dp,content_0_141:_p,content_0_142:wp,content_0_143:Cp,content_0_144:Lp,content_0_145:Zp,content_0_146:vp,content_0_147:Ap,content_0_148:Gp,content_0_149:Rp,content_0_150:Ip,content_0_151:jp,content_0_152:Fp,content_0_153:zp,content_0_154:Vp,content_0_155:Hp,content_0_156:Jp,content_0_157:Qp,content_0_158:tc,content_0_159:ec,content_0_160:pc,content_0_161:rc,content_0_162:ac,content_0_163:lc,content_0_164:mc,content_0_165:hc,content_0_166:kc,content_0_167:Dc,content_0_168:_c,content_0_169:wc,content_0_170:Cc,content_0_171:Lc,content_0_172:Zc,content_0_173:vc,content_0_174:Ac,content_0_175:Gc,content_0_176:Rc,content_0_177:Ic,content_0_178:jc,content_0_179:Fc,content_0_180:zc,content_0_181:Vc,content_0_182:Hc,content_0_183:Jc,content_0_184:Qc,content_0_185:tr,content_0_186:er,content_0_187:pr,content_0_188:rr,content_0_189:ar,content_0_190:lr,content_0_191:mr,content_0_192:hr,content_0_193:kr,content_0_194:Dr,content_0_195:_r,content_0_196:wr,content_0_197:Cr,content_0_198:Lr,content_0_199:Zr,content_0_200:vr,content_0_201:Ar,content_0_202:Gr,content_0_203:Rr,content_0_204:Ir,content_0_205:jr,content_0_206:Fr,content_0_207:zr,content_0_208:Vr,content_0_209:Hr,content_0_210:Jr,content_0_211:Qr,content_0_212:ts,content_0_213:es,content_0_214:ps,content_0_215:rs,content_0_216:as,content_0_217:ls,content_0_218:ms,content_0_219:hs,content_0_220:ks,content_0_221:Ds,content_0_222:_s,content_0_223:ws,content_0_224:Cs,content_0_225:Ls,content_0_226:Zs,content_0_227:vs,content_0_228:As,content_0_229:Gs,content_0_230:Rs,content_0_231:Is,content_0_232:js,content_0_233:Fs,content_0_234:zs,content_0_235:Vs,content_0_236:Hs,content_0_237:Js,content_0_238:Qs,content_0_239:ta,content_0_240:ea,content_0_241:pa,content_0_242:ra,content_0_243:aa,content_0_244:la,content_0_245:ma,content_0_246:ha,content_0_247:ka,content_0_248:Da,content_0_249:_a,content_0_250:wa,content_0_251:Ca,content_0_252:La,content_0_253:Za,content_0_254:va,content_0_255:Aa,content_0_256:Ga,content_0_257:Ra,content_0_258:Ia,content_0_259:ja,content_0_260:Fa,content_0_261:za,content_0_262:Va,content_0_263:Ha,content_0_264:Ja,content_0_265:Qa,content_0_266:ti,content_0_267:ei,content_0_268:pi,content_0_269:ri,content_0_270:ai,content_0_271:li,content_0_272:mi,content_0_273:hi,content_0_274:ki,content_0_275:Di,content_0_276:_i,content_0_277:wi,content_0_278:Ci,content_0_279:Li,content_0_280:Zi,content_0_281:vi,content_0_282:Ai,content_0_283:Gi,content_0_284:Ri,content_0_285:Ii,content_0_286:ji,content_0_287:Fi,content_0_288:zi,content_0_289:Vi,content_0_290:Hi,content_0_291:Ji,content_0_292:Qi,content_0_293:tl,content_0_294:el,content_0_295:pl,content_0_296:rl,content_0_297:al,content_0_298:ll,content_0_299:ml,content_0_300:hl,content_0_301:kl,content_0_302:Dl,content_0_303:_l,content_0_304:wl,content_0_305:Cl,content_0_306:Ll,content_0_307:Zl,content_0_308:vl,content_0_309:Al,content_0_310:Gl,content_0_311:Rl,content_0_312:Il,content_0_313:jl,content_0_314:Fl,content_0_315:zl,content_0_316:Vl,content_0_317:Hl,content_0_318:Jl,content_0_319:Ql,content_0_320:tu,content_0_321:eu,content_0_322:pu,content_0_323:ru,content_0_324:au,content_0_325:lu,content_0_326:mu,content_0_327:hu,content_0_328:ku,content_0_329:Du,content_0_330:_u,content_0_331:wu,content_0_332:Cu,content_0_333:Lu,content_0_334:Zu,content_0_335:vu,content_0_336:Au,content_0_337:Gu,content_0_338:Ru,content_0_339:Iu,content_0_340:ju,content_0_341:Fu,content_0_342:zu,content_0_343:Vu,content_0_344:Hu,content_0_345:Ju,content_0_346:Qu,content_0_347:tm,content_0_348:em,content_0_349:pm,content_0_350:rm,content_0_351:am,content_0_352:lm,content_0_353:mm,content_0_354:hm,content_0_355:km,content_0_356:Dm,content_0_357:_m,content_0_358:wm,content_0_359:Cm,content_0_360:Lm,content_0_361:Zm,content_0_362:vm,content_0_363:Am,content_0_364:Gm,content_0_365:Rm,content_0_366:Im,content_0_367:jm,content_0_368:Fm,content_0_369:zm,content_0_370:Vm,content_0_371:Hm,content_0_372:Jm,content_0_373:Qm,content_0_374:td,content_0_375:ed,content_0_376:pd,content_0_377:rd,content_0_378:ad,content_0_379:ld,content_0_380:md,content_0_381:hd,content_0_382:kd,content_0_383:Dd,content_0_384:_d,content_0_385:wd,content_0_386:Cd,content_0_387:Ld,content_0_388:Zd,content_0_389:vd,content_0_390:Ad,content_0_391:Gd,content_0_392:Rd,content_0_393:Id,content_0_394:jd,content_0_395:Fd,content_0_396:zd,content_0_397:Vd,content_0_398:Hd,content_0_399:Jd,content_0_400:Qd,content_0_401:th,content_1716_0:eh,content_1716_1:ph,content_1716_2:rh,content_1716_3:ah,content_1716_4:lh,content_1716_5:mh,content_1716_6:hh,content_1716_7:kh,content_1716_8:Dh,content_1716_9:_h,content_1716_10:wh,content_1716_11:Ch,content_1716_12:Lh,content_1716_13:Zh,content_1716_14:vh,content_1716_15:Ah,content_1716_16:Gh,content_1716_17:Rh,content_1716_18:Ih,content_1716_19:jh,content_1716_20:Fh,content_1716_21:zh,content_1716_22:Vh,content_1716_23:Hh,content_1716_24:Jh,content_1716_25:Qh,content_1716_26:ty,content_1716_27:ey,content_1716_28:py,content_1716_29:ry,content_1716_30:ay,content_1716_31:ly,content_1716_32:my,content_1716_33:hy,content_1716_34:ky,content_1716_35:Dy,content_1716_36:_y,content_1716_37:wy,content_1716_38:Cy,content_1716_39:Ly,content_1716_40:Zy,content_1716_41:vy,content_1716_42:Ay,content_1716_43:Gy,content_1716_44:Ry,content_1716_45:Iy,content_1716_46:jy,content_1716_47:Fy,content_1716_48:zy,content_1716_49:Vy,content_1716_50:Hy,content_1716_51:Jy,content_1716_52:Qy,content_1716_53:tk,content_1716_54:ek,content_1716_55:pk,content_1716_56:rk,content_1716_57:ak,content_1716_58:lk,content_1716_59:mk,content_1716_60:hk,content_1716_61:kk,content_1716_62:Dk,content_1716_63:_k,content_1716_64:wk,content_1716_65:Ck,content_1716_66:Lk,content_1716_67:Zk,content_1716_68:vk,content_1716_69:Ak,content_1716_70:Gk,content_1716_71:Rk,content_1716_72:Ik,content_1716_73:jk,content_1716_74:Fk,content_1716_75:zk,content_1716_76:Vk,content_1716_77:Hk,content_1716_78:Jk,content_1716_79:Qk,content_1716_80:tf,content_1716_81:ef,content_1716_82:pf,content_1716_83:rf,content_1716_84:af,content_1716_85:uf,content_1716_86:df,content_1716_87:yf,content_1716_88:ff,content_1716_89:Mf,content_1716_90:Xf,content_1716_91:Tf,content_1716_92:xf,content_1716_93:gf,content_1716_94:bf,content_1716_95:Nf,content_1716_96:Sf,content_1716_97:Pf,content_1716_98:Ef,content_1716_99:Wf,content_1716_100:Uf,content_1716_101:Of,content_1716_102:qf,content_1716_103:Bf,content_1716_104:Yf,content_1716_105:Kf,content_1716_106:$f,content_1716_107:nD,content_1716_108:oD,content_1716_109:cD,content_1716_110:sD,content_1716_111:iD,content_1716_112:uD,content_1716_113:dD,content_1716_114:yD,content_1716_115:fD,content_1716_116:MD,content_1716_117:XD,content_1716_118:TD,content_1716_119:xD,content_1716_120:gD,content_1716_121:bD,content_1716_122:ND,content_1716_123:SD,content_1716_124:PD,content_1716_125:ED,content_1716_126:WD,content_1716_127:UD,content_1716_128:OD,content_1716_129:qD,content_1716_130:BD,content_1716_131:YD,content_1716_132:KD,content_1716_133:$D,content_1716_134:nM,content_1716_135:oM,content_1716_136:cM,content_1716_137:sM,content_1716_138:iM,content_1716_139:uM,content_1716_140:dM,content_1716_141:yM,content_1716_142:fM,content_1716_143:MM,content_1716_144:XM,content_1716_145:TM,content_1716_146:xM,content_1716_147:gM,content_1716_148:bM,content_1716_149:NM,content_1716_150:SM,content_1716_151:PM,content_1716_152:EM,content_1716_153:WM,content_1716_154:UM,content_1716_155:OM,content_1716_156:qM,content_1716_157:BM,content_1716_158:YM,content_1716_159:KM,content_1716_160:$M,content_1716_161:n_,content_1716_162:o_,content_1716_163:c_,content_1716_164:s_,content_1716_165:i_,content_1716_166:u_,content_1716_167:d_,content_1716_168:y_,content_1716_169:f_,content_1716_170:M_,content_1716_171:X_,content_1716_172:T_,content_1716_173:x_,content_1716_174:g_,content_1716_175:b_,content_1716_176:N_,content_1716_177:S_,content_1716_178:P_,content_1716_179:E_,content_1716_180:W_,content_1716_181:U_,content_1716_182:O_,content_1716_183:q_,content_1716_184:B_,content_1716_185:Y_,content_1716_186:K_,content_1716_187:$_,content_1716_188:nX,content_1716_189:oX,content_1716_190:cX,content_1716_191:sX,content_1716_192:iX,content_1716_193:uX,content_1716_194:dX,content_1716_195:yX,content_1716_196:fX,content_1716_197:MX,content_1716_198:XX,content_1716_199:TX,content_1716_200:xX,content_1716_201:gX,content_1716_202:bX,content_1716_203:NX,content_1716_204:SX,content_1716_205:PX,content_1716_206:EX,content_1716_207:WX,content_1716_208:UX,content_1716_209:OX,content_1716_210:qX,content_1716_211:BX,content_1716_212:YX,content_1716_213:KX,content_1716_214:$X,content_1716_215:nw,content_1716_216:ow,content_1716_217:cw,content_1716_218:sw,content_1716_219:iw,content_1716_220:uw,content_1716_221:dw,content_1716_222:yw,content_1716_223:fw,content_1716_224:Mw,content_1716_225:Xw,content_1716_226:Tw,content_1716_227:xw,content_1716_228:gw,content_1716_229:bw,content_1716_230:Nw,content_1716_231:Sw,content_1716_232:Pw,content_1716_233:Ew,content_1716_234:Ww,content_1716_235:Uw,content_1716_236:Ow,content_1716_237:qw,content_1716_238:Bw,content_1716_239:Yw,content_1716_240:Kw,content_1716_241:$w,content_1716_242:nT,content_1716_243:oT,content_1716_244:cT,content_1716_245:sT,content_1716_246:iT,content_1716_247:uT,content_1716_248:dT,content_1716_249:yT,content_1716_250:fT,content_1716_251:MT,content_1716_252:XT,content_1716_253:TT,content_1716_254:xT,content_1716_255:gT,content_1716_256:bT,content_1716_257:NT,content_1716_258:ST,content_1716_259:PT,content_1716_260:ET,content_1716_261:WT,content_1716_262:UT,content_1716_263:OT,content_1716_264:qT,content_1716_265:BT,content_1716_266:YT,content_1716_267:KT,content_1716_268:$T,content_1716_269:nC,content_1716_270:oC,content_1716_271:cC,content_1716_272:sC,content_1716_273:iC,content_1716_274:uC,content_1716_275:dC,content_1716_276:yC,content_1716_277:fC,content_1716_278:MC,content_1716_279:XC,content_1716_280:TC,content_1716_281:xC,content_1716_282:gC,content_1716_283:bC,content_1716_284:NC,content_1716_285:SC,content_1716_286:PC,content_1716_287:EC,content_1716_288:WC,content_1716_289:UC,content_1716_290:OC,content_1716_291:qC,content_1716_292:BC,content_1716_293:YC,content_1716_294:KC,content_1716_295:$C,content_1716_296:nx,content_1716_297:ox,content_1716_298:cx,content_1716_299:sx,content_1716_300:ix,content_1716_301:ux,content_1716_302:dx,content_1716_303:yx,content_1716_304:fx,content_1716_305:Mx,content_1716_306:Xx,content_1716_307:Tx,content_1716_308:xx,content_1716_309:gx,content_1716_310:bx,content_1716_311:Nx,content_1716_312:Sx,content_1716_313:Px,content_1716_314:Ex,content_1716_315:Wx,content_1716_316:Ux,content_1716_317:Ox,content_1716_318:qx,content_1716_319:Bx,content_1716_320:Yx,content_1716_321:Kx,content_1716_322:$x,content_1716_323:nL,content_1716_324:oL,content_1716_325:cL,content_1716_326:sL,content_1716_327:iL,content_1716_328:uL,content_1716_329:dL,content_1716_330:yL,content_1716_331:fL,content_1716_332:ML,content_1716_333:XL,content_1716_334:TL,content_1716_335:xL,content_1716_336:gL,content_1716_337:bL,content_1716_338:NL,content_1716_339:SL,content_1716_340:PL,content_1716_341:EL,content_1716_342:WL,content_1716_343:UL,content_1716_344:OL,content_1716_345:qL,content_1716_346:BL,content_1716_347:YL,content_1716_348:KL,content_1716_349:$L,content_1716_350:ng,content_1716_351:og,content_1716_352:cg,content_1716_353:sg,content_1716_354:ig,content_1716_355:ug,content_1716_356:dg,content_1716_357:yg,content_1716_358:fg,content_1716_359:Mg,content_1716_360:Xg,content_1716_361:Tg,content_1716_362:xg,content_1716_363:gg,content_1716_364:bg,content_1716_365:Ng,content_1716_366:Sg,content_1716_367:Pg,content_1716_368:Eg,content_1716_369:Wg,content_1716_370:Ug,content_1716_371:Og,content_1716_372:qg,content_1716_373:Bg,content_1716_374:Yg,content_1716_375:Kg,content_1716_376:$g,content_1716_377:nZ,content_1716_378:oZ,content_1716_379:cZ,content_1716_380:sZ,content_1716_381:iZ,content_1716_382:uZ,content_1716_383:dZ,content_1716_384:yZ,content_1716_385:fZ,content_1716_386:MZ,content_1716_387:XZ,content_1716_388:TZ,content_1716_389:xZ,content_1716_390:gZ,content_1716_391:bZ,content_1716_392:NZ,content_1716_393:SZ,content_1716_394:PZ,content_1716_395:EZ,content_1716_396:WZ,content_1716_397:UZ,content_1716_398:OZ,content_1716_399:qZ,content_1716_400:BZ,content_1716_401:YZ,content_1716_402:KZ,content_1716_403:$Z,content_1716_404:nb,content_1716_405:ob,content_1716_406:cb,content_1716_407:sb,content_1716_408:ib,content_1716_409:ub,content_1716_410:db,content_1716_411:yb,content_1716_412:fb,content_1716_413:Mb,content_1716_414:Xb,content_1716_415:Tb,content_1716_416:xb,content_1716_417:gb,content_1716_418:bb,content_1716_419:Nb,content_1716_420:Sb,content_1716_421:Pb,content_1716_422:Eb,content_1716_423:Wb,content_1716_424:Ub,content_1716_425:Ob,content_1716_426:qb,content_1716_427:Bb,content_1716_428:Yb,content_1716_429:Kb,content_1716_430:$b,content_1716_431:nv,content_1716_432:ov,content_1716_433:cv,content_1716_434:sv,content_1716_435:iv,content_1716_436:uv,content_1716_437:dv,content_1716_438:yv,content_1716_439:fv,content_1716_440:Mv,content_1716_441:Xv,content_1716_442:Tv,content_1716_443:xv,content_1716_444:gv,content_1716_445:bv,content_1716_446:Nv,content_1716_447:Sv,content_1716_448:Pv,content_1716_449:Ev,content_1716_450:Wv,content_1716_451:Uv,content_1716_452:Ov,content_1716_453:qv,content_1716_454:Bv,content_1716_455:Yv,content_1716_456:Kv,content_1716_457:$v,content_1716_458:nN,content_1716_459:oN,content_1716_460:cN,content_1716_461:sN,content_1716_462:iN,content_1716_463:uN,content_1716_464:dN,content_1716_465:yN,content_1716_466:fN,content_1716_467:MN,content_1716_468:XN,content_1716_469:TN,content_1716_470:xN,content_1716_471:gN,content_1716_472:bN,content_1716_473:NN,content_1716_474:SN,content_1716_475:PN,content_1716_476:EN,content_1716_477:WN,content_1716_478:UN,content_1716_479:ON,content_1716_480:qN,content_1716_481:BN,content_1716_482:YN,content_1716_483:KN,content_1716_484:$N,content_1716_485:nA,content_1716_486:oA,content_1716_487:cA,content_1716_488:sA,content_1716_489:iA,content_1716_490:uA,content_1716_491:dA,content_1716_492:yA,content_1716_493:fA,content_1716_494:MA,content_1716_495:XA,content_1716_496:TA,content_1716_497:xA,content_1716_498:gA,content_1716_499:bA,content_1716_500:NA,content_1716_501:SA,content_1716_502:PA,content_1716_503:EA,content_1716_504:WA,content_1716_505:UA,content_1716_506:OA,content_1716_507:qA,content_1716_508:BA,content_1716_509:YA,content_1716_510:KA,content_1716_511:$A,content_1716_512:nS,content_1716_513:oS,content_1716_514:cS,content_1716_515:sS,content_1716_516:iS,content_1716_517:uS,content_1716_518:dS}}}]);
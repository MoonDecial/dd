"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3239],{4415:(t,n,e)=>{e.r(n),e.d(n,{default:()=>d});var o=e(2784),p=e(2104),r=e(9072),c=e(6183),s=e(1836),a=e(8617),l=e(68),i=e(7708),u=e(532),m=e(7390);function d(t){var n,e,d;let{route:h}=t;const k=(0,a.RU)(h.projectId),y=k[h.reflectionId],[f]=(0,i.mN)(),M=(0,o.useMemo)((()=>{const t=[];if(!y.groups||y.kind===m.W.Project)return t;for(const n of y.groups)if(t.push({value:n.title,id:n.title,level:2}),n.children)for(const e of n.children){const n=k[e];n&&!n.hasOwnPage&&(0,i.It)(f,n)&&t.push({value:`<code>${n.name}</code>`,id:n.anchor,level:3})}return t}),[y,f]);return o.createElement(c.b,{content:{frontMatter:{},metadata:{id:y.docId,unversionedId:y.docId,version:"current",title:y.name,description:null==(n=y.comment)?void 0:n.summaryText,slug:y.url,permalink:y.url,editUrl:(null==(e=y.sources)||null==(d=e[0])?void 0:d.url)??void 0,draft:!1,tags:[],frontMatter:{},next:y.next,previous:y.previous},toc:M,assets:{}}},o.createElement(l.Y0,null,o.createElement(p.Z,null),o.createElement(u.Z,null,o.createElement(r.Z,null,o.createElement(s.Z,{reflection:y})))))}},9770:(t,n,e)=>{e.d(n,{Z:()=>t2});var o={};e.r(o),e.d(o,{content_0_0:()=>a,content_0_10:()=>M,content_0_100:()=>tn,content_0_102:()=>en,content_0_104:()=>pn,content_0_106:()=>cn,content_0_108:()=>an,content_0_110:()=>un,content_0_112:()=>dn,content_0_114:()=>kn,content_0_116:()=>fn,content_0_118:()=>Dn,content_0_12:()=>w,content_0_120:()=>_n,content_0_122:()=>gn,content_0_124:()=>Cn,content_0_126:()=>Ln,content_0_128:()=>vn,content_0_130:()=>Nn,content_0_132:()=>An,content_0_134:()=>Sn,content_0_136:()=>In,content_0_138:()=>Pn,content_0_14:()=>X,content_0_140:()=>Fn,content_0_142:()=>jn,content_0_144:()=>Bn,content_0_146:()=>On,content_0_148:()=>Hn,content_0_150:()=>Kn,content_0_152:()=>Qn,content_0_154:()=>ne,content_0_156:()=>oe,content_0_158:()=>re,content_0_16:()=>x,content_0_160:()=>se,content_0_162:()=>le,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>ke,content_0_170:()=>fe,content_0_172:()=>De,content_0_174:()=>_e,content_0_176:()=>ge,content_0_178:()=>Ce,content_0_18:()=>T,content_0_180:()=>Le,content_0_182:()=>ve,content_0_184:()=>Ne,content_0_186:()=>Ae,content_0_188:()=>Se,content_0_190:()=>Ie,content_0_192:()=>Pe,content_0_194:()=>Fe,content_0_196:()=>je,content_0_198:()=>Be,content_0_2:()=>i,content_0_20:()=>Z,content_0_200:()=>Oe,content_0_202:()=>He,content_0_204:()=>Ke,content_0_206:()=>Qe,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>so,content_0_216:()=>lo,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>Mo,content_0_226:()=>wo,content_0_228:()=>Xo,content_0_230:()=>xo,content_0_232:()=>To,content_0_234:()=>Zo,content_0_236:()=>bo,content_0_238:()=>Eo,content_0_24:()=>E,content_0_240:()=>Ro,content_0_242:()=>zo,content_0_244:()=>Wo,content_0_246:()=>Go,content_0_248:()=>Uo,content_0_250:()=>Vo,content_0_252:()=>qo,content_0_254:()=>$o,content_0_256:()=>Yo,content_0_258:()=>Jo,content_0_26:()=>R,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>cp,content_0_268:()=>ap,content_0_270:()=>ip,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>yp,content_0_278:()=>Mp,content_0_28:()=>z,content_0_280:()=>wp,content_0_282:()=>Xp,content_0_284:()=>xp,content_0_286:()=>Tp,content_0_288:()=>Zp,content_0_290:()=>bp,content_0_292:()=>Ep,content_0_294:()=>Rp,content_0_296:()=>zp,content_0_298:()=>Wp,content_0_30:()=>W,content_0_300:()=>Gp,content_0_302:()=>Up,content_0_304:()=>Vp,content_0_306:()=>qp,content_0_308:()=>$p,content_0_310:()=>Yp,content_0_312:()=>Jp,content_0_314:()=>tr,content_0_316:()=>er,content_0_318:()=>pr,content_0_32:()=>G,content_0_320:()=>cr,content_0_322:()=>ar,content_0_324:()=>ir,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>yr,content_0_332:()=>Mr,content_0_334:()=>wr,content_0_336:()=>Xr,content_0_338:()=>xr,content_0_34:()=>U,content_0_340:()=>Tr,content_0_342:()=>Zr,content_0_344:()=>br,content_0_346:()=>Er,content_0_348:()=>Rr,content_0_350:()=>zr,content_0_352:()=>Wr,content_0_354:()=>Gr,content_0_356:()=>Ur,content_0_358:()=>Vr,content_0_36:()=>V,content_0_360:()=>qr,content_0_362:()=>$r,content_0_364:()=>Yr,content_0_366:()=>Jr,content_0_368:()=>tc,content_0_370:()=>ec,content_0_372:()=>pc,content_0_374:()=>cc,content_0_376:()=>ac,content_0_378:()=>ic,content_0_38:()=>q,content_0_380:()=>mc,content_0_382:()=>hc,content_0_384:()=>yc,content_0_386:()=>Mc,content_0_388:()=>wc,content_0_390:()=>Xc,content_0_392:()=>xc,content_0_394:()=>Tc,content_0_396:()=>Zc,content_0_398:()=>bc,content_0_4:()=>m,content_0_40:()=>$,content_0_400:()=>Ec,content_0_402:()=>Rc,content_0_404:()=>zc,content_0_406:()=>Wc,content_0_408:()=>Gc,content_0_410:()=>Uc,content_0_412:()=>Vc,content_0_414:()=>qc,content_0_416:()=>$c,content_0_418:()=>Yc,content_0_42:()=>Y,content_0_420:()=>Jc,content_0_422:()=>ts,content_0_424:()=>es,content_0_426:()=>ps,content_0_428:()=>cs,content_0_430:()=>as,content_0_432:()=>is,content_0_434:()=>ms,content_0_436:()=>hs,content_0_438:()=>ys,content_0_44:()=>J,content_0_440:()=>Ms,content_0_442:()=>ws,content_0_444:()=>Xs,content_0_446:()=>xs,content_0_448:()=>Ts,content_0_450:()=>Zs,content_0_452:()=>bs,content_0_454:()=>Es,content_0_456:()=>Rs,content_0_458:()=>zs,content_0_46:()=>tt,content_0_460:()=>Ws,content_0_462:()=>Gs,content_0_464:()=>Us,content_0_466:()=>Vs,content_0_468:()=>qs,content_0_470:()=>$s,content_0_472:()=>Ys,content_0_474:()=>Js,content_0_476:()=>ta,content_0_478:()=>ea,content_0_48:()=>et,content_0_480:()=>pa,content_0_482:()=>ca,content_0_484:()=>aa,content_0_486:()=>ia,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>ya,content_0_494:()=>Ma,content_0_496:()=>wa,content_0_498:()=>Xa,content_0_50:()=>pt,content_0_500:()=>xa,content_0_502:()=>Ta,content_0_504:()=>Za,content_0_506:()=>ba,content_0_508:()=>Ea,content_0_510:()=>Ra,content_0_512:()=>za,content_0_514:()=>Wa,content_0_516:()=>Ga,content_0_518:()=>Ua,content_0_52:()=>ct,content_0_520:()=>Va,content_0_522:()=>qa,content_0_524:()=>$a,content_0_526:()=>Ya,content_0_528:()=>Ja,content_0_530:()=>tl,content_0_532:()=>el,content_0_534:()=>pl,content_0_536:()=>cl,content_0_538:()=>al,content_0_54:()=>at,content_0_540:()=>il,content_0_542:()=>ml,content_0_544:()=>hl,content_0_546:()=>yl,content_0_548:()=>Ml,content_0_550:()=>wl,content_0_552:()=>Xl,content_0_554:()=>xl,content_0_556:()=>Tl,content_0_558:()=>Zl,content_0_56:()=>it,content_0_560:()=>bl,content_0_562:()=>El,content_0_564:()=>Rl,content_0_566:()=>zl,content_0_568:()=>Wl,content_0_570:()=>Gl,content_0_572:()=>Ul,content_0_574:()=>Vl,content_0_576:()=>ql,content_0_578:()=>$l,content_0_58:()=>mt,content_0_580:()=>Yl,content_0_582:()=>Jl,content_0_584:()=>ti,content_0_586:()=>ei,content_0_588:()=>pi,content_0_590:()=>ci,content_0_592:()=>ai,content_0_594:()=>ii,content_0_596:()=>mi,content_0_598:()=>hi,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yi,content_0_602:()=>Mi,content_0_604:()=>wi,content_0_606:()=>Xi,content_0_608:()=>xi,content_0_610:()=>Ti,content_0_612:()=>Zi,content_0_614:()=>bi,content_0_616:()=>Ei,content_0_618:()=>Ri,content_0_62:()=>yt,content_0_620:()=>zi,content_0_622:()=>Wi,content_0_624:()=>Gi,content_0_626:()=>Ui,content_0_628:()=>Vi,content_0_630:()=>qi,content_0_632:()=>$i,content_0_634:()=>Yi,content_0_636:()=>Ji,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>cu,content_0_646:()=>au,content_0_648:()=>iu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>Mu,content_0_658:()=>wu,content_0_66:()=>wt,content_0_660:()=>Xu,content_0_662:()=>xu,content_0_664:()=>Tu,content_0_666:()=>Zu,content_0_668:()=>bu,content_0_670:()=>Eu,content_0_672:()=>Ru,content_0_674:()=>zu,content_0_676:()=>Wu,content_0_678:()=>Gu,content_0_68:()=>Xt,content_0_680:()=>Uu,content_0_682:()=>Vu,content_0_684:()=>qu,content_0_686:()=>$u,content_0_688:()=>Yu,content_0_690:()=>Ju,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>cm,content_0_70:()=>xt,content_0_700:()=>am,content_0_702:()=>im,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>Mm,content_0_712:()=>wm,content_0_714:()=>Xm,content_0_716:()=>xm,content_0_718:()=>Tm,content_0_72:()=>Tt,content_0_720:()=>Zm,content_0_722:()=>bm,content_0_724:()=>Em,content_0_726:()=>Rm,content_0_728:()=>zm,content_0_730:()=>Wm,content_0_732:()=>Gm,content_0_734:()=>Um,content_0_736:()=>Vm,content_0_738:()=>qm,content_0_74:()=>Zt,content_0_740:()=>$m,content_0_742:()=>Ym,content_0_744:()=>Jm,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>cd,content_0_754:()=>ad,content_0_756:()=>id,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>Md,content_0_766:()=>wd,content_0_768:()=>Xd,content_0_770:()=>xd,content_0_772:()=>Td,content_0_774:()=>Zd,content_0_776:()=>bd,content_0_778:()=>Ed,content_0_78:()=>Et,content_0_780:()=>Rd,content_0_782:()=>zd,content_0_784:()=>Wd,content_0_786:()=>Gd,content_0_788:()=>Ud,content_0_790:()=>Vd,content_0_792:()=>qd,content_0_794:()=>$d,content_0_796:()=>Yd,content_0_798:()=>Jd,content_0_8:()=>y,content_0_80:()=>Rt,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>ch,content_0_808:()=>ah,content_0_810:()=>ih,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>Mh,content_0_82:()=>zt,content_0_820:()=>wh,content_0_822:()=>Xh,content_0_824:()=>xh,content_0_826:()=>Th,content_0_828:()=>Zh,content_0_830:()=>bh,content_0_832:()=>Eh,content_0_834:()=>Rh,content_0_836:()=>zh,content_0_838:()=>Wh,content_0_84:()=>Wt,content_0_840:()=>Gh,content_0_842:()=>Uh,content_0_844:()=>Vh,content_0_846:()=>qh,content_0_848:()=>$h,content_0_850:()=>Yh,content_0_852:()=>Jh,content_0_854:()=>tk,content_0_856:()=>ek,content_0_858:()=>pk,content_0_86:()=>Gt,content_0_860:()=>ck,content_0_862:()=>ak,content_0_864:()=>ik,content_0_866:()=>mk,content_0_868:()=>hk,content_0_870:()=>yk,content_0_872:()=>Mk,content_0_874:()=>wk,content_0_876:()=>Xk,content_0_878:()=>xk,content_0_88:()=>Ut,content_0_880:()=>Tk,content_0_882:()=>Zk,content_0_884:()=>bk,content_0_886:()=>Ek,content_0_888:()=>Rk,content_0_890:()=>zk,content_0_892:()=>Wk,content_0_894:()=>Gk,content_0_896:()=>Uk,content_0_898:()=>Vk,content_0_90:()=>Vt,content_0_900:()=>qk,content_0_902:()=>$k,content_0_904:()=>Yk,content_0_906:()=>Jk,content_0_908:()=>ty,content_0_910:()=>ey,content_0_912:()=>py,content_0_914:()=>cy,content_0_916:()=>ay,content_0_918:()=>iy,content_0_92:()=>qt,content_0_920:()=>my,content_0_922:()=>hy,content_0_924:()=>yy,content_0_94:()=>$t,content_0_96:()=>Yt,content_0_98:()=>Jt,content_2133_0:()=>My,content_2133_10:()=>Zy,content_2133_100:()=>uM,content_2133_1000:()=>OR,content_2133_1002:()=>HR,content_2133_1004:()=>KR,content_2133_1006:()=>QR,content_2133_1008:()=>nS,content_2133_1010:()=>oS,content_2133_1012:()=>rS,content_2133_1014:()=>sS,content_2133_1016:()=>lS,content_2133_1018:()=>uS,content_2133_102:()=>dM,content_2133_1020:()=>dS,content_2133_1022:()=>kS,content_2133_1024:()=>fS,content_2133_1026:()=>DS,content_2133_1028:()=>_S,content_2133_1030:()=>gS,content_2133_1032:()=>CS,content_2133_1034:()=>LS,content_2133_1036:()=>vS,content_2133_1038:()=>NS,content_2133_104:()=>kM,content_2133_1040:()=>AS,content_2133_1042:()=>SS,content_2133_1044:()=>IS,content_2133_1046:()=>PS,content_2133_1048:()=>FS,content_2133_1050:()=>jS,content_2133_1052:()=>BS,content_2133_1054:()=>OS,content_2133_1056:()=>HS,content_2133_1058:()=>KS,content_2133_106:()=>fM,content_2133_1060:()=>QS,content_2133_1062:()=>nz,content_2133_1064:()=>oz,content_2133_1066:()=>rz,content_2133_1068:()=>sz,content_2133_1070:()=>lz,content_2133_1072:()=>uz,content_2133_1074:()=>dz,content_2133_1076:()=>kz,content_2133_1078:()=>fz,content_2133_108:()=>DM,content_2133_1080:()=>Dz,content_2133_1082:()=>_z,content_2133_1084:()=>gz,content_2133_1086:()=>Cz,content_2133_1088:()=>Lz,content_2133_1090:()=>vz,content_2133_1092:()=>Nz,content_2133_1094:()=>Az,content_2133_1096:()=>Sz,content_2133_1098:()=>Iz,content_2133_110:()=>_M,content_2133_1100:()=>Pz,content_2133_1102:()=>Fz,content_2133_1104:()=>jz,content_2133_1106:()=>Bz,content_2133_1108:()=>Oz,content_2133_1110:()=>Hz,content_2133_1112:()=>Kz,content_2133_1114:()=>Qz,content_2133_1116:()=>nI,content_2133_1118:()=>oI,content_2133_112:()=>gM,content_2133_1120:()=>rI,content_2133_1122:()=>sI,content_2133_1124:()=>lI,content_2133_1126:()=>uI,content_2133_1128:()=>dI,content_2133_1130:()=>kI,content_2133_1132:()=>fI,content_2133_1134:()=>DI,content_2133_1136:()=>_I,content_2133_1138:()=>gI,content_2133_114:()=>CM,content_2133_1140:()=>CI,content_2133_1142:()=>LI,content_2133_1144:()=>vI,content_2133_1146:()=>NI,content_2133_1148:()=>AI,content_2133_1150:()=>SI,content_2133_1152:()=>II,content_2133_1154:()=>PI,content_2133_1156:()=>FI,content_2133_1158:()=>jI,content_2133_116:()=>LM,content_2133_1160:()=>BI,content_2133_1162:()=>OI,content_2133_1164:()=>HI,content_2133_1166:()=>KI,content_2133_1168:()=>QI,content_2133_1170:()=>nW,content_2133_1172:()=>oW,content_2133_1174:()=>rW,content_2133_1176:()=>sW,content_2133_1178:()=>lW,content_2133_118:()=>vM,content_2133_1180:()=>uW,content_2133_1182:()=>dW,content_2133_1184:()=>kW,content_2133_1186:()=>fW,content_2133_1188:()=>DW,content_2133_1190:()=>_W,content_2133_1192:()=>gW,content_2133_1194:()=>CW,content_2133_1196:()=>LW,content_2133_1198:()=>vW,content_2133_12:()=>by,content_2133_120:()=>NM,content_2133_1200:()=>NW,content_2133_1202:()=>AW,content_2133_1204:()=>SW,content_2133_1206:()=>IW,content_2133_1208:()=>PW,content_2133_1210:()=>FW,content_2133_1212:()=>jW,content_2133_1214:()=>BW,content_2133_1216:()=>OW,content_2133_1218:()=>HW,content_2133_122:()=>AM,content_2133_1220:()=>KW,content_2133_1222:()=>QW,content_2133_1224:()=>nP,content_2133_1226:()=>oP,content_2133_1228:()=>rP,content_2133_1230:()=>sP,content_2133_1232:()=>lP,content_2133_1234:()=>uP,content_2133_1236:()=>dP,content_2133_1238:()=>kP,content_2133_124:()=>SM,content_2133_1240:()=>fP,content_2133_1242:()=>DP,content_2133_1244:()=>_P,content_2133_1246:()=>gP,content_2133_1248:()=>CP,content_2133_1250:()=>LP,content_2133_1252:()=>vP,content_2133_1254:()=>NP,content_2133_1256:()=>AP,content_2133_1258:()=>SP,content_2133_126:()=>IM,content_2133_1260:()=>IP,content_2133_1262:()=>PP,content_2133_1264:()=>FP,content_2133_1266:()=>jP,content_2133_1268:()=>BP,content_2133_1270:()=>OP,content_2133_1272:()=>HP,content_2133_1274:()=>KP,content_2133_1276:()=>QP,content_2133_1278:()=>nG,content_2133_128:()=>PM,content_2133_1280:()=>oG,content_2133_1282:()=>rG,content_2133_1284:()=>sG,content_2133_1286:()=>lG,content_2133_1288:()=>uG,content_2133_1290:()=>dG,content_2133_1292:()=>kG,content_2133_1294:()=>fG,content_2133_1296:()=>DG,content_2133_1298:()=>_G,content_2133_130:()=>FM,content_2133_1300:()=>gG,content_2133_1302:()=>CG,content_2133_1304:()=>LG,content_2133_1306:()=>vG,content_2133_1308:()=>NG,content_2133_1310:()=>AG,content_2133_1312:()=>SG,content_2133_1314:()=>IG,content_2133_1316:()=>PG,content_2133_1318:()=>FG,content_2133_132:()=>jM,content_2133_1320:()=>jG,content_2133_1322:()=>BG,content_2133_1324:()=>OG,content_2133_1326:()=>HG,content_2133_1328:()=>KG,content_2133_1330:()=>QG,content_2133_1332:()=>nF,content_2133_1334:()=>oF,content_2133_1336:()=>rF,content_2133_1338:()=>sF,content_2133_134:()=>BM,content_2133_1340:()=>lF,content_2133_1342:()=>uF,content_2133_1344:()=>dF,content_2133_1346:()=>kF,content_2133_1348:()=>fF,content_2133_1350:()=>DF,content_2133_1352:()=>_F,content_2133_1354:()=>gF,content_2133_1356:()=>CF,content_2133_1358:()=>LF,content_2133_136:()=>OM,content_2133_1360:()=>vF,content_2133_1362:()=>NF,content_2133_1364:()=>AF,content_2133_1366:()=>SF,content_2133_1368:()=>IF,content_2133_1370:()=>PF,content_2133_1372:()=>FF,content_2133_1374:()=>jF,content_2133_1376:()=>BF,content_2133_1378:()=>OF,content_2133_138:()=>HM,content_2133_1380:()=>HF,content_2133_1382:()=>KF,content_2133_1384:()=>QF,content_2133_1386:()=>nU,content_2133_1388:()=>oU,content_2133_1390:()=>rU,content_2133_1392:()=>sU,content_2133_1394:()=>lU,content_2133_1396:()=>uU,content_2133_1398:()=>dU,content_2133_14:()=>Ey,content_2133_140:()=>KM,content_2133_1400:()=>kU,content_2133_1402:()=>fU,content_2133_1404:()=>DU,content_2133_1406:()=>_U,content_2133_1408:()=>gU,content_2133_1410:()=>CU,content_2133_1412:()=>LU,content_2133_1414:()=>vU,content_2133_1416:()=>NU,content_2133_1418:()=>AU,content_2133_142:()=>QM,content_2133_1420:()=>SU,content_2133_1422:()=>IU,content_2133_1424:()=>PU,content_2133_1426:()=>FU,content_2133_1428:()=>jU,content_2133_1430:()=>BU,content_2133_1432:()=>OU,content_2133_1434:()=>HU,content_2133_1436:()=>KU,content_2133_1438:()=>QU,content_2133_144:()=>nD,content_2133_1440:()=>nj,content_2133_1442:()=>oj,content_2133_1444:()=>rj,content_2133_1446:()=>sj,content_2133_1448:()=>lj,content_2133_1450:()=>uj,content_2133_1452:()=>dj,content_2133_1454:()=>kj,content_2133_1456:()=>fj,content_2133_1458:()=>Dj,content_2133_146:()=>oD,content_2133_1460:()=>_j,content_2133_1462:()=>gj,content_2133_1464:()=>Cj,content_2133_1466:()=>Lj,content_2133_1468:()=>vj,content_2133_1470:()=>Nj,content_2133_1472:()=>Aj,content_2133_1474:()=>Sj,content_2133_1476:()=>Ij,content_2133_1478:()=>Pj,content_2133_148:()=>rD,content_2133_1480:()=>Fj,content_2133_1482:()=>jj,content_2133_1484:()=>Bj,content_2133_1486:()=>Oj,content_2133_1488:()=>Hj,content_2133_1490:()=>Kj,content_2133_1492:()=>Qj,content_2133_1494:()=>nV,content_2133_1496:()=>oV,content_2133_1498:()=>rV,content_2133_150:()=>sD,content_2133_1500:()=>sV,content_2133_1502:()=>lV,content_2133_1504:()=>uV,content_2133_1506:()=>dV,content_2133_1508:()=>kV,content_2133_1510:()=>fV,content_2133_1512:()=>DV,content_2133_1514:()=>_V,content_2133_1516:()=>gV,content_2133_1518:()=>CV,content_2133_152:()=>lD,content_2133_1520:()=>LV,content_2133_1522:()=>vV,content_2133_1524:()=>NV,content_2133_1526:()=>AV,content_2133_1528:()=>SV,content_2133_1530:()=>IV,content_2133_1532:()=>PV,content_2133_1534:()=>FV,content_2133_1536:()=>jV,content_2133_1538:()=>BV,content_2133_154:()=>uD,content_2133_1540:()=>OV,content_2133_1542:()=>HV,content_2133_1544:()=>KV,content_2133_1546:()=>QV,content_2133_1548:()=>nB,content_2133_1550:()=>oB,content_2133_1552:()=>rB,content_2133_1554:()=>sB,content_2133_1556:()=>lB,content_2133_1558:()=>uB,content_2133_156:()=>dD,content_2133_1560:()=>dB,content_2133_1562:()=>kB,content_2133_1564:()=>fB,content_2133_1566:()=>DB,content_2133_1568:()=>_B,content_2133_1570:()=>gB,content_2133_1572:()=>CB,content_2133_1574:()=>LB,content_2133_1576:()=>vB,content_2133_1578:()=>NB,content_2133_158:()=>kD,content_2133_1580:()=>AB,content_2133_1582:()=>SB,content_2133_1584:()=>IB,content_2133_1586:()=>PB,content_2133_1588:()=>FB,content_2133_1590:()=>jB,content_2133_1592:()=>BB,content_2133_1594:()=>OB,content_2133_1596:()=>HB,content_2133_1598:()=>KB,content_2133_16:()=>Ry,content_2133_160:()=>fD,content_2133_1600:()=>QB,content_2133_1602:()=>nq,content_2133_1604:()=>oq,content_2133_1606:()=>rq,content_2133_1608:()=>sq,content_2133_1610:()=>lq,content_2133_1612:()=>uq,content_2133_1614:()=>dq,content_2133_1616:()=>kq,content_2133_1618:()=>fq,content_2133_162:()=>DD,content_2133_1620:()=>Dq,content_2133_1622:()=>_q,content_2133_1624:()=>gq,content_2133_1626:()=>Cq,content_2133_1628:()=>Lq,content_2133_1630:()=>vq,content_2133_1632:()=>Nq,content_2133_1634:()=>Aq,content_2133_1636:()=>Sq,content_2133_1638:()=>Iq,content_2133_164:()=>_D,content_2133_1640:()=>Pq,content_2133_1642:()=>Fq,content_2133_1644:()=>jq,content_2133_1646:()=>Bq,content_2133_1648:()=>Oq,content_2133_1650:()=>Hq,content_2133_1652:()=>Kq,content_2133_1654:()=>Qq,content_2133_1656:()=>nO,content_2133_1658:()=>oO,content_2133_166:()=>gD,content_2133_1660:()=>rO,content_2133_1662:()=>sO,content_2133_1664:()=>lO,content_2133_1666:()=>uO,content_2133_1668:()=>dO,content_2133_1670:()=>kO,content_2133_1672:()=>fO,content_2133_1674:()=>DO,content_2133_1676:()=>_O,content_2133_1678:()=>gO,content_2133_168:()=>CD,content_2133_1680:()=>CO,content_2133_1682:()=>LO,content_2133_1684:()=>vO,content_2133_1686:()=>NO,content_2133_1688:()=>AO,content_2133_1690:()=>SO,content_2133_1692:()=>IO,content_2133_1694:()=>PO,content_2133_1696:()=>FO,content_2133_1698:()=>jO,content_2133_170:()=>LD,content_2133_1700:()=>BO,content_2133_1702:()=>OO,content_2133_1704:()=>HO,content_2133_1706:()=>KO,content_2133_1708:()=>QO,content_2133_1710:()=>n$,content_2133_1712:()=>o$,content_2133_1714:()=>r$,content_2133_1716:()=>s$,content_2133_1718:()=>l$,content_2133_172:()=>vD,content_2133_1720:()=>u$,content_2133_1722:()=>d$,content_2133_1724:()=>k$,content_2133_1726:()=>f$,content_2133_1728:()=>D$,content_2133_1730:()=>_$,content_2133_1732:()=>g$,content_2133_1734:()=>C$,content_2133_1736:()=>L$,content_2133_1738:()=>v$,content_2133_174:()=>ND,content_2133_1740:()=>N$,content_2133_1742:()=>A$,content_2133_1744:()=>S$,content_2133_1746:()=>I$,content_2133_1748:()=>P$,content_2133_1750:()=>F$,content_2133_1752:()=>j$,content_2133_1754:()=>B$,content_2133_1756:()=>O$,content_2133_1758:()=>H$,content_2133_176:()=>AD,content_2133_1760:()=>K$,content_2133_1762:()=>Q$,content_2133_1764:()=>nH,content_2133_1766:()=>oH,content_2133_1768:()=>rH,content_2133_1770:()=>sH,content_2133_1772:()=>lH,content_2133_1774:()=>uH,content_2133_1776:()=>dH,content_2133_1778:()=>kH,content_2133_178:()=>SD,content_2133_1780:()=>fH,content_2133_1782:()=>DH,content_2133_1784:()=>_H,content_2133_1786:()=>gH,content_2133_1788:()=>CH,content_2133_1790:()=>LH,content_2133_1792:()=>vH,content_2133_1794:()=>NH,content_2133_1796:()=>AH,content_2133_1798:()=>SH,content_2133_18:()=>zy,content_2133_180:()=>ID,content_2133_1800:()=>IH,content_2133_1802:()=>PH,content_2133_1804:()=>FH,content_2133_1806:()=>jH,content_2133_1808:()=>BH,content_2133_1810:()=>OH,content_2133_1812:()=>HH,content_2133_1814:()=>KH,content_2133_1816:()=>QH,content_2133_1818:()=>nY,content_2133_182:()=>PD,content_2133_1820:()=>oY,content_2133_1822:()=>rY,content_2133_1824:()=>sY,content_2133_1826:()=>lY,content_2133_1828:()=>uY,content_2133_1830:()=>dY,content_2133_1832:()=>kY,content_2133_1834:()=>fY,content_2133_1836:()=>DY,content_2133_1838:()=>_Y,content_2133_184:()=>FD,content_2133_1840:()=>gY,content_2133_1842:()=>CY,content_2133_1844:()=>LY,content_2133_1846:()=>vY,content_2133_1848:()=>NY,content_2133_1850:()=>AY,content_2133_1852:()=>SY,content_2133_1854:()=>IY,content_2133_1856:()=>PY,content_2133_1858:()=>FY,content_2133_186:()=>jD,content_2133_1860:()=>jY,content_2133_1862:()=>BY,content_2133_1864:()=>OY,content_2133_1866:()=>HY,content_2133_1868:()=>KY,content_2133_1870:()=>QY,content_2133_1872:()=>nK,content_2133_1874:()=>oK,content_2133_1876:()=>rK,content_2133_1878:()=>sK,content_2133_188:()=>BD,content_2133_1880:()=>lK,content_2133_1882:()=>uK,content_2133_1884:()=>dK,content_2133_1886:()=>kK,content_2133_1888:()=>fK,content_2133_1890:()=>DK,content_2133_1892:()=>_K,content_2133_1894:()=>gK,content_2133_1896:()=>CK,content_2133_1898:()=>LK,content_2133_190:()=>OD,content_2133_1900:()=>vK,content_2133_1902:()=>NK,content_2133_1904:()=>AK,content_2133_1906:()=>SK,content_2133_1908:()=>IK,content_2133_1910:()=>PK,content_2133_1912:()=>FK,content_2133_1914:()=>jK,content_2133_1916:()=>BK,content_2133_1918:()=>OK,content_2133_192:()=>HD,content_2133_1920:()=>HK,content_2133_1922:()=>KK,content_2133_1924:()=>QK,content_2133_1926:()=>nJ,content_2133_1928:()=>oJ,content_2133_1930:()=>rJ,content_2133_1932:()=>sJ,content_2133_1934:()=>lJ,content_2133_1936:()=>uJ,content_2133_1938:()=>dJ,content_2133_194:()=>KD,content_2133_1940:()=>kJ,content_2133_1942:()=>fJ,content_2133_1944:()=>DJ,content_2133_1946:()=>_J,content_2133_1948:()=>gJ,content_2133_1950:()=>CJ,content_2133_1952:()=>LJ,content_2133_1954:()=>vJ,content_2133_1956:()=>NJ,content_2133_1958:()=>AJ,content_2133_196:()=>QD,content_2133_1960:()=>SJ,content_2133_1962:()=>IJ,content_2133_1964:()=>PJ,content_2133_1966:()=>FJ,content_2133_1968:()=>jJ,content_2133_1970:()=>BJ,content_2133_1972:()=>OJ,content_2133_1974:()=>HJ,content_2133_1976:()=>KJ,content_2133_1978:()=>QJ,content_2133_198:()=>nw,content_2133_1980:()=>nQ,content_2133_1982:()=>oQ,content_2133_1984:()=>rQ,content_2133_1986:()=>sQ,content_2133_1988:()=>lQ,content_2133_1990:()=>uQ,content_2133_1992:()=>dQ,content_2133_1994:()=>kQ,content_2133_1996:()=>fQ,content_2133_1998:()=>DQ,content_2133_2:()=>wy,content_2133_20:()=>Wy,content_2133_200:()=>ow,content_2133_2000:()=>_Q,content_2133_2002:()=>gQ,content_2133_2004:()=>CQ,content_2133_2006:()=>LQ,content_2133_2008:()=>vQ,content_2133_2010:()=>NQ,content_2133_2012:()=>AQ,content_2133_2014:()=>SQ,content_2133_2016:()=>IQ,content_2133_2018:()=>PQ,content_2133_202:()=>rw,content_2133_2020:()=>FQ,content_2133_2022:()=>jQ,content_2133_2024:()=>BQ,content_2133_2026:()=>OQ,content_2133_2028:()=>HQ,content_2133_2030:()=>KQ,content_2133_2032:()=>QQ,content_2133_2034:()=>n0,content_2133_2036:()=>o0,content_2133_2038:()=>r0,content_2133_204:()=>sw,content_2133_2040:()=>s0,content_2133_2042:()=>l0,content_2133_2044:()=>u0,content_2133_2046:()=>d0,content_2133_2048:()=>k0,content_2133_2050:()=>f0,content_2133_2052:()=>D0,content_2133_2054:()=>_0,content_2133_2056:()=>g0,content_2133_2058:()=>C0,content_2133_206:()=>lw,content_2133_2060:()=>L0,content_2133_2062:()=>v0,content_2133_2064:()=>N0,content_2133_2066:()=>A0,content_2133_2068:()=>S0,content_2133_2070:()=>I0,content_2133_2072:()=>P0,content_2133_2074:()=>F0,content_2133_2076:()=>j0,content_2133_2078:()=>B0,content_2133_208:()=>uw,content_2133_2080:()=>O0,content_2133_2082:()=>H0,content_2133_2084:()=>K0,content_2133_2086:()=>Q0,content_2133_2088:()=>n3,content_2133_2090:()=>o3,content_2133_2092:()=>r3,content_2133_2094:()=>s3,content_2133_2096:()=>l3,content_2133_2098:()=>u3,content_2133_210:()=>dw,content_2133_2100:()=>d3,content_2133_2102:()=>k3,content_2133_2104:()=>f3,content_2133_2106:()=>D3,content_2133_2108:()=>_3,content_2133_2110:()=>g3,content_2133_2112:()=>C3,content_2133_2114:()=>L3,content_2133_2116:()=>v3,content_2133_2118:()=>N3,content_2133_212:()=>kw,content_2133_2120:()=>A3,content_2133_2122:()=>S3,content_2133_2124:()=>I3,content_2133_2126:()=>P3,content_2133_2128:()=>F3,content_2133_2130:()=>j3,content_2133_2132:()=>B3,content_2133_2134:()=>O3,content_2133_2136:()=>H3,content_2133_2138:()=>K3,content_2133_214:()=>fw,content_2133_2140:()=>Q3,content_2133_2142:()=>n1,content_2133_2144:()=>o1,content_2133_2146:()=>r1,content_2133_2148:()=>s1,content_2133_2150:()=>l1,content_2133_2152:()=>u1,content_2133_2154:()=>d1,content_2133_2156:()=>k1,content_2133_2158:()=>f1,content_2133_216:()=>Dw,content_2133_2160:()=>D1,content_2133_2162:()=>_1,content_2133_2164:()=>g1,content_2133_2166:()=>C1,content_2133_2168:()=>L1,content_2133_2170:()=>v1,content_2133_2172:()=>N1,content_2133_2174:()=>A1,content_2133_2176:()=>S1,content_2133_2178:()=>I1,content_2133_218:()=>_w,content_2133_2180:()=>P1,content_2133_2182:()=>F1,content_2133_2184:()=>j1,content_2133_2186:()=>B1,content_2133_2188:()=>O1,content_2133_2190:()=>H1,content_2133_2192:()=>K1,content_2133_2194:()=>Q1,content_2133_22:()=>Gy,content_2133_220:()=>gw,content_2133_222:()=>Cw,content_2133_224:()=>Lw,content_2133_226:()=>vw,content_2133_228:()=>Nw,content_2133_230:()=>Aw,content_2133_232:()=>Sw,content_2133_234:()=>Iw,content_2133_236:()=>Pw,content_2133_238:()=>Fw,content_2133_24:()=>Uy,content_2133_240:()=>jw,content_2133_242:()=>Bw,content_2133_244:()=>Ow,content_2133_246:()=>Hw,content_2133_248:()=>Kw,content_2133_250:()=>Qw,content_2133_252:()=>n_,content_2133_254:()=>o_,content_2133_256:()=>r_,content_2133_258:()=>s_,content_2133_26:()=>Vy,content_2133_260:()=>l_,content_2133_262:()=>u_,content_2133_264:()=>d_,content_2133_266:()=>k_,content_2133_268:()=>f_,content_2133_270:()=>D_,content_2133_272:()=>__,content_2133_274:()=>g_,content_2133_276:()=>C_,content_2133_278:()=>L_,content_2133_28:()=>qy,content_2133_280:()=>v_,content_2133_282:()=>N_,content_2133_284:()=>A_,content_2133_286:()=>S_,content_2133_288:()=>I_,content_2133_290:()=>P_,content_2133_292:()=>F_,content_2133_294:()=>j_,content_2133_296:()=>B_,content_2133_298:()=>O_,content_2133_30:()=>$y,content_2133_300:()=>H_,content_2133_302:()=>K_,content_2133_304:()=>Q_,content_2133_306:()=>nX,content_2133_308:()=>oX,content_2133_310:()=>rX,content_2133_312:()=>sX,content_2133_314:()=>lX,content_2133_316:()=>uX,content_2133_318:()=>dX,content_2133_32:()=>Yy,content_2133_320:()=>kX,content_2133_322:()=>fX,content_2133_324:()=>DX,content_2133_326:()=>_X,content_2133_328:()=>gX,content_2133_330:()=>CX,content_2133_332:()=>LX,content_2133_334:()=>vX,content_2133_336:()=>NX,content_2133_338:()=>AX,content_2133_34:()=>Jy,content_2133_340:()=>SX,content_2133_342:()=>IX,content_2133_344:()=>PX,content_2133_346:()=>FX,content_2133_348:()=>jX,content_2133_350:()=>BX,content_2133_352:()=>OX,content_2133_354:()=>HX,content_2133_356:()=>KX,content_2133_358:()=>QX,content_2133_36:()=>tf,content_2133_360:()=>ng,content_2133_362:()=>og,content_2133_364:()=>rg,content_2133_366:()=>sg,content_2133_368:()=>lg,content_2133_370:()=>ug,content_2133_372:()=>dg,content_2133_374:()=>kg,content_2133_376:()=>fg,content_2133_378:()=>Dg,content_2133_38:()=>ef,content_2133_380:()=>_g,content_2133_382:()=>gg,content_2133_384:()=>Cg,content_2133_386:()=>Lg,content_2133_388:()=>vg,content_2133_390:()=>Ng,content_2133_392:()=>Ag,content_2133_394:()=>Sg,content_2133_396:()=>Ig,content_2133_398:()=>Pg,content_2133_4:()=>Xy,content_2133_40:()=>pf,content_2133_400:()=>Fg,content_2133_402:()=>jg,content_2133_404:()=>Bg,content_2133_406:()=>Og,content_2133_408:()=>Hg,content_2133_410:()=>Kg,content_2133_412:()=>Qg,content_2133_414:()=>nx,content_2133_416:()=>ox,content_2133_418:()=>rx,content_2133_42:()=>cf,content_2133_420:()=>sx,content_2133_422:()=>lx,content_2133_424:()=>ux,content_2133_426:()=>dx,content_2133_428:()=>kx,content_2133_430:()=>fx,content_2133_432:()=>Dx,content_2133_434:()=>_x,content_2133_436:()=>gx,content_2133_438:()=>Cx,content_2133_44:()=>af,content_2133_440:()=>Lx,content_2133_442:()=>vx,content_2133_444:()=>Nx,content_2133_446:()=>Ax,content_2133_448:()=>Sx,content_2133_450:()=>Ix,content_2133_452:()=>Px,content_2133_454:()=>Fx,content_2133_456:()=>jx,content_2133_458:()=>Bx,content_2133_46:()=>uf,content_2133_460:()=>Ox,content_2133_462:()=>Hx,content_2133_464:()=>Kx,content_2133_466:()=>Qx,content_2133_468:()=>nC,content_2133_470:()=>oC,content_2133_472:()=>rC,content_2133_474:()=>sC,content_2133_476:()=>lC,content_2133_478:()=>uC,content_2133_48:()=>df,content_2133_480:()=>dC,content_2133_482:()=>kC,content_2133_484:()=>fC,content_2133_486:()=>DC,content_2133_488:()=>_C,content_2133_490:()=>gC,content_2133_492:()=>CC,content_2133_494:()=>LC,content_2133_496:()=>vC,content_2133_498:()=>NC,content_2133_50:()=>kf,content_2133_500:()=>AC,content_2133_502:()=>SC,content_2133_504:()=>IC,content_2133_506:()=>PC,content_2133_508:()=>FC,content_2133_510:()=>jC,content_2133_512:()=>BC,content_2133_514:()=>OC,content_2133_516:()=>HC,content_2133_518:()=>KC,content_2133_52:()=>ff,content_2133_520:()=>QC,content_2133_522:()=>nT,content_2133_524:()=>oT,content_2133_526:()=>rT,content_2133_528:()=>sT,content_2133_530:()=>lT,content_2133_532:()=>uT,content_2133_534:()=>dT,content_2133_536:()=>kT,content_2133_538:()=>fT,content_2133_54:()=>Df,content_2133_540:()=>DT,content_2133_542:()=>_T,content_2133_544:()=>gT,content_2133_546:()=>CT,content_2133_548:()=>LT,content_2133_550:()=>vT,content_2133_552:()=>NT,content_2133_554:()=>AT,content_2133_556:()=>ST,content_2133_558:()=>IT,content_2133_56:()=>_f,content_2133_560:()=>PT,content_2133_562:()=>FT,content_2133_564:()=>jT,content_2133_566:()=>BT,content_2133_568:()=>OT,content_2133_570:()=>HT,content_2133_572:()=>KT,content_2133_574:()=>QT,content_2133_576:()=>nL,content_2133_578:()=>oL,content_2133_58:()=>gf,content_2133_580:()=>rL,content_2133_582:()=>sL,content_2133_584:()=>lL,content_2133_586:()=>uL,content_2133_588:()=>dL,content_2133_590:()=>kL,content_2133_592:()=>fL,content_2133_594:()=>DL,content_2133_596:()=>_L,content_2133_598:()=>gL,content_2133_6:()=>xy,content_2133_60:()=>Cf,content_2133_600:()=>CL,content_2133_602:()=>LL,content_2133_604:()=>vL,content_2133_606:()=>NL,content_2133_608:()=>AL,content_2133_610:()=>SL,content_2133_612:()=>IL,content_2133_614:()=>PL,content_2133_616:()=>FL,content_2133_618:()=>jL,content_2133_62:()=>Lf,content_2133_620:()=>BL,content_2133_622:()=>OL,content_2133_624:()=>HL,content_2133_626:()=>KL,content_2133_628:()=>QL,content_2133_630:()=>nZ,content_2133_632:()=>oZ,content_2133_634:()=>rZ,content_2133_636:()=>sZ,content_2133_638:()=>lZ,content_2133_64:()=>vf,content_2133_640:()=>uZ,content_2133_642:()=>dZ,content_2133_644:()=>kZ,content_2133_646:()=>fZ,content_2133_648:()=>DZ,content_2133_650:()=>_Z,content_2133_652:()=>gZ,content_2133_654:()=>CZ,content_2133_656:()=>LZ,content_2133_658:()=>vZ,content_2133_66:()=>Nf,content_2133_660:()=>NZ,content_2133_662:()=>AZ,content_2133_664:()=>SZ,content_2133_666:()=>IZ,content_2133_668:()=>PZ,content_2133_670:()=>FZ,content_2133_672:()=>jZ,content_2133_674:()=>BZ,content_2133_676:()=>OZ,content_2133_678:()=>HZ,content_2133_68:()=>Af,content_2133_680:()=>KZ,content_2133_682:()=>QZ,content_2133_684:()=>nv,content_2133_686:()=>ov,content_2133_688:()=>rv,content_2133_690:()=>sv,content_2133_692:()=>lv,content_2133_694:()=>uv,content_2133_696:()=>dv,content_2133_698:()=>kv,content_2133_70:()=>Sf,content_2133_700:()=>fv,content_2133_702:()=>Dv,content_2133_704:()=>_v,content_2133_706:()=>gv,content_2133_708:()=>Cv,content_2133_710:()=>Lv,content_2133_712:()=>vv,content_2133_714:()=>Nv,content_2133_716:()=>Av,content_2133_718:()=>Sv,content_2133_72:()=>If,content_2133_720:()=>Iv,content_2133_722:()=>Pv,content_2133_724:()=>Fv,content_2133_726:()=>jv,content_2133_728:()=>Bv,content_2133_730:()=>Ov,content_2133_732:()=>Hv,content_2133_734:()=>Kv,content_2133_736:()=>Qv,content_2133_738:()=>nb,content_2133_74:()=>Pf,content_2133_740:()=>ob,content_2133_742:()=>rb,content_2133_744:()=>sb,content_2133_746:()=>lb,content_2133_748:()=>ub,content_2133_750:()=>db,content_2133_752:()=>kb,content_2133_754:()=>fb,content_2133_756:()=>Db,content_2133_758:()=>_b,content_2133_76:()=>Ff,content_2133_760:()=>gb,content_2133_762:()=>Cb,content_2133_764:()=>Lb,content_2133_766:()=>vb,content_2133_768:()=>Nb,content_2133_770:()=>Ab,content_2133_772:()=>Sb,content_2133_774:()=>Ib,content_2133_776:()=>Pb,content_2133_778:()=>Fb,content_2133_78:()=>jf,content_2133_780:()=>jb,content_2133_782:()=>Bb,content_2133_784:()=>Ob,content_2133_786:()=>Hb,content_2133_788:()=>Kb,content_2133_790:()=>Qb,content_2133_792:()=>nN,content_2133_794:()=>oN,content_2133_796:()=>rN,content_2133_798:()=>sN,content_2133_8:()=>Ty,content_2133_80:()=>Bf,content_2133_800:()=>lN,content_2133_802:()=>uN,content_2133_804:()=>dN,content_2133_806:()=>kN,content_2133_808:()=>fN,content_2133_810:()=>DN,content_2133_812:()=>_N,content_2133_814:()=>gN,content_2133_816:()=>CN,content_2133_818:()=>LN,content_2133_82:()=>Of,content_2133_820:()=>vN,content_2133_822:()=>NN,content_2133_824:()=>AN,content_2133_826:()=>SN,content_2133_828:()=>IN,content_2133_830:()=>PN,content_2133_832:()=>FN,content_2133_834:()=>jN,content_2133_836:()=>BN,content_2133_838:()=>ON,content_2133_84:()=>Hf,content_2133_840:()=>HN,content_2133_842:()=>KN,content_2133_844:()=>QN,content_2133_846:()=>nE,content_2133_848:()=>oE,content_2133_850:()=>rE,content_2133_852:()=>sE,content_2133_854:()=>lE,content_2133_856:()=>uE,content_2133_858:()=>dE,content_2133_86:()=>Kf,content_2133_860:()=>kE,content_2133_862:()=>fE,content_2133_864:()=>DE,content_2133_866:()=>_E,content_2133_868:()=>gE,content_2133_870:()=>CE,content_2133_872:()=>LE,content_2133_874:()=>vE,content_2133_876:()=>NE,content_2133_878:()=>AE,content_2133_88:()=>Qf,content_2133_880:()=>SE,content_2133_882:()=>IE,content_2133_884:()=>PE,content_2133_886:()=>FE,content_2133_888:()=>jE,content_2133_890:()=>BE,content_2133_892:()=>OE,content_2133_894:()=>HE,content_2133_896:()=>KE,content_2133_898:()=>QE,content_2133_90:()=>nM,content_2133_900:()=>nA,content_2133_902:()=>oA,content_2133_904:()=>rA,content_2133_906:()=>sA,content_2133_908:()=>lA,content_2133_910:()=>uA,content_2133_912:()=>dA,content_2133_914:()=>kA,content_2133_916:()=>fA,content_2133_918:()=>DA,content_2133_92:()=>oM,content_2133_920:()=>_A,content_2133_922:()=>gA,content_2133_924:()=>CA,content_2133_926:()=>LA,content_2133_928:()=>vA,content_2133_930:()=>NA,content_2133_932:()=>AA,content_2133_934:()=>SA,content_2133_936:()=>IA,content_2133_938:()=>PA,content_2133_94:()=>rM,content_2133_940:()=>FA,content_2133_942:()=>jA,content_2133_944:()=>BA,content_2133_946:()=>OA,content_2133_948:()=>HA,content_2133_950:()=>KA,content_2133_952:()=>QA,content_2133_954:()=>nR,content_2133_956:()=>oR,content_2133_958:()=>rR,content_2133_96:()=>sM,content_2133_960:()=>sR,content_2133_962:()=>lR,content_2133_964:()=>uR,content_2133_966:()=>dR,content_2133_968:()=>kR,content_2133_970:()=>fR,content_2133_972:()=>DR,content_2133_974:()=>_R,content_2133_976:()=>gR,content_2133_978:()=>CR,content_2133_98:()=>lM,content_2133_980:()=>LR,content_2133_982:()=>vR,content_2133_984:()=>NR,content_2133_986:()=>AR,content_2133_988:()=>SR,content_2133_990:()=>IR,content_2133_992:()=>PR,content_2133_994:()=>FR,content_2133_996:()=>jR,content_2133_998:()=>BR});var p=e(2784),r=e(7896),c=e(876);const s={toc:[]};function a(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const l={toc:[]};function i(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscriptions and triggering of events."))}i.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,c.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}h.isMDXComponent=!0;const k={toc:[]};function y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches an asynchronous ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}y.isMDXComponent=!0;const f={toc:[]};function M(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}M.isMDXComponent=!0;const D={toc:[]};function w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}w.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}X.isMDXComponent=!0;const g={toc:[]};function x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}x.isMDXComponent=!0;const C={toc:[]};function T(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}T.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}Z.isMDXComponent=!0;const v={toc:[]};function b(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},v,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}b.isMDXComponent=!0;const N={toc:[]};function E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}E.isMDXComponent=!0;const A={toc:[]};function R(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}R.isMDXComponent=!0;const S={toc:[]};function z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}z.isMDXComponent=!0;const I={toc:[]};function W(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},I,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}W.isMDXComponent=!0;const P={toc:[]};function G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}G.isMDXComponent=!0;const F={toc:[]};function U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},F,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}U.isMDXComponent=!0;const j={toc:[]};function V(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}V.isMDXComponent=!0;const B={toc:[]};function q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}q.isMDXComponent=!0;const O={toc:[]};function $(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value argument to subscribers."))}$.isMDXComponent=!0;const H={toc:[]};function Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A base for dispatching ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,c.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Y.isMDXComponent=!0;const K={toc:[]};function J(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}J.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Q,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}pt.isMDXComponent=!0;const rt={toc:[]};function ct(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}ct.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}at.isMDXComponent=!0;const lt={toc:[]};function it(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}it.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the callback function."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,c.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,c.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}ht.isMDXComponent=!0;const kt={toc:[]};function yt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}yt.isMDXComponent=!0;const ft={toc:[]};function Mt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function wt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}wt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_t,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Are subscribers being notified?"))}Xt.isMDXComponent=!0;const gt={toc:[]};function xt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Notify all current and future subscribers."))}xt.isMDXComponent=!0;const Ct={toc:[]};function Tt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ct,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Stop notifying future subscribers."))}Tt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}Zt.isMDXComponent=!0;const vt={toc:[]};function bt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}bt.isMDXComponent=!0;const Nt={toc:[]};function Et(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}Et.isMDXComponent=!0;const At={toc:[]};function Rt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}Rt.isMDXComponent=!0;const St={toc:[]};function zt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},St,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}zt.isMDXComponent=!0;const It={toc:[]};function Wt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},It,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Wt.isMDXComponent=!0;const Pt={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,c.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Gt.isMDXComponent=!0;const Ft={toc:[]};function Ut(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ft,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}Ut.isMDXComponent=!0;const jt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}Vt.isMDXComponent=!0;const Bt={toc:[]};function qt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}qt.isMDXComponent=!0;const Ot={toc:[]};function $t(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}$t.isMDXComponent=!0;const Ht={toc:[]};function Yt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ht,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}Yt.isMDXComponent=!0;const Kt={toc:[]};function Jt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}Jt.isMDXComponent=!0;const Qt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the callback function."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}pn.isMDXComponent=!0;const rn={toc:[]};function cn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the most recent value of this dispatcher."))}cn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}dn.isMDXComponent=!0;const hn={toc:[]};function kn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}kn.isMDXComponent=!0;const yn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}fn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Dn.isMDXComponent=!0;const wn={toc:[]};function _n(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}gn.isMDXComponent=!0;const xn={toc:[]};function Cn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value passed to subscribers."))}Cn.isMDXComponent=!0;const Tn={toc:[]};function Ln(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function vn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}vn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Nn.isMDXComponent=!0;const En={toc:[]};function An(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},En,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The initial value."))}An.isMDXComponent=!0;const Rn={toc:[]};function Sn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the most recent value of this dispatcher."))}Sn.isMDXComponent=!0;const zn={toc:[]};function In(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Setting the value will immediately notify all subscribers."))}In.isMDXComponent=!0;const Wn={toc:[]};function Pn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set the current value of this dispatcher."))}Pn.isMDXComponent=!0;const Gn={toc:[]};function Fn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new value."))}Fn.isMDXComponent=!0;const Un={toc:[]};function jn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}jn.isMDXComponent=!0;const Vn={toc:[]};function Bn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}Bn.isMDXComponent=!0;const qn={toc:[]};function On(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}On.isMDXComponent=!0;const $n={toc:[]};function Hn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$n,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}Hn.isMDXComponent=!0;const Yn={toc:[]};function Kn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Kn.isMDXComponent=!0;const Jn={toc:[]};function Qn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}Qn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value passed to subscribers."))}oe.isMDXComponent=!0;const pe={toc:[]};function re(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}re.isMDXComponent=!0;const ce={toc:[]};function se(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ce,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}se.isMDXComponent=!0;const ae={toc:[]};function le(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}le.isMDXComponent=!0;const ie={toc:[]};function ue(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ie,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}de.isMDXComponent=!0;const he={toc:[]};function ke(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}ke.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ye,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fe.isMDXComponent=!0;const Me={toc:[]};function De(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Me,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}De.isMDXComponent=!0;const we={toc:[]};function _e(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}_e.isMDXComponent=!0;const Xe={toc:[]};function ge(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The amount of times the timer has ticked."))}ge.isMDXComponent=!0;const xe={toc:[]};function Ce(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator responsible for running this timer."))}Ce.isMDXComponent=!0;const Te={toc:[]};function Le(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait until the timer ticks."))}Le.isMDXComponent=!0;const Ze={toc:[]};function ve(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The current iteration index."))}ve.isMDXComponent=!0;const be={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},be,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Ne.isMDXComponent=!0;const Ee={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ee,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Ae.isMDXComponent=!0;const Re={toc:[]};function Se(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Re,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Se.isMDXComponent=!0;const ze={toc:[]};function Ie(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Ie.isMDXComponent=!0;const We={toc:[]};function Pe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},We,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Pe.isMDXComponent=!0;const Ge={toc:[]};function Fe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Fe.isMDXComponent=!0;const Ue={toc:[]};function je(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,c.kt)("p",null,"Note that the same animation can be written as:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,c.kt)("p",null,"The reason ",(0,c.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.corenerRadius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}je.isMDXComponent=!0;const Ve={toc:[]};function Be(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run tasks one after another."))}Be.isMDXComponent=!0;const qe={toc:[]};function Oe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Oe.isMDXComponent=!0;const $e={toc:[]};function He(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$e,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,c.kt)("p",null,"Note that the same animation can be written as:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,c.kt)("p",null,"The reason ",(0,c.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}He.isMDXComponent=!0;const Ye={toc:[]};function Ke(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ye,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Ke.isMDXComponent=!0;const Je={toc:[]};function Qe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Je,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The delay in seconds"))}Qe.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task or callback to run after the delay."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Call the given callback every N seconds."))}ro.isMDXComponent=!0;const co={toc:[]};function so(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},co,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The interval between subsequent calls."))}so.isMDXComponent=!0;const ao={toc:[]};function lo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to be called."))}lo.isMDXComponent=!0;const io={toc:[]};function uo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},io,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Each time iteration waits until the previous one is completed."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}ho.isMDXComponent=!0;const ko={toc:[]};function yo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ko,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run the given generator N times."))}yo.isMDXComponent=!0;const fo={toc:[]};function Mo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The number of iterations."))}Mo.isMDXComponent=!0;const Do={toc:[]};function wo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Do,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}wo.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_o,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Do nothing."))}Xo.isMDXComponent=!0;const go={toc:[]};function xo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}xo.isMDXComponent=!0;const Co={toc:[]};function To(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Co,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Turn the given generator function into a threadable generator."))}To.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a factory that creates the generator."))}Zo.isMDXComponent=!0;const vo={toc:[]};function bo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}bo.isMDXComponent=!0;const No={toc:[]};function Eo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Turn the given generator function into a threadable generator."))}Eo.isMDXComponent=!0;const Ao={toc:[]};function Ro(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Ro.isMDXComponent=!0;const So={toc:[]};function zo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},So,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a factory that creates the generator."))}zo.isMDXComponent=!0;const Io={toc:[]};function Wo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Io,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Wo.isMDXComponent=!0;const Po={toc:[]};function Go(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Po,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Go.isMDXComponent=!0;const Fo={toc:[]};function Uo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Uo.isMDXComponent=!0;const jo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The delay between each of the tasks."))}Vo.isMDXComponent=!0;const Bo={toc:[]};function qo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to be run in a sequence."))}qo.isMDXComponent=!0;const Oo={toc:[]};function $o(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}$o.isMDXComponent=!0;const Ho={toc:[]};function Yo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ho,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for the given amount of time."))}Yo.isMDXComponent=!0;const Ko={toc:[]};function Jo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ko,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The relative time in seconds."))}Jo.isMDXComponent=!0;const Qo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional task to be run after the function completes."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}pp.isMDXComponent=!0;const rp={toc:[]};function cp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait until the given time event."))}cp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the time event."))}ap.isMDXComponent=!0;const lp={toc:[]};function ip(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional task to be run after the function completes."))}ip.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Main Motion Canvas classes."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when a new message is logged."))}hp.isMDXComponent=!0;const kp={toc:[]};function yp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the meta file of a given entity."))}yp.isMDXComponent=!0;const fp={toc:[]};function Mp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when metadata changes."))}Mp.isMDXComponent=!0;const Dp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Load new metadata from a file."))}wp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_p,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"New metadata."))}Xp.isMDXComponent=!0;const gp={toc:[]};function xp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any possible errors will be logged to the console."))}xp.isMDXComponent=!0;const Cp={toc:[]};function Tp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set data without waiting for confirmation."))}Tp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"New data."))}Zp.isMDXComponent=!0;const vp={toc:[]};function bp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the data stored in the meta file."))}bp.isMDXComponent=!0;const Np={toc:[]};function Ep(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,c.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}Ep.isMDXComponent=!0;const Ap={toc:[]};function Rp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}))}Rp.isMDXComponent=!0;const Sp={toc:[]};function zp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The project configuration."))}zp.isMDXComponent=!0;const Ip={toc:[]};function Wp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ip,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the current scene changes."))}Wp.isMDXComponent=!0;const Pp={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Gp.isMDXComponent=!0;const Fp={toc:[]};function Up(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after the scenes were recalculated."))}Up.isMDXComponent=!0;const jp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the contents of a meta file."))}Vp.isMDXComponent=!0;const Bp={toc:[]};function qp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Multi-media management."))}qp.isMDXComponent=!0;const Op={toc:[]};function $p(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Op,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}$p.isMDXComponent=!0;const Hp={toc:[]};function Yp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause/resume the audio."))}Yp.isMDXComponent=!0;const Kp={toc:[]};function Jp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the audio should be paused or resumed."))}Jp.isMDXComponent=!0;const Qp={toc:[]};function tr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The absolute biggest value from the peaks array."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The amount of samples taken."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}pr.isMDXComponent=!0;const rr={toc:[]};function cr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Samples per seconds."))}cr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Playback control."))}ar.isMDXComponent=!0;const lr={toc:[]};function ir(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Abstract scene representations and related utilities."))}ir.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Signifies the various stages of a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs after a render ends."))}hr.isMDXComponent=!0;const kr={toc:[]};function yr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}yr.isMDXComponent=!0;const fr={toc:[]};function Mr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,c.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,c.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}wr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_r,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes the state of a scene."))}Xr.isMDXComponent=!0;const gr={toc:[]};function xr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}xr.isMDXComponent=!0;const Cr={toc:[]};function Tr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has finished transitioning in."))}Tr.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,c.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Zr.isMDXComponent=!0;const vr={toc:[]};function br(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene is ready to transition out."))}br.isMDXComponent=!0;const Nr={toc:[]};function Er(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Invoking ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,c.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Er.isMDXComponent=!0;const Ar={toc:[]};function Rr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has finished."))}Rr.isMDXComponent=!0;const Sr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has just been created/reset."))}zr.isMDXComponent=!0;const Ir={toc:[]};function Wr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ir,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The default implementation of the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,c.kt)("p",null,"Uses generators to control the animation."))}Wr.isMDXComponent=!0;const Pr={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Will be passed as the second argument to the constructor."))}Gr.isMDXComponent=!0;const Fr={toc:[]};function Ur(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the scene."))}Ur.isMDXComponent=!0;const jr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reference to the project."))}Vr.isMDXComponent=!0;const Br={toc:[]};function qr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Br,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene starts."))}qr.isMDXComponent=!0;const Or={toc:[]};function $r(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Or,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene ends."))}$r.isMDXComponent=!0;const Hr={toc:[]};function Yr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the cached data changes."))}Yr.isMDXComponent=!0;const Kr={toc:[]};function Jr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after scene is recalculated."))}Jr.isMDXComponent=!0;const Qr={toc:[]};function tc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reloaded."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reset."))}pc.isMDXComponent=!0;const rc={toc:[]};function cc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the main thread changes."))}cc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ac.isMDXComponent=!0;const lc={toc:[]};function ic(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ic.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hc.isMDXComponent=!0;const kc={toc:[]};function yc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the size of this scene."),(0,c.kt)("p",null,"Usually return ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}yc.isMDXComponent=!0;const fc={toc:[]};function Mc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Mc.isMDXComponent=!0;const Dc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene cached?"),(0,c.kt)("p",null,"Used only by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,c.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,c.kt)("p",null,"Should always return ",(0,c.kt)("inlineCode",{parentName:"p"},"true"),"."))}wc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_c,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,c.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Xc.isMDXComponent=!0;const gc={toc:[]};function xc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress this scene one frame forward."))}xc.isMDXComponent=!0;const Cc={toc:[]};function Tc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,c.kt)("p",null,"At the end of execution, this method should set ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,c.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Tc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Recalculate the scene."))}Zc.isMDXComponent=!0;const vc={toc:[]};function bc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,c.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}bc.isMDXComponent=!0;const Nc={toc:[]};function Ec(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reload the scene."))}Ec.isMDXComponent=!0;const Ac={toc:[]};function Rc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, a new configuration object."))}Rc.isMDXComponent=!0;const Sc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render the scene onto a canvas."))}zc.isMDXComponent=!0;const Ic={toc:[]};function Wc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ic,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to used when rendering."))}Wc.isMDXComponent=!0;const Pc={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset this scene to its initial state."))}Gc.isMDXComponent=!0;const Fc={toc:[]};function Uc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, the previous scene."))}Uc.isMDXComponent=!0;const jc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the view."),(0,c.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,c.kt)("p",null,"Can modify the state of the view."))}Vc.isMDXComponent=!0;const Bc={toc:[]};function qc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Lifecycle events for ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}qc.isMDXComponent=!0;const Oc={toc:[]};function $c(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A random number generator based on\n",(0,c.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,c.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}$c.isMDXComponent=!0;const Hc={toc:[]};function Yc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get an array filled with random floats in the given range."))}Yc.isMDXComponent=!0;const Kc={toc:[]};function Jc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The size of the array."))}Jc.isMDXComponent=!0;const Qc={toc:[]};function ts(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get an array filled with random integers in the given range."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"}),(0,c.kt)("li",{parentName:"ul"})))}ps.isMDXComponent=!0;const rs={toc:[]};function cs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The size of the array."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"})))}cs.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"})))}as.isMDXComponent=!0;const ls={toc:[]};function is(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ls,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. Exclusive."))}is.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the next random float in the given range."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}hs.isMDXComponent=!0;const ks={toc:[]};function ys(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ks,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range."))}ys.isMDXComponent=!0;const fs={toc:[]};function Ms(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the next random integer in the given range."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function ws(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ds,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}ws.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. Exclusive."))}Xs.isMDXComponent=!0;const gs={toc:[]};function xs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a new independent generator."))}xs.isMDXComponent=!0;const Cs={toc:[]};function Ts(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Manages time events for a given scene."))}Ts.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ls,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when time events change."))}Zs.isMDXComponent=!0;const vs={toc:[]};function bs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the time offset of the given event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function Es(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the event."))}Es.isMDXComponent=!0;const As={toc:[]};function Rs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The time offset in seconds."))}Rs.isMDXComponent=!0;const Ss={toc:[]};function zs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ss,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,c.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}zs.isMDXComponent=!0;const Is={toc:[]};function Ws(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Is,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes cached information about the timing of a scene."))}Ws.isMDXComponent=!0;const Ps={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ps,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes a complete scene together with the meta file."))}Gs.isMDXComponent=!0;const Fs={toc:[]};function Us(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Configuration object."))}Us.isMDXComponent=!0;const js={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The class used to instantiate the scene."))}Vs.isMDXComponent=!0;const Bs={toc:[]};function qs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The stack trace at the moment of creation."))}qs.isMDXComponent=!0;const Os={toc:[]};function $s(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Os,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}$s.isMDXComponent=!0;const Hs={toc:[]};function Ys(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Ys.isMDXComponent=!0;const Ks={toc:[]};function Js(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ks,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Js.isMDXComponent=!0;const Qs={toc:[]};function ta(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for the inspected element."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element for which to draw an overlay."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}pa.isMDXComponent=!0;const ra={toc:[]};function ca(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ra,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}ca.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}aa.isMDXComponent=!0;const la={toc:[]};function ia(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},la,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Return the attributes of the inspected element."))}ia.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element to inspect."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a possible element to inspect at a given position."))}ha.isMDXComponent=!0;const ka={toc:[]};function ya(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ka,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The x coordinate."))}ya.isMDXComponent=!0;const fa={toc:[]};function Ma(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The y coordinate."))}Ma.isMDXComponent=!0;const Da={toc:[]};function wa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Da,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}wa.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_a,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the inspected element is still valid."))}Xa.isMDXComponent=!0;const ga={toc:[]};function xa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element to validate."))}xa.isMDXComponent=!0;const Ca={toc:[]};function Ta(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ca,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a time event stored in a meta file."))}Ta.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},La,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,c.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Za.isMDXComponent=!0;const va={toc:[]};function ba(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The main interface for scenes."))}ba.isMDXComponent=!0;const Na={toc:[]};function Ea(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Will be passed as the second argument to the constructor."))}Ea.isMDXComponent=!0;const Aa={toc:[]};function Ra(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the scene."))}Ra.isMDXComponent=!0;const Sa={toc:[]};function za(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reference to the project."))}za.isMDXComponent=!0;const Ia={toc:[]};function Wa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ia,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene's ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,c.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Wa.isMDXComponent=!0;const Pa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene starts."))}Ga.isMDXComponent=!0;const Fa={toc:[]};function Ua(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene ends."))}Ua.isMDXComponent=!0;const ja={toc:[]};function Va(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the cached data changes."))}Va.isMDXComponent=!0;const Ba={toc:[]};function qa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ba,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after scene is recalculated."))}qa.isMDXComponent=!0;const Oa={toc:[]};function $a(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reloaded."))}$a.isMDXComponent=!0;const Ha={toc:[]};function Ya(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ha,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ya.isMDXComponent=!0;const Ka={toc:[]};function Ja(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ka,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reset."))}Ja.isMDXComponent=!0;const Qa={toc:[]};function tl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}pl.isMDXComponent=!0;const rl={toc:[]};function cl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}cl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the size of this scene."),(0,c.kt)("p",null,"Usually return ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}al.isMDXComponent=!0;const ll={toc:[]};function il(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ll,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}il.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene cached?"),(0,c.kt)("p",null,"Used only by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,c.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,c.kt)("p",null,"Should always return ",(0,c.kt)("inlineCode",{parentName:"p"},"true"),"."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,c.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}hl.isMDXComponent=!0;const kl={toc:[]};function yl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress this scene one frame forward."))}yl.isMDXComponent=!0;const fl={toc:[]};function Ml(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,c.kt)("p",null,"At the end of execution, this method should set ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,c.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Recalculate the scene."))}wl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_l,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,c.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Xl.isMDXComponent=!0;const gl={toc:[]};function xl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reload the scene."))}xl.isMDXComponent=!0;const Cl={toc:[]};function Tl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, a new configuration object."))}Tl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ll,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render the scene onto a canvas."))}Zl.isMDXComponent=!0;const vl={toc:[]};function bl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to used when rendering."))}bl.isMDXComponent=!0;const Nl={toc:[]};function El(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset this scene to its initial state."))}El.isMDXComponent=!0;const Al={toc:[]};function Rl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, the previous scene."))}Rl.isMDXComponent=!0;const Sl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}zl.isMDXComponent=!0;const Il={toc:[]};function Wl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Il,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Each class implementing the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Wl.isMDXComponent=!0;const Pl={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The constructor used when creating new scenes."))}Gl.isMDXComponent=!0;const Fl={toc:[]};function Ul(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,c.kt)("inlineCode",{parentName:"a"},"config")),"."))}Ul.isMDXComponent=!0;const jl={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes a scene exposed by scene files."))}Vl.isMDXComponent=!0;const Bl={toc:[]};function ql(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Configuration object."))}ql.isMDXComponent=!0;const Ol={toc:[]};function $l(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ol,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The class used to instantiate the scene."))}$l.isMDXComponent=!0;const Hl={toc:[]};function Yl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The stack trace at the moment of creation."))}Yl.isMDXComponent=!0;const Kl={toc:[]};function Jl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}Jl.isMDXComponent=!0;const Ql={toc:[]};function ti(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ql,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the contents of a meta file."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}pi.isMDXComponent=!0;const ri={toc:[]};function ci(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ri,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the main thread changes."))}ci.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a time event at runtime."))}ai.isMDXComponent=!0;const li={toc:[]};function ii(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},li,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"In other words, the moment at which ",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,c.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}ii.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the event."))}hi.isMDXComponent=!0;const ki={toc:[]};function yi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ki,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Duration of the event in seconds."))}yi.isMDXComponent=!0;const fi={toc:[]};function Mi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Stack trace at the moment of registration."))}Mi.isMDXComponent=!0;const Di={toc:[]};function wi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Di,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}wi.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_i,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents attributes of an inspected element."))}Xi.isMDXComponent=!0;const gi={toc:[]};function xi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}xi.isMDXComponent=!0;const Ci={toc:[]};function Ti(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ci,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents an element to inspect."))}Ti.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Li,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Zi.isMDXComponent=!0;const vi={toc:[]};function bi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}bi.isMDXComponent=!0;const Ni={toc:[]};function Ei(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Ei.isMDXComponent=!0;const Ai={toc:[]};function Ri(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}Ri.isMDXComponent=!0;const Si={toc:[]};function zi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Si,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}zi.isMDXComponent=!0;const Ii={toc:[]};function Wi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ii,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Wi.isMDXComponent=!0;const Pi={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Gi.isMDXComponent=!0;const Fi={toc:[]};function Ui(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Ui.isMDXComponent=!0;const ji={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Vi.isMDXComponent=!0;const Bi={toc:[]};function qi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}qi.isMDXComponent=!0;const Oi={toc:[]};function $i(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}$i.isMDXComponent=!0;const Hi={toc:[]};function Yi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}Yi.isMDXComponent=!0;const Ki={toc:[]};function Ji(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ki,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Ji.isMDXComponent=!0;const Qi={toc:[]};function tu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}pu.isMDXComponent=!0;const ru={toc:[]};function cu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ru,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}cu.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}au.isMDXComponent=!0;const lu={toc:[]};function iu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}iu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Thread management."))}hu.isMDXComponent=!0;const ku={toc:[]};function yu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ku,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,c.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}yu.isMDXComponent=!0;const fu={toc:[]};function Mu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A class representing an individual thread."))}Mu.isMDXComponent=!0;const Du={toc:[]};function wu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Du,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator wrapped by this thread."))}wu.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator wrapped by this thread."))}Xu.isMDXComponent=!0;const gu={toc:[]};function xu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Used by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,c.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}xu.isMDXComponent=!0;const Cu={toc:[]};function Tu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The current time of this thread."))}Tu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The next value to be passed to the wrapped generator."))}Zu.isMDXComponent=!0;const vu={toc:[]};function bu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}bu.isMDXComponent=!0;const Nu={toc:[]};function Eu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress the wrapped generator once."))}Eu.isMDXComponent=!0;const Au={toc:[]};function Ru(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the thread for the next update cycle."))}Ru.isMDXComponent=!0;const Su={toc:[]};function zu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Su,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a normal function that returns a generator."))}zu.isMDXComponent=!0;const Iu={toc:[]};function Wu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,c.kt)("p",null,"Progress to the next frame:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,c.kt)("p",null,"Run another generator synchronously:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,c.kt)("p",null,"Run another generator concurrently:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,c.kt)("p",null,"Await a Promise:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Wu.isMDXComponent=!0;const Pu={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Gu.isMDXComponent=!0;const Fu={toc:[]};function Uu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Cancel all listed tasks."),(0,c.kt)("p",null,"Example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Uu.isMDXComponent=!0;const ju={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to cancel."))}Vu.isMDXComponent=!0;const Bu={toc:[]};function qu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}qu.isMDXComponent=!0;const Ou={toc:[]};function $u(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ou,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A possible ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}$u.isMDXComponent=!0;const Hu={toc:[]};function Yu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the given value is a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,c.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Yu.isMDXComponent=!0;const Ku={toc:[]};function Ju(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ku,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A possible thread ",(0,c.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,c.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Ju.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to join."))}pm.isMDXComponent=!0;const rm={toc:[]};function cm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}cm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause the current generator until listed tasks are finished."))}am.isMDXComponent=!0;const lm={toc:[]};function im(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}im.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to join."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"From the perspective of the external generator, ",(0,c.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,c.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}hm.isMDXComponent=!0;const km={toc:[]};function ym(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},km,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}ym.isMDXComponent=!0;const fm={toc:[]};function Mm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a context in which generators can be run concurrently."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A function that returns the generator to run."))}wm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_m,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}Xm.isMDXComponent=!0;const gm={toc:[]};function xm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Transitions between scenes."))}xm.isMDXComponent=!0;const Cm={toc:[]};function Tm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}Tm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The direction in which to slide."))}Zm.isMDXComponent=!0;const vm={toc:[]};function bm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}bm.isMDXComponent=!0;const Nm={toc:[]};function Em(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Em.isMDXComponent=!0;const Am={toc:[]};function Rm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to use before the current scene is rendered."))}Rm.isMDXComponent=!0;const Sm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to use before the previous scene is rendered."))}zm.isMDXComponent=!0;const Im={toc:[]};function Wm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Im,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}Wm.isMDXComponent=!0;const Pm={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The area on which to zoom in."))}Gm.isMDXComponent=!0;const Fm={toc:[]};function Um(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}Um.isMDXComponent=!0;const jm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Vm.isMDXComponent=!0;const Bm={toc:[]};function qm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The area from which to zoom out."))}qm.isMDXComponent=!0;const Om={toc:[]};function $m(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Om,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}$m.isMDXComponent=!0;const Hm={toc:[]};function Ym(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolation and timing of tweens."))}Ym.isMDXComponent=!0;const Km={toc:[]};function Jm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Km,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any old key that is missing in ",(0,c.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,c.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,c.kt)("ol",null,(0,c.kt)("li",{parentName:"ol"})))}Jm.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A value matching the structure of from and to."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 0."))}pd.isMDXComponent=!0;const rd={toc:[]};function cd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 1."))}cd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}ad.isMDXComponent=!0;const ld={toc:[]};function id(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ld,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A value matching the structure of from and to."))}id.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 0."))}hd.isMDXComponent=!0;const kd={toc:[]};function yd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 1."))}yd.isMDXComponent=!0;const fd={toc:[]};function Md(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Md.isMDXComponent=!0;const Dd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Complex types used in animations."))}wd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a two-dimensional vector."))}Xd.isMDXComponent=!0;const gd={toc:[]};function xd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}xd.isMDXComponent=!0;const Cd={toc:[]};function Td(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The unclipped RGB components."))}Td.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ld,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}Zd.isMDXComponent=!0;const vd={toc:[]};function bd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}bd.isMDXComponent=!0;const Nd={toc:[]};function Ed(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Ed.isMDXComponent=!0;const Ad={toc:[]};function Rd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Rd.isMDXComponent=!0;const Sd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}zd.isMDXComponent=!0;const Id={toc:[]};function Wd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Id,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Wd.isMDXComponent=!0;const Pd={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}Gd.isMDXComponent=!0;const Fd={toc:[]};function Ud(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Alias of ",(0,c.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Ud.isMDXComponent=!0;const jd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Vd.isMDXComponent=!0;const Bd={toc:[]};function qd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}qd.isMDXComponent=!0;const Od={toc:[]};function $d(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Od,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}$d.isMDXComponent=!0;const Hd={toc:[]};function Yd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,c.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,c.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Yd.isMDXComponent=!0;const Kd={toc:[]};function Jd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Jd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,c.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,c.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("strong",{parentName:"p"},"L"),", ",(0,c.kt)("strong",{parentName:"p"},"a"),", and ",(0,c.kt)("strong",{parentName:"p"},"b")," components."))}ph.isMDXComponent=!0;const rh={toc:[]};function ch(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}ch.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,c.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,c.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}ah.isMDXComponent=!0;const lh={toc:[]};function ih(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}ih.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}hh.isMDXComponent=!0;const kh={toc:[]};function yh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}yh.isMDXComponent=!0;const fh={toc:[]};function Mh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get and set the color opacity."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,c.kt)("code",null,"'rgb'")))}wh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_h,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Similar to saturate, but the opposite direction."))}Xh.isMDXComponent=!0;const gh={toc:[]};function xh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"set"))}xh.isMDXComponent=!0;const Ch={toc:[]};function Th(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ch,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns a single channel value.\nAlso"))}Th.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}Zh.isMDXComponent=!0;const vh={toc:[]};function bh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color as hexadecimal string."))}bh.isMDXComponent=!0;const Nh={toc:[]};function Eh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,c.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,c.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Eh.isMDXComponent=!0;const Ah={toc:[]};function Rh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,c.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Rh.isMDXComponent=!0;const Sh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}zh.isMDXComponent=!0;const Ih={toc:[]};function Wh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ih,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Wh.isMDXComponent=!0;const Ph={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ph,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Gh.isMDXComponent=!0;const Fh={toc:[]};function Uh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Uh.isMDXComponent=!0;const jh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Vh.isMDXComponent=!0;const Bh={toc:[]};function qh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}qh.isMDXComponent=!0;const Oh={toc:[]};function $h(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}$h.isMDXComponent=!0;const Hh={toc:[]};function Yh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Yh.isMDXComponent=!0;const Kh={toc:[]};function Jh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Jh.isMDXComponent=!0;const Qh={toc:[]};function tk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Convert the given origin to a vector representing its offset."))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The origin to convert."))}pk.isMDXComponent=!0;const rk={toc:[]};function ck(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"General utilities and helper functions."))}ck.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}ak.isMDXComponent=!0;const lk={toc:[]};function ik(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Optional override for formatting stack traces"))}ik.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create .stack property on a target object"))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Invoke the reference instead."))}hk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}))}yk.isMDXComponent=!0;const fk={toc:[]};function Mk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Mark the given function as deprecated."))}Mk.isMDXComponent=!0;const Dk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function to deprecate."))}wk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_k,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The log message."))}Xk.isMDXComponent=!0;const gk={toc:[]};function xk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The optional log remarks."))}xk.isMDXComponent=!0;const Ck={toc:[]};function Tk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ck,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Tk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Mark the current scene as ready to transition out."))}Zk.isMDXComponent=!0;const vk={toc:[]};function bk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}bk.isMDXComponent=!0;const Nk={toc:[]};function Ek(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an array containing a range of numbers."))}Ek.isMDXComponent=!0;const Ak={toc:[]};function Rk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ak,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The length of the array."))}Rk.isMDXComponent=!0;const Sk={toc:[]};function zk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}zk.isMDXComponent=!0;const Ik={toc:[]};function Wk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ik,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an array containing a range of numbers."))}Wk.isMDXComponent=!0;const Pk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}Gk.isMDXComponent=!0;const Fk={toc:[]};function Uk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. ",(0,c.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Uk.isMDXComponent=!0;const jk={toc:[]};function Vk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}Vk.isMDXComponent=!0;const Bk={toc:[]};function qk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function that will be provided the context before render."))}qk.isMDXComponent=!0;const Ok={toc:[]};function $k(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ok,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}$k.isMDXComponent=!0;const Hk={toc:[]};function Yk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function that will be provided the context after render."))}Yk.isMDXComponent=!0;const Kk={toc:[]};function Jk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current project."))}Jk.isMDXComponent=!0;const Qk={toc:[]};function ty(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the random number generator for the current scene."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the random number generator for the given seed."))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The seed for the generator."))}py.isMDXComponent=!0;const ry={toc:[]};function cy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ry,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}cy.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current scene."))}ay.isMDXComponent=!0;const ly={toc:[]};function iy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ly,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current thread."))}iy.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,c.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}hy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ky,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the real time since the start of the animation."))}yy.isMDXComponent=!0;const fy={toc:[]};function My(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}My.isMDXComponent=!0;const Dy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}wy.isMDXComponent=!0;const _y={toc:[]};function Xy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_y,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Xy.isMDXComponent=!0;const gy={toc:[]};function xy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}xy.isMDXComponent=!0;const Cy={toc:[]};function Ty(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Ty.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}Zy.isMDXComponent=!0;const vy={toc:[]};function by(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}by.isMDXComponent=!0;const Ny={toc:[]};function Ey(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}Ey.isMDXComponent=!0;const Ay={toc:[]};function Ry(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ay,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ry.isMDXComponent=!0;const Sy={toc:[]};function zy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}zy.isMDXComponent=!0;const Iy={toc:[]};function Wy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Wy.isMDXComponent=!0;const Py={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Gy.isMDXComponent=!0;const Fy={toc:[]};function Uy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Uy.isMDXComponent=!0;const jy={toc:[]};function Vy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Vy.isMDXComponent=!0;const By={toc:[]};function qy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qy.isMDXComponent=!0;const Oy={toc:[]};function $y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}$y.isMDXComponent=!0;const Hy={toc:[]};function Yy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}Yy.isMDXComponent=!0;const Ky={toc:[]};function Jy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ky,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Jy.isMDXComponent=!0;const Qy={toc:[]};function tf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}pf.isMDXComponent=!0;const rf={toc:[]};function cf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}df.isMDXComponent=!0;const hf={toc:[]};function kf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}kf.isMDXComponent=!0;const yf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}ff.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Df.isMDXComponent=!0;const wf={toc:[]};function _f(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}gf.isMDXComponent=!0;const xf={toc:[]};function Cf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}Cf.isMDXComponent=!0;const Tf={toc:[]};function Lf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function vf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}vf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}Nf.isMDXComponent=!0;const Ef={toc:[]};function Af(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ef,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Af.isMDXComponent=!0;const Rf={toc:[]};function Sf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}Sf.isMDXComponent=!0;const zf={toc:[]};function If(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}If.isMDXComponent=!0;const Wf={toc:[]};function Pf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Pf.isMDXComponent=!0;const Gf={toc:[]};function Ff(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Ff.isMDXComponent=!0;const Uf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}jf.isMDXComponent=!0;const Vf={toc:[]};function Bf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}Bf.isMDXComponent=!0;const qf={toc:[]};function Of(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}Of.isMDXComponent=!0;const $f={toc:[]};function Hf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$f,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Hf.isMDXComponent=!0;const Yf={toc:[]};function Kf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Kf.isMDXComponent=!0;const Jf={toc:[]};function Qf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}Qf.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}rM.isMDXComponent=!0;const cM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}sM.isMDXComponent=!0;const aM={toc:[]};function lM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}lM.isMDXComponent=!0;const iM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}dM.isMDXComponent=!0;const hM={toc:[]};function kM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}kM.isMDXComponent=!0;const yM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}fM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}DM.isMDXComponent=!0;const wM={toc:[]};function _M(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}gM.isMDXComponent=!0;const xM={toc:[]};function CM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}CM.isMDXComponent=!0;const TM={toc:[]};function LM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}LM.isMDXComponent=!0;const ZM={toc:[]};function vM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}vM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}NM.isMDXComponent=!0;const EM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}AM.isMDXComponent=!0;const RM={toc:[]};function SM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}SM.isMDXComponent=!0;const zM={toc:[]};function IM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}IM.isMDXComponent=!0;const WM={toc:[]};function PM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}PM.isMDXComponent=!0;const GM={toc:[]};function FM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}FM.isMDXComponent=!0;const UM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jM.isMDXComponent=!0;const VM={toc:[]};function BM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}BM.isMDXComponent=!0;const qM={toc:[]};function OM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}OM.isMDXComponent=!0;const $M={toc:[]};function HM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$M,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}HM.isMDXComponent=!0;const YM={toc:[]};function KM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}KM.isMDXComponent=!0;const JM={toc:[]};function QM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}QM.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}rD.isMDXComponent=!0;const cD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}sD.isMDXComponent=!0;const aD={toc:[]};function lD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}lD.isMDXComponent=!0;const iD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}dD.isMDXComponent=!0;const hD={toc:[]};function kD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}kD.isMDXComponent=!0;const yD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}fD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DD.isMDXComponent=!0;const wD={toc:[]};function _D(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}gD.isMDXComponent=!0;const xD={toc:[]};function CD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}CD.isMDXComponent=!0;const TD={toc:[]};function LD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}LD.isMDXComponent=!0;const ZD={toc:[]};function vD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}vD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ND.isMDXComponent=!0;const ED={toc:[]};function AD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ED,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}AD.isMDXComponent=!0;const RD={toc:[]};function SD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}SD.isMDXComponent=!0;const zD={toc:[]};function ID(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ID.isMDXComponent=!0;const WD={toc:[]};function PD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}PD.isMDXComponent=!0;const GD={toc:[]};function FD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}FD.isMDXComponent=!0;const UD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}jD.isMDXComponent=!0;const VD={toc:[]};function BD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}BD.isMDXComponent=!0;const qD={toc:[]};function OD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}OD.isMDXComponent=!0;const $D={toc:[]};function HD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$D,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}HD.isMDXComponent=!0;const YD={toc:[]};function KD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}KD.isMDXComponent=!0;const JD={toc:[]};function QD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}QD.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}rw.isMDXComponent=!0;const cw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}sw.isMDXComponent=!0;const aw={toc:[]};function lw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}lw.isMDXComponent=!0;const iw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}dw.isMDXComponent=!0;const hw={toc:[]};function kw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}kw.isMDXComponent=!0;const yw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}fw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Dw.isMDXComponent=!0;const ww={toc:[]};function _w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}gw.isMDXComponent=!0;const xw={toc:[]};function Cw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}Cw.isMDXComponent=!0;const Tw={toc:[]};function Lw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Lw.isMDXComponent=!0;const Zw={toc:[]};function vw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}vw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}Nw.isMDXComponent=!0;const Ew={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ew,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Aw.isMDXComponent=!0;const Rw={toc:[]};function Sw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Sw.isMDXComponent=!0;const zw={toc:[]};function Iw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Iw.isMDXComponent=!0;const Ww={toc:[]};function Pw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ww,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Pw.isMDXComponent=!0;const Gw={toc:[]};function Fw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}Fw.isMDXComponent=!0;const Uw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}jw.isMDXComponent=!0;const Vw={toc:[]};function Bw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}Bw.isMDXComponent=!0;const qw={toc:[]};function Ow(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Ow.isMDXComponent=!0;const $w={toc:[]};function Hw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$w,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}Hw.isMDXComponent=!0;const Yw={toc:[]};function Kw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Kw.isMDXComponent=!0;const Jw={toc:[]};function Qw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}Qw.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}r_.isMDXComponent=!0;const c_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}s_.isMDXComponent=!0;const a_={toc:[]};function l_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}l_.isMDXComponent=!0;const i_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},i_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}d_.isMDXComponent=!0;const h_={toc:[]};function k_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}k_.isMDXComponent=!0;const y_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}f_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}D_.isMDXComponent=!0;const w_={toc:[]};function __(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}g_.isMDXComponent=!0;const x_={toc:[]};function C_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}C_.isMDXComponent=!0;const T_={toc:[]};function L_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}L_.isMDXComponent=!0;const Z_={toc:[]};function v_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}v_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}N_.isMDXComponent=!0;const E_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}A_.isMDXComponent=!0;const R_={toc:[]};function S_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}S_.isMDXComponent=!0;const z_={toc:[]};function I_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}I_.isMDXComponent=!0;const W_={toc:[]};function P_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}P_.isMDXComponent=!0;const G_={toc:[]};function F_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}F_.isMDXComponent=!0;const U_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}j_.isMDXComponent=!0;const V_={toc:[]};function B_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}B_.isMDXComponent=!0;const q_={toc:[]};function O_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}O_.isMDXComponent=!0;const $_={toc:[]};function H_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}H_.isMDXComponent=!0;const Y_={toc:[]};function K_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}K_.isMDXComponent=!0;const J_={toc:[]};function Q_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},J_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}Q_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}rX.isMDXComponent=!0;const cX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}sX.isMDXComponent=!0;const aX={toc:[]};function lX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}lX.isMDXComponent=!0;const iX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}dX.isMDXComponent=!0;const hX={toc:[]};function kX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}kX.isMDXComponent=!0;const yX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}fX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}DX.isMDXComponent=!0;const wX={toc:[]};function _X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}gX.isMDXComponent=!0;const xX={toc:[]};function CX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}CX.isMDXComponent=!0;const TX={toc:[]};function LX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}LX.isMDXComponent=!0;const ZX={toc:[]};function vX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}vX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}NX.isMDXComponent=!0;const EX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}AX.isMDXComponent=!0;const RX={toc:[]};function SX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}SX.isMDXComponent=!0;const zX={toc:[]};function IX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}IX.isMDXComponent=!0;const WX={toc:[]};function PX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}PX.isMDXComponent=!0;const GX={toc:[]};function FX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}FX.isMDXComponent=!0;const UX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}jX.isMDXComponent=!0;const VX={toc:[]};function BX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}BX.isMDXComponent=!0;const qX={toc:[]};function OX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}OX.isMDXComponent=!0;const $X={toc:[]};function HX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$X,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}HX.isMDXComponent=!0;const YX={toc:[]};function KX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}KX.isMDXComponent=!0;const JX={toc:[]};function QX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QX.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rg.isMDXComponent=!0;const cg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sg.isMDXComponent=!0;const ag={toc:[]};function lg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}lg.isMDXComponent=!0;const ig={toc:[]};function ug(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ig,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}dg.isMDXComponent=!0;const hg={toc:[]};function kg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}kg.isMDXComponent=!0;const yg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}fg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}Dg.isMDXComponent=!0;const wg={toc:[]};function _g(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}gg.isMDXComponent=!0;const xg={toc:[]};function Cg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Cg.isMDXComponent=!0;const Tg={toc:[]};function Lg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function vg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}vg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}Ng.isMDXComponent=!0;const Eg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Ag.isMDXComponent=!0;const Rg={toc:[]};function Sg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}Sg.isMDXComponent=!0;const zg={toc:[]};function Ig(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ig.isMDXComponent=!0;const Wg={toc:[]};function Pg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}Pg.isMDXComponent=!0;const Gg={toc:[]};function Fg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Fg.isMDXComponent=!0;const Ug={toc:[]};function jg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ug,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}jg.isMDXComponent=!0;const Vg={toc:[]};function Bg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}Bg.isMDXComponent=!0;const qg={toc:[]};function Og(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Og.isMDXComponent=!0;const $g={toc:[]};function Hg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$g,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}Hg.isMDXComponent=!0;const Yg={toc:[]};function Kg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}Kg.isMDXComponent=!0;const Jg={toc:[]};function Qg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}Qg.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}rx.isMDXComponent=!0;const cx={toc:[]};function sx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}sx.isMDXComponent=!0;const ax={toc:[]};function lx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lx.isMDXComponent=!0;const ix={toc:[]};function ux(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ix,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}dx.isMDXComponent=!0;const hx={toc:[]};function kx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}kx.isMDXComponent=!0;const yx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}fx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}Dx.isMDXComponent=!0;const wx={toc:[]};function _x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}gx.isMDXComponent=!0;const xx={toc:[]};function Cx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Cx.isMDXComponent=!0;const Tx={toc:[]};function Lx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function vx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}vx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Nx.isMDXComponent=!0;const Ex={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ex,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}Ax.isMDXComponent=!0;const Rx={toc:[]};function Sx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Sx.isMDXComponent=!0;const zx={toc:[]};function Ix(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}Ix.isMDXComponent=!0;const Wx={toc:[]};function Px(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Px.isMDXComponent=!0;const Gx={toc:[]};function Fx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Fx.isMDXComponent=!0;const Ux={toc:[]};function jx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ux,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}jx.isMDXComponent=!0;const Vx={toc:[]};function Bx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Bx.isMDXComponent=!0;const qx={toc:[]};function Ox(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given position."))}Ox.isMDXComponent=!0;const $x={toc:[]};function Hx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$x,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The position in local space at which to sample the color."))}Hx.isMDXComponent=!0;const Yx={toc:[]};function Kx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given pixel."))}Kx.isMDXComponent=!0;const Jx={toc:[]};function Qx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The pixel's position."))}Qx.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}rC.isMDXComponent=!0;const cC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sC.isMDXComponent=!0;const aC={toc:[]};function lC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}lC.isMDXComponent=!0;const iC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}dC.isMDXComponent=!0;const hC={toc:[]};function kC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}kC.isMDXComponent=!0;const yC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}fC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}DC.isMDXComponent=!0;const wC={toc:[]};function _C(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}gC.isMDXComponent=!0;const xC={toc:[]};function CC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}CC.isMDXComponent=!0;const TC={toc:[]};function LC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}LC.isMDXComponent=!0;const ZC={toc:[]};function vC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}vC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}NC.isMDXComponent=!0;const EC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}AC.isMDXComponent=!0;const RC={toc:[]};function SC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}SC.isMDXComponent=!0;const zC={toc:[]};function IC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}IC.isMDXComponent=!0;const WC={toc:[]};function PC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}PC.isMDXComponent=!0;const GC={toc:[]};function FC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}FC.isMDXComponent=!0;const UC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}jC.isMDXComponent=!0;const VC={toc:[]};function BC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}BC.isMDXComponent=!0;const qC={toc:[]};function OC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}OC.isMDXComponent=!0;const $C={toc:[]};function HC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$C,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}HC.isMDXComponent=!0;const YC={toc:[]};function KC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}KC.isMDXComponent=!0;const JC={toc:[]};function QC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}QC.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}rT.isMDXComponent=!0;const cT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}sT.isMDXComponent=!0;const aT={toc:[]};function lT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}lT.isMDXComponent=!0;const iT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}dT.isMDXComponent=!0;const hT={toc:[]};function kT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}kT.isMDXComponent=!0;const yT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}fT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}DT.isMDXComponent=!0;const wT={toc:[]};function _T(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gT.isMDXComponent=!0;const xT={toc:[]};function CT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}CT.isMDXComponent=!0;const TT={toc:[]};function LT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}LT.isMDXComponent=!0;const ZT={toc:[]};function vT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}vT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NT.isMDXComponent=!0;const ET={toc:[]};function AT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ET,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}AT.isMDXComponent=!0;const RT={toc:[]};function ST(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ST.isMDXComponent=!0;const zT={toc:[]};function IT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}IT.isMDXComponent=!0;const WT={toc:[]};function PT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}PT.isMDXComponent=!0;const GT={toc:[]};function FT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FT.isMDXComponent=!0;const UT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}jT.isMDXComponent=!0;const VT={toc:[]};function BT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}BT.isMDXComponent=!0;const qT={toc:[]};function OT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}OT.isMDXComponent=!0;const $T={toc:[]};function HT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$T,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}HT.isMDXComponent=!0;const YT={toc:[]};function KT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}KT.isMDXComponent=!0;const JT={toc:[]};function QT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}QT.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}rL.isMDXComponent=!0;const cL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}sL.isMDXComponent=!0;const aL={toc:[]};function lL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}lL.isMDXComponent=!0;const iL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}dL.isMDXComponent=!0;const hL={toc:[]};function kL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}kL.isMDXComponent=!0;const yL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}fL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ML,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}DL.isMDXComponent=!0;const wL={toc:[]};function _L(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}gL.isMDXComponent=!0;const xL={toc:[]};function CL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}CL.isMDXComponent=!0;const TL={toc:[]};function LL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}LL.isMDXComponent=!0;const ZL={toc:[]};function vL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}vL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}NL.isMDXComponent=!0;const EL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}AL.isMDXComponent=!0;const RL={toc:[]};function SL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}SL.isMDXComponent=!0;const zL={toc:[]};function IL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}IL.isMDXComponent=!0;const WL={toc:[]};function PL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}PL.isMDXComponent=!0;const GL={toc:[]};function FL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}FL.isMDXComponent=!0;const UL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}jL.isMDXComponent=!0;const VL={toc:[]};function BL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}BL.isMDXComponent=!0;const qL={toc:[]};function OL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}OL.isMDXComponent=!0;const $L={toc:[]};function HL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$L,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}HL.isMDXComponent=!0;const YL={toc:[]};function KL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}KL.isMDXComponent=!0;const JL={toc:[]};function QL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}QL.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}rZ.isMDXComponent=!0;const cZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function lZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}lZ.isMDXComponent=!0;const iZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function kZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}kZ.isMDXComponent=!0;const yZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}fZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}DZ.isMDXComponent=!0;const wZ={toc:[]};function _Z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}gZ.isMDXComponent=!0;const xZ={toc:[]};function CZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}CZ.isMDXComponent=!0;const TZ={toc:[]};function LZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function vZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}vZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}NZ.isMDXComponent=!0;const EZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}AZ.isMDXComponent=!0;const RZ={toc:[]};function SZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}SZ.isMDXComponent=!0;const zZ={toc:[]};function IZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}IZ.isMDXComponent=!0;const WZ={toc:[]};function PZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}PZ.isMDXComponent=!0;const GZ={toc:[]};function FZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}FZ.isMDXComponent=!0;const UZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}jZ.isMDXComponent=!0;const VZ={toc:[]};function BZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}BZ.isMDXComponent=!0;const qZ={toc:[]};function OZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}OZ.isMDXComponent=!0;const $Z={toc:[]};function HZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$Z,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}HZ.isMDXComponent=!0;const YZ={toc:[]};function KZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}KZ.isMDXComponent=!0;const JZ={toc:[]};function QZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}QZ.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}rv.isMDXComponent=!0;const cv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}sv.isMDXComponent=!0;const av={toc:[]};function lv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}lv.isMDXComponent=!0;const iv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}dv.isMDXComponent=!0;const hv={toc:[]};function kv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}kv.isMDXComponent=!0;const yv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}fv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Dv.isMDXComponent=!0;const wv={toc:[]};function _v(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}gv.isMDXComponent=!0;const xv={toc:[]};function Cv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}Cv.isMDXComponent=!0;const Tv={toc:[]};function Lv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function vv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}vv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Nv.isMDXComponent=!0;const Ev={toc:[]};function Av(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ev,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}Av.isMDXComponent=!0;const Rv={toc:[]};function Sv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Sv.isMDXComponent=!0;const zv={toc:[]};function Iv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}Iv.isMDXComponent=!0;const Wv={toc:[]};function Pv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}Pv.isMDXComponent=!0;const Gv={toc:[]};function Fv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}Fv.isMDXComponent=!0;const Uv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}jv.isMDXComponent=!0;const Vv={toc:[]};function Bv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Bv.isMDXComponent=!0;const qv={toc:[]};function Ov(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Ov.isMDXComponent=!0;const $v={toc:[]};function Hv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$v,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}Hv.isMDXComponent=!0;const Yv={toc:[]};function Kv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Kv.isMDXComponent=!0;const Jv={toc:[]};function Qv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Qv.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rb.isMDXComponent=!0;const cb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}sb.isMDXComponent=!0;const ab={toc:[]};function lb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lb.isMDXComponent=!0;const ib={toc:[]};function ub(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ib,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}db.isMDXComponent=!0;const hb={toc:[]};function kb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}kb.isMDXComponent=!0;const yb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}Db.isMDXComponent=!0;const wb={toc:[]};function _b(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}gb.isMDXComponent=!0;const xb={toc:[]};function Cb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}Cb.isMDXComponent=!0;const Tb={toc:[]};function Lb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function vb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}vb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Nb.isMDXComponent=!0;const Eb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}Ab.isMDXComponent=!0;const Rb={toc:[]};function Sb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Sb.isMDXComponent=!0;const zb={toc:[]};function Ib(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Ib.isMDXComponent=!0;const Wb={toc:[]};function Pb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Pb.isMDXComponent=!0;const Gb={toc:[]};function Fb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}Fb.isMDXComponent=!0;const Ub={toc:[]};function jb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ub,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}jb.isMDXComponent=!0;const Vb={toc:[]};function Bb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}Bb.isMDXComponent=!0;const qb={toc:[]};function Ob(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}Ob.isMDXComponent=!0;const $b={toc:[]};function Hb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$b,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}Hb.isMDXComponent=!0;const Yb={toc:[]};function Kb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Kb.isMDXComponent=!0;const Jb={toc:[]};function Qb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Qb.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}rN.isMDXComponent=!0;const cN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}sN.isMDXComponent=!0;const aN={toc:[]};function lN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}lN.isMDXComponent=!0;const iN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}dN.isMDXComponent=!0;const hN={toc:[]};function kN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}kN.isMDXComponent=!0;const yN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}fN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DN.isMDXComponent=!0;const wN={toc:[]};function _N(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}gN.isMDXComponent=!0;const xN={toc:[]};function CN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}CN.isMDXComponent=!0;const TN={toc:[]};function LN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LN.isMDXComponent=!0;const ZN={toc:[]};function vN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}vN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}NN.isMDXComponent=!0;const EN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}AN.isMDXComponent=!0;const RN={toc:[]};function SN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}SN.isMDXComponent=!0;const zN={toc:[]};function IN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}IN.isMDXComponent=!0;const WN={toc:[]};function PN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}PN.isMDXComponent=!0;const GN={toc:[]};function FN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FN.isMDXComponent=!0;const UN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}jN.isMDXComponent=!0;const VN={toc:[]};function BN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}BN.isMDXComponent=!0;const qN={toc:[]};function ON(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}ON.isMDXComponent=!0;const $N={toc:[]};function HN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$N,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}HN.isMDXComponent=!0;const YN={toc:[]};function KN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}KN.isMDXComponent=!0;const JN={toc:[]};function QN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}QN.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}rE.isMDXComponent=!0;const cE={toc:[]};function sE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sE.isMDXComponent=!0;const aE={toc:[]};function lE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lE.isMDXComponent=!0;const iE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}dE.isMDXComponent=!0;const hE={toc:[]};function kE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}kE.isMDXComponent=!0;const yE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}fE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ME,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}DE.isMDXComponent=!0;const wE={toc:[]};function _E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gE.isMDXComponent=!0;const xE={toc:[]};function CE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}CE.isMDXComponent=!0;const TE={toc:[]};function LE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}LE.isMDXComponent=!0;const ZE={toc:[]};function vE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}vE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}NE.isMDXComponent=!0;const EE={toc:[]};function AE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}AE.isMDXComponent=!0;const RE={toc:[]};function SE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}SE.isMDXComponent=!0;const zE={toc:[]};function IE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}IE.isMDXComponent=!0;const WE={toc:[]};function PE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}PE.isMDXComponent=!0;const GE={toc:[]};function FE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}FE.isMDXComponent=!0;const UE={toc:[]};function jE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}jE.isMDXComponent=!0;const VE={toc:[]};function BE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}BE.isMDXComponent=!0;const qE={toc:[]};function OE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}OE.isMDXComponent=!0;const $E={toc:[]};function HE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$E,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}HE.isMDXComponent=!0;const YE={toc:[]};function KE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}KE.isMDXComponent=!0;const JE={toc:[]};function QE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}QE.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}rA.isMDXComponent=!0;const cA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}sA.isMDXComponent=!0;const aA={toc:[]};function lA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}lA.isMDXComponent=!0;const iA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}dA.isMDXComponent=!0;const hA={toc:[]};function kA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}kA.isMDXComponent=!0;const yA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}fA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}DA.isMDXComponent=!0;const wA={toc:[]};function _A(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}gA.isMDXComponent=!0;const xA={toc:[]};function CA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}CA.isMDXComponent=!0;const TA={toc:[]};function LA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}LA.isMDXComponent=!0;const ZA={toc:[]};function vA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}vA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}NA.isMDXComponent=!0;const EA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}AA.isMDXComponent=!0;const RA={toc:[]};function SA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}SA.isMDXComponent=!0;const zA={toc:[]};function IA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}IA.isMDXComponent=!0;const WA={toc:[]};function PA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}PA.isMDXComponent=!0;const GA={toc:[]};function FA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}FA.isMDXComponent=!0;const UA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}jA.isMDXComponent=!0;const VA={toc:[]};function BA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}BA.isMDXComponent=!0;const qA={toc:[]};function OA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}OA.isMDXComponent=!0;const $A={toc:[]};function HA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$A,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}HA.isMDXComponent=!0;const YA={toc:[]};function KA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}KA.isMDXComponent=!0;const JA={toc:[]};function QA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}QA.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}rR.isMDXComponent=!0;const cR={toc:[]};function sR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}sR.isMDXComponent=!0;const aR={toc:[]};function lR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}lR.isMDXComponent=!0;const iR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}dR.isMDXComponent=!0;const hR={toc:[]};function kR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}kR.isMDXComponent=!0;const yR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}fR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}DR.isMDXComponent=!0;const wR={toc:[]};function _R(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}gR.isMDXComponent=!0;const xR={toc:[]};function CR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}CR.isMDXComponent=!0;const TR={toc:[]};function LR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}LR.isMDXComponent=!0;const ZR={toc:[]};function vR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}vR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}NR.isMDXComponent=!0;const ER={toc:[]};function AR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ER,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}AR.isMDXComponent=!0;const RR={toc:[]};function SR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}SR.isMDXComponent=!0;const zR={toc:[]};function IR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}IR.isMDXComponent=!0;const WR={toc:[]};function PR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}PR.isMDXComponent=!0;const GR={toc:[]};function FR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}FR.isMDXComponent=!0;const UR={toc:[]};function jR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}jR.isMDXComponent=!0;const VR={toc:[]};function BR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}BR.isMDXComponent=!0;const qR={toc:[]};function OR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}OR.isMDXComponent=!0;const $R={toc:[]};function HR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$R,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}HR.isMDXComponent=!0;const YR={toc:[]};function KR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}KR.isMDXComponent=!0;const JR={toc:[]};function QR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}QR.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}rS.isMDXComponent=!0;const cS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}sS.isMDXComponent=!0;const aS={toc:[]};function lS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}lS.isMDXComponent=!0;const iS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}dS.isMDXComponent=!0;const hS={toc:[]};function kS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}kS.isMDXComponent=!0;const yS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}fS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}DS.isMDXComponent=!0;const wS={toc:[]};function _S(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}gS.isMDXComponent=!0;const xS={toc:[]};function CS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}CS.isMDXComponent=!0;const TS={toc:[]};function LS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}LS.isMDXComponent=!0;const ZS={toc:[]};function vS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}vS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}NS.isMDXComponent=!0;const ES={toc:[]};function AS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ES,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}AS.isMDXComponent=!0;const RS={toc:[]};function SS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}SS.isMDXComponent=!0;const zS={toc:[]};function IS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}IS.isMDXComponent=!0;const WS={toc:[]};function PS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}PS.isMDXComponent=!0;const GS={toc:[]};function FS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}FS.isMDXComponent=!0;const US={toc:[]};function jS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},US,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}jS.isMDXComponent=!0;const VS={toc:[]};function BS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}BS.isMDXComponent=!0;const qS={toc:[]};function OS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}OS.isMDXComponent=!0;const $S={toc:[]};function HS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$S,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}HS.isMDXComponent=!0;const YS={toc:[]};function KS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}KS.isMDXComponent=!0;const JS={toc:[]};function QS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}QS.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}rz.isMDXComponent=!0;const cz={toc:[]};function sz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sz.isMDXComponent=!0;const az={toc:[]};function lz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},az,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}lz.isMDXComponent=!0;const iz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}dz.isMDXComponent=!0;const hz={toc:[]};function kz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kz.isMDXComponent=!0;const yz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}fz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Dz.isMDXComponent=!0;const wz={toc:[]};function _z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}gz.isMDXComponent=!0;const xz={toc:[]};function Cz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}Cz.isMDXComponent=!0;const Tz={toc:[]};function Lz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Lz.isMDXComponent=!0;const Zz={toc:[]};function vz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}vz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Nz.isMDXComponent=!0;const Ez={toc:[]};function Az(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ez,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}Az.isMDXComponent=!0;const Rz={toc:[]};function Sz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}Sz.isMDXComponent=!0;const zz={toc:[]};function Iz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Iz.isMDXComponent=!0;const Wz={toc:[]};function Pz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Pz.isMDXComponent=!0;const Gz={toc:[]};function Fz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}Fz.isMDXComponent=!0;const Uz={toc:[]};function jz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jz.isMDXComponent=!0;const Vz={toc:[]};function Bz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Bz.isMDXComponent=!0;const qz={toc:[]};function Oz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Oz.isMDXComponent=!0;const $z={toc:[]};function Hz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$z,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Hz.isMDXComponent=!0;const Yz={toc:[]};function Kz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Kz.isMDXComponent=!0;const Jz={toc:[]};function Qz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Qz.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}rI.isMDXComponent=!0;const cI={toc:[]};function sI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}sI.isMDXComponent=!0;const aI={toc:[]};function lI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}lI.isMDXComponent=!0;const iI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}dI.isMDXComponent=!0;const hI={toc:[]};function kI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}kI.isMDXComponent=!0;const yI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}fI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}DI.isMDXComponent=!0;const wI={toc:[]};function _I(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}gI.isMDXComponent=!0;const xI={toc:[]};function CI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}CI.isMDXComponent=!0;const TI={toc:[]};function LI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}LI.isMDXComponent=!0;const ZI={toc:[]};function vI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}NI.isMDXComponent=!0;const EI={toc:[]};function AI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}AI.isMDXComponent=!0;const RI={toc:[]};function SI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}SI.isMDXComponent=!0;const zI={toc:[]};function II(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}II.isMDXComponent=!0;const WI={toc:[]};function PI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}PI.isMDXComponent=!0;const GI={toc:[]};function FI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}FI.isMDXComponent=!0;const UI={toc:[]};function jI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jI.isMDXComponent=!0;const VI={toc:[]};function BI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}BI.isMDXComponent=!0;const qI={toc:[]};function OI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}OI.isMDXComponent=!0;const $I={toc:[]};function HI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$I,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}HI.isMDXComponent=!0;const YI={toc:[]};function KI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}KI.isMDXComponent=!0;const JI={toc:[]};function QI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}QI.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}rW.isMDXComponent=!0;const cW={toc:[]};function sW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}sW.isMDXComponent=!0;const aW={toc:[]};function lW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}lW.isMDXComponent=!0;const iW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dW.isMDXComponent=!0;const hW={toc:[]};function kW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}kW.isMDXComponent=!0;const yW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}fW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}DW.isMDXComponent=!0;const wW={toc:[]};function _W(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}gW.isMDXComponent=!0;const xW={toc:[]};function CW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}CW.isMDXComponent=!0;const TW={toc:[]};function LW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}LW.isMDXComponent=!0;const ZW={toc:[]};function vW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}vW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}NW.isMDXComponent=!0;const EW={toc:[]};function AW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}AW.isMDXComponent=!0;const RW={toc:[]};function SW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}SW.isMDXComponent=!0;const zW={toc:[]};function IW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}IW.isMDXComponent=!0;const WW={toc:[]};function PW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}PW.isMDXComponent=!0;const GW={toc:[]};function FW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}FW.isMDXComponent=!0;const UW={toc:[]};function jW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}jW.isMDXComponent=!0;const VW={toc:[]};function BW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}BW.isMDXComponent=!0;const qW={toc:[]};function OW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}OW.isMDXComponent=!0;const $W={toc:[]};function HW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$W,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}HW.isMDXComponent=!0;const YW={toc:[]};function KW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}KW.isMDXComponent=!0;const JW={toc:[]};function QW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}QW.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}rP.isMDXComponent=!0;const cP={toc:[]};function sP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}sP.isMDXComponent=!0;const aP={toc:[]};function lP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}lP.isMDXComponent=!0;const iP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}dP.isMDXComponent=!0;const hP={toc:[]};function kP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}kP.isMDXComponent=!0;const yP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}fP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}DP.isMDXComponent=!0;const wP={toc:[]};function _P(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}gP.isMDXComponent=!0;const xP={toc:[]};function CP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}CP.isMDXComponent=!0;const TP={toc:[]};function LP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}LP.isMDXComponent=!0;const ZP={toc:[]};function vP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}NP.isMDXComponent=!0;const EP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}AP.isMDXComponent=!0;const RP={toc:[]};function SP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}SP.isMDXComponent=!0;const zP={toc:[]};function IP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}IP.isMDXComponent=!0;const WP={toc:[]};function PP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}PP.isMDXComponent=!0;const GP={toc:[]};function FP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}FP.isMDXComponent=!0;const UP={toc:[]};function jP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}jP.isMDXComponent=!0;const VP={toc:[]};function BP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}BP.isMDXComponent=!0;const qP={toc:[]};function OP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}OP.isMDXComponent=!0;const $P={toc:[]};function HP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$P,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}HP.isMDXComponent=!0;const YP={toc:[]};function KP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}KP.isMDXComponent=!0;const JP={toc:[]};function QP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}QP.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}rG.isMDXComponent=!0;const cG={toc:[]};function sG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}sG.isMDXComponent=!0;const aG={toc:[]};function lG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}lG.isMDXComponent=!0;const iG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}dG.isMDXComponent=!0;const hG={toc:[]};function kG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}kG.isMDXComponent=!0;const yG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}fG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}DG.isMDXComponent=!0;const wG={toc:[]};function _G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}gG.isMDXComponent=!0;const xG={toc:[]};function CG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}CG.isMDXComponent=!0;const TG={toc:[]};function LG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}LG.isMDXComponent=!0;const ZG={toc:[]};function vG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}NG.isMDXComponent=!0;const EG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}AG.isMDXComponent=!0;const RG={toc:[]};function SG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}SG.isMDXComponent=!0;const zG={toc:[]};function IG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}IG.isMDXComponent=!0;const WG={toc:[]};function PG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}PG.isMDXComponent=!0;const GG={toc:[]};function FG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}FG.isMDXComponent=!0;const UG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}jG.isMDXComponent=!0;const VG={toc:[]};function BG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}BG.isMDXComponent=!0;const qG={toc:[]};function OG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}OG.isMDXComponent=!0;const $G={toc:[]};function HG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$G,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}HG.isMDXComponent=!0;const YG={toc:[]};function KG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}KG.isMDXComponent=!0;const JG={toc:[]};function QG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}QG.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}rF.isMDXComponent=!0;const cF={toc:[]};function sF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}sF.isMDXComponent=!0;const aF={toc:[]};function lF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}lF.isMDXComponent=!0;const iF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}dF.isMDXComponent=!0;const hF={toc:[]};function kF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}kF.isMDXComponent=!0;const yF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}fF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}DF.isMDXComponent=!0;const wF={toc:[]};function _F(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}gF.isMDXComponent=!0;const xF={toc:[]};function CF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}CF.isMDXComponent=!0;const TF={toc:[]};function LF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}LF.isMDXComponent=!0;const ZF={toc:[]};function vF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}vF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}NF.isMDXComponent=!0;const EF={toc:[]};function AF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}AF.isMDXComponent=!0;const RF={toc:[]};function SF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}SF.isMDXComponent=!0;const zF={toc:[]};function IF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}IF.isMDXComponent=!0;const WF={toc:[]};function PF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}PF.isMDXComponent=!0;const GF={toc:[]};function FF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}FF.isMDXComponent=!0;const UF={toc:[]};function jF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}jF.isMDXComponent=!0;const VF={toc:[]};function BF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}BF.isMDXComponent=!0;const qF={toc:[]};function OF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}OF.isMDXComponent=!0;const $F={toc:[]};function HF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$F,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}HF.isMDXComponent=!0;const YF={toc:[]};function KF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}KF.isMDXComponent=!0;const JF={toc:[]};function QF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}QF.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}rU.isMDXComponent=!0;const cU={toc:[]};function sU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}sU.isMDXComponent=!0;const aU={toc:[]};function lU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}lU.isMDXComponent=!0;const iU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dU.isMDXComponent=!0;const hU={toc:[]};function kU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}kU.isMDXComponent=!0;const yU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}fU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}DU.isMDXComponent=!0;const wU={toc:[]};function _U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}gU.isMDXComponent=!0;const xU={toc:[]};function CU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}CU.isMDXComponent=!0;const TU={toc:[]};function LU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}LU.isMDXComponent=!0;const ZU={toc:[]};function vU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}vU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}NU.isMDXComponent=!0;const EU={toc:[]};function AU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}AU.isMDXComponent=!0;const RU={toc:[]};function SU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}SU.isMDXComponent=!0;const zU={toc:[]};function IU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}IU.isMDXComponent=!0;const WU={toc:[]};function PU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}PU.isMDXComponent=!0;const GU={toc:[]};function FU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}FU.isMDXComponent=!0;const UU={toc:[]};function jU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}jU.isMDXComponent=!0;const VU={toc:[]};function BU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}BU.isMDXComponent=!0;const qU={toc:[]};function OU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}OU.isMDXComponent=!0;const $U={toc:[]};function HU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$U,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}HU.isMDXComponent=!0;const YU={toc:[]};function KU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}KU.isMDXComponent=!0;const JU={toc:[]};function QU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}QU.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}rj.isMDXComponent=!0;const cj={toc:[]};function sj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}sj.isMDXComponent=!0;const aj={toc:[]};function lj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}lj.isMDXComponent=!0;const ij={toc:[]};function uj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ij,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}dj.isMDXComponent=!0;const hj={toc:[]};function kj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}kj.isMDXComponent=!0;const yj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}fj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}Dj.isMDXComponent=!0;const wj={toc:[]};function _j(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}gj.isMDXComponent=!0;const xj={toc:[]};function Cj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Cj.isMDXComponent=!0;const Tj={toc:[]};function Lj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function vj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}vj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Nj.isMDXComponent=!0;const Ej={toc:[]};function Aj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ej,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Aj.isMDXComponent=!0;const Rj={toc:[]};function Sj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}Sj.isMDXComponent=!0;const zj={toc:[]};function Ij(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ij.isMDXComponent=!0;const Wj={toc:[]};function Pj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Pj.isMDXComponent=!0;const Gj={toc:[]};function Fj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}Fj.isMDXComponent=!0;const Uj={toc:[]};function jj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jj.isMDXComponent=!0;const Vj={toc:[]};function Bj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Bj.isMDXComponent=!0;const qj={toc:[]};function Oj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Oj.isMDXComponent=!0;const $j={toc:[]};function Hj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$j,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Hj.isMDXComponent=!0;const Yj={toc:[]};function Kj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Kj.isMDXComponent=!0;const Jj={toc:[]};function Qj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}Qj.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}rV.isMDXComponent=!0;const cV={toc:[]};function sV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}sV.isMDXComponent=!0;const aV={toc:[]};function lV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}lV.isMDXComponent=!0;const iV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}dV.isMDXComponent=!0;const hV={toc:[]};function kV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}kV.isMDXComponent=!0;const yV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}fV.isMDXComponent=!0;const MV={toc:[]};function DV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}DV.isMDXComponent=!0;const wV={toc:[]};function _V(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}gV.isMDXComponent=!0;const xV={toc:[]};function CV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}CV.isMDXComponent=!0;const TV={toc:[]};function LV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}LV.isMDXComponent=!0;const ZV={toc:[]};function vV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}vV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}NV.isMDXComponent=!0;const EV={toc:[]};function AV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}AV.isMDXComponent=!0;const RV={toc:[]};function SV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}SV.isMDXComponent=!0;const zV={toc:[]};function IV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}IV.isMDXComponent=!0;const WV={toc:[]};function PV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}PV.isMDXComponent=!0;const GV={toc:[]};function FV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}FV.isMDXComponent=!0;const UV={toc:[]};function jV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}jV.isMDXComponent=!0;const VV={toc:[]};function BV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}BV.isMDXComponent=!0;const qV={toc:[]};function OV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}OV.isMDXComponent=!0;const $V={toc:[]};function HV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$V,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}HV.isMDXComponent=!0;const YV={toc:[]};function KV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}KV.isMDXComponent=!0;const JV={toc:[]};function QV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}QV.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}rB.isMDXComponent=!0;const cB={toc:[]};function sB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sB.isMDXComponent=!0;const aB={toc:[]};function lB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}lB.isMDXComponent=!0;const iB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}dB.isMDXComponent=!0;const hB={toc:[]};function kB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}kB.isMDXComponent=!0;const yB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}fB.isMDXComponent=!0;const MB={toc:[]};function DB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}DB.isMDXComponent=!0;const wB={toc:[]};function _B(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}gB.isMDXComponent=!0;const xB={toc:[]};function CB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}CB.isMDXComponent=!0;const TB={toc:[]};function LB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}LB.isMDXComponent=!0;const ZB={toc:[]};function vB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}vB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}NB.isMDXComponent=!0;const EB={toc:[]};function AB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}AB.isMDXComponent=!0;const RB={toc:[]};function SB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}SB.isMDXComponent=!0;const zB={toc:[]};function IB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}IB.isMDXComponent=!0;const WB={toc:[]};function PB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}PB.isMDXComponent=!0;const GB={toc:[]};function FB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}FB.isMDXComponent=!0;const UB={toc:[]};function jB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}jB.isMDXComponent=!0;const VB={toc:[]};function BB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}BB.isMDXComponent=!0;const qB={toc:[]};function OB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}OB.isMDXComponent=!0;const $B={toc:[]};function HB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$B,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}HB.isMDXComponent=!0;const YB={toc:[]};function KB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}KB.isMDXComponent=!0;const JB={toc:[]};function QB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QB.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}rq.isMDXComponent=!0;const cq={toc:[]};function sq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sq.isMDXComponent=!0;const aq={toc:[]};function lq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}lq.isMDXComponent=!0;const iq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dq.isMDXComponent=!0;const hq={toc:[]};function kq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}kq.isMDXComponent=!0;const yq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}fq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Dq.isMDXComponent=!0;const wq={toc:[]};function _q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}gq.isMDXComponent=!0;const xq={toc:[]};function Cq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}Cq.isMDXComponent=!0;const Tq={toc:[]};function Lq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function vq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}vq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Nq.isMDXComponent=!0;const Eq={toc:[]};function Aq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}Aq.isMDXComponent=!0;const Rq={toc:[]};function Sq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Sq.isMDXComponent=!0;const zq={toc:[]};function Iq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}Iq.isMDXComponent=!0;const Wq={toc:[]};function Pq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Pq.isMDXComponent=!0;const Gq={toc:[]};function Fq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}Fq.isMDXComponent=!0;const Uq={toc:[]};function jq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}jq.isMDXComponent=!0;const Vq={toc:[]};function Bq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}Bq.isMDXComponent=!0;const qq={toc:[]};function Oq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}Oq.isMDXComponent=!0;const $q={toc:[]};function Hq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$q,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}Hq.isMDXComponent=!0;const Yq={toc:[]};function Kq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Kq.isMDXComponent=!0;const Jq={toc:[]};function Qq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Qq.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}rO.isMDXComponent=!0;const cO={toc:[]};function sO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}sO.isMDXComponent=!0;const aO={toc:[]};function lO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}lO.isMDXComponent=!0;const iO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}dO.isMDXComponent=!0;const hO={toc:[]};function kO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}kO.isMDXComponent=!0;const yO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}fO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}DO.isMDXComponent=!0;const wO={toc:[]};function _O(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}gO.isMDXComponent=!0;const xO={toc:[]};function CO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}CO.isMDXComponent=!0;const TO={toc:[]};function LO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}LO.isMDXComponent=!0;const ZO={toc:[]};function vO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}vO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}NO.isMDXComponent=!0;const EO={toc:[]};function AO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}AO.isMDXComponent=!0;const RO={toc:[]};function SO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}SO.isMDXComponent=!0;const zO={toc:[]};function IO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}IO.isMDXComponent=!0;const WO={toc:[]};function PO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}PO.isMDXComponent=!0;const GO={toc:[]};function FO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}FO.isMDXComponent=!0;const UO={toc:[]};function jO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}jO.isMDXComponent=!0;const VO={toc:[]};function BO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}BO.isMDXComponent=!0;const qO={toc:[]};function OO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}OO.isMDXComponent=!0;const $O={toc:[]};function HO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$O,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}HO.isMDXComponent=!0;const YO={toc:[]};function KO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}KO.isMDXComponent=!0;const JO={toc:[]};function QO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}QO.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}r$.isMDXComponent=!0;const c$={toc:[]};function s$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}s$.isMDXComponent=!0;const a$={toc:[]};function l$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}l$.isMDXComponent=!0;const i$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},i$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}d$.isMDXComponent=!0;const h$={toc:[]};function k$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}k$.isMDXComponent=!0;const y$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}f$.isMDXComponent=!0;const M$={toc:[]};function D$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}D$.isMDXComponent=!0;const w$={toc:[]};function _$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}g$.isMDXComponent=!0;const x$={toc:[]};function C$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}C$.isMDXComponent=!0;const T$={toc:[]};function L$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}L$.isMDXComponent=!0;const Z$={toc:[]};function v$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}v$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}N$.isMDXComponent=!0;const E$={toc:[]};function A$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}A$.isMDXComponent=!0;const R$={toc:[]};function S$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}S$.isMDXComponent=!0;const z$={toc:[]};function I$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}I$.isMDXComponent=!0;const W$={toc:[]};function P$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}P$.isMDXComponent=!0;const G$={toc:[]};function F$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}F$.isMDXComponent=!0;const U$={toc:[]};function j$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}j$.isMDXComponent=!0;const V$={toc:[]};function B$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},V$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}B$.isMDXComponent=!0;const q$={toc:[]};function O$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}O$.isMDXComponent=!0;const $$={toc:[]};function H$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}H$.isMDXComponent=!0;const Y$={toc:[]};function K$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}K$.isMDXComponent=!0;const J$={toc:[]};function Q$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},J$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Q$.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}rH.isMDXComponent=!0;const cH={toc:[]};function sH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}sH.isMDXComponent=!0;const aH={toc:[]};function lH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}lH.isMDXComponent=!0;const iH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}dH.isMDXComponent=!0;const hH={toc:[]};function kH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}kH.isMDXComponent=!0;const yH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}fH.isMDXComponent=!0;const MH={toc:[]};function DH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}DH.isMDXComponent=!0;const wH={toc:[]};function _H(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}gH.isMDXComponent=!0;const xH={toc:[]};function CH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}CH.isMDXComponent=!0;const TH={toc:[]};function LH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LH.isMDXComponent=!0;const ZH={toc:[]};function vH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}vH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NH.isMDXComponent=!0;const EH={toc:[]};function AH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}AH.isMDXComponent=!0;const RH={toc:[]};function SH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}SH.isMDXComponent=!0;const zH={toc:[]};function IH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IH.isMDXComponent=!0;const WH={toc:[]};function PH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}PH.isMDXComponent=!0;const GH={toc:[]};function FH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}FH.isMDXComponent=!0;const UH={toc:[]};function jH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}jH.isMDXComponent=!0;const VH={toc:[]};function BH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}BH.isMDXComponent=!0;const qH={toc:[]};function OH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}OH.isMDXComponent=!0;const $H={toc:[]};function HH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$H,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}HH.isMDXComponent=!0;const YH={toc:[]};function KH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}KH.isMDXComponent=!0;const JH={toc:[]};function QH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}QH.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}rY.isMDXComponent=!0;const cY={toc:[]};function sY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}sY.isMDXComponent=!0;const aY={toc:[]};function lY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}lY.isMDXComponent=!0;const iY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dY.isMDXComponent=!0;const hY={toc:[]};function kY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}kY.isMDXComponent=!0;const yY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}fY.isMDXComponent=!0;const MY={toc:[]};function DY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}DY.isMDXComponent=!0;const wY={toc:[]};function _Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}gY.isMDXComponent=!0;const xY={toc:[]};function CY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}CY.isMDXComponent=!0;const TY={toc:[]};function LY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}LY.isMDXComponent=!0;const ZY={toc:[]};function vY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}vY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}NY.isMDXComponent=!0;const EY={toc:[]};function AY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}AY.isMDXComponent=!0;const RY={toc:[]};function SY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}SY.isMDXComponent=!0;const zY={toc:[]};function IY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}IY.isMDXComponent=!0;const WY={toc:[]};function PY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}PY.isMDXComponent=!0;const GY={toc:[]};function FY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}FY.isMDXComponent=!0;const UY={toc:[]};function jY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}jY.isMDXComponent=!0;const VY={toc:[]};function BY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}BY.isMDXComponent=!0;const qY={toc:[]};function OY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}OY.isMDXComponent=!0;const $Y={toc:[]};function HY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$Y,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}HY.isMDXComponent=!0;const YY={toc:[]};function KY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}KY.isMDXComponent=!0;const JY={toc:[]};function QY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}QY.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}rK.isMDXComponent=!0;const cK={toc:[]};function sK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}sK.isMDXComponent=!0;const aK={toc:[]};function lK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}lK.isMDXComponent=!0;const iK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}dK.isMDXComponent=!0;const hK={toc:[]};function kK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}kK.isMDXComponent=!0;const yK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}fK.isMDXComponent=!0;const MK={toc:[]};function DK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}DK.isMDXComponent=!0;const wK={toc:[]};function _K(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}gK.isMDXComponent=!0;const xK={toc:[]};function CK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}CK.isMDXComponent=!0;const TK={toc:[]};function LK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}LK.isMDXComponent=!0;const ZK={toc:[]};function vK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}NK.isMDXComponent=!0;const EK={toc:[]};function AK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}AK.isMDXComponent=!0;const RK={toc:[]};function SK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}SK.isMDXComponent=!0;const zK={toc:[]};function IK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}IK.isMDXComponent=!0;const WK={toc:[]};function PK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the width, and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}PK.isMDXComponent=!0;const GK={toc:[]};function FK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}FK.isMDXComponent=!0;const UK={toc:[]};function jK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}jK.isMDXComponent=!0;const VK={toc:[]};function BK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}BK.isMDXComponent=!0;const qK={toc:[]};function OK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}OK.isMDXComponent=!0;const $K={toc:[]};function HK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$K,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}HK.isMDXComponent=!0;const YK={toc:[]};function KK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}KK.isMDXComponent=!0;const JK={toc:[]};function QK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}QK.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}rJ.isMDXComponent=!0;const cJ={toc:[]};function sJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}sJ.isMDXComponent=!0;const aJ={toc:[]};function lJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lJ.isMDXComponent=!0;const iJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function kJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}kJ.isMDXComponent=!0;const yJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}fJ.isMDXComponent=!0;const MJ={toc:[]};function DJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}DJ.isMDXComponent=!0;const wJ={toc:[]};function _J(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}gJ.isMDXComponent=!0;const xJ={toc:[]};function CJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}CJ.isMDXComponent=!0;const TJ={toc:[]};function LJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}LJ.isMDXComponent=!0;const ZJ={toc:[]};function vJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}vJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}NJ.isMDXComponent=!0;const EJ={toc:[]};function AJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}AJ.isMDXComponent=!0;const RJ={toc:[]};function SJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}SJ.isMDXComponent=!0;const zJ={toc:[]};function IJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}IJ.isMDXComponent=!0;const WJ={toc:[]};function PJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}PJ.isMDXComponent=!0;const GJ={toc:[]};function FJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}FJ.isMDXComponent=!0;const UJ={toc:[]};function jJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jJ.isMDXComponent=!0;const VJ={toc:[]};function BJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}BJ.isMDXComponent=!0;const qJ={toc:[]};function OJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}OJ.isMDXComponent=!0;const $J={toc:[]};function HJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$J,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}HJ.isMDXComponent=!0;const YJ={toc:[]};function KJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}KJ.isMDXComponent=!0;const JJ={toc:[]};function QJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}QJ.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}rQ.isMDXComponent=!0;const cQ={toc:[]};function sQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}sQ.isMDXComponent=!0;const aQ={toc:[]};function lQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}lQ.isMDXComponent=!0;const iQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function kQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kQ.isMDXComponent=!0;const yQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}fQ.isMDXComponent=!0;const MQ={toc:[]};function DQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},MQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}DQ.isMDXComponent=!0;const wQ={toc:[]};function _Q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}gQ.isMDXComponent=!0;const xQ={toc:[]};function CQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}CQ.isMDXComponent=!0;const TQ={toc:[]};function LQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},TQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}LQ.isMDXComponent=!0;const ZQ={toc:[]};function vQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}vQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}NQ.isMDXComponent=!0;const EQ={toc:[]};function AQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}AQ.isMDXComponent=!0;const RQ={toc:[]};function SQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}SQ.isMDXComponent=!0;const zQ={toc:[]};function IQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}IQ.isMDXComponent=!0;const WQ={toc:[]};function PQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}PQ.isMDXComponent=!0;const GQ={toc:[]};function FQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}FQ.isMDXComponent=!0;const UQ={toc:[]};function jQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}jQ.isMDXComponent=!0;const VQ={toc:[]};function BQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},VQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}BQ.isMDXComponent=!0;const qQ={toc:[]};function OQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}OQ.isMDXComponent=!0;const $Q={toc:[]};function HQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$Q,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}HQ.isMDXComponent=!0;const YQ={toc:[]};function KQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}KQ.isMDXComponent=!0;const JQ={toc:[]};function QQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},JQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}QQ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}r0.isMDXComponent=!0;const c0={toc:[]};function s0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}s0.isMDXComponent=!0;const a0={toc:[]};function l0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}l0.isMDXComponent=!0;const i0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},i0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}d0.isMDXComponent=!0;const h0={toc:[]};function k0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}k0.isMDXComponent=!0;const y0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}f0.isMDXComponent=!0;const M0={toc:[]};function D0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}D0.isMDXComponent=!0;const w0={toc:[]};function _0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}g0.isMDXComponent=!0;const x0={toc:[]};function C0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}C0.isMDXComponent=!0;const T0={toc:[]};function L0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}L0.isMDXComponent=!0;const Z0={toc:[]};function v0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}v0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}N0.isMDXComponent=!0;const E0={toc:[]};function A0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}A0.isMDXComponent=!0;const R0={toc:[]};function S0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}S0.isMDXComponent=!0;const z0={toc:[]};function I0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}I0.isMDXComponent=!0;const W0={toc:[]};function P0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}P0.isMDXComponent=!0;const G0={toc:[]};function F0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}F0.isMDXComponent=!0;const U0={toc:[]};function j0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}j0.isMDXComponent=!0;const V0={toc:[]};function B0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},V0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}B0.isMDXComponent=!0;const q0={toc:[]};function O0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}O0.isMDXComponent=!0;const $0={toc:[]};function H0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}H0.isMDXComponent=!0;const Y0={toc:[]};function K0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}K0.isMDXComponent=!0;const J0={toc:[]};function Q0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},J0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Q0.isMDXComponent=!0;const t3={toc:[]};function n3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}n3.isMDXComponent=!0;const e3={toc:[]};function o3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,c.kt)("p",null,"By default, any property is cloneable."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}r3.isMDXComponent=!0;const c3={toc:[]};function s3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a cloneable property decorator."))}s3.isMDXComponent=!0;const a3={toc:[]};function l3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the property should be cloneable."))}l3.isMDXComponent=!0;const i3={toc:[]};function u3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},i3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}d3.isMDXComponent=!0;const h3={toc:[]};function k3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a compound property decorator."))}k3.isMDXComponent=!0;const y3={toc:[]};function f3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}f3.isMDXComponent=!0;const M3={toc:[]};function D3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,c.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,c.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}D3.isMDXComponent=!0;const w3={toc:[]};function _3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a computed method decorator."))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the initial value of a property."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}g3.isMDXComponent=!0;const x3={toc:[]};function C3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}C3.isMDXComponent=!0;const T3={toc:[]};function L3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an initial signal value decorator."))}L3.isMDXComponent=!0;const Z3={toc:[]};function v3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The initial value of the property."))}v3.isMDXComponent=!0;const b3={toc:[]};function N3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,c.kt)("p",null,"By default, any property is inspectable."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}N3.isMDXComponent=!0;const E3={toc:[]};function A3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}A3.isMDXComponent=!0;const R3={toc:[]};function S3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an inspectable property decorator."))}S3.isMDXComponent=!0;const z3={toc:[]};function I3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the property should be inspectable."))}I3.isMDXComponent=!0;const W3={toc:[]};function P3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}P3.isMDXComponent=!0;const G3={toc:[]};function F3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}F3.isMDXComponent=!0;const U3={toc:[]};function j3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal interpolation function decorator."))}j3.isMDXComponent=!0;const V3={toc:[]};function B3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},V3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The interpolation function for the property."))}B3.isMDXComponent=!0;const q3={toc:[]};function O3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,c.kt)("p",null,"If the wrapper class has a method called ",(0,c.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}O3.isMDXComponent=!0;const $3={toc:[]};function H3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}H3.isMDXComponent=!0;const Y3={toc:[]};function K3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal parser decorator."))}K3.isMDXComponent=!0;const J3={toc:[]};function Q3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},J3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The wrapper class for the property."))}Q3.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns the given property into a signal."),(0,c.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal decorator."))}r1.isMDXComponent=!0;const c1={toc:[]};function s1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,c.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,c.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,c.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,c.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}s1.isMDXComponent=!0;const a1={toc:[]};function l1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}l1.isMDXComponent=!0;const i1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},i1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal wrapper decorator."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The wrapper class for the property."))}d1.isMDXComponent=!0;const h1={toc:[]};function k1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A unified abstraction for all CSS filters."))}k1.isMDXComponent=!0;const y1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value can be either:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length (equivalent to ",(0,c.kt)("inlineCode",{parentName:"li"},"auto")," in CSS)")))}f1.isMDXComponent=!0;const M1={toc:[]};function D1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a length used by most layout properties."))}D1.isMDXComponent=!0;const w1={toc:[]};function _1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,c.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter in pixels."))}g1.isMDXComponent=!0;const x1={toc:[]};function C1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,c.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}C1.isMDXComponent=!0;const T1={toc:[]};function L1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}L1.isMDXComponent=!0;const Z1={toc:[]};function v1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,c.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}v1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}N1.isMDXComponent=!0;const E1={toc:[]};function A1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,c.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}A1.isMDXComponent=!0;const R1={toc:[]};function S1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}S1.isMDXComponent=!0;const z1={toc:[]};function I1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,c.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}I1.isMDXComponent=!0;const W1={toc:[]};function P1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter in degrees."))}P1.isMDXComponent=!0;const G1={toc:[]};function F1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,c.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}F1.isMDXComponent=!0;const U1={toc:[]};function j1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}j1.isMDXComponent=!0;const V1={toc:[]};function B1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},V1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,c.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}B1.isMDXComponent=!0;const q1={toc:[]};function O1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}O1.isMDXComponent=!0;const $1={toc:[]};function H1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,c.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}H1.isMDXComponent=!0;const Y1={toc:[]};function K1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}K1.isMDXComponent=!0;const J1={toc:[]};function Q1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},J1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the view."),(0,c.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,c.kt)("p",null,"Can modify the state of the view."))}function t2(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}Q1.isMDXComponent=!0},9322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(9770),r=e(8698);const c="toggle_S_IX",s="collapsed_wdUB",a="collapse_TjTN",l="inverse_g6vW",i="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),h=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),k=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(c,e&&s),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:a},d.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:i})),o.createElement("div",{className:(0,u.Z)(i,l)})),h&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:h.contentId})),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:k.contentId})))}},1836:(t,n,e)=>{e.d(n,{Z:()=>Rt});var o=e(2784),p=e(7390),r=e(6835),c=e(68),s=e(6277),a=e(8569);const l={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,i.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:i}=t;const m=(0,r.F)(),d=(0,c.s2)();return o.createElement("div",{className:(0,s.Z)(a.Z.codeBlockContent,l.codeBlock,e&&l.highlight,p&&l.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,s.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},n)),i&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(i,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(9318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,s.Z)(l.codeBlockContainer,"language-typescript")},n)}var k=e(9817);function y(t){let{children:n,type:e,to:p,id:r,tooltip:s}=t;const a=(0,c.Ld)(e);return p?o.createElement(k.Z,(0,i.Z)({id:r,to:p,"data-tooltip":s},a),n):o.createElement("span",(0,i.Z)({id:r},a),n)}let f,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[f.None]:l.none,[f.Angle]:l.angle,[f.Curly]:l.curly,[f.Square]:l.square,[f.Parentheses]:l.parentheses};function w(t){let{children:n,type:e,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,s.Z)(l.list,D[e??f.None])},o.createElement("span",{className:(0,s.Z)(l.elements,p!==M.Comma&&l.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:l.element},t)))))}var _=e(8617);function X(t){var n;let{type:e}=t;const p=(0,_.RU)(e.project),r=null==p?void 0:p[e.id],c=e.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(y,{to:c,type:c?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(w,{type:f.Angle},e.typeArguments.map(((t,n)=>o.createElement(P,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(y,{type:"keyword"},n.name)}function x(t){let{type:n}=t;return n.elements?o.createElement(w,{type:f.Square},n.elements.map(((t,n)=>o.createElement(P,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function C(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.elementType}),"[]")}function T(t){let{type:n}=t;return o.createElement(w,{type:f.Parentheses,separator:M.Pipe},n.types.map(((t,n)=>o.createElement(P,{key:n,type:t}))))}function L(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(y,{type:p},e)}function Z(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,n.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(P,{type:n.targetType}))}function v(t){let{type:n}=t;const e=(0,_.in)();return o.createElement(Y,{reflection:e(n.declaration)})}function b(t){let{type:n}=t;return o.createElement(w,{type:f.Parentheses,separator:M.Ampersand},n.types.map(((t,n)=>o.createElement(P,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(P,{key:n,type:e}),"}",o.createElement(y,{type:"string"},p))})),o.createElement(y,{type:"string"},"`"))}function E(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(P,{type:n.queryType}))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(P,{type:n.extendsType})," ? ",o.createElement(P,{type:n.trueType})," : ",o.createElement(P,{type:n.falseType}))}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},n.name))}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.objectType}),"[",o.createElement(P,{type:n.indexType}),"]")}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},n.operator," "),o.createElement(P,{type:n.target}))}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(w,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},n.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(P,{type:n.parameterType}),"]: ",o.createElement(P,{type:n.templateType}))))}function W(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(P,{type:n.element}))}function P(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return z;case"conditional":return A;case"reflection":return v;case"query":return E;case"named-tuple-member":return W;case"union":return T;case"intrinsic":return g;case"literal":return L;case"reference":return X;case"predicate":return Z;case"tuple":return x;case"array":return C;case"intersection":return b;case"inferred":return R;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return S}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function G(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function F(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(P,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},n.defaultValue)))}function U(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.varianceModifier&&o.createElement(y,{type:"keyword"},n.varianceModifier," "),o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(P,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(P,{type:n.default})))}function j(t){var n,e;let{reflection:r,flags:c}=t;const s=(0,_.in)(),a="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:c??r.flags,explicitAccessModifier:!a}),r.kind===p.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:r.overwrites.externalUrl??(0,_.Gr)(s(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},r.type.name)):a?"":o.createElement(y,{type:"function"},r.name),!(null==(n=r.typeParameter)||!n.length)&&o.createElement(w,{type:f.Angle},r.typeParameter.map((t=>o.createElement(U,{key:t.id,reflection:s(t)})))),null!=(e=r.parameters)&&e.length?o.createElement(w,{type:f.Parentheses},r.parameters.map((t=>o.createElement(F,{key:t,reflection:s(t)})))):"()",r.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(P,{type:r.type})))}function V(t){let{reflection:n}=t;return o.createElement(F,{reflection:n})}const B={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function q(t){var n,e,p;let{reflection:r}=t;const c=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:r.flags}),o.createElement(y,{type:"keyword"},B[r.kind]," "),o.createElement(y,{type:"class-name"},r.name),!(null==(n=r.typeParameters)||!n.length)&&o.createElement(w,{type:f.Angle},r.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:c(t)}))))," ",!(null==(e=r.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(w,null,r.extendedTypes.map(((t,n)=>o.createElement(P,{key:n,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(w,null,r.implementedTypes.map(((t,n)=>o.createElement(P,{key:n,type:t}))))))}function O(t){let{reflection:n}=t;const e=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},n.name),n.typeParameters&&o.createElement(w,{type:f.Angle},n.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:e(t)}))))," = ",o.createElement(P,{type:n.type}))}function $(t){let{reflection:n}=t;const e=(0,_.in)();return n.signatures?o.createElement(j,{reflection:n.signatures[0]}):n.children?o.createElement(w,{type:f.Curly},n.children.map((t=>o.createElement(Y,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function H(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(j,{reflection:p})}function Y(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return q;case p.W.Constructor:return j;case p.W.Property:return V;case p.W.Method:return H;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return $;case p.W.TypeParameter:return U;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return O;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function K(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${l.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(l.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,s.Z)(l.line,"token-line")},n),o.createElement("br",null))}var J=e(9322),Q=e(9770);function tt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(U,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(F,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const r=(0,_.in)(),c=(0,o.useMemo)((()=>n.map(r)),[n]),[s,a]=(0,o.useState)(c[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,c.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===s.id,onClick:n.length>1?()=>a(t):void 0},o.createElement(K,null,o.createElement(j,{reflection:t,flags:e})))))),o.createElement(J.Z,{comment:s.comment}),o.createElement(tt,{parameters:s.typeParameter}),o.createElement(nt,{parameters:s.parameters}))}var ot=e(7708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,i.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",ct="filters_z1iC",st="icon_ROIU";function at(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,s.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:st})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,s.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,s.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function lt(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,s.Z)("row",rt)},o.createElement("div",{className:(0,s.Z)("col",ct)},o.createElement(at,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var it=e(3181),ut=e(8963),mt=e(3851),dt=e(9741),ht=e(2244),kt=e(4126);const yt="tabList_M0Dn",ft="tabItem_ysIP";function Mt(t){var n;const{lazy:e,block:p,defaultValue:r,values:c,groupId:a,className:l}=t,u=o.Children.map(t.children,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),m=c??u.map((t=>{let{props:{value:n,label:e,attributes:o}}=t;return{value:n,label:e,attributes:o}})),d=(0,ht.l)(m,((t,n)=>t.value===n.value));if(d.length>0)throw new Error(`Docusaurus error: Duplicate values "${d.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const h=null===r?r:r??(null==(n=u.find((t=>t.props.default)))?void 0:n.props.value)??u[0].props.value;if(null!==h&&!m.some((t=>t.value===h)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${h}" but none of its children has the corresponding value. Available values are: ${m.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:y}=(0,ut.U)(),[f,M]=(0,o.useState)(h),D=[],{blockElementScrollPositionUntilNextRender:w}=(0,kt.o5)();if(null!=a){const t=k[a];null!=t&&t!==f&&m.some((n=>n.value===t))&&M(t)}const _=t=>{const n=t.currentTarget,e=D.indexOf(n),o=m[e].value;o!==f&&(w(n),M(o),null!=a&&y(a,String(o)))},X=t=>{var n;let e=null;switch(t.key){case"Enter":_(t);break;case"ArrowRight":{const n=D.indexOf(t.currentTarget)+1;e=D[n]??D[0];break}case"ArrowLeft":{const n=D.indexOf(t.currentTarget)-1;e=D[n]??D[D.length-1];break}}null==(n=e)||n.focus()};return o.createElement("div",{className:(0,s.Z)("tabs-container",yt)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":p},l)},m.map((t=>{let{value:n,label:e,attributes:p}=t;return o.createElement("li",(0,i.Z)({role:"tab",tabIndex:f===n?0:-1,"aria-selected":f===n,key:n,ref:t=>D.push(t),onKeyDown:X,onClick:_},p,{className:(0,s.Z)("tabs__item",ft,null==p?void 0:p.className,{"tabs__item--active":f===n})}),e??n)}))),e?(0,o.cloneElement)(u.filter((t=>t.props.value===f))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},u.map(((t,n)=>(0,o.cloneElement)(t,{key:n,hidden:t.props.value!==f})))))}function Dt(t){const n=(0,dt.Z)();return o.createElement(Mt,(0,i.Z)({key:String(n)},t))}const wt="tabItem_OMyP";function _t(t){let{children:n,hidden:e,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,s.Z)(wt,p),hidden:e},n)}function Xt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(Rt,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(Rt,{reflection:t})))))}function gt(t){let{group:n,project:e}=t;const p=(0,it.TH)(),r=(0,_.RU)(e),{setTabGroupChoices:c}=(0,ut.U)(),s=p.hash.split("-")[0].slice(1),[a]=(0,ot.mN)(),l=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],r=[];for(const c of t.children){const t=n[c];t&&(0,ot.It)(e,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,a))).filter((t=>!!t))),[n,r,a]);return(0,o.useEffect)((()=>{if(1===l.length)return;const t=p.hash.split("-")[0].slice(1);for(const e of l)if(e.anchors.includes(t))return void c(n.title,e.title)}),[p.hash,l]),0===l.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h2",id:n.title},n.title),l.length>1?o.createElement(Dt,{groupId:n.title},l.map((t=>o.createElement(_t,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Xt,{group:t}))))):o.createElement(Xt,{group:l[0]}))}function xt(t){var n,e,p,r,c;let{reflection:s}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=s.sources)||null==(e=n[0])?void 0:e.url},o.createElement(K,null,o.createElement(Y,{reflection:s})))),o.createElement(lt,{kind:s.kind},o.createElement(J.Z,{comment:s.comment})),o.createElement(tt,{parameters:s.typeParameters}),(null==(p=s.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,s.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=s.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,s.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),s.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:s.signatures})),null==(c=s.groups)?void 0:c.map((t=>o.createElement(gt,{group:t,key:t.title,project:s.project}))))}function Ct(t){var n;let{reflection:e,headless:p}=t;const r=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(mt.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:r,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:e.overwrites}))))}function Tt(t){var n,e;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(mt.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement(K,null,o.createElement(V,{reflection:p})))),o.createElement(J.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function Lt(t){var n,e,p;let{reflection:r}=t;const c=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=r.sources)||null==(e=n[0])?void 0:e.url},o.createElement(K,null,o.createElement(Y,{reflection:r})))),o.createElement(J.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>c[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Rt,{key:t.id,reflection:t})))))))}var Zt=e(8128);function vt(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(Zt.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(lt,{kind:e.kind},o.createElement(J.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(gt,{group:t,key:t.title,project:e.project}))))}const bt="cardContainer_ybwo",Nt="cardTitle_Ehd1",Et="cardDescription_b6wr";function At(t){let{reflection:n}=t;const e=(0,_.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,s.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(k.Z,{href:t.href,className:(0,s.Z)("card padding--lg",bt)},o.createElement("h2",{className:(0,s.Z)("text--truncate",Nt)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,s.Z)("text--truncate",Et)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function Rt(t){let{reflection:n,headless:e=!1}=t;const r=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return At;case p.W.Module:return vt;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return xt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return Ct;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Tt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Lt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(r,{reflection:n,headless:e})}},7390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},532:(t,n,e)=>{e.d(n,{Z:()=>i});var o=e(2784),p=e(9741);const r="tooltip_lI6R",c="active_DOSD";var s=e(6277),a=e(8617),l=e(9322);function i(t){let{children:n}=t;const e=(0,p.Z)(),i=(0,a.rG)(),[u,m]=(0,o.useState)(!1),[d,h]=(0,o.useState)(null),k=(0,o.useRef)(),y=(0,o.useRef)(),f=(0,o.useRef)(),M=(0,o.useCallback)((()=>{if(!y.current||!f.current)return;const t=y.current.getBoundingClientRect();let n=window.innerWidth-t.left-496;n<0&&(n=0),f.current.style.right=`${n}px`,f.current.style.top=`${t.bottom}px`}),[]);return(0,o.useEffect)((()=>{if(!e)return;const t=t=>{var n,e,o;if(!t.target.href||null==(n=k.current)||!n.contains(t.target)||null!=(e=f.current)&&e.contains(t.target))return;const p=new URL(t.target.href,document.baseURI);if(p.pathname===window.location.pathname)return;const r=i(p.pathname+p.hash);null!=r&&null!=(o=r.comment)&&o.summary&&(y.current=t.target,m(!0),h(r.comment),M())},n=t=>{t.target===y.current&&m(!1)};return document.addEventListener("mouseenter",t,!0),document.addEventListener("focus",t,!0),document.addEventListener("mouseleave",n,!0),document.addEventListener("blur",n,!0),document.addEventListener("scroll",M),()=>{document.removeEventListener("mouseenter",t,!0),document.removeEventListener("focus",t,!0),document.removeEventListener("mouseleave",n,!0),document.removeEventListener("blur",n,!0),document.removeEventListener("scroll",M)}}),[e]),(0,o.useEffect)((()=>{M()})),o.createElement("div",{ref:k},n,o.createElement("div",{ref:f,className:(0,s.Z)(r,"padding--md margin-horiz--md",u&&c)},d&&o.createElement(l.Z,{comment:d,full:!1})))}},8617:(t,n,e)=>{e.d(n,{Gr:()=>l,RU:()=>c,gs:()=>r,in:()=>s,rG:()=>a});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:n,lookup:e,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:r}},n)}function c(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function s(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function a(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function l(t){if(t)return t.href}},68:(t,n,e)=>{e.d(n,{Ld:()=>s,Y0:()=>c,s2:()=>a});var o=e(2784),p=e(822);const r=o.createContext(null);function c(t){let{children:n}=t;const e=(0,p.p)(),c=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(r.Provider,{value:c},n)}function s(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return{className:`token ${t}`,style:n[t]??n.plain}}function a(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return n[t]??n.plain}},7708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>i,mN:()=>u});var o=e(2784),p=e(1263),r=e(9741);const c="api-filters",s=p.Z.canUseDOM?localStorage.getItem(c):null,a=s?JSON.parse(s):{inherited:!0,private:!1},l=o.createContext([a,()=>{}]);function i(t){let{children:n}=t;const[e,p]=(0,o.useState)(a),s=(0,r.Z)();return o.createElement(l.Provider,{value:[e,t=>{s&&localStorage.setItem(c,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(l)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!n.inheritedFrom;return!(!t.inherited&&r)}},6047:(t,n,e)=>{e.d(n,{Z:()=>u});var o=e(7896),p=e(2784),r=e(9055);const c="icon_Fw4I";function s(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),p.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}function l(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),p.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function i(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function u(t){const n=(0,p.useMemo)((()=>{switch(t.type){case"tip":return i;case"caution":return a;case"danger":return l;default:return s}}),[t.type]);return p.createElement(p.Fragment,null,p.createElement(r.Z,(0,o.Z)({icon:p.createElement(n,{className:c})},t)))}},4141:(t,n,e)=>{e.d(n,{Z:()=>s});var o=e(7896),p=e(2784),r=e(6277);const c="iconEdit_N_05";function s(t){let{className:n,...e}=t;return p.createElement("svg",(0,o.Z)({fill:"currentColor",width:"24px",height:"24px",viewBox:"0 0 24 24",className:(0,r.Z)(c,n),"aria-hidden":"true"},e),p.createElement("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"}))}},4648:(t,n,e)=>{e.d(n,{Z:()=>r});var o=e(7896),p=e(2784);function r(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",style:{width:16,height:16,marginTop:"0.1rem"}},t),p.createElement("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z",fill:"currentColor"}))}}}]);
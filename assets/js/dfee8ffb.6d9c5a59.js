"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[4625],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function c(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function r(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?c(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):c(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},c=Object.keys(t);for(o=0;o<c.length;o++)e=c[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(t);for(o=0;o<c.length;o++)e=c[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var a=o.createContext({}),i=function(t){var n=o.useContext(a),e=n;return t&&(e="function"==typeof t?t(n):r(r({},n),t)),e},l=function(t){var n=i(t.components);return o.createElement(a.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,c=t.originalType,a=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),u=i(e),d=p,h=u["".concat(a,".").concat(d)]||u[d]||m[d]||c;return e?o.createElement(h,r(r({ref:n},l),{},{components:e})):o.createElement(h,r({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var c=e.length,r=new Array(c);r[0]=d;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=t,s[u]="string"==typeof t?t:p,r[1]=s;for(var i=2;i<c;i++)r[i]=e[i];return o.createElement.apply(null,r)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},3350:(t,n,e)=>{e.r(n),e.d(n,{default:()=>tG});var o=e(7896),p=(e(2784),e(876));const c={toc:[]};function r(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,p.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}r.isMDXComponent=!0;const s={toc:[]};function a(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}a.isMDXComponent=!0;const i={toc:[]};function l(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},i,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches an asynchronous ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}h.isMDXComponent=!0;const y={toc:[]};function k(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}k.isMDXComponent=!0;const f={toc:[]};function D(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}D.isMDXComponent=!0;const M={toc:[]};function _(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},M,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}_.isMDXComponent=!0;const X={toc:[]};function w(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},X,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}w.isMDXComponent=!0;const T={toc:[]};function C(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},T,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}C.isMDXComponent=!0;const x={toc:[]};function g(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},x,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}g.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},L,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}Z.isMDXComponent=!0;const b={toc:[]};function v(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},b,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}v.isMDXComponent=!0;const N={toc:[]};function A(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}A.isMDXComponent=!0;const S={toc:[]};function G(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},S,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}G.isMDXComponent=!0;const P={toc:[]};function R(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}R.isMDXComponent=!0;const E={toc:[]};function I(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},E,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}I.isMDXComponent=!0;const W={toc:[]};function j(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},W,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}j.isMDXComponent=!0;const U={toc:[]};function F(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},U,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value argument to subscribers."))}F.isMDXComponent=!0;const O={toc:[]};function z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},O,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A base for dispatching ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,p.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}z.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}V.isMDXComponent=!0;const B={toc:[]};function H(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},B,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}H.isMDXComponent=!0;const Y={toc:[]};function J(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}J.isMDXComponent=!0;const K={toc:[]};function Q(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},K,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Q.isMDXComponent=!0;const $={toc:[]};function tt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}pt.isMDXComponent=!0;const ct={toc:[]};function rt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}rt.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,p.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,p.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}at.isMDXComponent=!0;const it={toc:[]};function lt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},it,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}ht.isMDXComponent=!0;const yt={toc:[]};function kt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Are subscribers being notified?"))}kt.isMDXComponent=!0;const ft={toc:[]};function Dt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Notify all current and future subscribers."))}Dt.isMDXComponent=!0;const Mt={toc:[]};function _t(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stop notifying future subscribers."))}_t.isMDXComponent=!0;const Xt={toc:[]};function wt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}wt.isMDXComponent=!0;const Tt={toc:[]};function Ct(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}Ct.isMDXComponent=!0;const xt={toc:[]};function gt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}gt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Zt.isMDXComponent=!0;const bt={toc:[]};function vt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}vt.isMDXComponent=!0;const Nt={toc:[]};function At(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}At.isMDXComponent=!0;const St={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},St,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Gt.isMDXComponent=!0;const Pt={toc:[]};function Rt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Rt.isMDXComponent=!0;const Et={toc:[]};function It(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Et,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}It.isMDXComponent=!0;const Wt={toc:[]};function jt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}jt.isMDXComponent=!0;const Ut={toc:[]};function Ft(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ut,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Ft.isMDXComponent=!0;const Ot={toc:[]};function zt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ot,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}zt.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}Vt.isMDXComponent=!0;const Bt={toc:[]};function Ht(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}Ht.isMDXComponent=!0;const Yt={toc:[]};function Jt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Jt.isMDXComponent=!0;const Kt={toc:[]};function Qt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}Qt.isMDXComponent=!0;const $t={toc:[]};function tn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$t,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}pn.isMDXComponent=!0;const cn={toc:[]};function rn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}rn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}yn.isMDXComponent=!0;const kn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}fn.isMDXComponent=!0;const Dn={toc:[]};function Mn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Mn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_n,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Xn.isMDXComponent=!0;const wn={toc:[]};function Tn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Tn.isMDXComponent=!0;const Cn={toc:[]};function xn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}xn.isMDXComponent=!0;const gn={toc:[]};function Ln(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function bn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}bn.isMDXComponent=!0;const vn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Nn.isMDXComponent=!0;const An={toc:[]};function Sn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},An,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set the current value of this dispatcher."))}Sn.isMDXComponent=!0;const Gn={toc:[]};function Pn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new value."))}Pn.isMDXComponent=!0;const Rn={toc:[]};function En(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}En.isMDXComponent=!0;const In={toc:[]};function Wn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},In,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}Wn.isMDXComponent=!0;const jn={toc:[]};function Un(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Un.isMDXComponent=!0;const Fn={toc:[]};function On(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}On.isMDXComponent=!0;const zn={toc:[]};function qn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}qn.isMDXComponent=!0;const Vn={toc:[]};function Bn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Bn.isMDXComponent=!0;const Hn={toc:[]};function Yn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Yn.isMDXComponent=!0;const Jn={toc:[]};function Kn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Kn.isMDXComponent=!0;const Qn={toc:[]};function $n(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}$n.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}oe.isMDXComponent=!0;const pe={toc:[]};function ce(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ce.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},re,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}se.isMDXComponent=!0;const ae={toc:[]};function ie(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}ie.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}de.isMDXComponent=!0;const he={toc:[]};function ye(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}ye.isMDXComponent=!0;const ke={toc:[]};function fe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ke,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of times the timer has ticked."))}fe.isMDXComponent=!0;const De={toc:[]};function Me(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},De,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator responsible for running this timer."))}Me.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_e,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the timer ticks."))}Xe.isMDXComponent=!0;const we={toc:[]};function Te(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current iteration index."))}Te.isMDXComponent=!0;const Ce={toc:[]};function xe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ce,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}xe.isMDXComponent=!0;const ge={toc:[]};function Le(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ge,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Le.isMDXComponent=!0;const Ze={toc:[]};function be(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}be.isMDXComponent=!0;const ve={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ve,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Ne.isMDXComponent=!0;const Ae={toc:[]};function Se(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ae,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Se.isMDXComponent=!0;const Ge={toc:[]};function Pe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Pe.isMDXComponent=!0;const Re={toc:[]};function Ee(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Re,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.corenerRadius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}Ee.isMDXComponent=!0;const Ie={toc:[]};function We(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ie,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run tasks one after another."))}We.isMDXComponent=!0;const je={toc:[]};function Ue(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},je,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Ue.isMDXComponent=!0;const Fe={toc:[]};function Oe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Oe.isMDXComponent=!0;const ze={toc:[]};function qe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}qe.isMDXComponent=!0;const Ve={toc:[]};function Be(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay in seconds"))}Be.isMDXComponent=!0;const He={toc:[]};function Ye(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task or callback to run after the delay."))}Ye.isMDXComponent=!0;const Je={toc:[]};function Ke(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Je,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}Ke.isMDXComponent=!0;const Qe={toc:[]};function $e(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Call the given callback every N seconds."))}$e.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interval between subsequent calls."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to be called."))}oo.isMDXComponent=!0;const po={toc:[]};function co(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each time iteration waits until the previous one is completed."))}co.isMDXComponent=!0;const ro={toc:[]};function so(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ro,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}so.isMDXComponent=!0;const ao={toc:[]};function io(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator N times."))}io.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of iterations."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}ho.isMDXComponent=!0;const yo={toc:[]};function ko(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Do nothing."))}ko.isMDXComponent=!0;const fo={toc:[]};function Do(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Do.isMDXComponent=!0;const Mo={toc:[]};function _o(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}_o.isMDXComponent=!0;const Xo={toc:[]};function wo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}wo.isMDXComponent=!0;const To={toc:[]};function Co(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},To,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Co.isMDXComponent=!0;const xo={toc:[]};function go(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}go.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Zo.isMDXComponent=!0;const bo={toc:[]};function vo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}vo.isMDXComponent=!0;const No={toc:[]};function Ao(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ao.isMDXComponent=!0;const So={toc:[]};function Go(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},So,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Go.isMDXComponent=!0;const Po={toc:[]};function Ro(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Po,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Ro.isMDXComponent=!0;const Eo={toc:[]};function Io(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay between each of the tasks."))}Io.isMDXComponent=!0;const Wo={toc:[]};function jo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to be run in a sequence."))}jo.isMDXComponent=!0;const Uo={toc:[]};function Fo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Fo.isMDXComponent=!0;const Oo={toc:[]};function zo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the given amount of time."))}zo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The relative time in seconds."))}Vo.isMDXComponent=!0;const Bo={toc:[]};function Ho(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}Ho.isMDXComponent=!0;const Yo={toc:[]};function Jo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}Jo.isMDXComponent=!0;const Ko={toc:[]};function Qo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ko,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}Qo.isMDXComponent=!0;const $o={toc:[]};function tp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the given time event."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the time event."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}pp.isMDXComponent=!0;const cp={toc:[]};function rp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when a new message is logged."))}rp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the meta file of a given entity."))}ap.isMDXComponent=!0;const ip={toc:[]};function lp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ip,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when metadata changes."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Load new metadata from a file."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New metadata."))}hp.isMDXComponent=!0;const yp={toc:[]};function kp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any possible errors will be logged to the console."))}kp.isMDXComponent=!0;const fp={toc:[]};function Dp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set data without waiting for confirmation."))}Dp.isMDXComponent=!0;const Mp={toc:[]};function _p(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New data."))}_p.isMDXComponent=!0;const Xp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the data stored in the meta file."))}wp.isMDXComponent=!0;const Tp={toc:[]};function Cp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the current scene changes."))}Cp.isMDXComponent=!0;const xp={toc:[]};function gp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after any of the scenes were reloaded."))}gp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after the scenes were recalculated."))}Zp.isMDXComponent=!0;const bp={toc:[]};function vp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}vp.isMDXComponent=!0;const Np={toc:[]};function Ap(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Ap.isMDXComponent=!0;const Sp={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause/resume the audio."))}Gp.isMDXComponent=!0;const Pp={toc:[]};function Rp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the audio should be paused or resumed."))}Rp.isMDXComponent=!0;const Ep={toc:[]};function Ip(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ep,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The absolute biggest value from the peaks array."))}Ip.isMDXComponent=!0;const Wp={toc:[]};function jp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of samples taken."))}jp.isMDXComponent=!0;const Up={toc:[]};function Fp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Up,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}Fp.isMDXComponent=!0;const Op={toc:[]};function zp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Op,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Samples per seconds."))}zp.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Signifies the various stages of a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}Vp.isMDXComponent=!0;const Bp={toc:[]};function Hp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs after a render ends."))}Hp.isMDXComponent=!0;const Yp={toc:[]};function Jp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}Jp.isMDXComponent=!0;const Kp={toc:[]};function Qp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,p.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Qp.isMDXComponent=!0;const $p={toc:[]};function tc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,p.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes the state of a scene."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}pc.isMDXComponent=!0;const cc={toc:[]};function rc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished transitioning in."))}rc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}ac.isMDXComponent=!0;const ic={toc:[]};function lc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ic,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene is ready to transition out."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoking ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished."))}hc.isMDXComponent=!0;const yc={toc:[]};function kc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has just been created/reset."))}kc.isMDXComponent=!0;const fc={toc:[]};function Dc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The default implementation of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,p.kt)("p",null,"Uses generators to control the animation."))}Dc.isMDXComponent=!0;const Mc={toc:[]};function _c(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}_c.isMDXComponent=!0;const Xc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}wc.isMDXComponent=!0;const Tc={toc:[]};function Cc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Cc.isMDXComponent=!0;const xc={toc:[]};function gc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}gc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Zc.isMDXComponent=!0;const bc={toc:[]};function vc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}vc.isMDXComponent=!0;const Nc={toc:[]};function Ac(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Ac.isMDXComponent=!0;const Sc={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Gc.isMDXComponent=!0;const Pc={toc:[]};function Rc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Rc.isMDXComponent=!0;const Ec={toc:[]};function Ic(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ec,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}Ic.isMDXComponent=!0;const Wc={toc:[]};function jc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}jc.isMDXComponent=!0;const Uc={toc:[]};function Fc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Fc.isMDXComponent=!0;const Oc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}zc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Vc.isMDXComponent=!0;const Bc={toc:[]};function Hc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}Hc.isMDXComponent=!0;const Yc={toc:[]};function Jc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Jc.isMDXComponent=!0;const Kc={toc:[]};function Qc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Qc.isMDXComponent=!0;const $c={toc:[]};function tr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}pr.isMDXComponent=!0;const cr={toc:[]};function rr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}rr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}ar.isMDXComponent=!0;const ir={toc:[]};function lr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ir,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}hr.isMDXComponent=!0;const yr={toc:[]};function kr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}kr.isMDXComponent=!0;const fr={toc:[]};function Dr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}Dr.isMDXComponent=!0;const Mr={toc:[]};function _r(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}_r.isMDXComponent=!0;const Xr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}wr.isMDXComponent=!0;const Tr={toc:[]};function Cr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Cr.isMDXComponent=!0;const xr={toc:[]};function gr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}gr.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}Zr.isMDXComponent=!0;const br={toc:[]};function vr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},br,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Lifecycle events for ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}vr.isMDXComponent=!0;const Nr={toc:[]};function Ar(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A random number generator based on\n",(0,p.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,p.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Ar.isMDXComponent=!0;const Sr={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random floats in the given range."))}Gr.isMDXComponent=!0;const Pr={toc:[]};function Rr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."))}Rr.isMDXComponent=!0;const Er={toc:[]};function Ir(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Er,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}Ir.isMDXComponent=!0;const Wr={toc:[]};function jr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}jr.isMDXComponent=!0;const Ur={toc:[]};function Fr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ur,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random integers in the given range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"}),(0,p.kt)("li",{parentName:"ul"})))}Fr.isMDXComponent=!0;const Or={toc:[]};function zr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Or,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}zr.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}Vr.isMDXComponent=!0;const Br={toc:[]};function Hr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Br,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}Hr.isMDXComponent=!0;const Yr={toc:[]};function Jr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random float in the given range."))}Jr.isMDXComponent=!0;const Kr={toc:[]};function Qr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}Qr.isMDXComponent=!0;const $r={toc:[]};function ts(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random integer in the given range."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ps.isMDXComponent=!0;const cs={toc:[]};function rs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}rs.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a new independent generator."))}as.isMDXComponent=!0;const is={toc:[]};function ls(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},is,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Manages time events for a given scene."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when time events change."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the time offset of the given event."))}hs.isMDXComponent=!0;const ys={toc:[]};function ks(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ys,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the event."))}ks.isMDXComponent=!0;const fs={toc:[]};function Ds(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The time offset in seconds."))}Ds.isMDXComponent=!0;const Ms={toc:[]};function _s(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ms,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}_s.isMDXComponent=!0;const Xs={toc:[]};function ws(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes cached information about the timing of a scene."))}ws.isMDXComponent=!0;const Ts={toc:[]};function Cs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ts,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Cs.isMDXComponent=!0;const xs={toc:[]};function gs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}gs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ls,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for the inspected element."))}Zs.isMDXComponent=!0;const bs={toc:[]};function vs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element for which to draw an overlay."))}vs.isMDXComponent=!0;const Ns={toc:[]};function As(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}As.isMDXComponent=!0;const Ss={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ss,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Gs.isMDXComponent=!0;const Ps={toc:[]};function Rs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ps,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}Rs.isMDXComponent=!0;const Es={toc:[]};function Is(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Es,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the attributes of the inspected element."))}Is.isMDXComponent=!0;const Ws={toc:[]};function js(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ws,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to inspect."))}js.isMDXComponent=!0;const Us={toc:[]};function Fs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Us,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a possible element to inspect at a given position."))}Fs.isMDXComponent=!0;const Os={toc:[]};function zs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Os,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x coordinate."))}zs.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y coordinate."))}Vs.isMDXComponent=!0;const Bs={toc:[]};function Hs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}Hs.isMDXComponent=!0;const Ys={toc:[]};function Js(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ys,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the inspected element is still valid."))}Js.isMDXComponent=!0;const Ks={toc:[]};function Qs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ks,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to validate."))}Qs.isMDXComponent=!0;const $s={toc:[]};function ta(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event stored in a meta file."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main interface for scenes."))}pa.isMDXComponent=!0;const ca={toc:[]};function ra(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}ra.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}aa.isMDXComponent=!0;const ia={toc:[]};function la(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ia,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene's ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}ha.isMDXComponent=!0;const ya={toc:[]};function ka(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ya,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}ka.isMDXComponent=!0;const fa={toc:[]};function Da(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Da.isMDXComponent=!0;const Ma={toc:[]};function _a(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ma,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}_a.isMDXComponent=!0;const Xa={toc:[]};function wa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}wa.isMDXComponent=!0;const Ta={toc:[]};function Ca(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ta,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ca.isMDXComponent=!0;const xa={toc:[]};function ga(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}ga.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},La,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Za.isMDXComponent=!0;const ba={toc:[]};function va(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ba,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}va.isMDXComponent=!0;const Na={toc:[]};function Aa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}Aa.isMDXComponent=!0;const Sa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}Ga.isMDXComponent=!0;const Pa={toc:[]};function Ra(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}Ra.isMDXComponent=!0;const Ea={toc:[]};function Ia(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ea,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Ia.isMDXComponent=!0;const Wa={toc:[]};function ja(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}ja.isMDXComponent=!0;const Ua={toc:[]};function Fa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ua,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Fa.isMDXComponent=!0;const Oa={toc:[]};function za(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}za.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Va.isMDXComponent=!0;const Ba={toc:[]};function Ha(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ba,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}Ha.isMDXComponent=!0;const Ya={toc:[]};function Ja(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ya,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Ja.isMDXComponent=!0;const Ka={toc:[]};function Qa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ka,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Qa.isMDXComponent=!0;const $a={toc:[]};function ti(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}pi.isMDXComponent=!0;const ci={toc:[]};function ri(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}ri.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}ai.isMDXComponent=!0;const ii={toc:[]};function li(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ii,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each class implementing the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constructor used when creating new scenes."))}hi.isMDXComponent=!0;const yi={toc:[]};function ki(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,p.kt)("inlineCode",{parentName:"a"},"config")),"."))}ki.isMDXComponent=!0;const fi={toc:[]};function Di(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a scene exposed by a ",(0,p.kt)("inlineCode",{parentName:"p"},"*.scene.tsx")," file."))}Di.isMDXComponent=!0;const Mi={toc:[]};function _i(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}_i.isMDXComponent=!0;const Xi={toc:[]};function wi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}wi.isMDXComponent=!0;const Ti={toc:[]};function Ci(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ti,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Ci.isMDXComponent=!0;const xi={toc:[]};function gi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}gi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Li,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}Zi.isMDXComponent=!0;const bi={toc:[]};function vi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}vi.isMDXComponent=!0;const Ni={toc:[]};function Ai(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}Ai.isMDXComponent=!0;const Si={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Si,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event at runtime."))}Gi.isMDXComponent=!0;const Pi={toc:[]};function Ri(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"In other words, the moment at which ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,p.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}Ri.isMDXComponent=!0;const Ei={toc:[]};function Ii(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ei,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}Ii.isMDXComponent=!0;const Wi={toc:[]};function ji(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the event."))}ji.isMDXComponent=!0;const Ui={toc:[]};function Fi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ui,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Duration of the event in seconds."))}Fi.isMDXComponent=!0;const Oi={toc:[]};function zi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stack trace at the moment of registration."))}zi.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}Vi.isMDXComponent=!0;const Bi={toc:[]};function Hi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents attributes of an inspected element."))}Hi.isMDXComponent=!0;const Yi={toc:[]};function Ji(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Ji.isMDXComponent=!0;const Ki={toc:[]};function Qi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ki,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents an element to inspect."))}Qi.isMDXComponent=!0;const $i={toc:[]};function tl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread management."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,p.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A class representing an individual thread."))}pl.isMDXComponent=!0;const cl={toc:[]};function rl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}rl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}al.isMDXComponent=!0;const il={toc:[]};function ll(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},il,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Used by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current time of this thread."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The next value to be passed to the wrapped generator."))}hl.isMDXComponent=!0;const yl={toc:[]};function kl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}kl.isMDXComponent=!0;const fl={toc:[]};function Dl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress the wrapped generator once."))}Dl.isMDXComponent=!0;const Ml={toc:[]};function _l(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ml,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the thread for the next update cycle."))}_l.isMDXComponent=!0;const Xl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a normal function that returns a generator."))}wl.isMDXComponent=!0;const Tl={toc:[]};function Cl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,p.kt)("p",null,"Progress to the next frame:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,p.kt)("p",null,"Run another generator synchronously:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,p.kt)("p",null,"Run another generator concurrently:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,p.kt)("p",null,"Await a Promise:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Cl.isMDXComponent=!0;const xl={toc:[]};function gl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}gl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ll,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Cancel all listed tasks."),(0,p.kt)("p",null,"Example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Zl.isMDXComponent=!0;const bl={toc:[]};function vl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to cancel."))}vl.isMDXComponent=!0;const Nl={toc:[]};function Al(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Al.isMDXComponent=!0;const Sl={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Gl.isMDXComponent=!0;const Pl={toc:[]};function Rl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Rl.isMDXComponent=!0;const El={toc:[]};function Il(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},El,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible thread ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Il.isMDXComponent=!0;const Wl={toc:[]};function jl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}jl.isMDXComponent=!0;const Ul={toc:[]};function Fl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ul,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Fl.isMDXComponent=!0;const Ol={toc:[]};function zl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ol,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}zl.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}Vl.isMDXComponent=!0;const Bl={toc:[]};function Hl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Hl.isMDXComponent=!0;const Yl={toc:[]};function Jl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Jl.isMDXComponent=!0;const Kl={toc:[]};function Ql(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}Ql.isMDXComponent=!0;const $l={toc:[]};function tu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"From the perspective of the external generator, ",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a context in which generators can be run concurrently."))}pu.isMDXComponent=!0;const cu={toc:[]};function ru(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the generator to run."))}ru.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}au.isMDXComponent=!0;const iu={toc:[]};function lu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},iu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the current scene is rendered."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the previous scene is rendered."))}hu.isMDXComponent=!0;const yu={toc:[]};function ku(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any old key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"})))}ku.isMDXComponent=!0;const fu={toc:[]};function Du(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Du.isMDXComponent=!0;const Mu={toc:[]};function _u(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}_u.isMDXComponent=!0;const Xu={toc:[]};function wu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}wu.isMDXComponent=!0;const Tu={toc:[]};function Cu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Cu.isMDXComponent=!0;const xu={toc:[]};function gu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}gu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Zu.isMDXComponent=!0;const bu={toc:[]};function vu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}vu.isMDXComponent=!0;const Nu={toc:[]};function Au(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Au.isMDXComponent=!0;const Su={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Su,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Gu.isMDXComponent=!0;const Pu={toc:[]};function Ru(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Ru.isMDXComponent=!0;const Eu={toc:[]};function Iu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a two-dimensional vector."))}Iu.isMDXComponent=!0;const Wu={toc:[]};function ju(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}ju.isMDXComponent=!0;const Uu={toc:[]};function Fu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The unclipped RGB components."))}Fu.isMDXComponent=!0;const Ou={toc:[]};function zu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ou,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}zu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}Vu.isMDXComponent=!0;const Bu={toc:[]};function Hu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Hu.isMDXComponent=!0;const Yu={toc:[]};function Ju(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Ju.isMDXComponent=!0;const Ku={toc:[]};function Qu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ku,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}Qu.isMDXComponent=!0;const $u={toc:[]};function tm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Alias of ",(0,p.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}pm.isMDXComponent=!0;const cm={toc:[]};function rm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}rm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}am.isMDXComponent=!0;const im={toc:[]};function lm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},im,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}hm.isMDXComponent=!0;const ym={toc:[]};function km(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ym,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}km.isMDXComponent=!0;const fm={toc:[]};function Dm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}Dm.isMDXComponent=!0;const Mm={toc:[]};function _m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"L"),", ",(0,p.kt)("strong",{parentName:"p"},"a"),", and ",(0,p.kt)("strong",{parentName:"p"},"b")," components."))}_m.isMDXComponent=!0;const Xm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}wm.isMDXComponent=!0;const Tm={toc:[]};function Cm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,p.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,p.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}Cm.isMDXComponent=!0;const xm={toc:[]};function gm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}gm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}Zm.isMDXComponent=!0;const bm={toc:[]};function vm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}vm.isMDXComponent=!0;const Nm={toc:[]};function Am(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}Am.isMDXComponent=!0;const Sm={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get and set the color opacity."))}Gm.isMDXComponent=!0;const Pm={toc:[]};function Rm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,p.kt)("code",null,"'rgb'")))}Rm.isMDXComponent=!0;const Em={toc:[]};function Im(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Em,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Similar to saturate, but the opposite direction."))}Im.isMDXComponent=!0;const Wm={toc:[]};function jm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"set"))}jm.isMDXComponent=!0;const Um={toc:[]};function Fm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Um,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a single channel value.\nAlso"))}Fm.isMDXComponent=!0;const Om={toc:[]};function zm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Om,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}zm.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color as hexadecimal string."))}Vm.isMDXComponent=!0;const Bm={toc:[]};function Hm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Hm.isMDXComponent=!0;const Ym={toc:[]};function Jm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ym,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,p.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Jm.isMDXComponent=!0;const Km={toc:[]};function Qm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Km,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}Qm.isMDXComponent=!0;const $m={toc:[]};function td(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}pd.isMDXComponent=!0;const cd={toc:[]};function rd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}rd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}ad.isMDXComponent=!0;const id={toc:[]};function ld(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},id,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}hd.isMDXComponent=!0;const yd={toc:[]};function kd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}kd.isMDXComponent=!0;const fd={toc:[]};function Dd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Dd.isMDXComponent=!0;const Md={toc:[]};function _d(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Md,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The origin to convert."))}_d.isMDXComponent=!0;const Xd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}wd.isMDXComponent=!0;const Td={toc:[]};function Cd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Td,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Cd.isMDXComponent=!0;const xd={toc:[]};function gd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}gd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ld,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Zd.isMDXComponent=!0;const bd={toc:[]};function vd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}vd.isMDXComponent=!0;const Nd={toc:[]};function Ad(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Ad.isMDXComponent=!0;const Sd={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Gd.isMDXComponent=!0;const Pd={toc:[]};function Rd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Rd.isMDXComponent=!0;const Ed={toc:[]};function Id(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ed,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Id.isMDXComponent=!0;const Wd={toc:[]};function jd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}jd.isMDXComponent=!0;const Ud={toc:[]};function Fd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ud,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Fd.isMDXComponent=!0;const Od={toc:[]};function zd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Od,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}zd.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Vd.isMDXComponent=!0;const Bd={toc:[]};function Hd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Hd.isMDXComponent=!0;const Yd={toc:[]};function Jd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Jd.isMDXComponent=!0;const Kd={toc:[]};function Qd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Qd.isMDXComponent=!0;const $d={toc:[]};function th(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The length of the array."))}ph.isMDXComponent=!0;const ch={toc:[]};function rh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}rh.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}ah.isMDXComponent=!0;const ih={toc:[]};function lh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ih,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}hh.isMDXComponent=!0;const yh={toc:[]};function kh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context before render."))}kh.isMDXComponent=!0;const fh={toc:[]};function Dh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}Dh.isMDXComponent=!0;const Mh={toc:[]};function _h(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context after render."))}_h.isMDXComponent=!0;const Xh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current project."))}wh.isMDXComponent=!0;const Th={toc:[]};function Ch(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Th,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the current scene."))}Ch.isMDXComponent=!0;const xh={toc:[]};function gh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the given seed."))}gh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The seed for the generator."))}Zh.isMDXComponent=!0;const bh={toc:[]};function vh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}vh.isMDXComponent=!0;const Nh={toc:[]};function Ah(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current scene."))}Ah.isMDXComponent=!0;const Sh={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current thread."))}Gh.isMDXComponent=!0;const Ph={toc:[]};function Rh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ph,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}Rh.isMDXComponent=!0;const Eh={toc:[]};function Ih(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}Ih.isMDXComponent=!0;const Wh={toc:[]};function jh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the real time since the start of the animation."))}jh.isMDXComponent=!0;const Uh={toc:[]};function Fh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Fh.isMDXComponent=!0;const Oh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}zh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Vh.isMDXComponent=!0;const Bh={toc:[]};function Hh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Hh.isMDXComponent=!0;const Yh={toc:[]};function Jh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Jh.isMDXComponent=!0;const Kh={toc:[]};function Qh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Qh.isMDXComponent=!0;const $h={toc:[]};function ty(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}py.isMDXComponent=!0;const cy={toc:[]};function ry(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ry.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ay.isMDXComponent=!0;const iy={toc:[]};function ly(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}hy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}ky.isMDXComponent=!0;const fy={toc:[]};function Dy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Dy.isMDXComponent=!0;const My={toc:[]};function _y(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},My,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}_y.isMDXComponent=!0;const Xy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}wy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ty,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}Cy.isMDXComponent=!0;const xy={toc:[]};function gy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}gy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Zy.isMDXComponent=!0;const by={toc:[]};function vy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},by,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}vy.isMDXComponent=!0;const Ny={toc:[]};function Ay(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Ay.isMDXComponent=!0;const Sy={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Gy.isMDXComponent=!0;const Py={toc:[]};function Ry(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Ry.isMDXComponent=!0;const Ey={toc:[]};function Iy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ey,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Iy.isMDXComponent=!0;const Wy={toc:[]};function jy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}jy.isMDXComponent=!0;const Uy={toc:[]};function Fy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Fy.isMDXComponent=!0;const Oy={toc:[]};function zy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}zy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Vy.isMDXComponent=!0;const By={toc:[]};function Hy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Hy.isMDXComponent=!0;const Yy={toc:[]};function Jy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Jy.isMDXComponent=!0;const Ky={toc:[]};function Qy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ky,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Qy.isMDXComponent=!0;const $y={toc:[]};function tk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}pk.isMDXComponent=!0;const ck={toc:[]};function rk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ck,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rk.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}ak.isMDXComponent=!0;const ik={toc:[]};function lk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}hk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}kk.isMDXComponent=!0;const fk={toc:[]};function Dk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Dk.isMDXComponent=!0;const Mk={toc:[]};function _k(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_k.isMDXComponent=!0;const Xk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}wk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Ck.isMDXComponent=!0;const xk={toc:[]};function gk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}gk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Zk.isMDXComponent=!0;const bk={toc:[]};function vk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}vk.isMDXComponent=!0;const Nk={toc:[]};function Ak(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Ak.isMDXComponent=!0;const Sk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Gk.isMDXComponent=!0;const Pk={toc:[]};function Rk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Rk.isMDXComponent=!0;const Ek={toc:[]};function Ik(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ek,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Ik.isMDXComponent=!0;const Wk={toc:[]};function jk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}jk.isMDXComponent=!0;const Uk={toc:[]};function Fk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Fk.isMDXComponent=!0;const Ok={toc:[]};function zk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ok,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}zk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Vk.isMDXComponent=!0;const Bk={toc:[]};function Hk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Hk.isMDXComponent=!0;const Yk={toc:[]};function Jk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Jk.isMDXComponent=!0;const Kk={toc:[]};function Qk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Qk.isMDXComponent=!0;const $k={toc:[]};function tf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$k,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}pf.isMDXComponent=!0;const cf={toc:[]};function rf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}rf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}yf.isMDXComponent=!0;const kf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}ff.isMDXComponent=!0;const Df={toc:[]};function Mf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Df,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Mf.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_f,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Xf.isMDXComponent=!0;const wf={toc:[]};function Tf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Tf.isMDXComponent=!0;const Cf={toc:[]};function xf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}xf.isMDXComponent=!0;const gf={toc:[]};function Lf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function bf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}bf.isMDXComponent=!0;const vf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Nf.isMDXComponent=!0;const Af={toc:[]};function Sf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Af,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Sf.isMDXComponent=!0;const Gf={toc:[]};function Pf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Pf.isMDXComponent=!0;const Rf={toc:[]};function Ef(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Ef.isMDXComponent=!0;const If={toc:[]};function Wf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},If,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Wf.isMDXComponent=!0;const jf={toc:[]};function Uf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Uf.isMDXComponent=!0;const Ff={toc:[]};function Of(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ff,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Of.isMDXComponent=!0;const zf={toc:[]};function qf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}qf.isMDXComponent=!0;const Vf={toc:[]};function Bf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Bf.isMDXComponent=!0;const Hf={toc:[]};function Yf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Yf.isMDXComponent=!0;const Jf={toc:[]};function Kf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Kf.isMDXComponent=!0;const Qf={toc:[]};function $f(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}$f.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}oD.isMDXComponent=!0;const pD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}cD.isMDXComponent=!0;const rD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}sD.isMDXComponent=!0;const aD={toc:[]};function iD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}iD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}yD.isMDXComponent=!0;const kD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}fD.isMDXComponent=!0;const DD={toc:[]};function MD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}MD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_D,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XD.isMDXComponent=!0;const wD={toc:[]};function TD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}TD.isMDXComponent=!0;const CD={toc:[]};function xD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}xD.isMDXComponent=!0;const gD={toc:[]};function LD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}LD.isMDXComponent=!0;const ZD={toc:[]};function bD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}bD.isMDXComponent=!0;const vD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}ND.isMDXComponent=!0;const AD={toc:[]};function SD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}SD.isMDXComponent=!0;const GD={toc:[]};function PD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}PD.isMDXComponent=!0;const RD={toc:[]};function ED(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}ED.isMDXComponent=!0;const ID={toc:[]};function WD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ID,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}WD.isMDXComponent=!0;const jD={toc:[]};function UD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}UD.isMDXComponent=!0;const FD={toc:[]};function OD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}OD.isMDXComponent=!0;const zD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}qD.isMDXComponent=!0;const VD={toc:[]};function BD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}BD.isMDXComponent=!0;const HD={toc:[]};function YD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}YD.isMDXComponent=!0;const JD={toc:[]};function KD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}KD.isMDXComponent=!0;const QD={toc:[]};function $D(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$D.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}oM.isMDXComponent=!0;const pM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}cM.isMDXComponent=!0;const rM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}sM.isMDXComponent=!0;const aM={toc:[]};function iM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}iM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}yM.isMDXComponent=!0;const kM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}fM.isMDXComponent=!0;const DM={toc:[]};function MM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}MM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_M,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}XM.isMDXComponent=!0;const wM={toc:[]};function TM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}TM.isMDXComponent=!0;const CM={toc:[]};function xM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xM.isMDXComponent=!0;const gM={toc:[]};function LM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}LM.isMDXComponent=!0;const ZM={toc:[]};function bM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bM.isMDXComponent=!0;const vM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}NM.isMDXComponent=!0;const AM={toc:[]};function SM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}SM.isMDXComponent=!0;const GM={toc:[]};function PM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}PM.isMDXComponent=!0;const RM={toc:[]};function EM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}EM.isMDXComponent=!0;const IM={toc:[]};function WM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}WM.isMDXComponent=!0;const jM={toc:[]};function UM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}UM.isMDXComponent=!0;const FM={toc:[]};function OM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}OM.isMDXComponent=!0;const zM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}qM.isMDXComponent=!0;const VM={toc:[]};function BM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}BM.isMDXComponent=!0;const HM={toc:[]};function YM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}YM.isMDXComponent=!0;const JM={toc:[]};function KM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}KM.isMDXComponent=!0;const QM={toc:[]};function $M(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}$M.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}o_.isMDXComponent=!0;const p_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}c_.isMDXComponent=!0;const r_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},r_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}s_.isMDXComponent=!0;const a_={toc:[]};function i_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}i_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}y_.isMDXComponent=!0;const k_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},k_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}f_.isMDXComponent=!0;const D_={toc:[]};function M_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},D_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}M_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},__,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}X_.isMDXComponent=!0;const w_={toc:[]};function T_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}T_.isMDXComponent=!0;const C_={toc:[]};function x_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},C_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}x_.isMDXComponent=!0;const g_={toc:[]};function L_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},g_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}L_.isMDXComponent=!0;const Z_={toc:[]};function b_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Z_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}b_.isMDXComponent=!0;const v_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},v_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}N_.isMDXComponent=!0;const A_={toc:[]};function S_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},A_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}S_.isMDXComponent=!0;const G_={toc:[]};function P_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}P_.isMDXComponent=!0;const R_={toc:[]};function E_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},R_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}E_.isMDXComponent=!0;const I_={toc:[]};function W_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},I_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}W_.isMDXComponent=!0;const j_={toc:[]};function U_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},j_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}U_.isMDXComponent=!0;const F_={toc:[]};function O_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},F_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}O_.isMDXComponent=!0;const z_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}q_.isMDXComponent=!0;const V_={toc:[]};function B_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}B_.isMDXComponent=!0;const H_={toc:[]};function Y_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},H_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Y_.isMDXComponent=!0;const J_={toc:[]};function K_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},J_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}K_.isMDXComponent=!0;const Q_={toc:[]};function $_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Q_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}$_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}oX.isMDXComponent=!0;const pX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}cX.isMDXComponent=!0;const rX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}sX.isMDXComponent=!0;const aX={toc:[]};function iX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}iX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}yX.isMDXComponent=!0;const kX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}fX.isMDXComponent=!0;const DX={toc:[]};function MX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}MX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_X,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}XX.isMDXComponent=!0;const wX={toc:[]};function TX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}TX.isMDXComponent=!0;const CX={toc:[]};function xX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}xX.isMDXComponent=!0;const gX={toc:[]};function LX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LX.isMDXComponent=!0;const ZX={toc:[]};function bX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}bX.isMDXComponent=!0;const vX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}NX.isMDXComponent=!0;const AX={toc:[]};function SX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}SX.isMDXComponent=!0;const GX={toc:[]};function PX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}PX.isMDXComponent=!0;const RX={toc:[]};function EX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}EX.isMDXComponent=!0;const IX={toc:[]};function WX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}WX.isMDXComponent=!0;const jX={toc:[]};function UX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}UX.isMDXComponent=!0;const FX={toc:[]};function OX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}OX.isMDXComponent=!0;const zX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}qX.isMDXComponent=!0;const VX={toc:[]};function BX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}BX.isMDXComponent=!0;const HX={toc:[]};function YX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}YX.isMDXComponent=!0;const JX={toc:[]};function KX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}KX.isMDXComponent=!0;const QX={toc:[]};function $X(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}$X.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}ow.isMDXComponent=!0;const pw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}cw.isMDXComponent=!0;const rw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}sw.isMDXComponent=!0;const aw={toc:[]};function iw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}iw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}yw.isMDXComponent=!0;const kw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}fw.isMDXComponent=!0;const Dw={toc:[]};function Mw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Mw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_w,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Xw.isMDXComponent=!0;const ww={toc:[]};function Tw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Tw.isMDXComponent=!0;const Cw={toc:[]};function xw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}xw.isMDXComponent=!0;const gw={toc:[]};function Lw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function bw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bw.isMDXComponent=!0;const vw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Nw.isMDXComponent=!0;const Aw={toc:[]};function Sw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Aw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Sw.isMDXComponent=!0;const Gw={toc:[]};function Pw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Pw.isMDXComponent=!0;const Rw={toc:[]};function Ew(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Ew.isMDXComponent=!0;const Iw={toc:[]};function Ww(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Iw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ww.isMDXComponent=!0;const jw={toc:[]};function Uw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Uw.isMDXComponent=!0;const Fw={toc:[]};function Ow(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Ow.isMDXComponent=!0;const zw={toc:[]};function qw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}qw.isMDXComponent=!0;const Vw={toc:[]};function Bw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Bw.isMDXComponent=!0;const Hw={toc:[]};function Yw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Yw.isMDXComponent=!0;const Jw={toc:[]};function Kw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Kw.isMDXComponent=!0;const Qw={toc:[]};function $w(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$w.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oT.isMDXComponent=!0;const pT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}cT.isMDXComponent=!0;const rT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sT.isMDXComponent=!0;const aT={toc:[]};function iT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}iT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yT.isMDXComponent=!0;const kT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}fT.isMDXComponent=!0;const DT={toc:[]};function MT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}MT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_T,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XT.isMDXComponent=!0;const wT={toc:[]};function TT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}TT.isMDXComponent=!0;const CT={toc:[]};function xT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}xT.isMDXComponent=!0;const gT={toc:[]};function LT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}LT.isMDXComponent=!0;const ZT={toc:[]};function bT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}bT.isMDXComponent=!0;const vT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}NT.isMDXComponent=!0;const AT={toc:[]};function ST(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}ST.isMDXComponent=!0;const GT={toc:[]};function PT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}PT.isMDXComponent=!0;const RT={toc:[]};function ET(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}ET.isMDXComponent=!0;const IT={toc:[]};function WT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}WT.isMDXComponent=!0;const jT={toc:[]};function UT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}UT.isMDXComponent=!0;const FT={toc:[]};function OT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}OT.isMDXComponent=!0;const zT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}qT.isMDXComponent=!0;const VT={toc:[]};function BT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}BT.isMDXComponent=!0;const HT={toc:[]};function YT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}YT.isMDXComponent=!0;const JT={toc:[]};function KT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}KT.isMDXComponent=!0;const QT={toc:[]};function $T(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}$T.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}oC.isMDXComponent=!0;const pC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}cC.isMDXComponent=!0;const rC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}sC.isMDXComponent=!0;const aC={toc:[]};function iC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}iC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}yC.isMDXComponent=!0;const kC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}fC.isMDXComponent=!0;const DC={toc:[]};function MC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}MC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_C,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}XC.isMDXComponent=!0;const wC={toc:[]};function TC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}TC.isMDXComponent=!0;const CC={toc:[]};function xC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}xC.isMDXComponent=!0;const gC={toc:[]};function LC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LC.isMDXComponent=!0;const ZC={toc:[]};function bC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}bC.isMDXComponent=!0;const vC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}NC.isMDXComponent=!0;const AC={toc:[]};function SC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}SC.isMDXComponent=!0;const GC={toc:[]};function PC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}PC.isMDXComponent=!0;const RC={toc:[]};function EC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}EC.isMDXComponent=!0;const IC={toc:[]};function WC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}WC.isMDXComponent=!0;const jC={toc:[]};function UC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}UC.isMDXComponent=!0;const FC={toc:[]};function OC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}OC.isMDXComponent=!0;const zC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}qC.isMDXComponent=!0;const VC={toc:[]};function BC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}BC.isMDXComponent=!0;const HC={toc:[]};function YC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}YC.isMDXComponent=!0;const JC={toc:[]};function KC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}KC.isMDXComponent=!0;const QC={toc:[]};function $C(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}$C.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}ox.isMDXComponent=!0;const px={toc:[]};function cx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}cx.isMDXComponent=!0;const rx={toc:[]};function sx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}sx.isMDXComponent=!0;const ax={toc:[]};function ix(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ix.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}yx.isMDXComponent=!0;const kx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}fx.isMDXComponent=!0;const Dx={toc:[]};function Mx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Mx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_x,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Xx.isMDXComponent=!0;const wx={toc:[]};function Tx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Tx.isMDXComponent=!0;const Cx={toc:[]};function xx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}xx.isMDXComponent=!0;const gx={toc:[]};function Lx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function bx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bx.isMDXComponent=!0;const vx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Nx.isMDXComponent=!0;const Ax={toc:[]};function Sx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ax,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Sx.isMDXComponent=!0;const Gx={toc:[]};function Px(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Px.isMDXComponent=!0;const Rx={toc:[]};function Ex(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Ex.isMDXComponent=!0;const Ix={toc:[]};function Wx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ix,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Wx.isMDXComponent=!0;const jx={toc:[]};function Ux(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Ux.isMDXComponent=!0;const Fx={toc:[]};function Ox(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Ox.isMDXComponent=!0;const zx={toc:[]};function qx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}qx.isMDXComponent=!0;const Vx={toc:[]};function Bx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Bx.isMDXComponent=!0;const Hx={toc:[]};function Yx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Yx.isMDXComponent=!0;const Jx={toc:[]};function Kx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Kx.isMDXComponent=!0;const Qx={toc:[]};function $x(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$x.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}og.isMDXComponent=!0;const pg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}cg.isMDXComponent=!0;const rg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sg.isMDXComponent=!0;const ag={toc:[]};function ig(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}ig.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yg.isMDXComponent=!0;const kg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}fg.isMDXComponent=!0;const Dg={toc:[]};function Mg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Mg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_g,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Xg.isMDXComponent=!0;const wg={toc:[]};function Tg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Tg.isMDXComponent=!0;const Cg={toc:[]};function xg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}xg.isMDXComponent=!0;const gg={toc:[]};function Lg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function bg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}bg.isMDXComponent=!0;const vg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Ng.isMDXComponent=!0;const Ag={toc:[]};function Sg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ag,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}Sg.isMDXComponent=!0;const Gg={toc:[]};function Pg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Pg.isMDXComponent=!0;const Rg={toc:[]};function Eg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Eg.isMDXComponent=!0;const Ig={toc:[]};function Wg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ig,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Wg.isMDXComponent=!0;const jg={toc:[]};function Ug(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Ug.isMDXComponent=!0;const Fg={toc:[]};function Og(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Og.isMDXComponent=!0;const zg={toc:[]};function qg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}qg.isMDXComponent=!0;const Vg={toc:[]};function Bg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Bg.isMDXComponent=!0;const Hg={toc:[]};function Yg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Yg.isMDXComponent=!0;const Jg={toc:[]};function Kg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Kg.isMDXComponent=!0;const Qg={toc:[]};function $g(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}$g.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}oL.isMDXComponent=!0;const pL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}cL.isMDXComponent=!0;const rL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}sL.isMDXComponent=!0;const aL={toc:[]};function iL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}iL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}yL.isMDXComponent=!0;const kL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}fL.isMDXComponent=!0;const DL={toc:[]};function ML(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ML.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_L,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}XL.isMDXComponent=!0;const wL={toc:[]};function TL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}TL.isMDXComponent=!0;const CL={toc:[]};function xL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}xL.isMDXComponent=!0;const gL={toc:[]};function LL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LL.isMDXComponent=!0;const ZL={toc:[]};function bL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bL.isMDXComponent=!0;const vL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}NL.isMDXComponent=!0;const AL={toc:[]};function SL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}SL.isMDXComponent=!0;const GL={toc:[]};function PL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}PL.isMDXComponent=!0;const RL={toc:[]};function EL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}EL.isMDXComponent=!0;const IL={toc:[]};function WL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}WL.isMDXComponent=!0;const jL={toc:[]};function UL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}UL.isMDXComponent=!0;const FL={toc:[]};function OL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}OL.isMDXComponent=!0;const zL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qL.isMDXComponent=!0;const VL={toc:[]};function BL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}BL.isMDXComponent=!0;const HL={toc:[]};function YL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}YL.isMDXComponent=!0;const JL={toc:[]};function KL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KL.isMDXComponent=!0;const QL={toc:[]};function $L(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}$L.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}cZ.isMDXComponent=!0;const rZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function iZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}iZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}yZ.isMDXComponent=!0;const kZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}fZ.isMDXComponent=!0;const DZ={toc:[]};function MZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}MZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_Z,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}XZ.isMDXComponent=!0;const wZ={toc:[]};function TZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}TZ.isMDXComponent=!0;const CZ={toc:[]};function xZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}xZ.isMDXComponent=!0;const gZ={toc:[]};function LZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function bZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}bZ.isMDXComponent=!0;const vZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NZ.isMDXComponent=!0;const AZ={toc:[]};function SZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}SZ.isMDXComponent=!0;const GZ={toc:[]};function PZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}PZ.isMDXComponent=!0;const RZ={toc:[]};function EZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}EZ.isMDXComponent=!0;const IZ={toc:[]};function WZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}WZ.isMDXComponent=!0;const jZ={toc:[]};function UZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}UZ.isMDXComponent=!0;const FZ={toc:[]};function OZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}OZ.isMDXComponent=!0;const zZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function BZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}BZ.isMDXComponent=!0;const HZ={toc:[]};function YZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}YZ.isMDXComponent=!0;const JZ={toc:[]};function KZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}KZ.isMDXComponent=!0;const QZ={toc:[]};function $Z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$Z.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ob.isMDXComponent=!0;const pb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}cb.isMDXComponent=!0;const rb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sb.isMDXComponent=!0;const ab={toc:[]};function ib(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ib.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}yb.isMDXComponent=!0;const kb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fb.isMDXComponent=!0;const Db={toc:[]};function Mb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Db,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mb.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_b,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Xb.isMDXComponent=!0;const wb={toc:[]};function Tb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Tb.isMDXComponent=!0;const Cb={toc:[]};function xb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xb.isMDXComponent=!0;const gb={toc:[]};function Lb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function bb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}bb.isMDXComponent=!0;const vb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Nb.isMDXComponent=!0;const Ab={toc:[]};function Sb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ab,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Sb.isMDXComponent=!0;const Gb={toc:[]};function Pb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Pb.isMDXComponent=!0;const Rb={toc:[]};function Eb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Eb.isMDXComponent=!0;const Ib={toc:[]};function Wb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ib,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Wb.isMDXComponent=!0;const jb={toc:[]};function Ub(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Ub.isMDXComponent=!0;const Fb={toc:[]};function Ob(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Ob.isMDXComponent=!0;const zb={toc:[]};function qb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}qb.isMDXComponent=!0;const Vb={toc:[]};function Bb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}Bb.isMDXComponent=!0;const Hb={toc:[]};function Yb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Yb.isMDXComponent=!0;const Jb={toc:[]};function Kb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Kb.isMDXComponent=!0;const Qb={toc:[]};function $b(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}$b.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ov.isMDXComponent=!0;const pv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}cv.isMDXComponent=!0;const rv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}sv.isMDXComponent=!0;const av={toc:[]};function iv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}iv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}yv.isMDXComponent=!0;const kv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}fv.isMDXComponent=!0;const Dv={toc:[]};function Mv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Mv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_v,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Xv.isMDXComponent=!0;const wv={toc:[]};function Tv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Tv.isMDXComponent=!0;const Cv={toc:[]};function xv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}xv.isMDXComponent=!0;const gv={toc:[]};function Lv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function bv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}bv.isMDXComponent=!0;const vv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Nv.isMDXComponent=!0;const Av={toc:[]};function Sv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Av,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Sv.isMDXComponent=!0;const Gv={toc:[]};function Pv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Pv.isMDXComponent=!0;const Rv={toc:[]};function Ev(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Ev.isMDXComponent=!0;const Iv={toc:[]};function Wv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Iv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Wv.isMDXComponent=!0;const jv={toc:[]};function Uv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Uv.isMDXComponent=!0;const Fv={toc:[]};function Ov(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ov.isMDXComponent=!0;const zv={toc:[]};function qv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}qv.isMDXComponent=!0;const Vv={toc:[]};function Bv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Bv.isMDXComponent=!0;const Hv={toc:[]};function Yv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Yv.isMDXComponent=!0;const Jv={toc:[]};function Kv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Kv.isMDXComponent=!0;const Qv={toc:[]};function $v(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}$v.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}oN.isMDXComponent=!0;const pN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}cN.isMDXComponent=!0;const rN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}sN.isMDXComponent=!0;const aN={toc:[]};function iN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}iN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yN.isMDXComponent=!0;const kN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}fN.isMDXComponent=!0;const DN={toc:[]};function MN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}MN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_N,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}XN.isMDXComponent=!0;const wN={toc:[]};function TN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}TN.isMDXComponent=!0;const CN={toc:[]};function xN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}xN.isMDXComponent=!0;const gN={toc:[]};function LN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the custom offset for this node's children."))}LN.isMDXComponent=!0;const ZN={toc:[]};function bN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}bN.isMDXComponent=!0;const vN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}NN.isMDXComponent=!0;const AN={toc:[]};function SN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}SN.isMDXComponent=!0;const GN={toc:[]};function PN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}PN.isMDXComponent=!0;const RN={toc:[]};function EN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}EN.isMDXComponent=!0;const IN={toc:[]};function WN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}WN.isMDXComponent=!0;const jN={toc:[]};function UN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}UN.isMDXComponent=!0;const FN={toc:[]};function ON(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}ON.isMDXComponent=!0;const zN={toc:[]};function qN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}qN.isMDXComponent=!0;const VN={toc:[]};function BN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}BN.isMDXComponent=!0;const HN={toc:[]};function YN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}YN.isMDXComponent=!0;const JN={toc:[]};function KN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}KN.isMDXComponent=!0;const QN={toc:[]};function $N(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}$N.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oA.isMDXComponent=!0;const pA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}cA.isMDXComponent=!0;const rA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sA.isMDXComponent=!0;const aA={toc:[]};function iA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}yA.isMDXComponent=!0;const kA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fA.isMDXComponent=!0;const DA={toc:[]};function MA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}MA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_A,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}XA.isMDXComponent=!0;const wA={toc:[]};function TA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}TA.isMDXComponent=!0;const CA={toc:[]};function xA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}xA.isMDXComponent=!0;const gA={toc:[]};function LA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}LA.isMDXComponent=!0;const ZA={toc:[]};function bA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}bA.isMDXComponent=!0;const vA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}NA.isMDXComponent=!0;const AA={toc:[]};function SA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}SA.isMDXComponent=!0;const GA={toc:[]};function PA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}PA.isMDXComponent=!0;const RA={toc:[]};function EA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}EA.isMDXComponent=!0;const IA={toc:[]};function WA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}WA.isMDXComponent=!0;const jA={toc:[]};function UA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,p.kt)("p",null,"By default, any property is cloneable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}UA.isMDXComponent=!0;const FA={toc:[]};function OA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}OA.isMDXComponent=!0;const zA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a cloneable property decorator."))}qA.isMDXComponent=!0;const VA={toc:[]};function BA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be cloneable."))}BA.isMDXComponent=!0;const HA={toc:[]};function YA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}YA.isMDXComponent=!0;const JA={toc:[]};function KA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}KA.isMDXComponent=!0;const QA={toc:[]};function $A(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a compound property decorator."))}$A.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#createComputed"},(0,p.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}oS.isMDXComponent=!0;const pS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a computed method decorator."))}cS.isMDXComponent=!0;const rS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the initial value of a property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}sS.isMDXComponent=!0;const aS={toc:[]};function iS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}iS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an initial property value decorator."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the property."))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,p.kt)("p",null,"By default, any property is inspectable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}yS.isMDXComponent=!0;const kS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}fS.isMDXComponent=!0;const DS={toc:[]};function MS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an inspectable property decorator."))}MS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_S,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be inspectable."))}XS.isMDXComponent=!0;const wS={toc:[]};function TS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}TS.isMDXComponent=!0;const CS={toc:[]};function xS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}xS.isMDXComponent=!0;const gS={toc:[]};function LS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a property interpolation function decorator."))}LS.isMDXComponent=!0;const ZS={toc:[]};function bS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function for the property."))}bS.isMDXComponent=!0;const vS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,p.kt)("p",null,"If the wrapper class has a method called ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}NS.isMDXComponent=!0;const AS={toc:[]};function SS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},AS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}SS.isMDXComponent=!0;const GS={toc:[]};function PS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a property parser decorator."))}PS.isMDXComponent=!0;const RS={toc:[]};function ES(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}ES.isMDXComponent=!0;const IS={toc:[]};function WS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given property into a signal."),(0,p.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")),(0,p.kt)("p",null,"See the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#PropertyOwner"},(0,p.kt)("inlineCode",{parentName:"a"},"PropertyOwner"))," type for more detailed method signatures."))}WS.isMDXComponent=!0;const jS={toc:[]};function US(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}US.isMDXComponent=!0;const FS={toc:[]};function OS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},FS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal property decorator."))}OS.isMDXComponent=!0;const zS={toc:[]};function qS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,p.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,p.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,p.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#property"},(0,p.kt)("inlineCode",{parentName:"a"},"property"))," decorator."))}qS.isMDXComponent=!0;const VS={toc:[]};function BS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}BS.isMDXComponent=!0;const HS={toc:[]};function YS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a property wrapper decorator."))}YS.isMDXComponent=!0;const JS={toc:[]};function KS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}KS.isMDXComponent=!0;const QS={toc:[]};function $S(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}$S.isMDXComponent=!0;const tG={content_0_0:r,content_0_1:a,content_0_2:l,content_0_3:m,content_0_4:h,content_0_5:k,content_0_6:D,content_0_7:_,content_0_8:w,content_0_9:C,content_0_10:g,content_0_11:Z,content_0_12:v,content_0_13:A,content_0_14:G,content_0_15:R,content_0_16:I,content_0_17:j,content_0_18:F,content_0_19:z,content_0_20:V,content_0_21:H,content_0_22:J,content_0_23:Q,content_0_24:tt,content_0_25:et,content_0_26:pt,content_0_27:rt,content_0_28:at,content_0_29:lt,content_0_30:mt,content_0_31:ht,content_0_32:kt,content_0_33:Dt,content_0_34:_t,content_0_35:wt,content_0_36:Ct,content_0_37:gt,content_0_38:Zt,content_0_39:vt,content_0_40:At,content_0_41:Gt,content_0_42:Rt,content_0_43:It,content_0_44:jt,content_0_45:Ft,content_0_46:zt,content_0_47:Vt,content_0_48:Ht,content_0_49:Jt,content_0_50:Qt,content_0_51:tn,content_0_52:en,content_0_53:pn,content_0_54:rn,content_0_55:an,content_0_56:un,content_0_57:dn,content_0_58:yn,content_0_59:fn,content_0_60:Mn,content_0_61:Xn,content_0_62:Tn,content_0_63:xn,content_0_64:Ln,content_0_65:bn,content_0_66:Nn,content_0_67:Sn,content_0_68:Pn,content_0_69:En,content_0_70:Wn,content_0_71:Un,content_0_72:On,content_0_73:qn,content_0_74:Bn,content_0_75:Yn,content_0_76:Kn,content_0_77:$n,content_0_78:ne,content_0_79:oe,content_0_80:ce,content_0_81:se,content_0_82:ie,content_0_83:ue,content_0_84:de,content_0_85:ye,content_0_86:fe,content_0_87:Me,content_0_88:Xe,content_0_89:Te,content_0_90:xe,content_0_91:Le,content_0_92:be,content_0_93:Ne,content_0_94:Se,content_0_95:Pe,content_0_96:Ee,content_0_97:We,content_0_98:Ue,content_0_99:Oe,content_0_100:qe,content_0_101:Be,content_0_102:Ye,content_0_103:Ke,content_0_104:$e,content_0_105:no,content_0_106:oo,content_0_107:co,content_0_108:so,content_0_109:io,content_0_110:uo,content_0_111:ho,content_0_112:ko,content_0_113:Do,content_0_114:_o,content_0_115:wo,content_0_116:Co,content_0_117:go,content_0_118:Zo,content_0_119:vo,content_0_120:Ao,content_0_121:Go,content_0_122:Ro,content_0_123:Io,content_0_124:jo,content_0_125:Fo,content_0_126:zo,content_0_127:Vo,content_0_128:Ho,content_0_129:Jo,content_0_130:Qo,content_0_131:tp,content_0_132:ep,content_0_133:pp,content_0_134:rp,content_0_135:ap,content_0_136:lp,content_0_137:mp,content_0_138:hp,content_0_139:kp,content_0_140:Dp,content_0_141:_p,content_0_142:wp,content_0_143:Cp,content_0_144:gp,content_0_145:Zp,content_0_146:vp,content_0_147:Ap,content_0_148:Gp,content_0_149:Rp,content_0_150:Ip,content_0_151:jp,content_0_152:Fp,content_0_153:zp,content_0_154:Vp,content_0_155:Hp,content_0_156:Jp,content_0_157:Qp,content_0_158:tc,content_0_159:ec,content_0_160:pc,content_0_161:rc,content_0_162:ac,content_0_163:lc,content_0_164:mc,content_0_165:hc,content_0_166:kc,content_0_167:Dc,content_0_168:_c,content_0_169:wc,content_0_170:Cc,content_0_171:gc,content_0_172:Zc,content_0_173:vc,content_0_174:Ac,content_0_175:Gc,content_0_176:Rc,content_0_177:Ic,content_0_178:jc,content_0_179:Fc,content_0_180:zc,content_0_181:Vc,content_0_182:Hc,content_0_183:Jc,content_0_184:Qc,content_0_185:tr,content_0_186:er,content_0_187:pr,content_0_188:rr,content_0_189:ar,content_0_190:lr,content_0_191:mr,content_0_192:hr,content_0_193:kr,content_0_194:Dr,content_0_195:_r,content_0_196:wr,content_0_197:Cr,content_0_198:gr,content_0_199:Zr,content_0_200:vr,content_0_201:Ar,content_0_202:Gr,content_0_203:Rr,content_0_204:Ir,content_0_205:jr,content_0_206:Fr,content_0_207:zr,content_0_208:Vr,content_0_209:Hr,content_0_210:Jr,content_0_211:Qr,content_0_212:ts,content_0_213:es,content_0_214:ps,content_0_215:rs,content_0_216:as,content_0_217:ls,content_0_218:ms,content_0_219:hs,content_0_220:ks,content_0_221:Ds,content_0_222:_s,content_0_223:ws,content_0_224:Cs,content_0_225:gs,content_0_226:Zs,content_0_227:vs,content_0_228:As,content_0_229:Gs,content_0_230:Rs,content_0_231:Is,content_0_232:js,content_0_233:Fs,content_0_234:zs,content_0_235:Vs,content_0_236:Hs,content_0_237:Js,content_0_238:Qs,content_0_239:ta,content_0_240:ea,content_0_241:pa,content_0_242:ra,content_0_243:aa,content_0_244:la,content_0_245:ma,content_0_246:ha,content_0_247:ka,content_0_248:Da,content_0_249:_a,content_0_250:wa,content_0_251:Ca,content_0_252:ga,content_0_253:Za,content_0_254:va,content_0_255:Aa,content_0_256:Ga,content_0_257:Ra,content_0_258:Ia,content_0_259:ja,content_0_260:Fa,content_0_261:za,content_0_262:Va,content_0_263:Ha,content_0_264:Ja,content_0_265:Qa,content_0_266:ti,content_0_267:ei,content_0_268:pi,content_0_269:ri,content_0_270:ai,content_0_271:li,content_0_272:mi,content_0_273:hi,content_0_274:ki,content_0_275:Di,content_0_276:_i,content_0_277:wi,content_0_278:Ci,content_0_279:gi,content_0_280:Zi,content_0_281:vi,content_0_282:Ai,content_0_283:Gi,content_0_284:Ri,content_0_285:Ii,content_0_286:ji,content_0_287:Fi,content_0_288:zi,content_0_289:Vi,content_0_290:Hi,content_0_291:Ji,content_0_292:Qi,content_0_293:tl,content_0_294:el,content_0_295:pl,content_0_296:rl,content_0_297:al,content_0_298:ll,content_0_299:ml,content_0_300:hl,content_0_301:kl,content_0_302:Dl,content_0_303:_l,content_0_304:wl,content_0_305:Cl,content_0_306:gl,content_0_307:Zl,content_0_308:vl,content_0_309:Al,content_0_310:Gl,content_0_311:Rl,content_0_312:Il,content_0_313:jl,content_0_314:Fl,content_0_315:zl,content_0_316:Vl,content_0_317:Hl,content_0_318:Jl,content_0_319:Ql,content_0_320:tu,content_0_321:eu,content_0_322:pu,content_0_323:ru,content_0_324:au,content_0_325:lu,content_0_326:mu,content_0_327:hu,content_0_328:ku,content_0_329:Du,content_0_330:_u,content_0_331:wu,content_0_332:Cu,content_0_333:gu,content_0_334:Zu,content_0_335:vu,content_0_336:Au,content_0_337:Gu,content_0_338:Ru,content_0_339:Iu,content_0_340:ju,content_0_341:Fu,content_0_342:zu,content_0_343:Vu,content_0_344:Hu,content_0_345:Ju,content_0_346:Qu,content_0_347:tm,content_0_348:em,content_0_349:pm,content_0_350:rm,content_0_351:am,content_0_352:lm,content_0_353:mm,content_0_354:hm,content_0_355:km,content_0_356:Dm,content_0_357:_m,content_0_358:wm,content_0_359:Cm,content_0_360:gm,content_0_361:Zm,content_0_362:vm,content_0_363:Am,content_0_364:Gm,content_0_365:Rm,content_0_366:Im,content_0_367:jm,content_0_368:Fm,content_0_369:zm,content_0_370:Vm,content_0_371:Hm,content_0_372:Jm,content_0_373:Qm,content_0_374:td,content_0_375:ed,content_0_376:pd,content_0_377:rd,content_0_378:ad,content_0_379:ld,content_0_380:md,content_0_381:hd,content_0_382:kd,content_0_383:Dd,content_0_384:_d,content_0_385:wd,content_0_386:Cd,content_0_387:gd,content_0_388:Zd,content_0_389:vd,content_0_390:Ad,content_0_391:Gd,content_0_392:Rd,content_0_393:Id,content_0_394:jd,content_0_395:Fd,content_0_396:zd,content_0_397:Vd,content_0_398:Hd,content_0_399:Jd,content_0_400:Qd,content_0_401:th,content_0_402:eh,content_0_403:ph,content_0_404:rh,content_0_405:ah,content_0_406:lh,content_0_407:mh,content_0_408:hh,content_0_409:kh,content_0_410:Dh,content_0_411:_h,content_0_412:wh,content_0_413:Ch,content_0_414:gh,content_0_415:Zh,content_0_416:vh,content_0_417:Ah,content_0_418:Gh,content_0_419:Rh,content_0_420:Ih,content_0_421:jh,content_1753_0:Fh,content_1753_1:zh,content_1753_2:Vh,content_1753_3:Hh,content_1753_4:Jh,content_1753_5:Qh,content_1753_6:ty,content_1753_7:ey,content_1753_8:py,content_1753_9:ry,content_1753_10:ay,content_1753_11:ly,content_1753_12:my,content_1753_13:hy,content_1753_14:ky,content_1753_15:Dy,content_1753_16:_y,content_1753_17:wy,content_1753_18:Cy,content_1753_19:gy,content_1753_20:Zy,content_1753_21:vy,content_1753_22:Ay,content_1753_23:Gy,content_1753_24:Ry,content_1753_25:Iy,content_1753_26:jy,content_1753_27:Fy,content_1753_28:zy,content_1753_29:Vy,content_1753_30:Hy,content_1753_31:Jy,content_1753_32:Qy,content_1753_33:tk,content_1753_34:ek,content_1753_35:pk,content_1753_36:rk,content_1753_37:ak,content_1753_38:lk,content_1753_39:mk,content_1753_40:hk,content_1753_41:kk,content_1753_42:Dk,content_1753_43:_k,content_1753_44:wk,content_1753_45:Ck,content_1753_46:gk,content_1753_47:Zk,content_1753_48:vk,content_1753_49:Ak,content_1753_50:Gk,content_1753_51:Rk,content_1753_52:Ik,content_1753_53:jk,content_1753_54:Fk,content_1753_55:zk,content_1753_56:Vk,content_1753_57:Hk,content_1753_58:Jk,content_1753_59:Qk,content_1753_60:tf,content_1753_61:ef,content_1753_62:pf,content_1753_63:rf,content_1753_64:af,content_1753_65:uf,content_1753_66:df,content_1753_67:yf,content_1753_68:ff,content_1753_69:Mf,content_1753_70:Xf,content_1753_71:Tf,content_1753_72:xf,content_1753_73:Lf,content_1753_74:bf,content_1753_75:Nf,content_1753_76:Sf,content_1753_77:Pf,content_1753_78:Ef,content_1753_79:Wf,content_1753_80:Uf,content_1753_81:Of,content_1753_82:qf,content_1753_83:Bf,content_1753_84:Yf,content_1753_85:Kf,content_1753_86:$f,content_1753_87:nD,content_1753_88:oD,content_1753_89:cD,content_1753_90:sD,content_1753_91:iD,content_1753_92:uD,content_1753_93:dD,content_1753_94:yD,content_1753_95:fD,content_1753_96:MD,content_1753_97:XD,content_1753_98:TD,content_1753_99:xD,content_1753_100:LD,content_1753_101:bD,content_1753_102:ND,content_1753_103:SD,content_1753_104:PD,content_1753_105:ED,content_1753_106:WD,content_1753_107:UD,content_1753_108:OD,content_1753_109:qD,content_1753_110:BD,content_1753_111:YD,content_1753_112:KD,content_1753_113:$D,content_1753_114:nM,content_1753_115:oM,content_1753_116:cM,content_1753_117:sM,content_1753_118:iM,content_1753_119:uM,content_1753_120:dM,content_1753_121:yM,content_1753_122:fM,content_1753_123:MM,content_1753_124:XM,content_1753_125:TM,content_1753_126:xM,content_1753_127:LM,content_1753_128:bM,content_1753_129:NM,content_1753_130:SM,content_1753_131:PM,content_1753_132:EM,content_1753_133:WM,content_1753_134:UM,content_1753_135:OM,content_1753_136:qM,content_1753_137:BM,content_1753_138:YM,content_1753_139:KM,content_1753_140:$M,content_1753_141:n_,content_1753_142:o_,content_1753_143:c_,content_1753_144:s_,content_1753_145:i_,content_1753_146:u_,content_1753_147:d_,content_1753_148:y_,content_1753_149:f_,content_1753_150:M_,content_1753_151:X_,content_1753_152:T_,content_1753_153:x_,content_1753_154:L_,content_1753_155:b_,content_1753_156:N_,content_1753_157:S_,content_1753_158:P_,content_1753_159:E_,content_1753_160:W_,content_1753_161:U_,content_1753_162:O_,content_1753_163:q_,content_1753_164:B_,content_1753_165:Y_,content_1753_166:K_,content_1753_167:$_,content_1753_168:nX,content_1753_169:oX,content_1753_170:cX,content_1753_171:sX,content_1753_172:iX,content_1753_173:uX,content_1753_174:dX,content_1753_175:yX,content_1753_176:fX,content_1753_177:MX,content_1753_178:XX,content_1753_179:TX,content_1753_180:xX,content_1753_181:LX,content_1753_182:bX,content_1753_183:NX,content_1753_184:SX,content_1753_185:PX,content_1753_186:EX,content_1753_187:WX,content_1753_188:UX,content_1753_189:OX,content_1753_190:qX,content_1753_191:BX,content_1753_192:YX,content_1753_193:KX,content_1753_194:$X,content_1753_195:nw,content_1753_196:ow,content_1753_197:cw,content_1753_198:sw,content_1753_199:iw,content_1753_200:uw,content_1753_201:dw,content_1753_202:yw,content_1753_203:fw,content_1753_204:Mw,content_1753_205:Xw,content_1753_206:Tw,content_1753_207:xw,content_1753_208:Lw,content_1753_209:bw,content_1753_210:Nw,content_1753_211:Sw,content_1753_212:Pw,content_1753_213:Ew,content_1753_214:Ww,content_1753_215:Uw,content_1753_216:Ow,content_1753_217:qw,content_1753_218:Bw,content_1753_219:Yw,content_1753_220:Kw,content_1753_221:$w,content_1753_222:nT,content_1753_223:oT,content_1753_224:cT,content_1753_225:sT,content_1753_226:iT,content_1753_227:uT,content_1753_228:dT,content_1753_229:yT,content_1753_230:fT,content_1753_231:MT,content_1753_232:XT,content_1753_233:TT,content_1753_234:xT,content_1753_235:LT,content_1753_236:bT,content_1753_237:NT,content_1753_238:ST,content_1753_239:PT,content_1753_240:ET,content_1753_241:WT,content_1753_242:UT,content_1753_243:OT,content_1753_244:qT,content_1753_245:BT,content_1753_246:YT,content_1753_247:KT,content_1753_248:$T,content_1753_249:nC,content_1753_250:oC,content_1753_251:cC,content_1753_252:sC,content_1753_253:iC,content_1753_254:uC,content_1753_255:dC,content_1753_256:yC,content_1753_257:fC,content_1753_258:MC,content_1753_259:XC,content_1753_260:TC,content_1753_261:xC,content_1753_262:LC,content_1753_263:bC,content_1753_264:NC,content_1753_265:SC,content_1753_266:PC,content_1753_267:EC,content_1753_268:WC,content_1753_269:UC,content_1753_270:OC,content_1753_271:qC,content_1753_272:BC,content_1753_273:YC,content_1753_274:KC,content_1753_275:$C,content_1753_276:nx,content_1753_277:ox,content_1753_278:cx,content_1753_279:sx,content_1753_280:ix,content_1753_281:ux,content_1753_282:dx,content_1753_283:yx,content_1753_284:fx,content_1753_285:Mx,content_1753_286:Xx,content_1753_287:Tx,content_1753_288:xx,content_1753_289:Lx,content_1753_290:bx,content_1753_291:Nx,content_1753_292:Sx,content_1753_293:Px,content_1753_294:Ex,content_1753_295:Wx,content_1753_296:Ux,content_1753_297:Ox,content_1753_298:qx,content_1753_299:Bx,content_1753_300:Yx,content_1753_301:Kx,content_1753_302:$x,content_1753_303:ng,content_1753_304:og,content_1753_305:cg,content_1753_306:sg,content_1753_307:ig,content_1753_308:ug,content_1753_309:dg,content_1753_310:yg,content_1753_311:fg,content_1753_312:Mg,content_1753_313:Xg,content_1753_314:Tg,content_1753_315:xg,content_1753_316:Lg,content_1753_317:bg,content_1753_318:Ng,content_1753_319:Sg,content_1753_320:Pg,content_1753_321:Eg,content_1753_322:Wg,content_1753_323:Ug,content_1753_324:Og,content_1753_325:qg,content_1753_326:Bg,content_1753_327:Yg,content_1753_328:Kg,content_1753_329:$g,content_1753_330:nL,content_1753_331:oL,content_1753_332:cL,content_1753_333:sL,content_1753_334:iL,content_1753_335:uL,content_1753_336:dL,content_1753_337:yL,content_1753_338:fL,content_1753_339:ML,content_1753_340:XL,content_1753_341:TL,content_1753_342:xL,content_1753_343:LL,content_1753_344:bL,content_1753_345:NL,content_1753_346:SL,content_1753_347:PL,content_1753_348:EL,content_1753_349:WL,content_1753_350:UL,content_1753_351:OL,content_1753_352:qL,content_1753_353:BL,content_1753_354:YL,content_1753_355:KL,content_1753_356:$L,content_1753_357:nZ,content_1753_358:oZ,content_1753_359:cZ,content_1753_360:sZ,content_1753_361:iZ,content_1753_362:uZ,content_1753_363:dZ,content_1753_364:yZ,content_1753_365:fZ,content_1753_366:MZ,content_1753_367:XZ,content_1753_368:TZ,content_1753_369:xZ,content_1753_370:LZ,content_1753_371:bZ,content_1753_372:NZ,content_1753_373:SZ,content_1753_374:PZ,content_1753_375:EZ,content_1753_376:WZ,content_1753_377:UZ,content_1753_378:OZ,content_1753_379:qZ,content_1753_380:BZ,content_1753_381:YZ,content_1753_382:KZ,content_1753_383:$Z,content_1753_384:nb,content_1753_385:ob,content_1753_386:cb,content_1753_387:sb,content_1753_388:ib,content_1753_389:ub,content_1753_390:db,content_1753_391:yb,content_1753_392:fb,content_1753_393:Mb,content_1753_394:Xb,content_1753_395:Tb,content_1753_396:xb,content_1753_397:Lb,content_1753_398:bb,content_1753_399:Nb,content_1753_400:Sb,content_1753_401:Pb,content_1753_402:Eb,content_1753_403:Wb,content_1753_404:Ub,content_1753_405:Ob,content_1753_406:qb,content_1753_407:Bb,content_1753_408:Yb,content_1753_409:Kb,content_1753_410:$b,content_1753_411:nv,content_1753_412:ov,content_1753_413:cv,content_1753_414:sv,content_1753_415:iv,content_1753_416:uv,content_1753_417:dv,content_1753_418:yv,content_1753_419:fv,content_1753_420:Mv,content_1753_421:Xv,content_1753_422:Tv,content_1753_423:xv,content_1753_424:Lv,content_1753_425:bv,content_1753_426:Nv,content_1753_427:Sv,content_1753_428:Pv,content_1753_429:Ev,content_1753_430:Wv,content_1753_431:Uv,content_1753_432:Ov,content_1753_433:qv,content_1753_434:Bv,content_1753_435:Yv,content_1753_436:Kv,content_1753_437:$v,content_1753_438:nN,content_1753_439:oN,content_1753_440:cN,content_1753_441:sN,content_1753_442:iN,content_1753_443:uN,content_1753_444:dN,content_1753_445:yN,content_1753_446:fN,content_1753_447:MN,content_1753_448:XN,content_1753_449:TN,content_1753_450:xN,content_1753_451:LN,content_1753_452:bN,content_1753_453:NN,content_1753_454:SN,content_1753_455:PN,content_1753_456:EN,content_1753_457:WN,content_1753_458:UN,content_1753_459:ON,content_1753_460:qN,content_1753_461:BN,content_1753_462:YN,content_1753_463:KN,content_1753_464:$N,content_1753_465:nA,content_1753_466:oA,content_1753_467:cA,content_1753_468:sA,content_1753_469:iA,content_1753_470:uA,content_1753_471:dA,content_1753_472:yA,content_1753_473:fA,content_1753_474:MA,content_1753_475:XA,content_1753_476:TA,content_1753_477:xA,content_1753_478:LA,content_1753_479:bA,content_1753_480:NA,content_1753_481:SA,content_1753_482:PA,content_1753_483:EA,content_1753_484:WA,content_1753_485:UA,content_1753_486:OA,content_1753_487:qA,content_1753_488:BA,content_1753_489:YA,content_1753_490:KA,content_1753_491:$A,content_1753_492:nS,content_1753_493:oS,content_1753_494:cS,content_1753_495:sS,content_1753_496:iS,content_1753_497:uS,content_1753_498:dS,content_1753_499:yS,content_1753_500:fS,content_1753_501:MS,content_1753_502:XS,content_1753_503:TS,content_1753_504:xS,content_1753_505:LS,content_1753_506:bS,content_1753_507:NS,content_1753_508:SS,content_1753_509:PS,content_1753_510:ES,content_1753_511:WS,content_1753_512:US,content_1753_513:OS,content_1753_514:qS,content_1753_515:BS,content_1753_516:YS,content_1753_517:KS,content_1753_518:$S}}}]);
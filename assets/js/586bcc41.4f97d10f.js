"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3239],{4415:(t,e,n)=>{n.r(e),n.d(e,{default:()=>d});var o=n(2784),c=n(2104),r=n(9072),p=n(6183),s=n(1836),a=n(8617),l=n(68),i=n(7708),u=n(532),m=n(7390);function d(t){var e,n,d;let{route:h}=t;const y=(0,a.RU)(h.projectId),k=y[h.reflectionId],[f]=(0,i.mN)(),M=(0,o.useMemo)((()=>{const t=[];if(!k.groups||k.kind===m.W.Project)return t;for(const e of k.groups)if(t.push({value:e.title,id:e.title,level:2}),e.children)for(const n of e.children){const e=y[n];e&&!e.hasOwnPage&&(0,i.It)(f,e)&&t.push({value:`<code>${e.name}</code>`,id:e.anchor,level:3})}return t}),[k,f]);return o.createElement(p.b,{content:{frontMatter:{},metadata:{id:k.docId,unversionedId:k.docId,version:"current",title:k.name,description:null==(e=k.comment)?void 0:e.summaryText,slug:k.url,permalink:k.url,editUrl:(null==(n=k.sources)||null==(d=n[0])?void 0:d.url)??void 0,draft:!1,tags:[],frontMatter:{},next:k.next,previous:k.previous},toc:M,assets:{}}},o.createElement(l.Y0,null,o.createElement(c.Z,null),o.createElement(u.Z,null,o.createElement(r.Z,null,o.createElement(s.Z,{reflection:k})))))}},2366:(t,e,n)=>{n.d(e,{Z:()=>Gq});var o={};n.r(o),n.d(o,{content_0_0:()=>a,content_0_10:()=>M,content_0_100:()=>te,content_0_102:()=>ne,content_0_104:()=>ce,content_0_106:()=>pe,content_0_108:()=>ae,content_0_110:()=>ie,content_0_112:()=>me,content_0_114:()=>he,content_0_116:()=>ke,content_0_118:()=>Me,content_0_12:()=>_,content_0_120:()=>_e,content_0_122:()=>we,content_0_124:()=>Ce,content_0_126:()=>ge,content_0_128:()=>Ze,content_0_130:()=>ve,content_0_132:()=>Ee,content_0_134:()=>Se,content_0_136:()=>Pe,content_0_138:()=>Ie,content_0_14:()=>w,content_0_140:()=>Ge,content_0_142:()=>ze,content_0_144:()=>qe,content_0_146:()=>Be,content_0_148:()=>$e,content_0_150:()=>Ke,content_0_152:()=>Je,content_0_154:()=>tn,content_0_156:()=>nn,content_0_158:()=>cn,content_0_16:()=>C,content_0_160:()=>pn,content_0_162:()=>an,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>yn,content_0_170:()=>fn,content_0_172:()=>Dn,content_0_174:()=>Xn,content_0_176:()=>Tn,content_0_178:()=>xn,content_0_18:()=>g,content_0_180:()=>Ln,content_0_182:()=>bn,content_0_184:()=>Nn,content_0_186:()=>An,content_0_188:()=>Rn,content_0_190:()=>Wn,content_0_192:()=>Fn,content_0_194:()=>Un,content_0_196:()=>jn,content_0_198:()=>Vn,content_0_2:()=>i,content_0_20:()=>Z,content_0_200:()=>On,content_0_202:()=>Hn,content_0_204:()=>Yn,content_0_206:()=>Qn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>so,content_0_216:()=>lo,content_0_218:()=>uo,content_0_22:()=>v,content_0_220:()=>ho,content_0_222:()=>ko,content_0_224:()=>Mo,content_0_226:()=>_o,content_0_228:()=>wo,content_0_230:()=>Co,content_0_232:()=>go,content_0_234:()=>Zo,content_0_236:()=>vo,content_0_238:()=>Eo,content_0_24:()=>E,content_0_240:()=>So,content_0_242:()=>Po,content_0_244:()=>Io,content_0_246:()=>Go,content_0_248:()=>zo,content_0_250:()=>qo,content_0_252:()=>Bo,content_0_254:()=>$o,content_0_256:()=>Ko,content_0_258:()=>Jo,content_0_26:()=>S,content_0_260:()=>tc,content_0_262:()=>nc,content_0_264:()=>cc,content_0_266:()=>pc,content_0_268:()=>ac,content_0_270:()=>ic,content_0_272:()=>mc,content_0_274:()=>hc,content_0_276:()=>kc,content_0_278:()=>Mc,content_0_28:()=>P,content_0_280:()=>_c,content_0_282:()=>wc,content_0_284:()=>Cc,content_0_286:()=>gc,content_0_288:()=>Zc,content_0_290:()=>vc,content_0_292:()=>Ec,content_0_294:()=>Sc,content_0_296:()=>Pc,content_0_298:()=>Ic,content_0_30:()=>I,content_0_300:()=>Gc,content_0_302:()=>zc,content_0_304:()=>qc,content_0_306:()=>Bc,content_0_308:()=>$c,content_0_310:()=>Kc,content_0_312:()=>Jc,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>cr,content_0_32:()=>G,content_0_320:()=>pr,content_0_322:()=>ar,content_0_324:()=>ir,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>kr,content_0_332:()=>Mr,content_0_334:()=>_r,content_0_336:()=>wr,content_0_338:()=>Cr,content_0_34:()=>z,content_0_340:()=>gr,content_0_342:()=>Zr,content_0_344:()=>vr,content_0_346:()=>Er,content_0_348:()=>Sr,content_0_350:()=>Pr,content_0_352:()=>Ir,content_0_354:()=>Gr,content_0_356:()=>zr,content_0_358:()=>qr,content_0_36:()=>q,content_0_360:()=>Br,content_0_362:()=>$r,content_0_364:()=>Kr,content_0_366:()=>Jr,content_0_368:()=>tp,content_0_370:()=>np,content_0_372:()=>cp,content_0_374:()=>pp,content_0_376:()=>ap,content_0_378:()=>ip,content_0_38:()=>B,content_0_380:()=>mp,content_0_382:()=>hp,content_0_384:()=>kp,content_0_386:()=>Mp,content_0_388:()=>_p,content_0_390:()=>wp,content_0_392:()=>Cp,content_0_394:()=>gp,content_0_396:()=>Zp,content_0_398:()=>vp,content_0_4:()=>m,content_0_40:()=>$,content_0_400:()=>Ep,content_0_402:()=>Sp,content_0_404:()=>Pp,content_0_406:()=>Ip,content_0_408:()=>Gp,content_0_410:()=>zp,content_0_412:()=>qp,content_0_414:()=>Bp,content_0_416:()=>$p,content_0_418:()=>Kp,content_0_42:()=>K,content_0_420:()=>Jp,content_0_422:()=>ts,content_0_424:()=>ns,content_0_426:()=>cs,content_0_428:()=>ps,content_0_430:()=>as,content_0_432:()=>is,content_0_434:()=>ms,content_0_436:()=>hs,content_0_438:()=>ks,content_0_44:()=>J,content_0_440:()=>Ms,content_0_442:()=>_s,content_0_444:()=>ws,content_0_446:()=>Cs,content_0_448:()=>gs,content_0_450:()=>Zs,content_0_452:()=>vs,content_0_454:()=>Es,content_0_456:()=>Ss,content_0_458:()=>Ps,content_0_46:()=>tt,content_0_460:()=>Is,content_0_462:()=>Gs,content_0_464:()=>zs,content_0_466:()=>qs,content_0_468:()=>Bs,content_0_470:()=>$s,content_0_472:()=>Ks,content_0_474:()=>Js,content_0_476:()=>ta,content_0_478:()=>na,content_0_48:()=>nt,content_0_480:()=>ca,content_0_482:()=>pa,content_0_484:()=>aa,content_0_486:()=>ia,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>ka,content_0_494:()=>Ma,content_0_496:()=>_a,content_0_498:()=>wa,content_0_50:()=>ct,content_0_500:()=>Ca,content_0_502:()=>ga,content_0_504:()=>Za,content_0_506:()=>va,content_0_508:()=>Ea,content_0_510:()=>Sa,content_0_512:()=>Pa,content_0_514:()=>Ia,content_0_516:()=>Ga,content_0_518:()=>za,content_0_52:()=>pt,content_0_520:()=>qa,content_0_522:()=>Ba,content_0_524:()=>$a,content_0_526:()=>Ka,content_0_528:()=>Ja,content_0_530:()=>tl,content_0_532:()=>nl,content_0_534:()=>cl,content_0_536:()=>pl,content_0_538:()=>al,content_0_54:()=>at,content_0_540:()=>il,content_0_542:()=>ml,content_0_544:()=>hl,content_0_546:()=>kl,content_0_548:()=>Ml,content_0_550:()=>_l,content_0_552:()=>wl,content_0_554:()=>Cl,content_0_556:()=>gl,content_0_558:()=>Zl,content_0_56:()=>it,content_0_560:()=>vl,content_0_562:()=>El,content_0_564:()=>Sl,content_0_566:()=>Pl,content_0_568:()=>Il,content_0_570:()=>Gl,content_0_572:()=>zl,content_0_574:()=>ql,content_0_576:()=>Bl,content_0_578:()=>$l,content_0_58:()=>mt,content_0_580:()=>Kl,content_0_582:()=>Jl,content_0_584:()=>ti,content_0_586:()=>ni,content_0_588:()=>ci,content_0_590:()=>pi,content_0_592:()=>ai,content_0_594:()=>ii,content_0_596:()=>mi,content_0_598:()=>hi,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>ki,content_0_602:()=>Mi,content_0_604:()=>_i,content_0_606:()=>wi,content_0_608:()=>Ci,content_0_610:()=>gi,content_0_612:()=>Zi,content_0_614:()=>vi,content_0_616:()=>Ei,content_0_618:()=>Si,content_0_62:()=>kt,content_0_620:()=>Pi,content_0_622:()=>Ii,content_0_624:()=>Gi,content_0_626:()=>zi,content_0_628:()=>qi,content_0_630:()=>Bi,content_0_632:()=>$i,content_0_634:()=>Ki,content_0_636:()=>Ji,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>nu,content_0_642:()=>cu,content_0_644:()=>pu,content_0_646:()=>au,content_0_648:()=>iu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>ku,content_0_656:()=>Mu,content_0_658:()=>_u,content_0_66:()=>_t,content_0_660:()=>wu,content_0_662:()=>Cu,content_0_664:()=>gu,content_0_666:()=>Zu,content_0_668:()=>vu,content_0_670:()=>Eu,content_0_672:()=>Su,content_0_674:()=>Pu,content_0_676:()=>Iu,content_0_678:()=>Gu,content_0_68:()=>wt,content_0_680:()=>zu,content_0_682:()=>qu,content_0_684:()=>Bu,content_0_686:()=>$u,content_0_688:()=>Ku,content_0_690:()=>Ju,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>cm,content_0_698:()=>pm,content_0_70:()=>Ct,content_0_700:()=>am,content_0_702:()=>im,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>km,content_0_710:()=>Mm,content_0_712:()=>_m,content_0_714:()=>wm,content_0_716:()=>Cm,content_0_718:()=>gm,content_0_72:()=>gt,content_0_720:()=>Zm,content_0_722:()=>vm,content_0_724:()=>Em,content_0_726:()=>Sm,content_0_728:()=>Pm,content_0_730:()=>Im,content_0_732:()=>Gm,content_0_734:()=>zm,content_0_736:()=>qm,content_0_738:()=>Bm,content_0_74:()=>Zt,content_0_740:()=>$m,content_0_742:()=>Km,content_0_744:()=>Jm,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>cd,content_0_752:()=>pd,content_0_754:()=>ad,content_0_756:()=>id,content_0_758:()=>md,content_0_76:()=>vt,content_0_760:()=>hd,content_0_762:()=>kd,content_0_764:()=>Md,content_0_766:()=>_d,content_0_768:()=>wd,content_0_770:()=>Cd,content_0_772:()=>gd,content_0_774:()=>Zd,content_0_776:()=>vd,content_0_778:()=>Ed,content_0_78:()=>Et,content_0_780:()=>Sd,content_0_782:()=>Pd,content_0_784:()=>Id,content_0_786:()=>Gd,content_0_788:()=>zd,content_0_790:()=>qd,content_0_792:()=>Bd,content_0_794:()=>$d,content_0_796:()=>Kd,content_0_798:()=>Jd,content_0_8:()=>k,content_0_80:()=>St,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>ch,content_0_806:()=>ph,content_0_808:()=>ah,content_0_810:()=>ih,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>kh,content_0_818:()=>Mh,content_0_82:()=>Pt,content_0_820:()=>_h,content_0_822:()=>wh,content_0_824:()=>Ch,content_0_826:()=>gh,content_0_828:()=>Zh,content_0_830:()=>vh,content_0_832:()=>Eh,content_0_834:()=>Sh,content_0_836:()=>Ph,content_0_838:()=>Ih,content_0_84:()=>It,content_0_840:()=>Gh,content_0_842:()=>zh,content_0_844:()=>qh,content_0_846:()=>Bh,content_0_848:()=>$h,content_0_850:()=>Kh,content_0_852:()=>Jh,content_0_854:()=>ty,content_0_856:()=>ny,content_0_858:()=>cy,content_0_86:()=>Gt,content_0_860:()=>py,content_0_862:()=>ay,content_0_864:()=>iy,content_0_866:()=>my,content_0_868:()=>hy,content_0_870:()=>ky,content_0_872:()=>My,content_0_874:()=>_y,content_0_876:()=>wy,content_0_878:()=>Cy,content_0_88:()=>zt,content_0_880:()=>gy,content_0_882:()=>Zy,content_0_884:()=>vy,content_0_886:()=>Ey,content_0_888:()=>Sy,content_0_890:()=>Py,content_0_892:()=>Iy,content_0_894:()=>Gy,content_0_896:()=>zy,content_0_898:()=>qy,content_0_90:()=>qt,content_0_900:()=>By,content_0_902:()=>$y,content_0_92:()=>Bt,content_0_94:()=>$t,content_0_96:()=>Kt,content_0_98:()=>Jt,content_2112_0:()=>Ky,content_2112_10:()=>pk,content_2112_100:()=>jf,content_2112_1000:()=>xS,content_2112_1002:()=>LS,content_2112_1004:()=>bS,content_2112_1006:()=>NS,content_2112_1008:()=>AS,content_2112_1010:()=>RS,content_2112_1012:()=>WS,content_2112_1014:()=>FS,content_2112_1016:()=>US,content_2112_1018:()=>jS,content_2112_102:()=>Vf,content_2112_1020:()=>VS,content_2112_1022:()=>OS,content_2112_1024:()=>HS,content_2112_1026:()=>YS,content_2112_1028:()=>QS,content_2112_1030:()=>eR,content_2112_1032:()=>oR,content_2112_1034:()=>rR,content_2112_1036:()=>sR,content_2112_1038:()=>lR,content_2112_104:()=>Of,content_2112_1040:()=>uR,content_2112_1042:()=>dR,content_2112_1044:()=>yR,content_2112_1046:()=>fR,content_2112_1048:()=>DR,content_2112_1050:()=>XR,content_2112_1052:()=>TR,content_2112_1054:()=>xR,content_2112_1056:()=>LR,content_2112_1058:()=>bR,content_2112_106:()=>Hf,content_2112_1060:()=>NR,content_2112_1062:()=>AR,content_2112_1064:()=>RR,content_2112_1066:()=>WR,content_2112_1068:()=>FR,content_2112_1070:()=>UR,content_2112_1072:()=>jR,content_2112_1074:()=>VR,content_2112_1076:()=>OR,content_2112_1078:()=>HR,content_2112_108:()=>Yf,content_2112_1080:()=>YR,content_2112_1082:()=>QR,content_2112_1084:()=>eP,content_2112_1086:()=>oP,content_2112_1088:()=>rP,content_2112_1090:()=>sP,content_2112_1092:()=>lP,content_2112_1094:()=>uP,content_2112_1096:()=>dP,content_2112_1098:()=>yP,content_2112_110:()=>Qf,content_2112_1100:()=>fP,content_2112_1102:()=>DP,content_2112_1104:()=>XP,content_2112_1106:()=>TP,content_2112_1108:()=>xP,content_2112_1110:()=>LP,content_2112_1112:()=>bP,content_2112_1114:()=>NP,content_2112_1116:()=>AP,content_2112_1118:()=>RP,content_2112_112:()=>eM,content_2112_1120:()=>WP,content_2112_1122:()=>FP,content_2112_1124:()=>UP,content_2112_1126:()=>jP,content_2112_1128:()=>VP,content_2112_1130:()=>OP,content_2112_1132:()=>HP,content_2112_1134:()=>YP,content_2112_1136:()=>QP,content_2112_1138:()=>eW,content_2112_114:()=>oM,content_2112_1140:()=>oW,content_2112_1142:()=>rW,content_2112_1144:()=>sW,content_2112_1146:()=>lW,content_2112_1148:()=>uW,content_2112_1150:()=>dW,content_2112_1152:()=>yW,content_2112_1154:()=>fW,content_2112_1156:()=>DW,content_2112_1158:()=>XW,content_2112_116:()=>rM,content_2112_1160:()=>TW,content_2112_1162:()=>xW,content_2112_1164:()=>LW,content_2112_1166:()=>bW,content_2112_1168:()=>NW,content_2112_1170:()=>AW,content_2112_1172:()=>RW,content_2112_1174:()=>WW,content_2112_1176:()=>FW,content_2112_1178:()=>UW,content_2112_118:()=>sM,content_2112_1180:()=>jW,content_2112_1182:()=>VW,content_2112_1184:()=>OW,content_2112_1186:()=>HW,content_2112_1188:()=>YW,content_2112_1190:()=>QW,content_2112_1192:()=>eI,content_2112_1194:()=>oI,content_2112_1196:()=>rI,content_2112_1198:()=>sI,content_2112_12:()=>ak,content_2112_120:()=>lM,content_2112_1200:()=>lI,content_2112_1202:()=>uI,content_2112_1204:()=>dI,content_2112_1206:()=>yI,content_2112_1208:()=>fI,content_2112_1210:()=>DI,content_2112_1212:()=>XI,content_2112_1214:()=>TI,content_2112_1216:()=>xI,content_2112_1218:()=>LI,content_2112_122:()=>uM,content_2112_1220:()=>bI,content_2112_1222:()=>NI,content_2112_1224:()=>AI,content_2112_1226:()=>RI,content_2112_1228:()=>WI,content_2112_1230:()=>FI,content_2112_1232:()=>UI,content_2112_1234:()=>jI,content_2112_1236:()=>VI,content_2112_1238:()=>OI,content_2112_124:()=>dM,content_2112_1240:()=>HI,content_2112_1242:()=>YI,content_2112_1244:()=>QI,content_2112_1246:()=>eF,content_2112_1248:()=>oF,content_2112_1250:()=>rF,content_2112_1252:()=>sF,content_2112_1254:()=>lF,content_2112_1256:()=>uF,content_2112_1258:()=>dF,content_2112_126:()=>yM,content_2112_1260:()=>yF,content_2112_1262:()=>fF,content_2112_1264:()=>DF,content_2112_1266:()=>XF,content_2112_1268:()=>TF,content_2112_1270:()=>xF,content_2112_1272:()=>LF,content_2112_1274:()=>bF,content_2112_1276:()=>NF,content_2112_1278:()=>AF,content_2112_128:()=>fM,content_2112_1280:()=>RF,content_2112_1282:()=>WF,content_2112_1284:()=>FF,content_2112_1286:()=>UF,content_2112_1288:()=>jF,content_2112_1290:()=>VF,content_2112_1292:()=>OF,content_2112_1294:()=>HF,content_2112_1296:()=>YF,content_2112_1298:()=>QF,content_2112_130:()=>DM,content_2112_1300:()=>eG,content_2112_1302:()=>oG,content_2112_1304:()=>rG,content_2112_1306:()=>sG,content_2112_1308:()=>lG,content_2112_1310:()=>uG,content_2112_1312:()=>dG,content_2112_1314:()=>yG,content_2112_1316:()=>fG,content_2112_1318:()=>DG,content_2112_132:()=>XM,content_2112_1320:()=>XG,content_2112_1322:()=>TG,content_2112_1324:()=>xG,content_2112_1326:()=>LG,content_2112_1328:()=>bG,content_2112_1330:()=>NG,content_2112_1332:()=>AG,content_2112_1334:()=>RG,content_2112_1336:()=>WG,content_2112_1338:()=>FG,content_2112_134:()=>TM,content_2112_1340:()=>UG,content_2112_1342:()=>jG,content_2112_1344:()=>VG,content_2112_1346:()=>OG,content_2112_1348:()=>HG,content_2112_1350:()=>YG,content_2112_1352:()=>QG,content_2112_1354:()=>eU,content_2112_1356:()=>oU,content_2112_1358:()=>rU,content_2112_136:()=>xM,content_2112_1360:()=>sU,content_2112_1362:()=>lU,content_2112_1364:()=>uU,content_2112_1366:()=>dU,content_2112_1368:()=>yU,content_2112_1370:()=>fU,content_2112_1372:()=>DU,content_2112_1374:()=>XU,content_2112_1376:()=>TU,content_2112_1378:()=>xU,content_2112_138:()=>LM,content_2112_1380:()=>LU,content_2112_1382:()=>bU,content_2112_1384:()=>NU,content_2112_1386:()=>AU,content_2112_1388:()=>RU,content_2112_1390:()=>WU,content_2112_1392:()=>FU,content_2112_1394:()=>UU,content_2112_1396:()=>jU,content_2112_1398:()=>VU,content_2112_14:()=>ik,content_2112_140:()=>bM,content_2112_1400:()=>OU,content_2112_1402:()=>HU,content_2112_1404:()=>YU,content_2112_1406:()=>QU,content_2112_1408:()=>ez,content_2112_1410:()=>oz,content_2112_1412:()=>rz,content_2112_1414:()=>sz,content_2112_1416:()=>lz,content_2112_1418:()=>uz,content_2112_142:()=>NM,content_2112_1420:()=>dz,content_2112_1422:()=>yz,content_2112_1424:()=>fz,content_2112_1426:()=>Dz,content_2112_1428:()=>Xz,content_2112_1430:()=>Tz,content_2112_1432:()=>xz,content_2112_1434:()=>Lz,content_2112_1436:()=>bz,content_2112_1438:()=>Nz,content_2112_144:()=>AM,content_2112_1440:()=>Az,content_2112_1442:()=>Rz,content_2112_1444:()=>Wz,content_2112_1446:()=>Fz,content_2112_1448:()=>Uz,content_2112_1450:()=>jz,content_2112_1452:()=>Vz,content_2112_1454:()=>Oz,content_2112_1456:()=>Hz,content_2112_1458:()=>Yz,content_2112_146:()=>RM,content_2112_1460:()=>Qz,content_2112_1462:()=>ej,content_2112_1464:()=>oj,content_2112_1466:()=>rj,content_2112_1468:()=>sj,content_2112_1470:()=>lj,content_2112_1472:()=>uj,content_2112_1474:()=>dj,content_2112_1476:()=>yj,content_2112_1478:()=>fj,content_2112_148:()=>WM,content_2112_1480:()=>Dj,content_2112_1482:()=>Xj,content_2112_1484:()=>Tj,content_2112_1486:()=>xj,content_2112_1488:()=>Lj,content_2112_1490:()=>bj,content_2112_1492:()=>Nj,content_2112_1494:()=>Aj,content_2112_1496:()=>Rj,content_2112_1498:()=>Wj,content_2112_150:()=>FM,content_2112_1500:()=>Fj,content_2112_1502:()=>Uj,content_2112_1504:()=>jj,content_2112_1506:()=>Vj,content_2112_1508:()=>Oj,content_2112_1510:()=>Hj,content_2112_1512:()=>Yj,content_2112_1514:()=>Qj,content_2112_1516:()=>eq,content_2112_1518:()=>oq,content_2112_152:()=>UM,content_2112_1520:()=>rq,content_2112_1522:()=>sq,content_2112_1524:()=>lq,content_2112_1526:()=>uq,content_2112_1528:()=>dq,content_2112_1530:()=>yq,content_2112_1532:()=>fq,content_2112_1534:()=>Dq,content_2112_1536:()=>Xq,content_2112_1538:()=>Tq,content_2112_154:()=>jM,content_2112_1540:()=>xq,content_2112_1542:()=>Lq,content_2112_1544:()=>bq,content_2112_1546:()=>Nq,content_2112_1548:()=>Aq,content_2112_1550:()=>Rq,content_2112_1552:()=>Wq,content_2112_1554:()=>Fq,content_2112_156:()=>VM,content_2112_158:()=>OM,content_2112_16:()=>mk,content_2112_160:()=>HM,content_2112_162:()=>YM,content_2112_164:()=>QM,content_2112_166:()=>eD,content_2112_168:()=>oD,content_2112_170:()=>rD,content_2112_172:()=>sD,content_2112_174:()=>lD,content_2112_176:()=>uD,content_2112_178:()=>dD,content_2112_18:()=>hk,content_2112_180:()=>yD,content_2112_182:()=>fD,content_2112_184:()=>DD,content_2112_186:()=>XD,content_2112_188:()=>TD,content_2112_190:()=>xD,content_2112_192:()=>LD,content_2112_194:()=>bD,content_2112_196:()=>ND,content_2112_198:()=>AD,content_2112_2:()=>Jy,content_2112_20:()=>kk,content_2112_200:()=>RD,content_2112_202:()=>WD,content_2112_204:()=>FD,content_2112_206:()=>UD,content_2112_208:()=>jD,content_2112_210:()=>VD,content_2112_212:()=>OD,content_2112_214:()=>HD,content_2112_216:()=>YD,content_2112_218:()=>QD,content_2112_22:()=>Mk,content_2112_220:()=>e_,content_2112_222:()=>o_,content_2112_224:()=>r_,content_2112_226:()=>s_,content_2112_228:()=>l_,content_2112_230:()=>u_,content_2112_232:()=>d_,content_2112_234:()=>y_,content_2112_236:()=>f_,content_2112_238:()=>D_,content_2112_24:()=>_k,content_2112_240:()=>X_,content_2112_242:()=>T_,content_2112_244:()=>x_,content_2112_246:()=>L_,content_2112_248:()=>b_,content_2112_250:()=>N_,content_2112_252:()=>A_,content_2112_254:()=>R_,content_2112_256:()=>W_,content_2112_258:()=>F_,content_2112_26:()=>wk,content_2112_260:()=>U_,content_2112_262:()=>j_,content_2112_264:()=>V_,content_2112_266:()=>O_,content_2112_268:()=>H_,content_2112_270:()=>Y_,content_2112_272:()=>Q_,content_2112_274:()=>eX,content_2112_276:()=>oX,content_2112_278:()=>rX,content_2112_28:()=>Ck,content_2112_280:()=>sX,content_2112_282:()=>lX,content_2112_284:()=>uX,content_2112_286:()=>dX,content_2112_288:()=>yX,content_2112_290:()=>fX,content_2112_292:()=>DX,content_2112_294:()=>XX,content_2112_296:()=>TX,content_2112_298:()=>xX,content_2112_30:()=>gk,content_2112_300:()=>LX,content_2112_302:()=>bX,content_2112_304:()=>NX,content_2112_306:()=>AX,content_2112_308:()=>RX,content_2112_310:()=>WX,content_2112_312:()=>FX,content_2112_314:()=>UX,content_2112_316:()=>jX,content_2112_318:()=>VX,content_2112_32:()=>Zk,content_2112_320:()=>OX,content_2112_322:()=>HX,content_2112_324:()=>YX,content_2112_326:()=>QX,content_2112_328:()=>ew,content_2112_330:()=>ow,content_2112_332:()=>rw,content_2112_334:()=>sw,content_2112_336:()=>lw,content_2112_338:()=>uw,content_2112_34:()=>vk,content_2112_340:()=>dw,content_2112_342:()=>yw,content_2112_344:()=>fw,content_2112_346:()=>Dw,content_2112_348:()=>Xw,content_2112_350:()=>Tw,content_2112_352:()=>xw,content_2112_354:()=>Lw,content_2112_356:()=>bw,content_2112_358:()=>Nw,content_2112_36:()=>Ek,content_2112_360:()=>Aw,content_2112_362:()=>Rw,content_2112_364:()=>Ww,content_2112_366:()=>Fw,content_2112_368:()=>Uw,content_2112_370:()=>jw,content_2112_372:()=>Vw,content_2112_374:()=>Ow,content_2112_376:()=>Hw,content_2112_378:()=>Yw,content_2112_38:()=>Sk,content_2112_380:()=>Qw,content_2112_382:()=>eT,content_2112_384:()=>oT,content_2112_386:()=>rT,content_2112_388:()=>sT,content_2112_390:()=>lT,content_2112_392:()=>uT,content_2112_394:()=>dT,content_2112_396:()=>yT,content_2112_398:()=>fT,content_2112_4:()=>tk,content_2112_40:()=>Pk,content_2112_400:()=>DT,content_2112_402:()=>XT,content_2112_404:()=>TT,content_2112_406:()=>xT,content_2112_408:()=>LT,content_2112_410:()=>bT,content_2112_412:()=>NT,content_2112_414:()=>AT,content_2112_416:()=>RT,content_2112_418:()=>WT,content_2112_42:()=>Ik,content_2112_420:()=>FT,content_2112_422:()=>UT,content_2112_424:()=>jT,content_2112_426:()=>VT,content_2112_428:()=>OT,content_2112_430:()=>HT,content_2112_432:()=>YT,content_2112_434:()=>QT,content_2112_436:()=>eC,content_2112_438:()=>oC,content_2112_44:()=>Gk,content_2112_440:()=>rC,content_2112_442:()=>sC,content_2112_444:()=>lC,content_2112_446:()=>uC,content_2112_448:()=>dC,content_2112_450:()=>yC,content_2112_452:()=>fC,content_2112_454:()=>DC,content_2112_456:()=>XC,content_2112_458:()=>TC,content_2112_46:()=>zk,content_2112_460:()=>xC,content_2112_462:()=>LC,content_2112_464:()=>bC,content_2112_466:()=>NC,content_2112_468:()=>AC,content_2112_470:()=>RC,content_2112_472:()=>WC,content_2112_474:()=>FC,content_2112_476:()=>UC,content_2112_478:()=>jC,content_2112_48:()=>qk,content_2112_480:()=>VC,content_2112_482:()=>OC,content_2112_484:()=>HC,content_2112_486:()=>YC,content_2112_488:()=>QC,content_2112_490:()=>ex,content_2112_492:()=>ox,content_2112_494:()=>rx,content_2112_496:()=>sx,content_2112_498:()=>lx,content_2112_50:()=>Bk,content_2112_500:()=>ux,content_2112_502:()=>dx,content_2112_504:()=>yx,content_2112_506:()=>fx,content_2112_508:()=>Dx,content_2112_510:()=>Xx,content_2112_512:()=>Tx,content_2112_514:()=>xx,content_2112_516:()=>Lx,content_2112_518:()=>bx,content_2112_52:()=>$k,content_2112_520:()=>Nx,content_2112_522:()=>Ax,content_2112_524:()=>Rx,content_2112_526:()=>Wx,content_2112_528:()=>Fx,content_2112_530:()=>Ux,content_2112_532:()=>jx,content_2112_534:()=>Vx,content_2112_536:()=>Ox,content_2112_538:()=>Hx,content_2112_54:()=>Kk,content_2112_540:()=>Yx,content_2112_542:()=>Qx,content_2112_544:()=>eg,content_2112_546:()=>og,content_2112_548:()=>rg,content_2112_550:()=>sg,content_2112_552:()=>lg,content_2112_554:()=>ug,content_2112_556:()=>dg,content_2112_558:()=>yg,content_2112_56:()=>Jk,content_2112_560:()=>fg,content_2112_562:()=>Dg,content_2112_564:()=>Xg,content_2112_566:()=>Tg,content_2112_568:()=>xg,content_2112_570:()=>Lg,content_2112_572:()=>bg,content_2112_574:()=>Ng,content_2112_576:()=>Ag,content_2112_578:()=>Rg,content_2112_58:()=>tf,content_2112_580:()=>Wg,content_2112_582:()=>Fg,content_2112_584:()=>Ug,content_2112_586:()=>jg,content_2112_588:()=>Vg,content_2112_590:()=>Og,content_2112_592:()=>Hg,content_2112_594:()=>Yg,content_2112_596:()=>Qg,content_2112_598:()=>eL,content_2112_6:()=>nk,content_2112_60:()=>nf,content_2112_600:()=>oL,content_2112_602:()=>rL,content_2112_604:()=>sL,content_2112_606:()=>lL,content_2112_608:()=>uL,content_2112_610:()=>dL,content_2112_612:()=>yL,content_2112_614:()=>fL,content_2112_616:()=>DL,content_2112_618:()=>XL,content_2112_62:()=>cf,content_2112_620:()=>TL,content_2112_622:()=>xL,content_2112_624:()=>LL,content_2112_626:()=>bL,content_2112_628:()=>NL,content_2112_630:()=>AL,content_2112_632:()=>RL,content_2112_634:()=>WL,content_2112_636:()=>FL,content_2112_638:()=>UL,content_2112_64:()=>pf,content_2112_640:()=>jL,content_2112_642:()=>VL,content_2112_644:()=>OL,content_2112_646:()=>HL,content_2112_648:()=>YL,content_2112_650:()=>QL,content_2112_652:()=>eZ,content_2112_654:()=>oZ,content_2112_656:()=>rZ,content_2112_658:()=>sZ,content_2112_66:()=>af,content_2112_660:()=>lZ,content_2112_662:()=>uZ,content_2112_664:()=>dZ,content_2112_666:()=>yZ,content_2112_668:()=>fZ,content_2112_670:()=>DZ,content_2112_672:()=>XZ,content_2112_674:()=>TZ,content_2112_676:()=>xZ,content_2112_678:()=>LZ,content_2112_68:()=>uf,content_2112_680:()=>bZ,content_2112_682:()=>NZ,content_2112_684:()=>AZ,content_2112_686:()=>RZ,content_2112_688:()=>WZ,content_2112_690:()=>FZ,content_2112_692:()=>UZ,content_2112_694:()=>jZ,content_2112_696:()=>VZ,content_2112_698:()=>OZ,content_2112_70:()=>df,content_2112_700:()=>HZ,content_2112_702:()=>YZ,content_2112_704:()=>QZ,content_2112_706:()=>eb,content_2112_708:()=>ob,content_2112_710:()=>rb,content_2112_712:()=>sb,content_2112_714:()=>lb,content_2112_716:()=>ub,content_2112_718:()=>db,content_2112_72:()=>yf,content_2112_720:()=>yb,content_2112_722:()=>fb,content_2112_724:()=>Db,content_2112_726:()=>Xb,content_2112_728:()=>Tb,content_2112_730:()=>xb,content_2112_732:()=>Lb,content_2112_734:()=>bb,content_2112_736:()=>Nb,content_2112_738:()=>Ab,content_2112_74:()=>ff,content_2112_740:()=>Rb,content_2112_742:()=>Wb,content_2112_744:()=>Fb,content_2112_746:()=>Ub,content_2112_748:()=>jb,content_2112_750:()=>Vb,content_2112_752:()=>Ob,content_2112_754:()=>Hb,content_2112_756:()=>Yb,content_2112_758:()=>Qb,content_2112_76:()=>Df,content_2112_760:()=>ev,content_2112_762:()=>ov,content_2112_764:()=>rv,content_2112_766:()=>sv,content_2112_768:()=>lv,content_2112_770:()=>uv,content_2112_772:()=>dv,content_2112_774:()=>yv,content_2112_776:()=>fv,content_2112_778:()=>Dv,content_2112_78:()=>Xf,content_2112_780:()=>Xv,content_2112_782:()=>Tv,content_2112_784:()=>xv,content_2112_786:()=>Lv,content_2112_788:()=>bv,content_2112_790:()=>Nv,content_2112_792:()=>Av,content_2112_794:()=>Rv,content_2112_796:()=>Wv,content_2112_798:()=>Fv,content_2112_8:()=>ck,content_2112_80:()=>Tf,content_2112_800:()=>Uv,content_2112_802:()=>jv,content_2112_804:()=>Vv,content_2112_806:()=>Ov,content_2112_808:()=>Hv,content_2112_810:()=>Yv,content_2112_812:()=>Qv,content_2112_814:()=>eN,content_2112_816:()=>oN,content_2112_818:()=>rN,content_2112_82:()=>xf,content_2112_820:()=>sN,content_2112_822:()=>lN,content_2112_824:()=>uN,content_2112_826:()=>dN,content_2112_828:()=>yN,content_2112_830:()=>fN,content_2112_832:()=>DN,content_2112_834:()=>XN,content_2112_836:()=>TN,content_2112_838:()=>xN,content_2112_84:()=>Lf,content_2112_840:()=>LN,content_2112_842:()=>bN,content_2112_844:()=>NN,content_2112_846:()=>AN,content_2112_848:()=>RN,content_2112_850:()=>WN,content_2112_852:()=>FN,content_2112_854:()=>UN,content_2112_856:()=>jN,content_2112_858:()=>VN,content_2112_86:()=>bf,content_2112_860:()=>ON,content_2112_862:()=>HN,content_2112_864:()=>YN,content_2112_866:()=>QN,content_2112_868:()=>eE,content_2112_870:()=>oE,content_2112_872:()=>rE,content_2112_874:()=>sE,content_2112_876:()=>lE,content_2112_878:()=>uE,content_2112_88:()=>Nf,content_2112_880:()=>dE,content_2112_882:()=>yE,content_2112_884:()=>fE,content_2112_886:()=>DE,content_2112_888:()=>XE,content_2112_890:()=>TE,content_2112_892:()=>xE,content_2112_894:()=>LE,content_2112_896:()=>bE,content_2112_898:()=>NE,content_2112_90:()=>Af,content_2112_900:()=>AE,content_2112_902:()=>RE,content_2112_904:()=>WE,content_2112_906:()=>FE,content_2112_908:()=>UE,content_2112_910:()=>jE,content_2112_912:()=>VE,content_2112_914:()=>OE,content_2112_916:()=>HE,content_2112_918:()=>YE,content_2112_92:()=>Rf,content_2112_920:()=>QE,content_2112_922:()=>eA,content_2112_924:()=>oA,content_2112_926:()=>rA,content_2112_928:()=>sA,content_2112_930:()=>lA,content_2112_932:()=>uA,content_2112_934:()=>dA,content_2112_936:()=>yA,content_2112_938:()=>fA,content_2112_94:()=>Wf,content_2112_940:()=>DA,content_2112_942:()=>XA,content_2112_944:()=>TA,content_2112_946:()=>xA,content_2112_948:()=>LA,content_2112_950:()=>bA,content_2112_952:()=>NA,content_2112_954:()=>AA,content_2112_956:()=>RA,content_2112_958:()=>WA,content_2112_96:()=>Ff,content_2112_960:()=>FA,content_2112_962:()=>UA,content_2112_964:()=>jA,content_2112_966:()=>VA,content_2112_968:()=>OA,content_2112_970:()=>HA,content_2112_972:()=>YA,content_2112_974:()=>QA,content_2112_976:()=>eS,content_2112_978:()=>oS,content_2112_98:()=>Uf,content_2112_980:()=>rS,content_2112_982:()=>sS,content_2112_984:()=>lS,content_2112_986:()=>uS,content_2112_988:()=>dS,content_2112_990:()=>yS,content_2112_992:()=>fS,content_2112_994:()=>DS,content_2112_996:()=>XS,content_2112_998:()=>TS});var c=n(2784),r=n(7896),p=n(876);const s={toc:[]};function a(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const l={toc:[]};function i(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscriptions and triggering of events."))}i.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,p.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}h.isMDXComponent=!0;const y={toc:[]};function k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches an asynchronous ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}k.isMDXComponent=!0;const f={toc:[]};function M(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}M.isMDXComponent=!0;const D={toc:[]};function _(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}_.isMDXComponent=!0;const X={toc:[]};function w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}w.isMDXComponent=!0;const T={toc:[]};function C(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}C.isMDXComponent=!0;const x={toc:[]};function g(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}g.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Z.isMDXComponent=!0;const b={toc:[]};function v(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}v.isMDXComponent=!0;const N={toc:[]};function E(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}E.isMDXComponent=!0;const A={toc:[]};function S(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}S.isMDXComponent=!0;const R={toc:[]};function P(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}P.isMDXComponent=!0;const W={toc:[]};function I(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}I.isMDXComponent=!0;const F={toc:[]};function G(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}G.isMDXComponent=!0;const U={toc:[]};function z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}z.isMDXComponent=!0;const j={toc:[]};function q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}q.isMDXComponent=!0;const V={toc:[]};function B(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}B.isMDXComponent=!0;const O={toc:[]};function $(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value argument to subscribers."))}$.isMDXComponent=!0;const H={toc:[]};function K(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A base for dispatching ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,p.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}K.isMDXComponent=!0;const Y={toc:[]};function J(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}J.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}nt.isMDXComponent=!0;const ot={toc:[]};function ct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}ct.isMDXComponent=!0;const rt={toc:[]};function pt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}pt.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},st,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}at.isMDXComponent=!0;const lt={toc:[]};function it(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}it.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,p.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,p.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}ht.isMDXComponent=!0;const yt={toc:[]};function kt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}kt.isMDXComponent=!0;const ft={toc:[]};function Mt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function _t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}_t.isMDXComponent=!0;const Xt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Are subscribers being notified?"))}wt.isMDXComponent=!0;const Tt={toc:[]};function Ct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Notify all current and future subscribers."))}Ct.isMDXComponent=!0;const xt={toc:[]};function gt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stop notifying future subscribers."))}gt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Zt.isMDXComponent=!0;const bt={toc:[]};function vt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}vt.isMDXComponent=!0;const Nt={toc:[]};function Et(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Et.isMDXComponent=!0;const At={toc:[]};function St(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},At,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}St.isMDXComponent=!0;const Rt={toc:[]};function Pt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Pt.isMDXComponent=!0;const Wt={toc:[]};function It(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}It.isMDXComponent=!0;const Ft={toc:[]};function Gt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Gt.isMDXComponent=!0;const Ut={toc:[]};function zt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}zt.isMDXComponent=!0;const jt={toc:[]};function qt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}qt.isMDXComponent=!0;const Vt={toc:[]};function Bt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Bt.isMDXComponent=!0;const Ot={toc:[]};function $t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}$t.isMDXComponent=!0;const Ht={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Kt.isMDXComponent=!0;const Yt={toc:[]};function Jt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}Jt.isMDXComponent=!0;const Qt={toc:[]};function te(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ne.isMDXComponent=!0;const oe={toc:[]};function ce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}ce.isMDXComponent=!0;const re={toc:[]};function pe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}pe.isMDXComponent=!0;const se={toc:[]};function ae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},se,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}ae.isMDXComponent=!0;const le={toc:[]};function ie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}ie.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}he.isMDXComponent=!0;const ye={toc:[]};function ke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}ke.isMDXComponent=!0;const fe={toc:[]};function Me(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Me.isMDXComponent=!0;const De={toc:[]};function _e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},De,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}_e.isMDXComponent=!0;const Xe={toc:[]};function we(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}we.isMDXComponent=!0;const Te={toc:[]};function Ce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Te,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Ce.isMDXComponent=!0;const xe={toc:[]};function ge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}ge.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Ze.isMDXComponent=!0;const be={toc:[]};function ve(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},be,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}ve.isMDXComponent=!0;const Ne={toc:[]};function Ee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value."))}Ee.isMDXComponent=!0;const Ae={toc:[]};function Se(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}Se.isMDXComponent=!0;const Re={toc:[]};function Pe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Pe.isMDXComponent=!0;const We={toc:[]};function Ie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},We,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set the current value of this dispatcher."))}Ie.isMDXComponent=!0;const Fe={toc:[]};function Ge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new value."))}Ge.isMDXComponent=!0;const Ue={toc:[]};function ze(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}ze.isMDXComponent=!0;const je={toc:[]};function qe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},je,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}qe.isMDXComponent=!0;const Ve={toc:[]};function Be(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ve,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Be.isMDXComponent=!0;const Oe={toc:[]};function $e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}$e.isMDXComponent=!0;const He={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},He,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Ke.isMDXComponent=!0;const Ye={toc:[]};function Je(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Je.isMDXComponent=!0;const Qe={toc:[]};function tn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}nn.isMDXComponent=!0;const on={toc:[]};function cn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}cn.isMDXComponent=!0;const rn={toc:[]};function pn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}pn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}yn.isMDXComponent=!0;const kn={toc:[]};function fn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}Dn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_n,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}Xn.isMDXComponent=!0;const wn={toc:[]};function Tn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of times the timer has ticked."))}Tn.isMDXComponent=!0;const Cn={toc:[]};function xn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator responsible for running this timer."))}xn.isMDXComponent=!0;const gn={toc:[]};function Ln(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the timer ticks."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function bn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current iteration index."))}bn.isMDXComponent=!0;const vn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Nn.isMDXComponent=!0;const En={toc:[]};function An(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}An.isMDXComponent=!0;const Sn={toc:[]};function Rn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Rn.isMDXComponent=!0;const Pn={toc:[]};function Wn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Wn.isMDXComponent=!0;const In={toc:[]};function Fn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},In,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Fn.isMDXComponent=!0;const Gn={toc:[]};function Un(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Un.isMDXComponent=!0;const zn={toc:[]};function jn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.corenerRadius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}jn.isMDXComponent=!0;const qn={toc:[]};function Vn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run tasks one after another."))}Vn.isMDXComponent=!0;const Bn={toc:[]};function On(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}On.isMDXComponent=!0;const $n={toc:[]};function Hn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$n,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Hn.isMDXComponent=!0;const Kn={toc:[]};function Yn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Yn.isMDXComponent=!0;const Jn={toc:[]};function Qn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay in seconds"))}Qn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task or callback to run after the delay."))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}oo.isMDXComponent=!0;const co={toc:[]};function ro(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},co,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Call the given callback every N seconds."))}ro.isMDXComponent=!0;const po={toc:[]};function so(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interval between subsequent calls."))}so.isMDXComponent=!0;const ao={toc:[]};function lo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ao,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to be called."))}lo.isMDXComponent=!0;const io={toc:[]};function uo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each time iteration waits until the previous one is completed."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}ho.isMDXComponent=!0;const yo={toc:[]};function ko(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator N times."))}ko.isMDXComponent=!0;const fo={toc:[]};function Mo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of iterations."))}Mo.isMDXComponent=!0;const Do={toc:[]};function _o(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}_o.isMDXComponent=!0;const Xo={toc:[]};function wo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Do nothing."))}wo.isMDXComponent=!0;const To={toc:[]};function Co(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},To,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Co.isMDXComponent=!0;const xo={toc:[]};function go(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}go.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}Zo.isMDXComponent=!0;const bo={toc:[]};function vo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}vo.isMDXComponent=!0;const No={toc:[]};function Eo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}Eo.isMDXComponent=!0;const Ao={toc:[]};function So(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional name used when displaying this generator in the UI."))}So.isMDXComponent=!0;const Ro={toc:[]};function Po(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}Po.isMDXComponent=!0;const Wo={toc:[]};function Io(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Io.isMDXComponent=!0;const Fo={toc:[]};function Go(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Go.isMDXComponent=!0;const Uo={toc:[]};function zo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Start all tasks one after another with a constant delay between."))}zo.isMDXComponent=!0;const jo={toc:[]};function qo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay between each of the tasks."))}qo.isMDXComponent=!0;const Vo={toc:[]};function Bo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to be run in a sequence."))}Bo.isMDXComponent=!0;const Oo={toc:[]};function $o(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}$o.isMDXComponent=!0;const Ho={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ho,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the given amount of time."))}Ko.isMDXComponent=!0;const Yo={toc:[]};function Jo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The relative time in seconds."))}Jo.isMDXComponent=!0;const Qo={toc:[]};function tc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}nc.isMDXComponent=!0;const oc={toc:[]};function cc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}cc.isMDXComponent=!0;const rc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the given time event."))}pc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the time event."))}ac.isMDXComponent=!0;const lc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}ic.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Main Motion Canvas classes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when a new message is logged."))}hc.isMDXComponent=!0;const yc={toc:[]};function kc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the meta file of a given entity."))}kc.isMDXComponent=!0;const fc={toc:[]};function Mc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when metadata changes."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function _c(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Load new metadata from a file."))}_c.isMDXComponent=!0;const Xc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New metadata."))}wc.isMDXComponent=!0;const Tc={toc:[]};function Cc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any possible errors will be logged to the console."))}Cc.isMDXComponent=!0;const xc={toc:[]};function gc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set data without waiting for confirmation."))}gc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New data."))}Zc.isMDXComponent=!0;const bc={toc:[]};function vc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the data stored in the meta file."))}vc.isMDXComponent=!0;const Nc={toc:[]};function Ec(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,p.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}Ec.isMDXComponent=!0;const Ac={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}))}Sc.isMDXComponent=!0;const Rc={toc:[]};function Pc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The project configuration."))}Pc.isMDXComponent=!0;const Wc={toc:[]};function Ic(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the current scene changes."))}Ic.isMDXComponent=!0;const Fc={toc:[]};function Gc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Gc.isMDXComponent=!0;const Uc={toc:[]};function zc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after the scenes were recalculated."))}zc.isMDXComponent=!0;const jc={toc:[]};function qc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}qc.isMDXComponent=!0;const Vc={toc:[]};function Bc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Multi-media management."))}Bc.isMDXComponent=!0;const Oc={toc:[]};function $c(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}$c.isMDXComponent=!0;const Hc={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause/resume the audio."))}Kc.isMDXComponent=!0;const Yc={toc:[]};function Jc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the audio should be paused or resumed."))}Jc.isMDXComponent=!0;const Qc={toc:[]};function tr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The absolute biggest value from the peaks array."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of samples taken."))}nr.isMDXComponent=!0;const or={toc:[]};function cr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}cr.isMDXComponent=!0;const rr={toc:[]};function pr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Samples per seconds."))}pr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Playback control."))}ar.isMDXComponent=!0;const lr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Abstract scene representations and related utilities."))}ir.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Signifies the various stages of a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs after a render ends."))}hr.isMDXComponent=!0;const yr={toc:[]};function kr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}kr.isMDXComponent=!0;const fr={toc:[]};function Mr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,p.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function _r(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,p.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}_r.isMDXComponent=!0;const Xr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes the state of a scene."))}wr.isMDXComponent=!0;const Tr={toc:[]};function Cr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Cr.isMDXComponent=!0;const xr={toc:[]};function gr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished transitioning in."))}gr.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Zr.isMDXComponent=!0;const br={toc:[]};function vr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},br,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene is ready to transition out."))}vr.isMDXComponent=!0;const Nr={toc:[]};function Er(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoking ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Er.isMDXComponent=!0;const Ar={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished."))}Sr.isMDXComponent=!0;const Rr={toc:[]};function Pr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has just been created/reset."))}Pr.isMDXComponent=!0;const Wr={toc:[]};function Ir(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The default implementation of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,p.kt)("p",null,"Uses generators to control the animation."))}Ir.isMDXComponent=!0;const Fr={toc:[]};function Gr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Gr.isMDXComponent=!0;const Ur={toc:[]};function zr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ur,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}zr.isMDXComponent=!0;const jr={toc:[]};function qr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}qr.isMDXComponent=!0;const Vr={toc:[]};function Br(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Br.isMDXComponent=!0;const Or={toc:[]};function $r(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}$r.isMDXComponent=!0;const Hr={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Kr.isMDXComponent=!0;const Yr={toc:[]};function Jr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Jr.isMDXComponent=!0;const Qr={toc:[]};function tp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}np.isMDXComponent=!0;const op={toc:[]};function cp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}cp.isMDXComponent=!0;const rp={toc:[]};function pp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}pp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ap.isMDXComponent=!0;const lp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ip.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hp.isMDXComponent=!0;const yp={toc:[]};function kp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}kp.isMDXComponent=!0;const fp={toc:[]};function Mp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Mp.isMDXComponent=!0;const Dp={toc:[]};function _p(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}_p.isMDXComponent=!0;const Xp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}wp.isMDXComponent=!0;const Tp={toc:[]};function Cp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}Cp.isMDXComponent=!0;const xp={toc:[]};function gp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}gp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}Zp.isMDXComponent=!0;const bp={toc:[]};function vp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}vp.isMDXComponent=!0;const Np={toc:[]};function Ep(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Ep.isMDXComponent=!0;const Ap={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}Sp.isMDXComponent=!0;const Rp={toc:[]};function Pp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Pp.isMDXComponent=!0;const Wp={toc:[]};function Ip(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Ip.isMDXComponent=!0;const Fp={toc:[]};function Gp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Gp.isMDXComponent=!0;const Up={toc:[]};function zp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Up,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}zp.isMDXComponent=!0;const jp={toc:[]};function qp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}qp.isMDXComponent=!0;const Vp={toc:[]};function Bp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Lifecycle events for ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Bp.isMDXComponent=!0;const Op={toc:[]};function $p(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A random number generator based on\n",(0,p.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,p.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}$p.isMDXComponent=!0;const Hp={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random floats in the given range."))}Kp.isMDXComponent=!0;const Yp={toc:[]};function Jp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."))}Jp.isMDXComponent=!0;const Qp={toc:[]};function ts(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}ns.isMDXComponent=!0;const os={toc:[]};function cs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random integers in the given range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"}),(0,p.kt)("li",{parentName:"ul"})))}cs.isMDXComponent=!0;const rs={toc:[]};function ps(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}ps.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ss,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}as.isMDXComponent=!0;const ls={toc:[]};function is(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ls,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}is.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random float in the given range."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}hs.isMDXComponent=!0;const ys={toc:[]};function ks(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}ks.isMDXComponent=!0;const fs={toc:[]};function Ms(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random integer in the given range."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function _s(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}_s.isMDXComponent=!0;const Xs={toc:[]};function ws(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}ws.isMDXComponent=!0;const Ts={toc:[]};function Cs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ts,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a new independent generator."))}Cs.isMDXComponent=!0;const xs={toc:[]};function gs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Manages time events for a given scene."))}gs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ls,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when time events change."))}Zs.isMDXComponent=!0;const bs={toc:[]};function vs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the time offset of the given event."))}vs.isMDXComponent=!0;const Ns={toc:[]};function Es(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the event."))}Es.isMDXComponent=!0;const As={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The time offset in seconds."))}Ss.isMDXComponent=!0;const Rs={toc:[]};function Ps(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}Ps.isMDXComponent=!0;const Ws={toc:[]};function Is(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ws,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes cached information about the timing of a scene."))}Is.isMDXComponent=!0;const Fs={toc:[]};function Gs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a complete scene together with the meta file."))}Gs.isMDXComponent=!0;const Us={toc:[]};function zs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Us,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}zs.isMDXComponent=!0;const js={toc:[]};function qs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},js,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}qs.isMDXComponent=!0;const Vs={toc:[]};function Bs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Bs.isMDXComponent=!0;const Os={toc:[]};function $s(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}$s.isMDXComponent=!0;const Hs={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Ks.isMDXComponent=!0;const Ys={toc:[]};function Js(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ys,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Js.isMDXComponent=!0;const Qs={toc:[]};function ta(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for the inspected element."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element for which to draw an overlay."))}na.isMDXComponent=!0;const oa={toc:[]};function ca(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}ca.isMDXComponent=!0;const ra={toc:[]};function pa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}pa.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}aa.isMDXComponent=!0;const la={toc:[]};function ia(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},la,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the attributes of the inspected element."))}ia.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to inspect."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a possible element to inspect at a given position."))}ha.isMDXComponent=!0;const ya={toc:[]};function ka(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x coordinate."))}ka.isMDXComponent=!0;const fa={toc:[]};function Ma(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y coordinate."))}Ma.isMDXComponent=!0;const Da={toc:[]};function _a(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}_a.isMDXComponent=!0;const Xa={toc:[]};function wa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the inspected element is still valid."))}wa.isMDXComponent=!0;const Ta={toc:[]};function Ca(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ta,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to validate."))}Ca.isMDXComponent=!0;const xa={toc:[]};function ga(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event stored in a meta file."))}ga.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},La,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Za.isMDXComponent=!0;const ba={toc:[]};function va(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ba,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main interface for scenes."))}va.isMDXComponent=!0;const Na={toc:[]};function Ea(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Ea.isMDXComponent=!0;const Aa={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Sa.isMDXComponent=!0;const Ra={toc:[]};function Pa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Pa.isMDXComponent=!0;const Wa={toc:[]};function Ia(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene's ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Ia.isMDXComponent=!0;const Fa={toc:[]};function Ga(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Ga.isMDXComponent=!0;const Ua={toc:[]};function za(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ua,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}za.isMDXComponent=!0;const ja={toc:[]};function qa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ja,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}qa.isMDXComponent=!0;const Va={toc:[]};function Ba(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Va,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Ba.isMDXComponent=!0;const Oa={toc:[]};function $a(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}$a.isMDXComponent=!0;const Ha={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ha,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ka.isMDXComponent=!0;const Ya={toc:[]};function Ja(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ya,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Ja.isMDXComponent=!0;const Qa={toc:[]};function tl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}nl.isMDXComponent=!0;const ol={toc:[]};function cl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}cl.isMDXComponent=!0;const rl={toc:[]};function pl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}pl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}al.isMDXComponent=!0;const ll={toc:[]};function il(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ll,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}il.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}hl.isMDXComponent=!0;const yl={toc:[]};function kl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}kl.isMDXComponent=!0;const fl={toc:[]};function Ml(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function _l(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}_l.isMDXComponent=!0;const Xl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}wl.isMDXComponent=!0;const Tl={toc:[]};function Cl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Cl.isMDXComponent=!0;const xl={toc:[]};function gl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}gl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ll,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Zl.isMDXComponent=!0;const bl={toc:[]};function vl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}vl.isMDXComponent=!0;const Nl={toc:[]};function El(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}El.isMDXComponent=!0;const Al={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Sl.isMDXComponent=!0;const Rl={toc:[]};function Pl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Pl.isMDXComponent=!0;const Wl={toc:[]};function Il(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each class implementing the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Il.isMDXComponent=!0;const Fl={toc:[]};function Gl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constructor used when creating new scenes."))}Gl.isMDXComponent=!0;const Ul={toc:[]};function zl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ul,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,p.kt)("inlineCode",{parentName:"a"},"config")),"."))}zl.isMDXComponent=!0;const jl={toc:[]};function ql(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a scene exposed by scene files."))}ql.isMDXComponent=!0;const Vl={toc:[]};function Bl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Bl.isMDXComponent=!0;const Ol={toc:[]};function $l(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}$l.isMDXComponent=!0;const Hl={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Kl.isMDXComponent=!0;const Yl={toc:[]};function Jl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Jl.isMDXComponent=!0;const Ql={toc:[]};function ti(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ql,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ni.isMDXComponent=!0;const oi={toc:[]};function ci(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ci.isMDXComponent=!0;const ri={toc:[]};function pi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}pi.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},si,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event at runtime."))}ai.isMDXComponent=!0;const li={toc:[]};function ii(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},li,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"In other words, the moment at which ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,p.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}ii.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the event."))}hi.isMDXComponent=!0;const yi={toc:[]};function ki(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Duration of the event in seconds."))}ki.isMDXComponent=!0;const fi={toc:[]};function Mi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stack trace at the moment of registration."))}Mi.isMDXComponent=!0;const Di={toc:[]};function _i(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}_i.isMDXComponent=!0;const Xi={toc:[]};function wi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents attributes of an inspected element."))}wi.isMDXComponent=!0;const Ti={toc:[]};function Ci(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ti,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Ci.isMDXComponent=!0;const xi={toc:[]};function gi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents an element to inspect."))}gi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Li,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Zi.isMDXComponent=!0;const bi={toc:[]};function vi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}vi.isMDXComponent=!0;const Ni={toc:[]};function Ei(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Ei.isMDXComponent=!0;const Ai={toc:[]};function Si(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Si.isMDXComponent=!0;const Ri={toc:[]};function Pi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Pi.isMDXComponent=!0;const Wi={toc:[]};function Ii(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Ii.isMDXComponent=!0;const Fi={toc:[]};function Gi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Gi.isMDXComponent=!0;const Ui={toc:[]};function zi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ui,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}zi.isMDXComponent=!0;const ji={toc:[]};function qi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ji,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}qi.isMDXComponent=!0;const Vi={toc:[]};function Bi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Bi.isMDXComponent=!0;const Oi={toc:[]};function $i(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}$i.isMDXComponent=!0;const Hi={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Ki.isMDXComponent=!0;const Yi={toc:[]};function Ji(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Ji.isMDXComponent=!0;const Qi={toc:[]};function tu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}nu.isMDXComponent=!0;const ou={toc:[]};function cu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}cu.isMDXComponent=!0;const ru={toc:[]};function pu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}pu.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},su,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}au.isMDXComponent=!0;const lu={toc:[]};function iu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}iu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread management."))}hu.isMDXComponent=!0;const yu={toc:[]};function ku(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,p.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}ku.isMDXComponent=!0;const fu={toc:[]};function Mu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A class representing an individual thread."))}Mu.isMDXComponent=!0;const Du={toc:[]};function _u(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}_u.isMDXComponent=!0;const Xu={toc:[]};function wu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}wu.isMDXComponent=!0;const Tu={toc:[]};function Cu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Used by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}Cu.isMDXComponent=!0;const xu={toc:[]};function gu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current time of this thread."))}gu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The next value to be passed to the wrapped generator."))}Zu.isMDXComponent=!0;const bu={toc:[]};function vu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}vu.isMDXComponent=!0;const Nu={toc:[]};function Eu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress the wrapped generator once."))}Eu.isMDXComponent=!0;const Au={toc:[]};function Su(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the thread for the next update cycle."))}Su.isMDXComponent=!0;const Ru={toc:[]};function Pu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a normal function that returns a generator."))}Pu.isMDXComponent=!0;const Wu={toc:[]};function Iu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,p.kt)("p",null,"Progress to the next frame:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,p.kt)("p",null,"Run another generator synchronously:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,p.kt)("p",null,"Run another generator concurrently:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,p.kt)("p",null,"Await a Promise:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Iu.isMDXComponent=!0;const Fu={toc:[]};function Gu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Gu.isMDXComponent=!0;const Uu={toc:[]};function zu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Cancel all listed tasks."),(0,p.kt)("p",null,"Example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}zu.isMDXComponent=!0;const ju={toc:[]};function qu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ju,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to cancel."))}qu.isMDXComponent=!0;const Vu={toc:[]};function Bu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Bu.isMDXComponent=!0;const Ou={toc:[]};function $u(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}$u.isMDXComponent=!0;const Hu={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Ku.isMDXComponent=!0;const Yu={toc:[]};function Ju(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible thread ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Ju.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}nm.isMDXComponent=!0;const om={toc:[]};function cm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}cm.isMDXComponent=!0;const rm={toc:[]};function pm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}pm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until listed tasks are finished."))}am.isMDXComponent=!0;const lm={toc:[]};function im(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}im.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"From the perspective of the external generator, ",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}hm.isMDXComponent=!0;const ym={toc:[]};function km(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}km.isMDXComponent=!0;const fm={toc:[]};function Mm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a context in which generators can be run concurrently."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function _m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the generator to run."))}_m.isMDXComponent=!0;const Xm={toc:[]};function wm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}wm.isMDXComponent=!0;const Tm={toc:[]};function Cm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transitions between scenes."))}Cm.isMDXComponent=!0;const xm={toc:[]};function gm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}gm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the current scene is rendered."))}Zm.isMDXComponent=!0;const bm={toc:[]};function vm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the previous scene is rendered."))}vm.isMDXComponent=!0;const Nm={toc:[]};function Em(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolation and timing of tweens."))}Em.isMDXComponent=!0;const Am={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any old key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"})))}Sm.isMDXComponent=!0;const Rm={toc:[]};function Pm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Pm.isMDXComponent=!0;const Wm={toc:[]};function Im(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Im.isMDXComponent=!0;const Fm={toc:[]};function Gm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Gm.isMDXComponent=!0;const Um={toc:[]};function zm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Um,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}zm.isMDXComponent=!0;const jm={toc:[]};function qm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}qm.isMDXComponent=!0;const Vm={toc:[]};function Bm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Bm.isMDXComponent=!0;const Om={toc:[]};function $m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}$m.isMDXComponent=!0;const Hm={toc:[]};function Km(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Km.isMDXComponent=!0;const Ym={toc:[]};function Jm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ym,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Jm.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Complex types used in animations."))}nd.isMDXComponent=!0;const od={toc:[]};function cd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a two-dimensional vector."))}cd.isMDXComponent=!0;const rd={toc:[]};function pd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}pd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The unclipped RGB components."))}ad.isMDXComponent=!0;const ld={toc:[]};function id(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ld,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}id.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}hd.isMDXComponent=!0;const yd={toc:[]};function kd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}kd.isMDXComponent=!0;const fd={toc:[]};function Md(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}Md.isMDXComponent=!0;const Dd={toc:[]};function _d(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}_d.isMDXComponent=!0;const Xd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}wd.isMDXComponent=!0;const Td={toc:[]};function Cd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Td,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Alias of ",(0,p.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Cd.isMDXComponent=!0;const xd={toc:[]};function gd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}gd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ld,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Zd.isMDXComponent=!0;const bd={toc:[]};function vd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}vd.isMDXComponent=!0;const Nd={toc:[]};function Ed(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Ed.isMDXComponent=!0;const Ad={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Sd.isMDXComponent=!0;const Rd={toc:[]};function Pd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Pd.isMDXComponent=!0;const Wd={toc:[]};function Id(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}Id.isMDXComponent=!0;const Fd={toc:[]};function Gd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"L"),", ",(0,p.kt)("strong",{parentName:"p"},"a"),", and ",(0,p.kt)("strong",{parentName:"p"},"b")," components."))}Gd.isMDXComponent=!0;const Ud={toc:[]};function zd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ud,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}zd.isMDXComponent=!0;const jd={toc:[]};function qd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,p.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,p.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}qd.isMDXComponent=!0;const Vd={toc:[]};function Bd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}Bd.isMDXComponent=!0;const Od={toc:[]};function $d(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}$d.isMDXComponent=!0;const Hd={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Kd.isMDXComponent=!0;const Yd={toc:[]};function Jd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}Jd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get and set the color opacity."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,p.kt)("code",null,"'rgb'")))}nh.isMDXComponent=!0;const oh={toc:[]};function ch(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Similar to saturate, but the opposite direction."))}ch.isMDXComponent=!0;const rh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"set"))}ph.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a single channel value.\nAlso"))}ah.isMDXComponent=!0;const lh={toc:[]};function ih(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}ih.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color as hexadecimal string."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}hh.isMDXComponent=!0;const yh={toc:[]};function kh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,p.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}kh.isMDXComponent=!0;const fh={toc:[]};function Mh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function _h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}_h.isMDXComponent=!0;const Xh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}wh.isMDXComponent=!0;const Th={toc:[]};function Ch(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Th,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Ch.isMDXComponent=!0;const xh={toc:[]};function gh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}gh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}Zh.isMDXComponent=!0;const bh={toc:[]};function vh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}vh.isMDXComponent=!0;const Nh={toc:[]};function Eh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Eh.isMDXComponent=!0;const Ah={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Sh.isMDXComponent=!0;const Rh={toc:[]};function Ph(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Ph.isMDXComponent=!0;const Wh={toc:[]};function Ih(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Ih.isMDXComponent=!0;const Fh={toc:[]};function Gh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The origin to convert."))}Gh.isMDXComponent=!0;const Uh={toc:[]};function zh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"General utilities and helper functions."))}zh.isMDXComponent=!0;const jh={toc:[]};function qh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}qh.isMDXComponent=!0;const Vh={toc:[]};function Bh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Optional override for formatting stack traces"))}Bh.isMDXComponent=!0;const Oh={toc:[]};function $h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create .stack property on a target object"))}$h.isMDXComponent=!0;const Hh={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the reference instead."))}Kh.isMDXComponent=!0;const Yh={toc:[]};function Jh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yh,n,{components:e,mdxType:"MDXLayout"}))}Jh.isMDXComponent=!0;const Qh={toc:[]};function ty(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mark the given function as deprecated."))}ty.isMDXComponent=!0;const ey={toc:[]};function ny(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function to deprecate."))}ny.isMDXComponent=!0;const oy={toc:[]};function cy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The log message."))}cy.isMDXComponent=!0;const ry={toc:[]};function py(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ry,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The optional log remarks."))}py.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}ay.isMDXComponent=!0;const ly={toc:[]};function iy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}iy.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The length of the array."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}hy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}ky.isMDXComponent=!0;const fy={toc:[]};function My(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}My.isMDXComponent=!0;const Dy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}_y.isMDXComponent=!0;const Xy={toc:[]};function wy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}wy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context before render."))}Cy.isMDXComponent=!0;const xy={toc:[]};function gy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}gy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context after render."))}Zy.isMDXComponent=!0;const by={toc:[]};function vy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},by,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current project."))}vy.isMDXComponent=!0;const Ny={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the current scene."))}Ey.isMDXComponent=!0;const Ay={toc:[]};function Sy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ay,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the given seed."))}Sy.isMDXComponent=!0;const Ry={toc:[]};function Py(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The seed for the generator."))}Py.isMDXComponent=!0;const Wy={toc:[]};function Iy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}Iy.isMDXComponent=!0;const Fy={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current scene."))}Gy.isMDXComponent=!0;const Uy={toc:[]};function zy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current thread."))}zy.isMDXComponent=!0;const jy={toc:[]};function qy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}qy.isMDXComponent=!0;const Vy={toc:[]};function By(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}By.isMDXComponent=!0;const Oy={toc:[]};function $y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the real time since the start of the animation."))}$y.isMDXComponent=!0;const Hy={toc:[]};function Ky(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Ky.isMDXComponent=!0;const Yy={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Jy.isMDXComponent=!0;const Qy={toc:[]};function tk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}tk.isMDXComponent=!0;const ek={toc:[]};function nk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ek,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}nk.isMDXComponent=!0;const ok={toc:[]};function ck(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ok,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}ck.isMDXComponent=!0;const rk={toc:[]};function pk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pk.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ak.isMDXComponent=!0;const lk={toc:[]};function ik(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ik.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}hk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}kk.isMDXComponent=!0;const fk={toc:[]};function Mk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Mk.isMDXComponent=!0;const Dk={toc:[]};function _k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}_k.isMDXComponent=!0;const Xk={toc:[]};function wk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Ck.isMDXComponent=!0;const xk={toc:[]};function gk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}gk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Zk.isMDXComponent=!0;const bk={toc:[]};function vk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}vk.isMDXComponent=!0;const Nk={toc:[]};function Ek(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ek.isMDXComponent=!0;const Ak={toc:[]};function Sk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ak,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Sk.isMDXComponent=!0;const Rk={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Pk.isMDXComponent=!0;const Wk={toc:[]};function Ik(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Ik.isMDXComponent=!0;const Fk={toc:[]};function Gk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Gk.isMDXComponent=!0;const Uk={toc:[]};function zk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}zk.isMDXComponent=!0;const jk={toc:[]};function qk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}qk.isMDXComponent=!0;const Vk={toc:[]};function Bk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Bk.isMDXComponent=!0;const Ok={toc:[]};function $k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ok,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}$k.isMDXComponent=!0;const Hk={toc:[]};function Kk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Kk.isMDXComponent=!0;const Yk={toc:[]};function Jk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Jk.isMDXComponent=!0;const Qk={toc:[]};function tf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}nf.isMDXComponent=!0;const of={toc:[]};function cf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}cf.isMDXComponent=!0;const rf={toc:[]};function pf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}pf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}yf.isMDXComponent=!0;const kf={toc:[]};function ff(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ff.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Df.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Xf.isMDXComponent=!0;const wf={toc:[]};function Tf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Tf.isMDXComponent=!0;const Cf={toc:[]};function xf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}xf.isMDXComponent=!0;const gf={toc:[]};function Lf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function bf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}bf.isMDXComponent=!0;const vf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Nf.isMDXComponent=!0;const Ef={toc:[]};function Af(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ef,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Af.isMDXComponent=!0;const Sf={toc:[]};function Rf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}Rf.isMDXComponent=!0;const Pf={toc:[]};function Wf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wf.isMDXComponent=!0;const If={toc:[]};function Ff(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},If,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Ff.isMDXComponent=!0;const Gf={toc:[]};function Uf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Uf.isMDXComponent=!0;const zf={toc:[]};function jf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}jf.isMDXComponent=!0;const qf={toc:[]};function Vf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}Vf.isMDXComponent=!0;const Bf={toc:[]};function Of(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Of.isMDXComponent=!0;const $f={toc:[]};function Hf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Hf.isMDXComponent=!0;const Kf={toc:[]};function Yf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Yf.isMDXComponent=!0;const Jf={toc:[]};function Qf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Qf.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oM.isMDXComponent=!0;const cM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rM.isMDXComponent=!0;const pM={toc:[]};function sM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}sM.isMDXComponent=!0;const aM={toc:[]};function lM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lM.isMDXComponent=!0;const iM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}yM.isMDXComponent=!0;const kM={toc:[]};function fM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}DM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_M,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}XM.isMDXComponent=!0;const wM={toc:[]};function TM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}TM.isMDXComponent=!0;const CM={toc:[]};function xM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}xM.isMDXComponent=!0;const gM={toc:[]};function LM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}LM.isMDXComponent=!0;const ZM={toc:[]};function bM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}bM.isMDXComponent=!0;const vM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}NM.isMDXComponent=!0;const EM={toc:[]};function AM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}AM.isMDXComponent=!0;const SM={toc:[]};function RM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}RM.isMDXComponent=!0;const PM={toc:[]};function WM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}WM.isMDXComponent=!0;const IM={toc:[]};function FM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}FM.isMDXComponent=!0;const GM={toc:[]};function UM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}UM.isMDXComponent=!0;const zM={toc:[]};function jM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jM.isMDXComponent=!0;const qM={toc:[]};function VM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}VM.isMDXComponent=!0;const BM={toc:[]};function OM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}OM.isMDXComponent=!0;const $M={toc:[]};function HM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$M,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}HM.isMDXComponent=!0;const KM={toc:[]};function YM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}YM.isMDXComponent=!0;const JM={toc:[]};function QM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}oD.isMDXComponent=!0;const cD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}rD.isMDXComponent=!0;const pD={toc:[]};function sD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}sD.isMDXComponent=!0;const aD={toc:[]};function lD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}lD.isMDXComponent=!0;const iD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}yD.isMDXComponent=!0;const kD={toc:[]};function fD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}fD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}DD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_D,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}XD.isMDXComponent=!0;const wD={toc:[]};function TD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}TD.isMDXComponent=!0;const CD={toc:[]};function xD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}xD.isMDXComponent=!0;const gD={toc:[]};function LD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}LD.isMDXComponent=!0;const ZD={toc:[]};function bD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}bD.isMDXComponent=!0;const vD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ND.isMDXComponent=!0;const ED={toc:[]};function AD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ED,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}AD.isMDXComponent=!0;const SD={toc:[]};function RD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}RD.isMDXComponent=!0;const PD={toc:[]};function WD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}WD.isMDXComponent=!0;const ID={toc:[]};function FD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ID,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}FD.isMDXComponent=!0;const GD={toc:[]};function UD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}UD.isMDXComponent=!0;const zD={toc:[]};function jD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}jD.isMDXComponent=!0;const qD={toc:[]};function VD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}VD.isMDXComponent=!0;const BD={toc:[]};function OD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}OD.isMDXComponent=!0;const $D={toc:[]};function HD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$D,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}HD.isMDXComponent=!0;const KD={toc:[]};function YD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}YD.isMDXComponent=!0;const JD={toc:[]};function QD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}QD.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}o_.isMDXComponent=!0;const c_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}r_.isMDXComponent=!0;const p_={toc:[]};function s_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}s_.isMDXComponent=!0;const a_={toc:[]};function l_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}l_.isMDXComponent=!0;const i_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}y_.isMDXComponent=!0;const k_={toc:[]};function f_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}f_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}D_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},__,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}X_.isMDXComponent=!0;const w_={toc:[]};function T_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}T_.isMDXComponent=!0;const C_={toc:[]};function x_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}x_.isMDXComponent=!0;const g_={toc:[]};function L_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}L_.isMDXComponent=!0;const Z_={toc:[]};function b_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}b_.isMDXComponent=!0;const v_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}N_.isMDXComponent=!0;const E_={toc:[]};function A_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}A_.isMDXComponent=!0;const S_={toc:[]};function R_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}R_.isMDXComponent=!0;const P_={toc:[]};function W_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}W_.isMDXComponent=!0;const I_={toc:[]};function F_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}F_.isMDXComponent=!0;const G_={toc:[]};function U_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}U_.isMDXComponent=!0;const z_={toc:[]};function j_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}j_.isMDXComponent=!0;const q_={toc:[]};function V_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}V_.isMDXComponent=!0;const B_={toc:[]};function O_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}O_.isMDXComponent=!0;const $_={toc:[]};function H_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}H_.isMDXComponent=!0;const K_={toc:[]};function Y_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}Y_.isMDXComponent=!0;const J_={toc:[]};function Q_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Q_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}oX.isMDXComponent=!0;const cX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}rX.isMDXComponent=!0;const pX={toc:[]};function sX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}sX.isMDXComponent=!0;const aX={toc:[]};function lX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lX.isMDXComponent=!0;const iX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}yX.isMDXComponent=!0;const kX={toc:[]};function fX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}fX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}DX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_X,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XX.isMDXComponent=!0;const wX={toc:[]};function TX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}TX.isMDXComponent=!0;const CX={toc:[]};function xX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}xX.isMDXComponent=!0;const gX={toc:[]};function LX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}LX.isMDXComponent=!0;const ZX={toc:[]};function bX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}bX.isMDXComponent=!0;const vX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}NX.isMDXComponent=!0;const EX={toc:[]};function AX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}AX.isMDXComponent=!0;const SX={toc:[]};function RX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}RX.isMDXComponent=!0;const PX={toc:[]};function WX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}WX.isMDXComponent=!0;const IX={toc:[]};function FX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}FX.isMDXComponent=!0;const GX={toc:[]};function UX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}UX.isMDXComponent=!0;const zX={toc:[]};function jX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jX.isMDXComponent=!0;const qX={toc:[]};function VX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}VX.isMDXComponent=!0;const BX={toc:[]};function OX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}OX.isMDXComponent=!0;const $X={toc:[]};function HX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$X,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}HX.isMDXComponent=!0;const KX={toc:[]};function YX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}YX.isMDXComponent=!0;const JX={toc:[]};function QX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}QX.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}ow.isMDXComponent=!0;const cw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}rw.isMDXComponent=!0;const pw={toc:[]};function sw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}sw.isMDXComponent=!0;const aw={toc:[]};function lw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}lw.isMDXComponent=!0;const iw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yw.isMDXComponent=!0;const kw={toc:[]};function fw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}fw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Dw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_w,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Xw.isMDXComponent=!0;const ww={toc:[]};function Tw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Tw.isMDXComponent=!0;const Cw={toc:[]};function xw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}xw.isMDXComponent=!0;const gw={toc:[]};function Lw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function bw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}bw.isMDXComponent=!0;const vw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Nw.isMDXComponent=!0;const Ew={toc:[]};function Aw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ew,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Aw.isMDXComponent=!0;const Sw={toc:[]};function Rw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Rw.isMDXComponent=!0;const Pw={toc:[]};function Ww(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Ww.isMDXComponent=!0;const Iw={toc:[]};function Fw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}Fw.isMDXComponent=!0;const Gw={toc:[]};function Uw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Uw.isMDXComponent=!0;const zw={toc:[]};function jw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}jw.isMDXComponent=!0;const qw={toc:[]};function Vw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Vw.isMDXComponent=!0;const Bw={toc:[]};function Ow(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Ow.isMDXComponent=!0;const $w={toc:[]};function Hw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$w,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Hw.isMDXComponent=!0;const Kw={toc:[]};function Yw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Yw.isMDXComponent=!0;const Jw={toc:[]};function Qw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qw.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oT.isMDXComponent=!0;const cT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}rT.isMDXComponent=!0;const pT={toc:[]};function sT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}sT.isMDXComponent=!0;const aT={toc:[]};function lT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}lT.isMDXComponent=!0;const iT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}yT.isMDXComponent=!0;const kT={toc:[]};function fT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}fT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}DT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_T,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}XT.isMDXComponent=!0;const wT={toc:[]};function TT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}TT.isMDXComponent=!0;const CT={toc:[]};function xT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}xT.isMDXComponent=!0;const gT={toc:[]};function LT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}LT.isMDXComponent=!0;const ZT={toc:[]};function bT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bT.isMDXComponent=!0;const vT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}NT.isMDXComponent=!0;const ET={toc:[]};function AT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ET,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}AT.isMDXComponent=!0;const ST={toc:[]};function RT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}RT.isMDXComponent=!0;const PT={toc:[]};function WT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}WT.isMDXComponent=!0;const IT={toc:[]};function FT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}FT.isMDXComponent=!0;const GT={toc:[]};function UT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}UT.isMDXComponent=!0;const zT={toc:[]};function jT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}jT.isMDXComponent=!0;const qT={toc:[]};function VT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}VT.isMDXComponent=!0;const BT={toc:[]};function OT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}OT.isMDXComponent=!0;const $T={toc:[]};function HT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$T,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}HT.isMDXComponent=!0;const KT={toc:[]};function YT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}YT.isMDXComponent=!0;const JT={toc:[]};function QT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}QT.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}oC.isMDXComponent=!0;const cC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}rC.isMDXComponent=!0;const pC={toc:[]};function sC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}sC.isMDXComponent=!0;const aC={toc:[]};function lC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}lC.isMDXComponent=!0;const iC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}yC.isMDXComponent=!0;const kC={toc:[]};function fC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}fC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}DC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_C,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}XC.isMDXComponent=!0;const wC={toc:[]};function TC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}TC.isMDXComponent=!0;const CC={toc:[]};function xC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}xC.isMDXComponent=!0;const gC={toc:[]};function LC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}LC.isMDXComponent=!0;const ZC={toc:[]};function bC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}bC.isMDXComponent=!0;const vC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}NC.isMDXComponent=!0;const EC={toc:[]};function AC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}AC.isMDXComponent=!0;const SC={toc:[]};function RC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}RC.isMDXComponent=!0;const PC={toc:[]};function WC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}WC.isMDXComponent=!0;const IC={toc:[]};function FC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}FC.isMDXComponent=!0;const GC={toc:[]};function UC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}UC.isMDXComponent=!0;const zC={toc:[]};function jC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}jC.isMDXComponent=!0;const qC={toc:[]};function VC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}VC.isMDXComponent=!0;const BC={toc:[]};function OC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}OC.isMDXComponent=!0;const $C={toc:[]};function HC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$C,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}HC.isMDXComponent=!0;const KC={toc:[]};function YC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}YC.isMDXComponent=!0;const JC={toc:[]};function QC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}QC.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}ox.isMDXComponent=!0;const cx={toc:[]};function rx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}rx.isMDXComponent=!0;const px={toc:[]};function sx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}sx.isMDXComponent=!0;const ax={toc:[]};function lx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ax,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}lx.isMDXComponent=!0;const ix={toc:[]};function ux(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}yx.isMDXComponent=!0;const kx={toc:[]};function fx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}fx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Dx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_x,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Xx.isMDXComponent=!0;const wx={toc:[]};function Tx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Tx.isMDXComponent=!0;const Cx={toc:[]};function xx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}xx.isMDXComponent=!0;const gx={toc:[]};function Lx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function bx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}bx.isMDXComponent=!0;const vx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Nx.isMDXComponent=!0;const Ex={toc:[]};function Ax(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ex,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ax.isMDXComponent=!0;const Sx={toc:[]};function Rx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Rx.isMDXComponent=!0;const Px={toc:[]};function Wx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Px,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wx.isMDXComponent=!0;const Ix={toc:[]};function Fx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ix,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Fx.isMDXComponent=!0;const Gx={toc:[]};function Ux(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ux.isMDXComponent=!0;const zx={toc:[]};function jx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}jx.isMDXComponent=!0;const qx={toc:[]};function Vx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}Vx.isMDXComponent=!0;const Bx={toc:[]};function Ox(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Ox.isMDXComponent=!0;const $x={toc:[]};function Hx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$x,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Hx.isMDXComponent=!0;const Kx={toc:[]};function Yx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Yx.isMDXComponent=!0;const Jx={toc:[]};function Qx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Qx.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}og.isMDXComponent=!0;const cg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}rg.isMDXComponent=!0;const pg={toc:[]};function sg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}sg.isMDXComponent=!0;const ag={toc:[]};function lg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ag,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}lg.isMDXComponent=!0;const ig={toc:[]};function ug(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yg.isMDXComponent=!0;const kg={toc:[]};function fg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}fg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Dg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_g,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Xg.isMDXComponent=!0;const wg={toc:[]};function Tg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Tg.isMDXComponent=!0;const Cg={toc:[]};function xg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}xg.isMDXComponent=!0;const gg={toc:[]};function Lg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function bg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}bg.isMDXComponent=!0;const vg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Ng.isMDXComponent=!0;const Eg={toc:[]};function Ag(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Ag.isMDXComponent=!0;const Sg={toc:[]};function Rg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Rg.isMDXComponent=!0;const Pg={toc:[]};function Wg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Wg.isMDXComponent=!0;const Ig={toc:[]};function Fg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ig,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Fg.isMDXComponent=!0;const Gg={toc:[]};function Ug(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Ug.isMDXComponent=!0;const zg={toc:[]};function jg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}jg.isMDXComponent=!0;const qg={toc:[]};function Vg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Vg.isMDXComponent=!0;const Bg={toc:[]};function Og(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Og.isMDXComponent=!0;const $g={toc:[]};function Hg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$g,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Hg.isMDXComponent=!0;const Kg={toc:[]};function Yg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Yg.isMDXComponent=!0;const Jg={toc:[]};function Qg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Qg.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}oL.isMDXComponent=!0;const cL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}rL.isMDXComponent=!0;const pL={toc:[]};function sL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}sL.isMDXComponent=!0;const aL={toc:[]};function lL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}lL.isMDXComponent=!0;const iL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}yL.isMDXComponent=!0;const kL={toc:[]};function fL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}fL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}DL.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_L,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}XL.isMDXComponent=!0;const wL={toc:[]};function TL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}TL.isMDXComponent=!0;const CL={toc:[]};function xL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xL.isMDXComponent=!0;const gL={toc:[]};function LL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}LL.isMDXComponent=!0;const ZL={toc:[]};function bL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bL.isMDXComponent=!0;const vL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}NL.isMDXComponent=!0;const EL={toc:[]};function AL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}AL.isMDXComponent=!0;const SL={toc:[]};function RL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}RL.isMDXComponent=!0;const PL={toc:[]};function WL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}WL.isMDXComponent=!0;const IL={toc:[]};function FL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}FL.isMDXComponent=!0;const GL={toc:[]};function UL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}UL.isMDXComponent=!0;const zL={toc:[]};function jL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}jL.isMDXComponent=!0;const qL={toc:[]};function VL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}VL.isMDXComponent=!0;const BL={toc:[]};function OL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}OL.isMDXComponent=!0;const $L={toc:[]};function HL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$L,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}HL.isMDXComponent=!0;const KL={toc:[]};function YL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}YL.isMDXComponent=!0;const JL={toc:[]};function QL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}QL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}oZ.isMDXComponent=!0;const cZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rZ.isMDXComponent=!0;const pZ={toc:[]};function sZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function lZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}lZ.isMDXComponent=!0;const iZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}yZ.isMDXComponent=!0;const kZ={toc:[]};function fZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}fZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}XZ.isMDXComponent=!0;const wZ={toc:[]};function TZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}TZ.isMDXComponent=!0;const CZ={toc:[]};function xZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}xZ.isMDXComponent=!0;const gZ={toc:[]};function LZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function bZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}bZ.isMDXComponent=!0;const vZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}NZ.isMDXComponent=!0;const EZ={toc:[]};function AZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}AZ.isMDXComponent=!0;const SZ={toc:[]};function RZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}RZ.isMDXComponent=!0;const PZ={toc:[]};function WZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}WZ.isMDXComponent=!0;const IZ={toc:[]};function FZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}FZ.isMDXComponent=!0;const GZ={toc:[]};function UZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}UZ.isMDXComponent=!0;const zZ={toc:[]};function jZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}jZ.isMDXComponent=!0;const qZ={toc:[]};function VZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}VZ.isMDXComponent=!0;const BZ={toc:[]};function OZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}OZ.isMDXComponent=!0;const $Z={toc:[]};function HZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}HZ.isMDXComponent=!0;const KZ={toc:[]};function YZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}YZ.isMDXComponent=!0;const JZ={toc:[]};function QZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}QZ.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}ob.isMDXComponent=!0;const cb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}rb.isMDXComponent=!0;const pb={toc:[]};function sb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sb.isMDXComponent=!0;const ab={toc:[]};function lb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ab,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lb.isMDXComponent=!0;const ib={toc:[]};function ub(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}yb.isMDXComponent=!0;const kb={toc:[]};function fb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}fb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Db.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_b,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Xb.isMDXComponent=!0;const wb={toc:[]};function Tb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}Tb.isMDXComponent=!0;const Cb={toc:[]};function xb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}xb.isMDXComponent=!0;const gb={toc:[]};function Lb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function bb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}bb.isMDXComponent=!0;const vb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Nb.isMDXComponent=!0;const Eb={toc:[]};function Ab(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Ab.isMDXComponent=!0;const Sb={toc:[]};function Rb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Rb.isMDXComponent=!0;const Pb={toc:[]};function Wb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Wb.isMDXComponent=!0;const Ib={toc:[]};function Fb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ib,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}Fb.isMDXComponent=!0;const Gb={toc:[]};function Ub(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Ub.isMDXComponent=!0;const zb={toc:[]};function jb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}jb.isMDXComponent=!0;const qb={toc:[]};function Vb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Vb.isMDXComponent=!0;const Bb={toc:[]};function Ob(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Ob.isMDXComponent=!0;const $b={toc:[]};function Hb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$b,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}Hb.isMDXComponent=!0;const Kb={toc:[]};function Yb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Yb.isMDXComponent=!0;const Jb={toc:[]};function Qb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Qb.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ov.isMDXComponent=!0;const cv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rv.isMDXComponent=!0;const pv={toc:[]};function sv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}sv.isMDXComponent=!0;const av={toc:[]};function lv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},av,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lv.isMDXComponent=!0;const iv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yv.isMDXComponent=!0;const kv={toc:[]};function fv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Dv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_v,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Xv.isMDXComponent=!0;const wv={toc:[]};function Tv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Tv.isMDXComponent=!0;const Cv={toc:[]};function xv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}xv.isMDXComponent=!0;const gv={toc:[]};function Lv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function bv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}bv.isMDXComponent=!0;const vv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Nv.isMDXComponent=!0;const Ev={toc:[]};function Av(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ev,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Av.isMDXComponent=!0;const Sv={toc:[]};function Rv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Rv.isMDXComponent=!0;const Pv={toc:[]};function Wv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Wv.isMDXComponent=!0;const Iv={toc:[]};function Fv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Fv.isMDXComponent=!0;const Gv={toc:[]};function Uv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Uv.isMDXComponent=!0;const zv={toc:[]};function jv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}jv.isMDXComponent=!0;const qv={toc:[]};function Vv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Vv.isMDXComponent=!0;const Bv={toc:[]};function Ov(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Ov.isMDXComponent=!0;const $v={toc:[]};function Hv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$v,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Hv.isMDXComponent=!0;const Kv={toc:[]};function Yv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Yv.isMDXComponent=!0;const Jv={toc:[]};function Qv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Qv.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}oN.isMDXComponent=!0;const cN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}rN.isMDXComponent=!0;const pN={toc:[]};function sN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}sN.isMDXComponent=!0;const aN={toc:[]};function lN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}lN.isMDXComponent=!0;const iN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}yN.isMDXComponent=!0;const kN={toc:[]};function fN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}DN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}XN.isMDXComponent=!0;const wN={toc:[]};function TN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}TN.isMDXComponent=!0;const CN={toc:[]};function xN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}xN.isMDXComponent=!0;const gN={toc:[]};function LN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}LN.isMDXComponent=!0;const ZN={toc:[]};function bN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}bN.isMDXComponent=!0;const vN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}NN.isMDXComponent=!0;const EN={toc:[]};function AN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}AN.isMDXComponent=!0;const SN={toc:[]};function RN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}RN.isMDXComponent=!0;const PN={toc:[]};function WN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}WN.isMDXComponent=!0;const IN={toc:[]};function FN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}FN.isMDXComponent=!0;const GN={toc:[]};function UN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}UN.isMDXComponent=!0;const zN={toc:[]};function jN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}jN.isMDXComponent=!0;const qN={toc:[]};function VN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}VN.isMDXComponent=!0;const BN={toc:[]};function ON(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ON.isMDXComponent=!0;const $N={toc:[]};function HN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}HN.isMDXComponent=!0;const KN={toc:[]};function YN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}YN.isMDXComponent=!0;const JN={toc:[]};function QN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}QN.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}oE.isMDXComponent=!0;const cE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}rE.isMDXComponent=!0;const pE={toc:[]};function sE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}sE.isMDXComponent=!0;const aE={toc:[]};function lE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}lE.isMDXComponent=!0;const iE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}dE.isMDXComponent=!0;const hE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}yE.isMDXComponent=!0;const kE={toc:[]};function fE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}fE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}DE.isMDXComponent=!0;const _E={toc:[]};function XE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_E,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}XE.isMDXComponent=!0;const wE={toc:[]};function TE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}TE.isMDXComponent=!0;const CE={toc:[]};function xE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}xE.isMDXComponent=!0;const gE={toc:[]};function LE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}LE.isMDXComponent=!0;const ZE={toc:[]};function bE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}bE.isMDXComponent=!0;const vE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}NE.isMDXComponent=!0;const EE={toc:[]};function AE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}AE.isMDXComponent=!0;const SE={toc:[]};function RE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}RE.isMDXComponent=!0;const PE={toc:[]};function WE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}WE.isMDXComponent=!0;const IE={toc:[]};function FE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FE.isMDXComponent=!0;const GE={toc:[]};function UE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}UE.isMDXComponent=!0;const zE={toc:[]};function jE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}jE.isMDXComponent=!0;const qE={toc:[]};function VE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}VE.isMDXComponent=!0;const BE={toc:[]};function OE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}OE.isMDXComponent=!0;const $E={toc:[]};function HE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$E,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}HE.isMDXComponent=!0;const KE={toc:[]};function YE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}YE.isMDXComponent=!0;const JE={toc:[]};function QE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}QE.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oA.isMDXComponent=!0;const cA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}rA.isMDXComponent=!0;const pA={toc:[]};function sA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sA.isMDXComponent=!0;const aA={toc:[]};function lA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}lA.isMDXComponent=!0;const iA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yA.isMDXComponent=!0;const kA={toc:[]};function fA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}fA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}DA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_A,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}XA.isMDXComponent=!0;const wA={toc:[]};function TA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}TA.isMDXComponent=!0;const CA={toc:[]};function xA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}xA.isMDXComponent=!0;const gA={toc:[]};function LA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}LA.isMDXComponent=!0;const ZA={toc:[]};function bA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}bA.isMDXComponent=!0;const vA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}NA.isMDXComponent=!0;const EA={toc:[]};function AA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}AA.isMDXComponent=!0;const SA={toc:[]};function RA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}RA.isMDXComponent=!0;const PA={toc:[]};function WA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}WA.isMDXComponent=!0;const IA={toc:[]};function FA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}FA.isMDXComponent=!0;const GA={toc:[]};function UA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}UA.isMDXComponent=!0;const zA={toc:[]};function jA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}jA.isMDXComponent=!0;const qA={toc:[]};function VA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}VA.isMDXComponent=!0;const BA={toc:[]};function OA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}OA.isMDXComponent=!0;const $A={toc:[]};function HA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$A,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}HA.isMDXComponent=!0;const KA={toc:[]};function YA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}YA.isMDXComponent=!0;const JA={toc:[]};function QA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QA.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}oS.isMDXComponent=!0;const cS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}rS.isMDXComponent=!0;const pS={toc:[]};function sS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}sS.isMDXComponent=!0;const aS={toc:[]};function lS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lS.isMDXComponent=!0;const iS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}yS.isMDXComponent=!0;const kS={toc:[]};function fS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}fS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}DS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_S,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}XS.isMDXComponent=!0;const wS={toc:[]};function TS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}TS.isMDXComponent=!0;const CS={toc:[]};function xS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}xS.isMDXComponent=!0;const gS={toc:[]};function LS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}LS.isMDXComponent=!0;const ZS={toc:[]};function bS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}bS.isMDXComponent=!0;const vS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}NS.isMDXComponent=!0;const ES={toc:[]};function AS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ES,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}AS.isMDXComponent=!0;const SS={toc:[]};function RS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}RS.isMDXComponent=!0;const PS={toc:[]};function WS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}WS.isMDXComponent=!0;const IS={toc:[]};function FS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}FS.isMDXComponent=!0;const GS={toc:[]};function US(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}US.isMDXComponent=!0;const zS={toc:[]};function jS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}jS.isMDXComponent=!0;const qS={toc:[]};function VS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}VS.isMDXComponent=!0;const BS={toc:[]};function OS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}OS.isMDXComponent=!0;const $S={toc:[]};function HS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$S,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}HS.isMDXComponent=!0;const KS={toc:[]};function YS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}YS.isMDXComponent=!0;const JS={toc:[]};function QS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}QS.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}oR.isMDXComponent=!0;const cR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}rR.isMDXComponent=!0;const pR={toc:[]};function sR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}sR.isMDXComponent=!0;const aR={toc:[]};function lR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lR.isMDXComponent=!0;const iR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}dR.isMDXComponent=!0;const hR={toc:[]};function yR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yR.isMDXComponent=!0;const kR={toc:[]};function fR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}fR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}DR.isMDXComponent=!0;const _R={toc:[]};function XR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_R,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}XR.isMDXComponent=!0;const wR={toc:[]};function TR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}TR.isMDXComponent=!0;const CR={toc:[]};function xR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}xR.isMDXComponent=!0;const gR={toc:[]};function LR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}LR.isMDXComponent=!0;const ZR={toc:[]};function bR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}bR.isMDXComponent=!0;const vR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}NR.isMDXComponent=!0;const ER={toc:[]};function AR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ER,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}AR.isMDXComponent=!0;const SR={toc:[]};function RR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}RR.isMDXComponent=!0;const PR={toc:[]};function WR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}WR.isMDXComponent=!0;const IR={toc:[]};function FR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}FR.isMDXComponent=!0;const GR={toc:[]};function UR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}UR.isMDXComponent=!0;const zR={toc:[]};function jR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}jR.isMDXComponent=!0;const qR={toc:[]};function VR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}VR.isMDXComponent=!0;const BR={toc:[]};function OR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}OR.isMDXComponent=!0;const $R={toc:[]};function HR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$R,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}HR.isMDXComponent=!0;const KR={toc:[]};function YR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}YR.isMDXComponent=!0;const JR={toc:[]};function QR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}QR.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}oP.isMDXComponent=!0;const cP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}rP.isMDXComponent=!0;const pP={toc:[]};function sP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}sP.isMDXComponent=!0;const aP={toc:[]};function lP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}lP.isMDXComponent=!0;const iP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dP.isMDXComponent=!0;const hP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}yP.isMDXComponent=!0;const kP={toc:[]};function fP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}fP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}DP.isMDXComponent=!0;const _P={toc:[]};function XP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_P,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}XP.isMDXComponent=!0;const wP={toc:[]};function TP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}TP.isMDXComponent=!0;const CP={toc:[]};function xP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}xP.isMDXComponent=!0;const gP={toc:[]};function LP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}LP.isMDXComponent=!0;const ZP={toc:[]};function bP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}bP.isMDXComponent=!0;const vP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}NP.isMDXComponent=!0;const EP={toc:[]};function AP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}AP.isMDXComponent=!0;const SP={toc:[]};function RP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}RP.isMDXComponent=!0;const PP={toc:[]};function WP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}WP.isMDXComponent=!0;const IP={toc:[]};function FP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}FP.isMDXComponent=!0;const GP={toc:[]};function UP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}UP.isMDXComponent=!0;const zP={toc:[]};function jP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}jP.isMDXComponent=!0;const qP={toc:[]};function VP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}VP.isMDXComponent=!0;const BP={toc:[]};function OP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}OP.isMDXComponent=!0;const $P={toc:[]};function HP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$P,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}HP.isMDXComponent=!0;const KP={toc:[]};function YP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}YP.isMDXComponent=!0;const JP={toc:[]};function QP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}QP.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oW.isMDXComponent=!0;const cW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}rW.isMDXComponent=!0;const pW={toc:[]};function sW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}sW.isMDXComponent=!0;const aW={toc:[]};function lW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}lW.isMDXComponent=!0;const iW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}dW.isMDXComponent=!0;const hW={toc:[]};function yW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}yW.isMDXComponent=!0;const kW={toc:[]};function fW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}fW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DW.isMDXComponent=!0;const _W={toc:[]};function XW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_W,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}XW.isMDXComponent=!0;const wW={toc:[]};function TW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}TW.isMDXComponent=!0;const CW={toc:[]};function xW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}xW.isMDXComponent=!0;const gW={toc:[]};function LW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}LW.isMDXComponent=!0;const ZW={toc:[]};function bW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bW.isMDXComponent=!0;const vW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}NW.isMDXComponent=!0;const EW={toc:[]};function AW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}AW.isMDXComponent=!0;const SW={toc:[]};function RW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}RW.isMDXComponent=!0;const PW={toc:[]};function WW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}WW.isMDXComponent=!0;const IW={toc:[]};function FW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FW.isMDXComponent=!0;const GW={toc:[]};function UW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}UW.isMDXComponent=!0;const zW={toc:[]};function jW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}jW.isMDXComponent=!0;const qW={toc:[]};function VW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}VW.isMDXComponent=!0;const BW={toc:[]};function OW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}OW.isMDXComponent=!0;const $W={toc:[]};function HW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$W,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}HW.isMDXComponent=!0;const KW={toc:[]};function YW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}YW.isMDXComponent=!0;const JW={toc:[]};function QW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}QW.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}oI.isMDXComponent=!0;const cI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}rI.isMDXComponent=!0;const pI={toc:[]};function sI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}sI.isMDXComponent=!0;const aI={toc:[]};function lI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}lI.isMDXComponent=!0;const iI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}dI.isMDXComponent=!0;const hI={toc:[]};function yI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}yI.isMDXComponent=!0;const kI={toc:[]};function fI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}fI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}DI.isMDXComponent=!0;const _I={toc:[]};function XI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_I,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}XI.isMDXComponent=!0;const wI={toc:[]};function TI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}TI.isMDXComponent=!0;const CI={toc:[]};function xI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}xI.isMDXComponent=!0;const gI={toc:[]};function LI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}LI.isMDXComponent=!0;const ZI={toc:[]};function bI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}bI.isMDXComponent=!0;const vI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}NI.isMDXComponent=!0;const EI={toc:[]};function AI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}AI.isMDXComponent=!0;const SI={toc:[]};function RI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}RI.isMDXComponent=!0;const PI={toc:[]};function WI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}WI.isMDXComponent=!0;const II={toc:[]};function FI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},II,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}FI.isMDXComponent=!0;const GI={toc:[]};function UI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}UI.isMDXComponent=!0;const zI={toc:[]};function jI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}jI.isMDXComponent=!0;const qI={toc:[]};function VI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}VI.isMDXComponent=!0;const BI={toc:[]};function OI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}OI.isMDXComponent=!0;const $I={toc:[]};function HI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$I,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}HI.isMDXComponent=!0;const KI={toc:[]};function YI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}YI.isMDXComponent=!0;const JI={toc:[]};function QI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}QI.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}oF.isMDXComponent=!0;const cF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}rF.isMDXComponent=!0;const pF={toc:[]};function sF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}sF.isMDXComponent=!0;const aF={toc:[]};function lF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}lF.isMDXComponent=!0;const iF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}dF.isMDXComponent=!0;const hF={toc:[]};function yF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yF.isMDXComponent=!0;const kF={toc:[]};function fF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}fF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}DF.isMDXComponent=!0;const _F={toc:[]};function XF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_F,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}XF.isMDXComponent=!0;const wF={toc:[]};function TF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}TF.isMDXComponent=!0;const CF={toc:[]};function xF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}xF.isMDXComponent=!0;const gF={toc:[]};function LF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}LF.isMDXComponent=!0;const ZF={toc:[]};function bF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}bF.isMDXComponent=!0;const vF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}NF.isMDXComponent=!0;const EF={toc:[]};function AF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}AF.isMDXComponent=!0;const SF={toc:[]};function RF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}RF.isMDXComponent=!0;const PF={toc:[]};function WF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WF.isMDXComponent=!0;const IF={toc:[]};function FF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}FF.isMDXComponent=!0;const GF={toc:[]};function UF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}UF.isMDXComponent=!0;const zF={toc:[]};function jF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jF.isMDXComponent=!0;const qF={toc:[]};function VF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}VF.isMDXComponent=!0;const BF={toc:[]};function OF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}OF.isMDXComponent=!0;const $F={toc:[]};function HF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$F,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}HF.isMDXComponent=!0;const KF={toc:[]};function YF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}YF.isMDXComponent=!0;const JF={toc:[]};function QF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}QF.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oG.isMDXComponent=!0;const cG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}rG.isMDXComponent=!0;const pG={toc:[]};function sG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}sG.isMDXComponent=!0;const aG={toc:[]};function lG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lG.isMDXComponent=!0;const iG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}dG.isMDXComponent=!0;const hG={toc:[]};function yG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}yG.isMDXComponent=!0;const kG={toc:[]};function fG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}fG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}DG.isMDXComponent=!0;const _G={toc:[]};function XG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_G,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}XG.isMDXComponent=!0;const wG={toc:[]};function TG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}TG.isMDXComponent=!0;const CG={toc:[]};function xG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}xG.isMDXComponent=!0;const gG={toc:[]};function LG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}LG.isMDXComponent=!0;const ZG={toc:[]};function bG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}bG.isMDXComponent=!0;const vG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}NG.isMDXComponent=!0;const EG={toc:[]};function AG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}AG.isMDXComponent=!0;const SG={toc:[]};function RG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}RG.isMDXComponent=!0;const PG={toc:[]};function WG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}WG.isMDXComponent=!0;const IG={toc:[]};function FG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FG.isMDXComponent=!0;const GG={toc:[]};function UG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}UG.isMDXComponent=!0;const zG={toc:[]};function jG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}jG.isMDXComponent=!0;const qG={toc:[]};function VG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}VG.isMDXComponent=!0;const BG={toc:[]};function OG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}OG.isMDXComponent=!0;const $G={toc:[]};function HG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$G,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}HG.isMDXComponent=!0;const KG={toc:[]};function YG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}YG.isMDXComponent=!0;const JG={toc:[]};function QG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}QG.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}oU.isMDXComponent=!0;const cU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}rU.isMDXComponent=!0;const pU={toc:[]};function sU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sU.isMDXComponent=!0;const aU={toc:[]};function lU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}lU.isMDXComponent=!0;const iU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}dU.isMDXComponent=!0;const hU={toc:[]};function yU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}yU.isMDXComponent=!0;const kU={toc:[]};function fU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}fU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}DU.isMDXComponent=!0;const _U={toc:[]};function XU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_U,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}XU.isMDXComponent=!0;const wU={toc:[]};function TU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}TU.isMDXComponent=!0;const CU={toc:[]};function xU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}xU.isMDXComponent=!0;const gU={toc:[]};function LU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}LU.isMDXComponent=!0;const ZU={toc:[]};function bU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}bU.isMDXComponent=!0;const vU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}NU.isMDXComponent=!0;const EU={toc:[]};function AU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}AU.isMDXComponent=!0;const SU={toc:[]};function RU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}RU.isMDXComponent=!0;const PU={toc:[]};function WU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}WU.isMDXComponent=!0;const IU={toc:[]};function FU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}FU.isMDXComponent=!0;const GU={toc:[]};function UU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}UU.isMDXComponent=!0;const zU={toc:[]};function jU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}jU.isMDXComponent=!0;const qU={toc:[]};function VU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}VU.isMDXComponent=!0;const BU={toc:[]};function OU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},BU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}OU.isMDXComponent=!0;const $U={toc:[]};function HU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$U,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}HU.isMDXComponent=!0;const KU={toc:[]};function YU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}YU.isMDXComponent=!0;const JU={toc:[]};function QU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}QU.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}oz.isMDXComponent=!0;const cz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}rz.isMDXComponent=!0;const pz={toc:[]};function sz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}sz.isMDXComponent=!0;const az={toc:[]};function lz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},az,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}lz.isMDXComponent=!0;const iz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dz.isMDXComponent=!0;const hz={toc:[]};function yz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}yz.isMDXComponent=!0;const kz={toc:[]};function fz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}fz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Dz.isMDXComponent=!0;const _z={toc:[]};function Xz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Xz.isMDXComponent=!0;const wz={toc:[]};function Tz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Tz.isMDXComponent=!0;const Cz={toc:[]};function xz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}xz.isMDXComponent=!0;const gz={toc:[]};function Lz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lz.isMDXComponent=!0;const Zz={toc:[]};function bz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bz.isMDXComponent=!0;const vz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Nz.isMDXComponent=!0;const Ez={toc:[]};function Az(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ez,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Az.isMDXComponent=!0;const Sz={toc:[]};function Rz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Rz.isMDXComponent=!0;const Pz={toc:[]};function Wz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Wz.isMDXComponent=!0;const Iz={toc:[]};function Fz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Fz.isMDXComponent=!0;const Gz={toc:[]};function Uz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Uz.isMDXComponent=!0;const zz={toc:[]};function jz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}jz.isMDXComponent=!0;const qz={toc:[]};function Vz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Vz.isMDXComponent=!0;const Bz={toc:[]};function Oz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,p.kt)("p",null,"By default, any property is cloneable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Oz.isMDXComponent=!0;const $z={toc:[]};function Hz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Hz.isMDXComponent=!0;const Kz={toc:[]};function Yz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a cloneable property decorator."))}Yz.isMDXComponent=!0;const Jz={toc:[]};function Qz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be cloneable."))}Qz.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}oj.isMDXComponent=!0;const cj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a compound property decorator."))}rj.isMDXComponent=!0;const pj={toc:[]};function sj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}sj.isMDXComponent=!0;const aj={toc:[]};function lj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,p.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,p.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}lj.isMDXComponent=!0;const ij={toc:[]};function uj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a computed method decorator."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the initial value of a property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}dj.isMDXComponent=!0;const hj={toc:[]};function yj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}yj.isMDXComponent=!0;const kj={toc:[]};function fj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an initial signal value decorator."))}fj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the property."))}Dj.isMDXComponent=!0;const _j={toc:[]};function Xj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_j,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,p.kt)("p",null,"By default, any property is inspectable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Xj.isMDXComponent=!0;const wj={toc:[]};function Tj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}Tj.isMDXComponent=!0;const Cj={toc:[]};function xj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an inspectable property decorator."))}xj.isMDXComponent=!0;const gj={toc:[]};function Lj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be inspectable."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function bj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}bj.isMDXComponent=!0;const vj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}Nj.isMDXComponent=!0;const Ej={toc:[]};function Aj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ej,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal interpolation function decorator."))}Aj.isMDXComponent=!0;const Sj={toc:[]};function Rj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function for the property."))}Rj.isMDXComponent=!0;const Pj={toc:[]};function Wj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,p.kt)("p",null,"If the wrapper class has a method called ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Wj.isMDXComponent=!0;const Ij={toc:[]};function Fj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ij,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Fj.isMDXComponent=!0;const Gj={toc:[]};function Uj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal parser decorator."))}Uj.isMDXComponent=!0;const zj={toc:[]};function jj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}jj.isMDXComponent=!0;const qj={toc:[]};function Vj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given property into a signal."),(0,p.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}Vj.isMDXComponent=!0;const Bj={toc:[]};function Oj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Oj.isMDXComponent=!0;const $j={toc:[]};function Hj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$j,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal decorator."))}Hj.isMDXComponent=!0;const Kj={toc:[]};function Yj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,p.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,p.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,p.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Yj.isMDXComponent=!0;const Jj={toc:[]};function Qj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Qj.isMDXComponent=!0;const tq={toc:[]};function eq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal wrapper decorator."))}eq.isMDXComponent=!0;const nq={toc:[]};function oq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}oq.isMDXComponent=!0;const cq={toc:[]};function rq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A unified abstraction for all CSS filters."))}rq.isMDXComponent=!0;const pq={toc:[]};function sq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,p.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}sq.isMDXComponent=!0;const aq={toc:[]};function lq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in pixels."))}lq.isMDXComponent=!0;const iq={toc:[]};function uq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,p.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}dq.isMDXComponent=!0;const hq={toc:[]};function yq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,p.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}yq.isMDXComponent=!0;const kq={toc:[]};function fq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}fq.isMDXComponent=!0;const Mq={toc:[]};function Dq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,p.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}Dq.isMDXComponent=!0;const _q={toc:[]};function Xq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_q,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}Xq.isMDXComponent=!0;const wq={toc:[]};function Tq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,p.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}Tq.isMDXComponent=!0;const Cq={toc:[]};function xq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in degrees."))}xq.isMDXComponent=!0;const gq={toc:[]};function Lq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,p.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function bq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}bq.isMDXComponent=!0;const vq={toc:[]};function Nq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,p.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}Nq.isMDXComponent=!0;const Eq={toc:[]};function Aq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}Aq.isMDXComponent=!0;const Sq={toc:[]};function Rq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,p.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}Rq.isMDXComponent=!0;const Pq={toc:[]};function Wq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}Wq.isMDXComponent=!0;const Iq={toc:[]};function Fq(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iq,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}function Gq(t){let{id:e}=t;const n=o[e]??c.Fragment;return c.createElement(n,null)}Fq.isMDXComponent=!0},9322:(t,e,n)=>{n.d(e,{Z:()=>m});var o=n(2784),c=n(2366),r=n(8698);const p="toggle_S_IX",s="collapsed_wdUB",a="collapse_TjTN",l="inverse_g6vW",i="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(c.Z,{id:null==e?void 0:e.summaryId}),o.createElement(c.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),h=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(p,n&&s),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:a},d.map((t=>o.createElement(c.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:i})),o.createElement("div",{className:(0,u.Z)(i,l)})),h&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(c.Z,{id:h.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(c.Z,{id:y.contentId})))}},1836:(t,e,n)=>{n.d(e,{Z:()=>St});var o=n(2784),c=n(7390),r=n(6835),p=n(68),s=n(6277),a=n(8569);const l={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=n(7896);function u(t){let{width:e=24,height:n=24,...c}=t;return o.createElement("svg",(0,i.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},c),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:c,link:i}=t;const m=(0,r.F)(),d=(0,p.s2)();return o.createElement("div",{className:(0,s.Z)(a.Z.codeBlockContent,l.codeBlock,n&&l.highlight,c&&l.pointer)},o.createElement("pre",{onClick:c,onKeyDown:t=>{"Enter"===t.key&&(null==c||c())},tabIndex:0,ref:m.codeBlockRef,className:(0,s.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},e)),i&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(i,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(9318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,s.Z)(l.codeBlockContainer,"language-typescript")},e)}var y=n(9817);function k(t){let{children:e,type:n,to:c,id:r,tooltip:s}=t;const a=(0,p.Ld)(n);return c?o.createElement(y.Z,(0,i.Z)({id:r,to:c,"data-tooltip":s},a),e):o.createElement("span",(0,i.Z)({id:r},a),e)}let f,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[f.None]:l.none,[f.Angle]:l.angle,[f.Curly]:l.curly,[f.Square]:l.square,[f.Parentheses]:l.parentheses};function _(t){let{children:e,type:n,separator:c=M.Comma}=t;return o.createElement("span",{className:(0,s.Z)(l.list,D[n??f.None])},o.createElement("span",{className:(0,s.Z)(l.elements,c!==M.Comma&&l.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":c,key:e,className:l.element},t)))))}var X=n(8617);function w(t){var e;let{type:n}=t;const c=(0,X.RU)(n.project),r=null==c?void 0:c[n.id],p=n.externalUrl??(0,X.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(k,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(_,{type:f.Angle},n.typeArguments.map(((t,e)=>o.createElement(F,{key:e,type:t})))))}function T(t){let{type:e}=t;return o.createElement(k,{type:"keyword"},e.name)}function C(t){let{type:e}=t;return e.elements?o.createElement(_,{type:f.Square},e.elements.map(((t,e)=>o.createElement(F,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function x(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.elementType}),"[]")}function g(t){let{type:e}=t;return o.createElement(_,{type:f.Parentheses,separator:M.Pipe},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function L(t){let{type:e}=t;const[n,c]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(k,{type:c},n)}function Z(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"asserts "),o.createElement(k,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(k,null,e.name," "),o.createElement(k,{type:"keyword"},"is "),o.createElement(F,{type:e.targetType}))}function b(t){let{type:e}=t;const n=(0,X.in)();return o.createElement(K,{reflection:n(e.declaration)})}function v(t){let{type:e}=t;return o.createElement(_,{type:f.Parentheses,separator:M.Ampersand},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,c]=t;return o.createElement(o.Fragment,null,"${",o.createElement(F,{key:e,type:n}),"}",o.createElement(k,{type:"string"},c))})),o.createElement(k,{type:"string"},"`"))}function E(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"typeof "),o.createElement(F,{type:e.queryType}))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.checkType}),o.createElement(k,{type:"keyword"}," extends "),o.createElement(F,{type:e.extendsType})," ? ",o.createElement(F,{type:e.trueType})," : ",o.createElement(F,{type:e.falseType}))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"infer "),o.createElement(k,{type:"constant"},e.name))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.objectType}),"[",o.createElement(F,{type:e.indexType}),"]")}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},e.operator," "),o.createElement(F,{type:e.target}))}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(_,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(k,{type:"class"},e.parameter),o.createElement(k,{type:"keyword"}," in "),o.createElement(F,{type:e.parameterType}),"]: ",o.createElement(F,{type:e.templateType}))))}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(F,{type:e.element}))}function F(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return P;case"conditional":return A;case"reflection":return b;case"query":return E;case"named-tuple-member":return I;case"union":return g;case"intrinsic":return T;case"literal":return L;case"reference":return w;case"predicate":return Z;case"tuple":return C;case"array":return x;case"intersection":return v;case"inferred":return S;case"mapped":return W;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function G(t){let{flags:e,explicitAccessModifier:n}=t;const c=[];return null!=e&&e.isAbstract&&c.push("abstract"),null!=e&&e.isStatic&&c.push("static"),null!=e&&e.isConst&&c.push("const"),null!=e&&e.isReadonly&&c.push("readonly"),null!=e&&e.isPrivate&&c.push("private"),null!=e&&e.isProtected&&c.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||c.push("public"),o.createElement(o.Fragment,null,c.map((t=>o.createElement(k,{key:t,type:"keyword"},t," "))))}function U(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(F,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(k,{type:"plain"},e.defaultValue)))}function z(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(G,{flags:e.flags}),e.varianceModifier&&o.createElement(k,{type:"keyword"},e.varianceModifier," "),o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(F,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(F,{type:e.default})))}function j(t){var e,n;let{reflection:r,flags:p}=t;const s=(0,X.in)(),a="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:p??r.flags,explicitAccessModifier:!a}),r.kind===c.W.GetSignature&&o.createElement(k,{type:"keyword"},"get "),r.kind===c.W.SetSignature&&o.createElement(k,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(k,{to:r.overwrites.externalUrl??(0,X.Gr)(s(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===c.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(k,{to:"#",type:"keyword"},"new")," ",o.createElement(k,{type:"plain"},r.type.name)):a?"":o.createElement(k,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(_,{type:f.Angle},r.typeParameter.map((t=>o.createElement(z,{key:t.id,reflection:s(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(_,{type:f.Parentheses},r.parameters.map((t=>o.createElement(U,{key:t,reflection:s(t)})))):"()",r.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(F,{type:r.type})))}function q(t){let{reflection:e}=t;return o.createElement(U,{reflection:e})}const V={[c.W.Namespace]:"namespace",[c.W.Enum]:"enum",[c.W.Class]:"class",[c.W.Interface]:"interface"};function B(t){var e,n,c;let{reflection:r}=t;const p=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:r.flags}),o.createElement(k,{type:"keyword"},V[r.kind]," "),o.createElement(k,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(_,{type:f.Angle},r.typeParameters.map((t=>o.createElement(z,{key:t.id,reflection:p(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"extends "),o.createElement(_,null,r.extendedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))),!(null==(c=r.implementedTypes)||!c.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"implements "),o.createElement(_,null,r.implementedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))))}function O(t){let{reflection:e}=t;const n=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:e.flags}),o.createElement(k,{type:"keyword"},"type "),o.createElement(k,{type:"class-name"},e.name),e.typeParameters&&o.createElement(_,{type:f.Angle},e.typeParameters.map((t=>o.createElement(z,{key:t.id,reflection:n(t)}))))," = ",o.createElement(F,{type:e.type}))}function $(t){let{reflection:e}=t;const n=(0,X.in)();return e.signatures?o.createElement(j,{reflection:e.signatures[0]}):e.children?o.createElement(_,{type:f.Curly},e.children.map((t=>o.createElement(K,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"unknown"))}function H(t){var e;let{reflection:n}=t;const c=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(j,{reflection:c})}function K(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case c.W.Project:case c.W.Module:case c.W.EnumMember:case c.W.Variable:case c.W.Function:break;case c.W.Namespace:case c.W.Enum:case c.W.Class:case c.W.Interface:return B;case c.W.Constructor:return j;case c.W.Property:return q;case c.W.Method:return H;case c.W.CallSignature:case c.W.IndexSignature:case c.W.ConstructorSignature:case c.W.Parameter:break;case c.W.TypeLiteral:return $;case c.W.TypeParameter:return z;case c.W.Accessor:case c.W.GetSignature:case c.W.SetSignature:case c.W.ObjectLiteral:break;case c.W.TypeAlias:return O;case c.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function Y(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${l.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(l.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,s.Z)(l.line,"token-line")},e),o.createElement("br",null))}var J=n(9322),Q=n(2366);function tt(t){let{parameters:e}=t;const n=(0,X.in)(),c=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=c&&c.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,c.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(z,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,X.in)(),c=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=c&&c.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,c.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(U,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:c}=t;const r=(0,X.in)(),p=(0,o.useMemo)((()=>e.map(r)),[e]),[s,a]=(0,o.useState)(p[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,p.map((t=>o.createElement(m,{link:null==c?void 0:c.url,key:t.id,highlight:e.length>1&&t.id===s.id,onClick:e.length>1?()=>a(t):void 0},o.createElement(Y,null,o.createElement(j,{reflection:t,flags:n})))))),o.createElement(J.Z,{comment:s.comment}),o.createElement(tt,{parameters:s.typeParameter}),o.createElement(et,{parameters:s.parameters}))}var ot=n(7708);function ct(t){let{width:e=24,height:n=24,...c}=t;return o.createElement("svg",(0,i.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},c),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",pt="filters_z1iC",st="icon_ROIU";function at(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[c,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,s.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(ct,{className:st})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,s.Z)("dropdown__link",c.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:c.private,onChange:t=>{r({...c,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,s.Z)("dropdown__link",c.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:c.inherited,onChange:t=>{r({...c,inherited:t.target.checked})}}),"Inherited members")))))}function lt(t){let{children:e,kind:n}=t;return n===c.W.Class||n===c.W.Interface?o.createElement("div",{className:(0,s.Z)("row",rt)},o.createElement("div",{className:(0,s.Z)("col",pt)},o.createElement(at,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var it=n(3181),ut=n(8963),mt=n(3851),dt=n(9741),ht=n(2244),yt=n(4126);const kt="tabList_M0Dn",ft="tabItem_ysIP";function Mt(t){var e;const{lazy:n,block:c,defaultValue:r,values:p,groupId:a,className:l}=t,u=o.Children.map(t.children,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),m=p??u.map((t=>{let{props:{value:e,label:n,attributes:o}}=t;return{value:e,label:n,attributes:o}})),d=(0,ht.l)(m,((t,e)=>t.value===e.value));if(d.length>0)throw new Error(`Docusaurus error: Duplicate values "${d.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const h=null===r?r:r??(null==(e=u.find((t=>t.props.default)))?void 0:e.props.value)??u[0].props.value;if(null!==h&&!m.some((t=>t.value===h)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${h}" but none of its children has the corresponding value. Available values are: ${m.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:k}=(0,ut.U)(),[f,M]=(0,o.useState)(h),D=[],{blockElementScrollPositionUntilNextRender:_}=(0,yt.o5)();if(null!=a){const t=y[a];null!=t&&t!==f&&m.some((e=>e.value===t))&&M(t)}const X=t=>{const e=t.currentTarget,n=D.indexOf(e),o=m[n].value;o!==f&&(_(e),M(o),null!=a&&k(a,String(o)))},w=t=>{var e;let n=null;switch(t.key){case"Enter":X(t);break;case"ArrowRight":{const e=D.indexOf(t.currentTarget)+1;n=D[e]??D[0];break}case"ArrowLeft":{const e=D.indexOf(t.currentTarget)-1;n=D[e]??D[D.length-1];break}}null==(e=n)||e.focus()};return o.createElement("div",{className:(0,s.Z)("tabs-container",kt)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":c},l)},m.map((t=>{let{value:e,label:n,attributes:c}=t;return o.createElement("li",(0,i.Z)({role:"tab",tabIndex:f===e?0:-1,"aria-selected":f===e,key:e,ref:t=>D.push(t),onKeyDown:w,onClick:X},c,{className:(0,s.Z)("tabs__item",ft,null==c?void 0:c.className,{"tabs__item--active":f===e})}),n??e)}))),n?(0,o.cloneElement)(u.filter((t=>t.props.value===f))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},u.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==f})))))}function Dt(t){const e=(0,dt.Z)();return o.createElement(Mt,(0,i.Z)({key:String(e)},t))}const _t="tabItem_OMyP";function Xt(t){let{children:e,hidden:n,className:c}=t;return o.createElement("div",{role:"tabpanel",className:(0,s.Z)(_t,c),hidden:n},e)}function wt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(St,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(St,{reflection:t})))))}function Tt(t){let{group:e,project:n}=t;const c=(0,it.TH)(),r=(0,X.RU)(n),{setTabGroupChoices:p}=(0,ut.U)(),s=c.hash.split("-")[0].slice(1),[a]=(0,ot.mN)(),l=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],c=[],r=[];for(const p of t.children){const t=e[p];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):c.push(t))}if(o.length>0||c.length>0)return{title:t.title,external:o,nested:c,anchors:r}}(t,r,a))).filter((t=>!!t))),[e,r,a]);return(0,o.useEffect)((()=>{if(1===l.length)return;const t=c.hash.split("-")[0].slice(1);for(const n of l)if(n.anchors.includes(t))return void p(e.title,n.title)}),[c.hash,l]),0===l.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h2",id:e.title},e.title),l.length>1?o.createElement(Dt,{groupId:e.title},l.map((t=>o.createElement(Xt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(wt,{group:t}))))):o.createElement(wt,{group:l[0]}))}function Ct(t){var e,n,c,r,p;let{reflection:s}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=s.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(K,{reflection:s})))),o.createElement(lt,{kind:s.kind},o.createElement(J.Z,{comment:s.comment})),o.createElement(tt,{parameters:s.typeParameters}),(null==(c=s.implementedBy)?void 0:c.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,s.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),(null==(r=s.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,s.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),s.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:s.signatures})),null==(p=s.groups)?void 0:p.map((t=>o.createElement(Tt,{group:t,key:t.title,project:s.project}))))}function xt(t){var e;let{reflection:n,headless:c}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!c&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(mt.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(w,{type:n.overwrites}))))}function gt(t){var e,n;let{reflection:c}=t;return o.createElement(o.Fragment,null,c.hasOwnPage?o.createElement("h1",null,c.name):o.createElement(mt.Z,{as:"h3",id:c.anchor},o.createElement("code",null,c.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=c.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(q,{reflection:c})))),o.createElement(J.Z,{comment:c.comment}),c.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:c.inheritedFrom}))))}function Lt(t){var e,n,c;let{reflection:r}=t;const p=(0,X.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement(Y,null,o.createElement(K,{reflection:r})))),o.createElement(J.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(c=r.groups)?void 0:c.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>p[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(St,{key:t.id,reflection:t})))))))}var Zt=n(8128);function bt(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(Zt.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(lt,{kind:n.kind},o.createElement(J.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Tt,{group:t,key:t.title,project:n.project}))))}const vt="cardContainer_ybwo",Nt="cardTitle_Ehd1",Et="cardDescription_b6wr";function At(t){let{reflection:e}=t;const n=(0,X.RU)(e.project),c=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,s.Z)("row")},c.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(y.Z,{href:t.href,className:(0,s.Z)("card padding--lg",vt)},o.createElement("h2",{className:(0,s.Z)("text--truncate",Nt)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,s.Z)("text--truncate",Et)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function St(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case c.W.Project:return At;case c.W.Module:return bt;case c.W.Namespace:case c.W.Enum:case c.W.Class:case c.W.Interface:return Ct;case c.W.Function:case c.W.Accessor:case c.W.Constructor:case c.W.Method:return xt;case c.W.Variable:case c.W.Property:case c.W.EnumMember:return gt;case c.W.CallSignature:case c.W.IndexSignature:case c.W.ConstructorSignature:case c.W.Parameter:case c.W.TypeLiteral:case c.W.TypeParameter:case c.W.GetSignature:case c.W.SetSignature:case c.W.ObjectLiteral:break;case c.W.TypeAlias:return Lt;case c.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},7390:(t,e,n)=>{let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},532:(t,e,n)=>{n.d(e,{Z:()=>i});var o=n(2784),c=n(9741);const r="tooltip_lI6R",p="active_DOSD";var s=n(6277),a=n(8617),l=n(9322);function i(t){let{children:e}=t;const n=(0,c.Z)(),i=(0,a.rG)(),[u,m]=(0,o.useState)(!1),[d,h]=(0,o.useState)(null),y=(0,o.useRef)(),k=(0,o.useRef)(),f=(0,o.useRef)(),M=(0,o.useCallback)((()=>{if(!k.current||!f.current)return;const t=k.current.getBoundingClientRect();let e=window.innerWidth-t.left-496;e<0&&(e=0),f.current.style.right=`${e}px`,f.current.style.top=`${t.bottom}px`}),[]);return(0,o.useEffect)((()=>{if(!n)return;const t=t=>{var e,n,o;if(!t.target.href||null==(e=y.current)||!e.contains(t.target)||null!=(n=f.current)&&n.contains(t.target))return;const c=new URL(t.target.href,document.baseURI);if(c.pathname===window.location.pathname)return;const r=i(c.pathname+c.hash);null!=r&&null!=(o=r.comment)&&o.summary&&(k.current=t.target,m(!0),h(r.comment),M())},e=t=>{t.target===k.current&&m(!1)};return document.addEventListener("mouseenter",t,!0),document.addEventListener("focus",t,!0),document.addEventListener("mouseleave",e,!0),document.addEventListener("blur",e,!0),document.addEventListener("scroll",M),()=>{document.removeEventListener("mouseenter",t,!0),document.removeEventListener("focus",t,!0),document.removeEventListener("mouseleave",e,!0),document.removeEventListener("blur",e,!0),document.removeEventListener("scroll",M)}}),[n]),(0,o.useEffect)((()=>{M()})),o.createElement("div",{ref:y},e,o.createElement("div",{ref:f,className:(0,s.Z)(r,"padding--md margin-horiz--md",u&&p)},d&&o.createElement(l.Z,{comment:d,full:!1})))}},8617:(t,e,n)=>{n.d(e,{Gr:()=>l,RU:()=>p,gs:()=>r,in:()=>s,rG:()=>a});var o=n(2784);const c=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(c.Provider,{value:{lookup:n,urlLookup:r}},e)}function p(t){const{lookup:e}=(0,o.useContext)(c);return e[t]}function s(){const{lookup:t}=(0,o.useContext)(c);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function a(){const{urlLookup:t,lookup:e}=(0,o.useContext)(c);return n=>{var o;const c=t[n];return c?(null==(o=e[c.projectId])?void 0:o[c.id])??null:null}}function l(t){if(t)return t.href}},68:(t,e,n)=>{n.d(e,{Ld:()=>s,Y0:()=>p,s2:()=>a});var o=n(2784),c=n(822);const r=o.createContext(null);function p(t){let{children:e}=t;const n=(0,c.p)(),p=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),c=t.styles.reduce(((t,n)=>{const{languages:o,style:c}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...c}})),t}),o);return c.root=n,c.plain={...n,backgroundColor:null},c}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:p},e)}function s(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function a(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>i,mN:()=>u});var o=n(2784),c=n(1263),r=n(9741);const p="api-filters",s=c.Z.canUseDOM?localStorage.getItem(p):null,a=s?JSON.parse(s):{inherited:!0,private:!1},l=o.createContext([a,()=>{}]);function i(t){let{children:e}=t;const[n,c]=(0,o.useState)(a),s=(0,r.Z)();return o.createElement(l.Provider,{value:[n,t=>{s&&localStorage.setItem(p,JSON.stringify(t)),c(t)}]},e)}function u(){return(0,o.useContext)(l)}function m(t,e){var n,o;const c=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&c)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},6047:(t,e,n)=>{n.d(e,{Z:()=>u});var o=n(7896),c=n(2784),r=n(9055);const p="icon_Fw4I";function s(t){return c.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),c.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(t){return c.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),c.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}function l(t){return c.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),c.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function i(t){return c.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),c.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function u(t){const e=(0,c.useMemo)((()=>{switch(t.type){case"tip":return i;case"caution":return a;case"danger":return l;default:return s}}),[t.type]);return c.createElement(c.Fragment,null,c.createElement(r.Z,(0,o.Z)({icon:c.createElement(e,{className:p})},t)))}},4141:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(7896),c=n(2784),r=n(6277);const p="iconEdit_N_05";function s(t){let{className:e,...n}=t;return c.createElement("svg",(0,o.Z)({fill:"currentColor",width:"24px",height:"24px",viewBox:"0 0 24 24",className:(0,r.Z)(p,e),"aria-hidden":"true"},n),c.createElement("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"}))}},4648:(t,e,n)=>{n.d(e,{Z:()=>r});var o=n(7896),c=n(2784);function r(t){return c.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",style:{width:16,height:16,marginTop:"0.1rem"}},t),c.createElement("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z",fill:"currentColor"}))}}}]);
"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[1316],{2665:(e,a,t)=>{t.d(a,{Z:()=>m});var n=t(2784);const i="container_lQCo",l="small_As57",s="banner_A4QS",r="player_tELG",o="link_BTzN",c="icon_wSGd";var d=t(7896);function g(e){let{width:a=24,height:t=24,...i}=e;return n.createElement("svg",(0,d.Z)({viewBox:"0 0 24 24",width:a,height:t,"aria-hidden":!0},i),n.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",fill:"currentColor"}))}var p=t(9817),u=t(6277);function h(e){let{name:a}=e;const t="https://github.com/motion-canvas/motion-canvas/blob/main/packages/examples/src/scenes/"+a+".tsx";return n.createElement(p.Z,{to:t,className:(0,u.Z)("padding--sm",o)},n.createElement("span",null,"View source code"),n.createElement(g,{className:c}))}function m(e){let{name:a,banner:t,small:o}=e;return n.createElement("div",{className:(0,u.Z)(i,t&&s,o&&l)},n.createElement("motion-canvas-player",{class:r,src:"/examples/"+a+".js",auto:t}),n.createElement(h,{name:a}))}t(1263).Z.canUseDOM&&t.e(5483).then(t.bind(t,5483))},1803:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>g});var n=t(7896),i=(t(2784),t(876)),l=t(2665),s=t(8128);const r={sidebar_position:3},o="Signals",c={unversionedId:"guides/getting-started/signals",id:"guides/getting-started/signals",title:"Signals",description:"Signals represent a value that may change over time.",source:"@site/docs/guides/getting-started/signals.mdx",sourceDirName:"guides/getting-started",slug:"/guides/getting-started/signals",permalink:"/guides/getting-started/signals",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/docs/guides/getting-started/signals.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"guides",previous:{title:"Animation flow",permalink:"/guides/getting-started/flow"},next:{title:"Tweening",permalink:"/guides/getting-started/tweening"}},d={},g=[{value:"Overview",id:"overview",level:2},{value:"Explanation",id:"explanation",level:2},{value:"Laziness",id:"laziness",level:3},{value:"Caching",id:"caching",level:3},{value:"Dependency tracking",id:"dependency-tracking",level:3},{value:"Complex example",id:"complex-example",level:2}],p={toc:g};function u(e){let{components:a,...t}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"signals"},"Signals"),(0,i.kt)("p",null,"Signals represent a value that may change over time.\nThey can be used to define dependencies between the state of the animation.\nThis way, when a value changes, all other values that depend on it get automatically updated."),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Signals for primitive types are created using the ",(0,i.kt)("a",{parentName:"p",href:"/api/core/signals#createSignal"},(0,i.kt)("inlineCode",{parentName:"a"},"createSignal()"))," function, where the first argument specifies their initial value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {createSignal} from '@motion-canvas/core/lib/signals';\n\nconst signal = createSignal(0);\n")),(0,i.kt)("p",null,"Additionally, each complex type has a static ",(0,i.kt)("inlineCode",{parentName:"p"},"createSignal()")," method that can be used to create a signal for said type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import {Vector2} from '@motion-canvas/core/lib/types';\n\nconst signal = Vector2.createSignal(Vector2.up);\n")),(0,i.kt)("p",null,"Properties of every node are also represented by signals:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const circle = <Circle />;\n\nconst signal = circle.fill;\n")),(0,i.kt)("p",null,"Once created, signals can be invoked to perform one of the three possible actions\n(The action is chosen based on the number of arguments):"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"retrieve the value:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const value = signal();\n"))),(0,i.kt)("li",{parentName:"ol"},"update the value:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"signal(3);\n"))),(0,i.kt)("li",{parentName:"ol"},"create a ",(0,i.kt)("a",{parentName:"li",href:"/guides/getting-started/tweening"},"tween")," for the value:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield * signal(2, 0.3);\n")))),(0,i.kt)("p",null,"Instead of the actual value, a signal can be provided with a function that computes the value dynamically. Consider the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const radius = createSignal(1);\nconst area = createSignal(() => Math.PI * radius() * radius());\n\nconsole.log(area()); // 3.141592653589793\nradius(2);\nconsole.log(area()); // 12.566370614359172\n")),(0,i.kt)("p",null,"Here, the ",(0,i.kt)("inlineCode",{parentName:"p"},"area")," signal uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"radius")," signal to compute its value."),(0,i.kt)("h2",{id:"explanation"},"Explanation"),(0,i.kt)("p",null,"To better understand how signals work, let's modify the example from before to see when exactly the area is calculated:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const radius = createSignal(1);\nconst area = createSignal(() => {\n  console.log('area recalculated!');\n  return Math.PI * radius() * radius();\n});\n\narea(); // area recalculated!\narea();\nradius(2);\narea(); // area recalculated!\nradius(3);\nradius(4);\narea(); // area recalculated!\n")),(0,i.kt)("p",null,"This demonstrates three important aspects of signals:"),(0,i.kt)("h3",{id:"laziness"},"Laziness"),(0,i.kt)("p",null,"Signals are only calculated when their value is requested. The first ",(0,i.kt)("inlineCode",{parentName:"p"},'"area recalculated!"')," message is logged to console only after ",(0,i.kt)("inlineCode",{parentName:"p"},"area()")," is called."),(0,i.kt)("h3",{id:"caching"},"Caching"),(0,i.kt)("p",null,"Once the signal is calculated, its value is saved and then returned during subsequent calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"area()"),". That's why nothing is logged to the console during the second call. This aspect of signals makes them perfect for caching computationally heavy operations. In fact, Motion Canvas uses signals internally to cache things such as matrices."),(0,i.kt)("h3",{id:"dependency-tracking"},"Dependency tracking"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"area")," signal keeps track of other signals it depends on. When we change the ",(0,i.kt)("inlineCode",{parentName:"p"},"radius")," signal, the ",(0,i.kt)("inlineCode",{parentName:"p"},"area")," signal is notified about that. But it doesn't get recalculated immediately - laziness is still at play. We can modify the radius however many times we want, but the ",(0,i.kt)("inlineCode",{parentName:"p"},"area")," will be recalculated only once its value is requested again by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"area()"),"."),(0,i.kt)("h2",{id:"complex-example"},"Complex example"),(0,i.kt)("p",null,"We can use the fact that properties of nodes are represented by signals to construct scenes that automatically update when the data changes. Following the previous example, let's create a visualisation for the area of the circle:"),(0,i.kt)(l.Z,{small:!0,name:"node-signal",mdxType:"AnimationPlayer"}),(0,i.kt)("p",null,"Below you'll find the code used to create this animation. We highlighted all the places where signals are used:"),(0,i.kt)(s.Z,{language:"tsx",mdxType:"CodeBlock"},"import {makeScene2D} from '@motion-canvas/2d/lib/scenes';\nimport {Circle, Text, Line} from '@motion-canvas/2d/lib/components';\nimport {createSignal} from '@motion-canvas/core/lib/signals';\nimport {Vector2} from '@motion-canvas/core/lib/types';\nimport {waitFor} from '@motion-canvas/core/lib/flow';\n\nexport default makeScene2D(function* (view) {\n  // highlight-start\n  const radius = createSignal(3);\n  const area = createSignal(() => Math.PI * radius() * radius());\n  // highlight-end\n\n  const scale = 100;\n  const textStyle = {\n    fontWeight: 700,\n    fontSize: 56,\n    offsetY: -1,\n    padding: 20,\n    cache: true,\n  };\n\n  view.add(\n    <>\n      <Circle\n        // highlight-start\n        width={() => radius() * scale * 2}\n        height={() => radius() * scale * 2}\n        // highlight-end\n        fill={'#e13238'}\n      />\n      <Line\n        points={[\n          Vector2.zero,\n          // highlight-next-line\n          () => Vector2.right.scale(radius() * scale),\n        ]}\n        lineDash={[20, 20]}\n        startArrow\n        endArrow\n        endOffset={8}\n        lineWidth={8}\n        stroke={'#242424'}\n      />\n      <Text\n        // highlight-start\n        text={() => `r = ${radius().toFixed(2)}`}\n        x={() => (radius() * scale) / 2}\n        // highlight-end\n        fill={'#242424'}\n        {...textStyle}\n      />\n      <Text\n        // highlight-start\n        text={() => `A = ${area().toFixed(2)}`}\n        y={() => radius() * scale}\n        // highlight-end\n        fill={'#e13238'}\n        {...textStyle}\n      />\n    </>,\n  );\n\n  yield* radius(4, 2).to(3, 2);\n  yield* waitFor(1);\n});\n"),(0,i.kt)("p",null,"With this setup, all we need to do is animate the ",(0,i.kt)("inlineCode",{parentName:"p"},"radius")," signal, and the rest of the scene will adjust accordingly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"yield * radius(4, 2).to(3, 2);\n")))}u.isMDXComponent=!0}}]);
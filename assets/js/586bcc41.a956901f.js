"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[3239],{4415:(t,n,e)=>{e.r(n),e.d(n,{default:()=>d});var o=e(2784),p=e(2104),c=e(9072),r=e(6183),s=e(1836),a=e(8617),i=e(68),l=e(7708),u=e(532),m=e(7390);function d(t){var n,e,d;let{route:h}=t;const k=(0,a.RU)(h.projectId),y=k[h.reflectionId],[f]=(0,l.mN)(),M=(0,o.useMemo)((()=>{const t=[];if(!y.groups||y.kind===m.W.Project)return t;for(const n of y.groups)if(t.push({value:n.title,id:n.title,level:2}),n.children)for(const e of n.children){const n=k[e];n&&!n.hasOwnPage&&(0,l.It)(f,n)&&t.push({value:`<code>${n.name}</code>`,id:n.anchor,level:3})}return t}),[y,f]);return o.createElement(r.b,{content:{frontMatter:{},metadata:{id:y.docId,unversionedId:y.docId,version:"current",title:y.name,description:null==(n=y.comment)?void 0:n.summaryText,slug:y.url,permalink:y.url,editUrl:(null==(e=y.sources)||null==(d=e[0])?void 0:d.url)??void 0,draft:!1,tags:[],frontMatter:{},next:y.next,previous:y.previous},toc:M,assets:{}}},o.createElement(i.Y0,null,o.createElement(p.Z,null),o.createElement(u.Z,null,o.createElement(c.Z,null,o.createElement(s.Z,{reflection:y})))))}},5728:(t,n,e)=>{e.d(n,{Z:()=>p3});var o={};e.r(o),e.d(o,{content_0_0:()=>a,content_0_10:()=>M,content_0_100:()=>tn,content_0_102:()=>en,content_0_104:()=>pn,content_0_106:()=>rn,content_0_108:()=>an,content_0_110:()=>un,content_0_112:()=>dn,content_0_114:()=>kn,content_0_116:()=>fn,content_0_118:()=>wn,content_0_12:()=>D,content_0_120:()=>_n,content_0_122:()=>gn,content_0_124:()=>Cn,content_0_126:()=>Ln,content_0_128:()=>vn,content_0_130:()=>Nn,content_0_132:()=>An,content_0_134:()=>zn,content_0_136:()=>In,content_0_138:()=>Pn,content_0_14:()=>X,content_0_140:()=>Fn,content_0_142:()=>jn,content_0_144:()=>qn,content_0_146:()=>On,content_0_148:()=>Hn,content_0_150:()=>Kn,content_0_152:()=>Qn,content_0_154:()=>ne,content_0_156:()=>oe,content_0_158:()=>ce,content_0_16:()=>x,content_0_160:()=>se,content_0_162:()=>ie,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>ke,content_0_170:()=>fe,content_0_172:()=>we,content_0_174:()=>_e,content_0_176:()=>ge,content_0_178:()=>Ce,content_0_18:()=>T,content_0_180:()=>Le,content_0_182:()=>ve,content_0_184:()=>Ne,content_0_186:()=>Ae,content_0_188:()=>ze,content_0_190:()=>Ie,content_0_192:()=>Pe,content_0_194:()=>Fe,content_0_196:()=>je,content_0_198:()=>qe,content_0_2:()=>l,content_0_20:()=>Z,content_0_200:()=>Oe,content_0_202:()=>He,content_0_204:()=>Ke,content_0_206:()=>Qe,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>co,content_0_214:()=>so,content_0_216:()=>io,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>yo,content_0_224:()=>Mo,content_0_226:()=>Do,content_0_228:()=>Xo,content_0_230:()=>xo,content_0_232:()=>To,content_0_234:()=>Zo,content_0_236:()=>bo,content_0_238:()=>Eo,content_0_24:()=>E,content_0_240:()=>Ro,content_0_242:()=>So,content_0_244:()=>Wo,content_0_246:()=>Go,content_0_248:()=>Uo,content_0_250:()=>Vo,content_0_252:()=>Bo,content_0_254:()=>$o,content_0_256:()=>Yo,content_0_258:()=>Jo,content_0_26:()=>R,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>rp,content_0_268:()=>ap,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>yp,content_0_278:()=>Mp,content_0_28:()=>S,content_0_280:()=>Dp,content_0_282:()=>Xp,content_0_284:()=>xp,content_0_286:()=>Tp,content_0_288:()=>Zp,content_0_290:()=>bp,content_0_292:()=>Ep,content_0_294:()=>Rp,content_0_296:()=>Sp,content_0_298:()=>Wp,content_0_30:()=>W,content_0_300:()=>Gp,content_0_302:()=>Up,content_0_304:()=>Vp,content_0_306:()=>Bp,content_0_308:()=>$p,content_0_310:()=>Yp,content_0_312:()=>Jp,content_0_314:()=>tc,content_0_316:()=>ec,content_0_318:()=>pc,content_0_32:()=>G,content_0_320:()=>rc,content_0_322:()=>ac,content_0_324:()=>lc,content_0_326:()=>mc,content_0_328:()=>hc,content_0_330:()=>yc,content_0_332:()=>Mc,content_0_334:()=>Dc,content_0_336:()=>Xc,content_0_338:()=>xc,content_0_34:()=>U,content_0_340:()=>Tc,content_0_342:()=>Zc,content_0_344:()=>bc,content_0_346:()=>Ec,content_0_348:()=>Rc,content_0_350:()=>Sc,content_0_352:()=>Wc,content_0_354:()=>Gc,content_0_356:()=>Uc,content_0_358:()=>Vc,content_0_36:()=>V,content_0_360:()=>Bc,content_0_362:()=>$c,content_0_364:()=>Yc,content_0_366:()=>Jc,content_0_368:()=>tr,content_0_370:()=>er,content_0_372:()=>pr,content_0_374:()=>rr,content_0_376:()=>ar,content_0_378:()=>lr,content_0_38:()=>B,content_0_380:()=>mr,content_0_382:()=>hr,content_0_384:()=>yr,content_0_386:()=>Mr,content_0_388:()=>Dr,content_0_390:()=>Xr,content_0_392:()=>xr,content_0_394:()=>Tr,content_0_396:()=>Zr,content_0_398:()=>br,content_0_4:()=>m,content_0_40:()=>$,content_0_400:()=>Er,content_0_402:()=>Rr,content_0_404:()=>Sr,content_0_406:()=>Wr,content_0_408:()=>Gr,content_0_410:()=>Ur,content_0_412:()=>Vr,content_0_414:()=>Br,content_0_416:()=>$r,content_0_418:()=>Yr,content_0_42:()=>Y,content_0_420:()=>Jr,content_0_422:()=>ts,content_0_424:()=>es,content_0_426:()=>ps,content_0_428:()=>rs,content_0_430:()=>as,content_0_432:()=>ls,content_0_434:()=>ms,content_0_436:()=>hs,content_0_438:()=>ys,content_0_44:()=>J,content_0_440:()=>Ms,content_0_442:()=>Ds,content_0_444:()=>Xs,content_0_446:()=>xs,content_0_448:()=>Ts,content_0_450:()=>Zs,content_0_452:()=>bs,content_0_454:()=>Es,content_0_456:()=>Rs,content_0_458:()=>Ss,content_0_46:()=>tt,content_0_460:()=>Ws,content_0_462:()=>Gs,content_0_464:()=>Us,content_0_466:()=>Vs,content_0_468:()=>Bs,content_0_470:()=>$s,content_0_472:()=>Ys,content_0_474:()=>Js,content_0_476:()=>ta,content_0_478:()=>ea,content_0_48:()=>et,content_0_480:()=>pa,content_0_482:()=>ra,content_0_484:()=>aa,content_0_486:()=>la,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>ya,content_0_494:()=>Ma,content_0_496:()=>Da,content_0_498:()=>Xa,content_0_50:()=>pt,content_0_500:()=>xa,content_0_502:()=>Ta,content_0_504:()=>Za,content_0_506:()=>ba,content_0_508:()=>Ea,content_0_510:()=>Ra,content_0_512:()=>Sa,content_0_514:()=>Wa,content_0_516:()=>Ga,content_0_518:()=>Ua,content_0_52:()=>rt,content_0_520:()=>Va,content_0_522:()=>Ba,content_0_524:()=>$a,content_0_526:()=>Ya,content_0_528:()=>Ja,content_0_530:()=>ti,content_0_532:()=>ei,content_0_534:()=>pi,content_0_536:()=>ri,content_0_538:()=>ai,content_0_54:()=>at,content_0_540:()=>li,content_0_542:()=>mi,content_0_544:()=>hi,content_0_546:()=>yi,content_0_548:()=>Mi,content_0_550:()=>Di,content_0_552:()=>Xi,content_0_554:()=>xi,content_0_556:()=>Ti,content_0_558:()=>Zi,content_0_56:()=>lt,content_0_560:()=>bi,content_0_562:()=>Ei,content_0_564:()=>Ri,content_0_566:()=>Si,content_0_568:()=>Wi,content_0_570:()=>Gi,content_0_572:()=>Ui,content_0_574:()=>Vi,content_0_576:()=>Bi,content_0_578:()=>$i,content_0_58:()=>mt,content_0_580:()=>Yi,content_0_582:()=>Ji,content_0_584:()=>tl,content_0_586:()=>el,content_0_588:()=>pl,content_0_590:()=>rl,content_0_592:()=>al,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>yl,content_0_602:()=>Ml,content_0_604:()=>Dl,content_0_606:()=>Xl,content_0_608:()=>xl,content_0_610:()=>Tl,content_0_612:()=>Zl,content_0_614:()=>bl,content_0_616:()=>El,content_0_618:()=>Rl,content_0_62:()=>yt,content_0_620:()=>Sl,content_0_622:()=>Wl,content_0_624:()=>Gl,content_0_626:()=>Ul,content_0_628:()=>Vl,content_0_630:()=>Bl,content_0_632:()=>$l,content_0_634:()=>Yl,content_0_636:()=>Jl,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>ru,content_0_646:()=>au,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>yu,content_0_656:()=>Mu,content_0_658:()=>Du,content_0_66:()=>Dt,content_0_660:()=>Xu,content_0_662:()=>xu,content_0_664:()=>Tu,content_0_666:()=>Zu,content_0_668:()=>bu,content_0_670:()=>Eu,content_0_672:()=>Ru,content_0_674:()=>Su,content_0_676:()=>Wu,content_0_678:()=>Gu,content_0_68:()=>Xt,content_0_680:()=>Uu,content_0_682:()=>Vu,content_0_684:()=>Bu,content_0_686:()=>$u,content_0_688:()=>Yu,content_0_690:()=>Ju,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>rm,content_0_70:()=>xt,content_0_700:()=>am,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>ym,content_0_710:()=>Mm,content_0_712:()=>Dm,content_0_714:()=>Xm,content_0_716:()=>xm,content_0_718:()=>Tm,content_0_72:()=>Tt,content_0_720:()=>Zm,content_0_722:()=>bm,content_0_724:()=>Em,content_0_726:()=>Rm,content_0_728:()=>Sm,content_0_730:()=>Wm,content_0_732:()=>Gm,content_0_734:()=>Um,content_0_736:()=>Vm,content_0_738:()=>Bm,content_0_74:()=>Zt,content_0_740:()=>$m,content_0_742:()=>Ym,content_0_744:()=>Jm,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>rd,content_0_754:()=>ad,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>yd,content_0_764:()=>Md,content_0_766:()=>Dd,content_0_768:()=>Xd,content_0_770:()=>xd,content_0_772:()=>Td,content_0_774:()=>Zd,content_0_776:()=>bd,content_0_778:()=>Ed,content_0_78:()=>Et,content_0_780:()=>Rd,content_0_782:()=>Sd,content_0_784:()=>Wd,content_0_786:()=>Gd,content_0_788:()=>Ud,content_0_790:()=>Vd,content_0_792:()=>Bd,content_0_794:()=>$d,content_0_796:()=>Yd,content_0_798:()=>Jd,content_0_8:()=>y,content_0_80:()=>Rt,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>rh,content_0_808:()=>ah,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>yh,content_0_818:()=>Mh,content_0_82:()=>St,content_0_820:()=>Dh,content_0_822:()=>Xh,content_0_824:()=>xh,content_0_826:()=>Th,content_0_828:()=>Zh,content_0_830:()=>bh,content_0_832:()=>Eh,content_0_834:()=>Rh,content_0_836:()=>Sh,content_0_838:()=>Wh,content_0_84:()=>Wt,content_0_840:()=>Gh,content_0_842:()=>Uh,content_0_844:()=>Vh,content_0_846:()=>Bh,content_0_848:()=>$h,content_0_850:()=>Yh,content_0_852:()=>Jh,content_0_854:()=>tk,content_0_856:()=>ek,content_0_858:()=>pk,content_0_86:()=>Gt,content_0_860:()=>rk,content_0_862:()=>ak,content_0_864:()=>lk,content_0_866:()=>mk,content_0_868:()=>hk,content_0_870:()=>yk,content_0_872:()=>Mk,content_0_874:()=>Dk,content_0_876:()=>Xk,content_0_878:()=>xk,content_0_88:()=>Ut,content_0_880:()=>Tk,content_0_882:()=>Zk,content_0_884:()=>bk,content_0_886:()=>Ek,content_0_888:()=>Rk,content_0_890:()=>Sk,content_0_892:()=>Wk,content_0_894:()=>Gk,content_0_896:()=>Uk,content_0_898:()=>Vk,content_0_90:()=>Vt,content_0_900:()=>Bk,content_0_902:()=>$k,content_0_904:()=>Yk,content_0_906:()=>Jk,content_0_908:()=>ty,content_0_910:()=>ey,content_0_912:()=>py,content_0_914:()=>ry,content_0_916:()=>ay,content_0_918:()=>ly,content_0_92:()=>Bt,content_0_920:()=>my,content_0_922:()=>hy,content_0_924:()=>yy,content_0_926:()=>My,content_0_928:()=>Dy,content_0_930:()=>Xy,content_0_932:()=>xy,content_0_934:()=>Ty,content_0_936:()=>Zy,content_0_938:()=>by,content_0_94:()=>$t,content_0_940:()=>Ey,content_0_942:()=>Ry,content_0_944:()=>Sy,content_0_946:()=>Wy,content_0_96:()=>Yt,content_0_98:()=>Jt,content_2272_0:()=>Gy,content_2272_10:()=>Yy,content_2272_100:()=>AM,content_2272_1000:()=>kz,content_2272_1002:()=>fz,content_2272_1004:()=>wz,content_2272_1006:()=>_z,content_2272_1008:()=>gz,content_2272_1010:()=>Cz,content_2272_1012:()=>Lz,content_2272_1014:()=>vz,content_2272_1016:()=>Nz,content_2272_1018:()=>Az,content_2272_102:()=>zM,content_2272_1020:()=>zz,content_2272_1022:()=>Iz,content_2272_1024:()=>Pz,content_2272_1026:()=>Fz,content_2272_1028:()=>jz,content_2272_1030:()=>qz,content_2272_1032:()=>Oz,content_2272_1034:()=>Hz,content_2272_1036:()=>Kz,content_2272_1038:()=>Qz,content_2272_104:()=>IM,content_2272_1040:()=>nS,content_2272_1042:()=>oS,content_2272_1044:()=>cS,content_2272_1046:()=>sS,content_2272_1048:()=>iS,content_2272_1050:()=>uS,content_2272_1052:()=>dS,content_2272_1054:()=>kS,content_2272_1056:()=>fS,content_2272_1058:()=>wS,content_2272_106:()=>PM,content_2272_1060:()=>_S,content_2272_1062:()=>gS,content_2272_1064:()=>CS,content_2272_1066:()=>LS,content_2272_1068:()=>vS,content_2272_1070:()=>NS,content_2272_1072:()=>AS,content_2272_1074:()=>zS,content_2272_1076:()=>IS,content_2272_1078:()=>PS,content_2272_108:()=>FM,content_2272_1080:()=>FS,content_2272_1082:()=>jS,content_2272_1084:()=>qS,content_2272_1086:()=>OS,content_2272_1088:()=>HS,content_2272_1090:()=>KS,content_2272_1092:()=>QS,content_2272_1094:()=>nI,content_2272_1096:()=>oI,content_2272_1098:()=>cI,content_2272_110:()=>jM,content_2272_1100:()=>sI,content_2272_1102:()=>iI,content_2272_1104:()=>uI,content_2272_1106:()=>dI,content_2272_1108:()=>kI,content_2272_1110:()=>fI,content_2272_1112:()=>wI,content_2272_1114:()=>_I,content_2272_1116:()=>gI,content_2272_1118:()=>CI,content_2272_112:()=>qM,content_2272_1120:()=>LI,content_2272_1122:()=>vI,content_2272_1124:()=>NI,content_2272_1126:()=>AI,content_2272_1128:()=>zI,content_2272_1130:()=>II,content_2272_1132:()=>PI,content_2272_1134:()=>FI,content_2272_1136:()=>jI,content_2272_1138:()=>qI,content_2272_114:()=>OM,content_2272_1140:()=>OI,content_2272_1142:()=>HI,content_2272_1144:()=>KI,content_2272_1146:()=>QI,content_2272_1148:()=>nW,content_2272_1150:()=>oW,content_2272_1152:()=>cW,content_2272_1154:()=>sW,content_2272_1156:()=>iW,content_2272_1158:()=>uW,content_2272_116:()=>HM,content_2272_1160:()=>dW,content_2272_1162:()=>kW,content_2272_1164:()=>fW,content_2272_1166:()=>wW,content_2272_1168:()=>_W,content_2272_1170:()=>gW,content_2272_1172:()=>CW,content_2272_1174:()=>LW,content_2272_1176:()=>vW,content_2272_1178:()=>NW,content_2272_118:()=>KM,content_2272_1180:()=>AW,content_2272_1182:()=>zW,content_2272_1184:()=>IW,content_2272_1186:()=>PW,content_2272_1188:()=>FW,content_2272_1190:()=>jW,content_2272_1192:()=>qW,content_2272_1194:()=>OW,content_2272_1196:()=>HW,content_2272_1198:()=>KW,content_2272_12:()=>Jy,content_2272_120:()=>QM,content_2272_1200:()=>QW,content_2272_1202:()=>nP,content_2272_1204:()=>oP,content_2272_1206:()=>cP,content_2272_1208:()=>sP,content_2272_1210:()=>iP,content_2272_1212:()=>uP,content_2272_1214:()=>dP,content_2272_1216:()=>kP,content_2272_1218:()=>fP,content_2272_122:()=>nw,content_2272_1220:()=>wP,content_2272_1222:()=>_P,content_2272_1224:()=>gP,content_2272_1226:()=>CP,content_2272_1228:()=>LP,content_2272_1230:()=>vP,content_2272_1232:()=>NP,content_2272_1234:()=>AP,content_2272_1236:()=>zP,content_2272_1238:()=>IP,content_2272_124:()=>ow,content_2272_1240:()=>PP,content_2272_1242:()=>FP,content_2272_1244:()=>jP,content_2272_1246:()=>qP,content_2272_1248:()=>OP,content_2272_1250:()=>HP,content_2272_1252:()=>KP,content_2272_1254:()=>QP,content_2272_1256:()=>nG,content_2272_1258:()=>oG,content_2272_126:()=>cw,content_2272_1260:()=>cG,content_2272_1262:()=>sG,content_2272_1264:()=>iG,content_2272_1266:()=>uG,content_2272_1268:()=>dG,content_2272_1270:()=>kG,content_2272_1272:()=>fG,content_2272_1274:()=>wG,content_2272_1276:()=>_G,content_2272_1278:()=>gG,content_2272_128:()=>sw,content_2272_1280:()=>CG,content_2272_1282:()=>LG,content_2272_1284:()=>vG,content_2272_1286:()=>NG,content_2272_1288:()=>AG,content_2272_1290:()=>zG,content_2272_1292:()=>IG,content_2272_1294:()=>PG,content_2272_1296:()=>FG,content_2272_1298:()=>jG,content_2272_130:()=>iw,content_2272_1300:()=>qG,content_2272_1302:()=>OG,content_2272_1304:()=>HG,content_2272_1306:()=>KG,content_2272_1308:()=>QG,content_2272_1310:()=>nF,content_2272_1312:()=>oF,content_2272_1314:()=>cF,content_2272_1316:()=>sF,content_2272_1318:()=>iF,content_2272_132:()=>uw,content_2272_1320:()=>uF,content_2272_1322:()=>dF,content_2272_1324:()=>kF,content_2272_1326:()=>fF,content_2272_1328:()=>wF,content_2272_1330:()=>_F,content_2272_1332:()=>gF,content_2272_1334:()=>CF,content_2272_1336:()=>LF,content_2272_1338:()=>vF,content_2272_134:()=>dw,content_2272_1340:()=>NF,content_2272_1342:()=>AF,content_2272_1344:()=>zF,content_2272_1346:()=>IF,content_2272_1348:()=>PF,content_2272_1350:()=>FF,content_2272_1352:()=>jF,content_2272_1354:()=>qF,content_2272_1356:()=>OF,content_2272_1358:()=>HF,content_2272_136:()=>kw,content_2272_1360:()=>KF,content_2272_1362:()=>QF,content_2272_1364:()=>nU,content_2272_1366:()=>oU,content_2272_1368:()=>cU,content_2272_1370:()=>sU,content_2272_1372:()=>iU,content_2272_1374:()=>uU,content_2272_1376:()=>dU,content_2272_1378:()=>kU,content_2272_138:()=>fw,content_2272_1380:()=>fU,content_2272_1382:()=>wU,content_2272_1384:()=>_U,content_2272_1386:()=>gU,content_2272_1388:()=>CU,content_2272_1390:()=>LU,content_2272_1392:()=>vU,content_2272_1394:()=>NU,content_2272_1396:()=>AU,content_2272_1398:()=>zU,content_2272_14:()=>tf,content_2272_140:()=>ww,content_2272_1400:()=>IU,content_2272_1402:()=>PU,content_2272_1404:()=>FU,content_2272_1406:()=>jU,content_2272_1408:()=>qU,content_2272_1410:()=>OU,content_2272_1412:()=>HU,content_2272_1414:()=>KU,content_2272_1416:()=>QU,content_2272_1418:()=>nj,content_2272_142:()=>_w,content_2272_1420:()=>oj,content_2272_1422:()=>cj,content_2272_1424:()=>sj,content_2272_1426:()=>ij,content_2272_1428:()=>uj,content_2272_1430:()=>dj,content_2272_1432:()=>kj,content_2272_1434:()=>fj,content_2272_1436:()=>wj,content_2272_1438:()=>_j,content_2272_144:()=>gw,content_2272_1440:()=>gj,content_2272_1442:()=>Cj,content_2272_1444:()=>Lj,content_2272_1446:()=>vj,content_2272_1448:()=>Nj,content_2272_1450:()=>Aj,content_2272_1452:()=>zj,content_2272_1454:()=>Ij,content_2272_1456:()=>Pj,content_2272_1458:()=>Fj,content_2272_146:()=>Cw,content_2272_1460:()=>jj,content_2272_1462:()=>qj,content_2272_1464:()=>Oj,content_2272_1466:()=>Hj,content_2272_1468:()=>Kj,content_2272_1470:()=>Qj,content_2272_1472:()=>nV,content_2272_1474:()=>oV,content_2272_1476:()=>cV,content_2272_1478:()=>sV,content_2272_148:()=>Lw,content_2272_1480:()=>iV,content_2272_1482:()=>uV,content_2272_1484:()=>dV,content_2272_1486:()=>kV,content_2272_1488:()=>fV,content_2272_1490:()=>wV,content_2272_1492:()=>_V,content_2272_1494:()=>gV,content_2272_1496:()=>CV,content_2272_1498:()=>LV,content_2272_150:()=>vw,content_2272_1500:()=>vV,content_2272_1502:()=>NV,content_2272_1504:()=>AV,content_2272_1506:()=>zV,content_2272_1508:()=>IV,content_2272_1510:()=>PV,content_2272_1512:()=>FV,content_2272_1514:()=>jV,content_2272_1516:()=>qV,content_2272_1518:()=>OV,content_2272_152:()=>Nw,content_2272_1520:()=>HV,content_2272_1522:()=>KV,content_2272_1524:()=>QV,content_2272_1526:()=>nq,content_2272_1528:()=>oq,content_2272_1530:()=>cq,content_2272_1532:()=>sq,content_2272_1534:()=>iq,content_2272_1536:()=>uq,content_2272_1538:()=>dq,content_2272_154:()=>Aw,content_2272_1540:()=>kq,content_2272_1542:()=>fq,content_2272_1544:()=>wq,content_2272_1546:()=>_q,content_2272_1548:()=>gq,content_2272_1550:()=>Cq,content_2272_1552:()=>Lq,content_2272_1554:()=>vq,content_2272_1556:()=>Nq,content_2272_1558:()=>Aq,content_2272_156:()=>zw,content_2272_1560:()=>zq,content_2272_1562:()=>Iq,content_2272_1564:()=>Pq,content_2272_1566:()=>Fq,content_2272_1568:()=>jq,content_2272_1570:()=>qq,content_2272_1572:()=>Oq,content_2272_1574:()=>Hq,content_2272_1576:()=>Kq,content_2272_1578:()=>Qq,content_2272_158:()=>Iw,content_2272_1580:()=>nB,content_2272_1582:()=>oB,content_2272_1584:()=>cB,content_2272_1586:()=>sB,content_2272_1588:()=>iB,content_2272_1590:()=>uB,content_2272_1592:()=>dB,content_2272_1594:()=>kB,content_2272_1596:()=>fB,content_2272_1598:()=>wB,content_2272_16:()=>ef,content_2272_160:()=>Pw,content_2272_1600:()=>_B,content_2272_1602:()=>gB,content_2272_1604:()=>CB,content_2272_1606:()=>LB,content_2272_1608:()=>vB,content_2272_1610:()=>NB,content_2272_1612:()=>AB,content_2272_1614:()=>zB,content_2272_1616:()=>IB,content_2272_1618:()=>PB,content_2272_162:()=>Fw,content_2272_1620:()=>FB,content_2272_1622:()=>jB,content_2272_1624:()=>qB,content_2272_1626:()=>OB,content_2272_1628:()=>HB,content_2272_1630:()=>KB,content_2272_1632:()=>QB,content_2272_1634:()=>nO,content_2272_1636:()=>oO,content_2272_1638:()=>cO,content_2272_164:()=>jw,content_2272_1640:()=>sO,content_2272_1642:()=>iO,content_2272_1644:()=>uO,content_2272_1646:()=>dO,content_2272_1648:()=>kO,content_2272_1650:()=>fO,content_2272_1652:()=>wO,content_2272_1654:()=>_O,content_2272_1656:()=>gO,content_2272_1658:()=>CO,content_2272_166:()=>qw,content_2272_1660:()=>LO,content_2272_1662:()=>vO,content_2272_1664:()=>NO,content_2272_1666:()=>AO,content_2272_1668:()=>zO,content_2272_1670:()=>IO,content_2272_1672:()=>PO,content_2272_1674:()=>FO,content_2272_1676:()=>jO,content_2272_1678:()=>qO,content_2272_168:()=>Ow,content_2272_1680:()=>OO,content_2272_1682:()=>HO,content_2272_1684:()=>KO,content_2272_1686:()=>QO,content_2272_1688:()=>n$,content_2272_1690:()=>o$,content_2272_1692:()=>c$,content_2272_1694:()=>s$,content_2272_1696:()=>i$,content_2272_1698:()=>u$,content_2272_170:()=>Hw,content_2272_1700:()=>d$,content_2272_1702:()=>k$,content_2272_1704:()=>f$,content_2272_1706:()=>w$,content_2272_1708:()=>_$,content_2272_1710:()=>g$,content_2272_1712:()=>C$,content_2272_1714:()=>L$,content_2272_1716:()=>v$,content_2272_1718:()=>N$,content_2272_172:()=>Kw,content_2272_1720:()=>A$,content_2272_1722:()=>z$,content_2272_1724:()=>I$,content_2272_1726:()=>P$,content_2272_1728:()=>F$,content_2272_1730:()=>j$,content_2272_1732:()=>q$,content_2272_1734:()=>O$,content_2272_1736:()=>H$,content_2272_1738:()=>K$,content_2272_174:()=>Qw,content_2272_1740:()=>Q$,content_2272_1742:()=>nH,content_2272_1744:()=>oH,content_2272_1746:()=>cH,content_2272_1748:()=>sH,content_2272_1750:()=>iH,content_2272_1752:()=>uH,content_2272_1754:()=>dH,content_2272_1756:()=>kH,content_2272_1758:()=>fH,content_2272_176:()=>nD,content_2272_1760:()=>wH,content_2272_1762:()=>_H,content_2272_1764:()=>gH,content_2272_1766:()=>CH,content_2272_1768:()=>LH,content_2272_1770:()=>vH,content_2272_1772:()=>NH,content_2272_1774:()=>AH,content_2272_1776:()=>zH,content_2272_1778:()=>IH,content_2272_178:()=>oD,content_2272_1780:()=>PH,content_2272_1782:()=>FH,content_2272_1784:()=>jH,content_2272_1786:()=>qH,content_2272_1788:()=>OH,content_2272_1790:()=>HH,content_2272_1792:()=>KH,content_2272_1794:()=>QH,content_2272_1796:()=>nY,content_2272_1798:()=>oY,content_2272_18:()=>pf,content_2272_180:()=>cD,content_2272_1800:()=>cY,content_2272_1802:()=>sY,content_2272_1804:()=>iY,content_2272_1806:()=>uY,content_2272_1808:()=>dY,content_2272_1810:()=>kY,content_2272_1812:()=>fY,content_2272_1814:()=>wY,content_2272_1816:()=>_Y,content_2272_1818:()=>gY,content_2272_182:()=>sD,content_2272_1820:()=>CY,content_2272_1822:()=>LY,content_2272_1824:()=>vY,content_2272_1826:()=>NY,content_2272_1828:()=>AY,content_2272_1830:()=>zY,content_2272_1832:()=>IY,content_2272_1834:()=>PY,content_2272_1836:()=>FY,content_2272_1838:()=>jY,content_2272_184:()=>iD,content_2272_1840:()=>qY,content_2272_1842:()=>OY,content_2272_1844:()=>HY,content_2272_1846:()=>KY,content_2272_1848:()=>QY,content_2272_1850:()=>nK,content_2272_1852:()=>oK,content_2272_1854:()=>cK,content_2272_1856:()=>sK,content_2272_1858:()=>iK,content_2272_186:()=>uD,content_2272_1860:()=>uK,content_2272_1862:()=>dK,content_2272_1864:()=>kK,content_2272_1866:()=>fK,content_2272_1868:()=>wK,content_2272_1870:()=>_K,content_2272_1872:()=>gK,content_2272_1874:()=>CK,content_2272_1876:()=>LK,content_2272_1878:()=>vK,content_2272_188:()=>dD,content_2272_1880:()=>NK,content_2272_1882:()=>AK,content_2272_1884:()=>zK,content_2272_1886:()=>IK,content_2272_1888:()=>PK,content_2272_1890:()=>FK,content_2272_1892:()=>jK,content_2272_1894:()=>qK,content_2272_1896:()=>OK,content_2272_1898:()=>HK,content_2272_190:()=>kD,content_2272_1900:()=>KK,content_2272_1902:()=>QK,content_2272_1904:()=>nJ,content_2272_1906:()=>oJ,content_2272_1908:()=>cJ,content_2272_1910:()=>sJ,content_2272_1912:()=>iJ,content_2272_1914:()=>uJ,content_2272_1916:()=>dJ,content_2272_1918:()=>kJ,content_2272_192:()=>fD,content_2272_1920:()=>fJ,content_2272_1922:()=>wJ,content_2272_1924:()=>_J,content_2272_1926:()=>gJ,content_2272_1928:()=>CJ,content_2272_1930:()=>LJ,content_2272_1932:()=>vJ,content_2272_1934:()=>NJ,content_2272_1936:()=>AJ,content_2272_1938:()=>zJ,content_2272_194:()=>wD,content_2272_1940:()=>IJ,content_2272_1942:()=>PJ,content_2272_1944:()=>FJ,content_2272_1946:()=>jJ,content_2272_1948:()=>qJ,content_2272_1950:()=>OJ,content_2272_1952:()=>HJ,content_2272_1954:()=>KJ,content_2272_1956:()=>QJ,content_2272_1958:()=>nQ,content_2272_196:()=>_D,content_2272_1960:()=>oQ,content_2272_1962:()=>cQ,content_2272_1964:()=>sQ,content_2272_1966:()=>iQ,content_2272_1968:()=>uQ,content_2272_1970:()=>dQ,content_2272_1972:()=>kQ,content_2272_1974:()=>fQ,content_2272_1976:()=>wQ,content_2272_1978:()=>_Q,content_2272_198:()=>gD,content_2272_1980:()=>gQ,content_2272_1982:()=>CQ,content_2272_1984:()=>LQ,content_2272_1986:()=>vQ,content_2272_1988:()=>NQ,content_2272_1990:()=>AQ,content_2272_1992:()=>zQ,content_2272_1994:()=>IQ,content_2272_1996:()=>PQ,content_2272_1998:()=>FQ,content_2272_2:()=>Uy,content_2272_20:()=>rf,content_2272_200:()=>CD,content_2272_2000:()=>jQ,content_2272_2002:()=>qQ,content_2272_2004:()=>OQ,content_2272_2006:()=>HQ,content_2272_2008:()=>KQ,content_2272_2010:()=>QQ,content_2272_2012:()=>n0,content_2272_2014:()=>o0,content_2272_2016:()=>c0,content_2272_2018:()=>s0,content_2272_202:()=>LD,content_2272_2020:()=>i0,content_2272_2022:()=>u0,content_2272_2024:()=>d0,content_2272_2026:()=>k0,content_2272_2028:()=>f0,content_2272_2030:()=>w0,content_2272_2032:()=>_0,content_2272_2034:()=>g0,content_2272_2036:()=>C0,content_2272_2038:()=>L0,content_2272_204:()=>vD,content_2272_2040:()=>v0,content_2272_2042:()=>N0,content_2272_2044:()=>A0,content_2272_2046:()=>z0,content_2272_2048:()=>I0,content_2272_2050:()=>P0,content_2272_2052:()=>F0,content_2272_2054:()=>j0,content_2272_2056:()=>q0,content_2272_2058:()=>O0,content_2272_206:()=>ND,content_2272_2060:()=>H0,content_2272_2062:()=>K0,content_2272_2064:()=>Q0,content_2272_2066:()=>n2,content_2272_2068:()=>o2,content_2272_2070:()=>c2,content_2272_2072:()=>s2,content_2272_2074:()=>i2,content_2272_2076:()=>u2,content_2272_2078:()=>d2,content_2272_208:()=>AD,content_2272_2080:()=>k2,content_2272_2082:()=>f2,content_2272_2084:()=>w2,content_2272_2086:()=>_2,content_2272_2088:()=>g2,content_2272_2090:()=>C2,content_2272_2092:()=>L2,content_2272_2094:()=>v2,content_2272_2096:()=>N2,content_2272_2098:()=>A2,content_2272_210:()=>zD,content_2272_2100:()=>z2,content_2272_2102:()=>I2,content_2272_2104:()=>P2,content_2272_2106:()=>F2,content_2272_2108:()=>j2,content_2272_2110:()=>q2,content_2272_2112:()=>O2,content_2272_2114:()=>H2,content_2272_2116:()=>K2,content_2272_2118:()=>Q2,content_2272_212:()=>ID,content_2272_2120:()=>n7,content_2272_2122:()=>o7,content_2272_2124:()=>c7,content_2272_2126:()=>s7,content_2272_2128:()=>i7,content_2272_2130:()=>u7,content_2272_2132:()=>d7,content_2272_2134:()=>k7,content_2272_2136:()=>f7,content_2272_2138:()=>w7,content_2272_214:()=>PD,content_2272_2140:()=>_7,content_2272_2142:()=>g7,content_2272_2144:()=>C7,content_2272_2146:()=>L7,content_2272_2148:()=>v7,content_2272_2150:()=>N7,content_2272_2152:()=>A7,content_2272_2154:()=>z7,content_2272_2156:()=>I7,content_2272_2158:()=>P7,content_2272_216:()=>FD,content_2272_2160:()=>F7,content_2272_2162:()=>j7,content_2272_2164:()=>q7,content_2272_2166:()=>O7,content_2272_2168:()=>H7,content_2272_2170:()=>K7,content_2272_2172:()=>Q7,content_2272_2174:()=>n1,content_2272_2176:()=>o1,content_2272_2178:()=>c1,content_2272_218:()=>jD,content_2272_2180:()=>s1,content_2272_2182:()=>i1,content_2272_2184:()=>u1,content_2272_2186:()=>d1,content_2272_2188:()=>k1,content_2272_2190:()=>f1,content_2272_2192:()=>w1,content_2272_2194:()=>_1,content_2272_2196:()=>g1,content_2272_2198:()=>C1,content_2272_22:()=>af,content_2272_220:()=>qD,content_2272_2200:()=>L1,content_2272_2202:()=>v1,content_2272_2204:()=>N1,content_2272_2206:()=>A1,content_2272_2208:()=>z1,content_2272_2210:()=>I1,content_2272_2212:()=>P1,content_2272_2214:()=>F1,content_2272_2216:()=>j1,content_2272_2218:()=>q1,content_2272_222:()=>OD,content_2272_2220:()=>O1,content_2272_2222:()=>H1,content_2272_2224:()=>K1,content_2272_2226:()=>Q1,content_2272_2228:()=>n4,content_2272_2230:()=>o4,content_2272_2232:()=>c4,content_2272_2234:()=>s4,content_2272_2236:()=>i4,content_2272_2238:()=>u4,content_2272_224:()=>HD,content_2272_2240:()=>d4,content_2272_2242:()=>k4,content_2272_2244:()=>f4,content_2272_2246:()=>w4,content_2272_2248:()=>_4,content_2272_2250:()=>g4,content_2272_2252:()=>C4,content_2272_2254:()=>L4,content_2272_2256:()=>v4,content_2272_2258:()=>N4,content_2272_226:()=>KD,content_2272_2260:()=>A4,content_2272_2262:()=>z4,content_2272_2264:()=>I4,content_2272_2266:()=>P4,content_2272_2268:()=>F4,content_2272_2270:()=>j4,content_2272_2272:()=>q4,content_2272_2274:()=>O4,content_2272_2276:()=>H4,content_2272_2278:()=>K4,content_2272_228:()=>QD,content_2272_2280:()=>Q4,content_2272_2282:()=>n8,content_2272_2284:()=>o8,content_2272_2286:()=>c8,content_2272_2288:()=>s8,content_2272_2290:()=>i8,content_2272_2292:()=>u8,content_2272_2294:()=>d8,content_2272_2296:()=>k8,content_2272_2298:()=>f8,content_2272_230:()=>n_,content_2272_2300:()=>w8,content_2272_2302:()=>_8,content_2272_2304:()=>g8,content_2272_2306:()=>C8,content_2272_2308:()=>L8,content_2272_2310:()=>v8,content_2272_2312:()=>N8,content_2272_2314:()=>A8,content_2272_2316:()=>z8,content_2272_2318:()=>I8,content_2272_232:()=>o_,content_2272_2320:()=>P8,content_2272_2322:()=>F8,content_2272_2324:()=>j8,content_2272_2326:()=>q8,content_2272_2328:()=>O8,content_2272_2330:()=>H8,content_2272_2332:()=>K8,content_2272_2334:()=>Q8,content_2272_2336:()=>n6,content_2272_2338:()=>o6,content_2272_234:()=>c_,content_2272_2340:()=>c6,content_2272_2342:()=>s6,content_2272_2344:()=>i6,content_2272_2346:()=>u6,content_2272_2348:()=>d6,content_2272_2350:()=>k6,content_2272_2352:()=>f6,content_2272_2354:()=>w6,content_2272_2356:()=>_6,content_2272_2358:()=>g6,content_2272_236:()=>s_,content_2272_2360:()=>C6,content_2272_2362:()=>L6,content_2272_2364:()=>v6,content_2272_2366:()=>N6,content_2272_2368:()=>A6,content_2272_2370:()=>z6,content_2272_2372:()=>I6,content_2272_2374:()=>P6,content_2272_2376:()=>F6,content_2272_2378:()=>j6,content_2272_238:()=>i_,content_2272_2380:()=>q6,content_2272_2382:()=>O6,content_2272_2384:()=>H6,content_2272_2386:()=>K6,content_2272_2388:()=>Q6,content_2272_2390:()=>n3,content_2272_2392:()=>o3,content_2272_24:()=>uf,content_2272_240:()=>u_,content_2272_242:()=>d_,content_2272_244:()=>k_,content_2272_246:()=>f_,content_2272_248:()=>w_,content_2272_250:()=>__,content_2272_252:()=>g_,content_2272_254:()=>C_,content_2272_256:()=>L_,content_2272_258:()=>v_,content_2272_26:()=>df,content_2272_260:()=>N_,content_2272_262:()=>A_,content_2272_264:()=>z_,content_2272_266:()=>I_,content_2272_268:()=>P_,content_2272_270:()=>F_,content_2272_272:()=>j_,content_2272_274:()=>q_,content_2272_276:()=>O_,content_2272_278:()=>H_,content_2272_28:()=>kf,content_2272_280:()=>K_,content_2272_282:()=>Q_,content_2272_284:()=>nX,content_2272_286:()=>oX,content_2272_288:()=>cX,content_2272_290:()=>sX,content_2272_292:()=>iX,content_2272_294:()=>uX,content_2272_296:()=>dX,content_2272_298:()=>kX,content_2272_30:()=>ff,content_2272_300:()=>fX,content_2272_302:()=>wX,content_2272_304:()=>_X,content_2272_306:()=>gX,content_2272_308:()=>CX,content_2272_310:()=>LX,content_2272_312:()=>vX,content_2272_314:()=>NX,content_2272_316:()=>AX,content_2272_318:()=>zX,content_2272_32:()=>wf,content_2272_320:()=>IX,content_2272_322:()=>PX,content_2272_324:()=>FX,content_2272_326:()=>jX,content_2272_328:()=>qX,content_2272_330:()=>OX,content_2272_332:()=>HX,content_2272_334:()=>KX,content_2272_336:()=>QX,content_2272_338:()=>ng,content_2272_34:()=>_f,content_2272_340:()=>og,content_2272_342:()=>cg,content_2272_344:()=>sg,content_2272_346:()=>ig,content_2272_348:()=>ug,content_2272_350:()=>dg,content_2272_352:()=>kg,content_2272_354:()=>fg,content_2272_356:()=>wg,content_2272_358:()=>_g,content_2272_36:()=>gf,content_2272_360:()=>gg,content_2272_362:()=>Cg,content_2272_364:()=>Lg,content_2272_366:()=>vg,content_2272_368:()=>Ng,content_2272_370:()=>Ag,content_2272_372:()=>zg,content_2272_374:()=>Ig,content_2272_376:()=>Pg,content_2272_378:()=>Fg,content_2272_38:()=>Cf,content_2272_380:()=>jg,content_2272_382:()=>qg,content_2272_384:()=>Og,content_2272_386:()=>Hg,content_2272_388:()=>Kg,content_2272_390:()=>Qg,content_2272_392:()=>nx,content_2272_394:()=>ox,content_2272_396:()=>cx,content_2272_398:()=>sx,content_2272_4:()=>Vy,content_2272_40:()=>Lf,content_2272_400:()=>ix,content_2272_402:()=>ux,content_2272_404:()=>dx,content_2272_406:()=>kx,content_2272_408:()=>fx,content_2272_410:()=>wx,content_2272_412:()=>_x,content_2272_414:()=>gx,content_2272_416:()=>Cx,content_2272_418:()=>Lx,content_2272_42:()=>vf,content_2272_420:()=>vx,content_2272_422:()=>Nx,content_2272_424:()=>Ax,content_2272_426:()=>zx,content_2272_428:()=>Ix,content_2272_430:()=>Px,content_2272_432:()=>Fx,content_2272_434:()=>jx,content_2272_436:()=>qx,content_2272_438:()=>Ox,content_2272_44:()=>Nf,content_2272_440:()=>Hx,content_2272_442:()=>Kx,content_2272_444:()=>Qx,content_2272_446:()=>nC,content_2272_448:()=>oC,content_2272_450:()=>cC,content_2272_452:()=>sC,content_2272_454:()=>iC,content_2272_456:()=>uC,content_2272_458:()=>dC,content_2272_46:()=>Af,content_2272_460:()=>kC,content_2272_462:()=>fC,content_2272_464:()=>wC,content_2272_466:()=>_C,content_2272_468:()=>gC,content_2272_470:()=>CC,content_2272_472:()=>LC,content_2272_474:()=>vC,content_2272_476:()=>NC,content_2272_478:()=>AC,content_2272_48:()=>zf,content_2272_480:()=>zC,content_2272_482:()=>IC,content_2272_484:()=>PC,content_2272_486:()=>FC,content_2272_488:()=>jC,content_2272_490:()=>qC,content_2272_492:()=>OC,content_2272_494:()=>HC,content_2272_496:()=>KC,content_2272_498:()=>QC,content_2272_50:()=>If,content_2272_500:()=>nT,content_2272_502:()=>oT,content_2272_504:()=>cT,content_2272_506:()=>sT,content_2272_508:()=>iT,content_2272_510:()=>uT,content_2272_512:()=>dT,content_2272_514:()=>kT,content_2272_516:()=>fT,content_2272_518:()=>wT,content_2272_52:()=>Pf,content_2272_520:()=>_T,content_2272_522:()=>gT,content_2272_524:()=>CT,content_2272_526:()=>LT,content_2272_528:()=>vT,content_2272_530:()=>NT,content_2272_532:()=>AT,content_2272_534:()=>zT,content_2272_536:()=>IT,content_2272_538:()=>PT,content_2272_54:()=>Ff,content_2272_540:()=>FT,content_2272_542:()=>jT,content_2272_544:()=>qT,content_2272_546:()=>OT,content_2272_548:()=>HT,content_2272_550:()=>KT,content_2272_552:()=>QT,content_2272_554:()=>nL,content_2272_556:()=>oL,content_2272_558:()=>cL,content_2272_56:()=>jf,content_2272_560:()=>sL,content_2272_562:()=>iL,content_2272_564:()=>uL,content_2272_566:()=>dL,content_2272_568:()=>kL,content_2272_570:()=>fL,content_2272_572:()=>wL,content_2272_574:()=>_L,content_2272_576:()=>gL,content_2272_578:()=>CL,content_2272_58:()=>qf,content_2272_580:()=>LL,content_2272_582:()=>vL,content_2272_584:()=>NL,content_2272_586:()=>AL,content_2272_588:()=>zL,content_2272_590:()=>IL,content_2272_592:()=>PL,content_2272_594:()=>FL,content_2272_596:()=>jL,content_2272_598:()=>qL,content_2272_6:()=>By,content_2272_60:()=>Of,content_2272_600:()=>OL,content_2272_602:()=>HL,content_2272_604:()=>KL,content_2272_606:()=>QL,content_2272_608:()=>nZ,content_2272_610:()=>oZ,content_2272_612:()=>cZ,content_2272_614:()=>sZ,content_2272_616:()=>iZ,content_2272_618:()=>uZ,content_2272_62:()=>Hf,content_2272_620:()=>dZ,content_2272_622:()=>kZ,content_2272_624:()=>fZ,content_2272_626:()=>wZ,content_2272_628:()=>_Z,content_2272_630:()=>gZ,content_2272_632:()=>CZ,content_2272_634:()=>LZ,content_2272_636:()=>vZ,content_2272_638:()=>NZ,content_2272_64:()=>Kf,content_2272_640:()=>AZ,content_2272_642:()=>zZ,content_2272_644:()=>IZ,content_2272_646:()=>PZ,content_2272_648:()=>FZ,content_2272_650:()=>jZ,content_2272_652:()=>qZ,content_2272_654:()=>OZ,content_2272_656:()=>HZ,content_2272_658:()=>KZ,content_2272_66:()=>Qf,content_2272_660:()=>QZ,content_2272_662:()=>nv,content_2272_664:()=>ov,content_2272_666:()=>cv,content_2272_668:()=>sv,content_2272_670:()=>iv,content_2272_672:()=>uv,content_2272_674:()=>dv,content_2272_676:()=>kv,content_2272_678:()=>fv,content_2272_68:()=>nM,content_2272_680:()=>wv,content_2272_682:()=>_v,content_2272_684:()=>gv,content_2272_686:()=>Cv,content_2272_688:()=>Lv,content_2272_690:()=>vv,content_2272_692:()=>Nv,content_2272_694:()=>Av,content_2272_696:()=>zv,content_2272_698:()=>Iv,content_2272_70:()=>oM,content_2272_700:()=>Pv,content_2272_702:()=>Fv,content_2272_704:()=>jv,content_2272_706:()=>qv,content_2272_708:()=>Ov,content_2272_710:()=>Hv,content_2272_712:()=>Kv,content_2272_714:()=>Qv,content_2272_716:()=>nb,content_2272_718:()=>ob,content_2272_72:()=>cM,content_2272_720:()=>cb,content_2272_722:()=>sb,content_2272_724:()=>ib,content_2272_726:()=>ub,content_2272_728:()=>db,content_2272_730:()=>kb,content_2272_732:()=>fb,content_2272_734:()=>wb,content_2272_736:()=>_b,content_2272_738:()=>gb,content_2272_74:()=>sM,content_2272_740:()=>Cb,content_2272_742:()=>Lb,content_2272_744:()=>vb,content_2272_746:()=>Nb,content_2272_748:()=>Ab,content_2272_750:()=>zb,content_2272_752:()=>Ib,content_2272_754:()=>Pb,content_2272_756:()=>Fb,content_2272_758:()=>jb,content_2272_76:()=>iM,content_2272_760:()=>qb,content_2272_762:()=>Ob,content_2272_764:()=>Hb,content_2272_766:()=>Kb,content_2272_768:()=>Qb,content_2272_770:()=>nN,content_2272_772:()=>oN,content_2272_774:()=>cN,content_2272_776:()=>sN,content_2272_778:()=>iN,content_2272_78:()=>uM,content_2272_780:()=>uN,content_2272_782:()=>dN,content_2272_784:()=>kN,content_2272_786:()=>fN,content_2272_788:()=>wN,content_2272_790:()=>_N,content_2272_792:()=>gN,content_2272_794:()=>CN,content_2272_796:()=>LN,content_2272_798:()=>vN,content_2272_8:()=>$y,content_2272_80:()=>dM,content_2272_800:()=>NN,content_2272_802:()=>AN,content_2272_804:()=>zN,content_2272_806:()=>IN,content_2272_808:()=>PN,content_2272_810:()=>FN,content_2272_812:()=>jN,content_2272_814:()=>qN,content_2272_816:()=>ON,content_2272_818:()=>HN,content_2272_82:()=>kM,content_2272_820:()=>KN,content_2272_822:()=>QN,content_2272_824:()=>nE,content_2272_826:()=>oE,content_2272_828:()=>cE,content_2272_830:()=>sE,content_2272_832:()=>iE,content_2272_834:()=>uE,content_2272_836:()=>dE,content_2272_838:()=>kE,content_2272_84:()=>fM,content_2272_840:()=>fE,content_2272_842:()=>wE,content_2272_844:()=>_E,content_2272_846:()=>gE,content_2272_848:()=>CE,content_2272_850:()=>LE,content_2272_852:()=>vE,content_2272_854:()=>NE,content_2272_856:()=>AE,content_2272_858:()=>zE,content_2272_86:()=>wM,content_2272_860:()=>IE,content_2272_862:()=>PE,content_2272_864:()=>FE,content_2272_866:()=>jE,content_2272_868:()=>qE,content_2272_870:()=>OE,content_2272_872:()=>HE,content_2272_874:()=>KE,content_2272_876:()=>QE,content_2272_878:()=>nA,content_2272_88:()=>_M,content_2272_880:()=>oA,content_2272_882:()=>cA,content_2272_884:()=>sA,content_2272_886:()=>iA,content_2272_888:()=>uA,content_2272_890:()=>dA,content_2272_892:()=>kA,content_2272_894:()=>fA,content_2272_896:()=>wA,content_2272_898:()=>_A,content_2272_90:()=>gM,content_2272_900:()=>gA,content_2272_902:()=>CA,content_2272_904:()=>LA,content_2272_906:()=>vA,content_2272_908:()=>NA,content_2272_910:()=>AA,content_2272_912:()=>zA,content_2272_914:()=>IA,content_2272_916:()=>PA,content_2272_918:()=>FA,content_2272_92:()=>CM,content_2272_920:()=>jA,content_2272_922:()=>qA,content_2272_924:()=>OA,content_2272_926:()=>HA,content_2272_928:()=>KA,content_2272_930:()=>QA,content_2272_932:()=>nR,content_2272_934:()=>oR,content_2272_936:()=>cR,content_2272_938:()=>sR,content_2272_94:()=>LM,content_2272_940:()=>iR,content_2272_942:()=>uR,content_2272_944:()=>dR,content_2272_946:()=>kR,content_2272_948:()=>fR,content_2272_950:()=>wR,content_2272_952:()=>_R,content_2272_954:()=>gR,content_2272_956:()=>CR,content_2272_958:()=>LR,content_2272_96:()=>vM,content_2272_960:()=>vR,content_2272_962:()=>NR,content_2272_964:()=>AR,content_2272_966:()=>zR,content_2272_968:()=>IR,content_2272_970:()=>PR,content_2272_972:()=>FR,content_2272_974:()=>jR,content_2272_976:()=>qR,content_2272_978:()=>OR,content_2272_98:()=>NM,content_2272_980:()=>HR,content_2272_982:()=>KR,content_2272_984:()=>QR,content_2272_986:()=>nz,content_2272_988:()=>oz,content_2272_990:()=>cz,content_2272_992:()=>sz,content_2272_994:()=>iz,content_2272_996:()=>uz,content_2272_998:()=>dz});var p=e(2784),c=e(7896),r=e(876);const s={toc:[]};function a(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const i={toc:[]};function l(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},i,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscriptions and triggering of events."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,r.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}h.isMDXComponent=!0;const k={toc:[]};function y(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},k,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Dispatches an asynchronous ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,r.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}y.isMDXComponent=!0;const f={toc:[]};function M(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}M.isMDXComponent=!0;const w={toc:[]};function D(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},w,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}D.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}X.isMDXComponent=!0;const g={toc:[]};function x(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}x.isMDXComponent=!0;const C={toc:[]};function T(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},C,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}T.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},L,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}Z.isMDXComponent=!0;const v={toc:[]};function b(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},v,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}b.isMDXComponent=!0;const N={toc:[]};function E(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}E.isMDXComponent=!0;const A={toc:[]};function R(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Dispatches a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,r.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}R.isMDXComponent=!0;const z={toc:[]};function S(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},z,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}S.isMDXComponent=!0;const I={toc:[]};function W(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},I,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}W.isMDXComponent=!0;const P={toc:[]};function G(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}G.isMDXComponent=!0;const F={toc:[]};function U(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},F,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}U.isMDXComponent=!0;const j={toc:[]};function V(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}V.isMDXComponent=!0;const q={toc:[]};function B(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}B.isMDXComponent=!0;const O={toc:[]};function $(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},O,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the value argument to subscribers."))}$.isMDXComponent=!0;const H={toc:[]};function Y(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},H,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A base for dispatching ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,r.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Y.isMDXComponent=!0;const K={toc:[]};function J(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},K,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}J.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Q,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}pt.isMDXComponent=!0;const ct={toc:[]};function rt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}rt.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}at.isMDXComponent=!0;const it={toc:[]};function lt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},it,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the callback function."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,r.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,r.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}ht.isMDXComponent=!0;const kt={toc:[]};function yt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},kt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}yt.isMDXComponent=!0;const ft={toc:[]};function Mt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Dispatches a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,r.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}Mt.isMDXComponent=!0;const wt={toc:[]};function Dt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}Dt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_t,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Are subscribers being notified?"))}Xt.isMDXComponent=!0;const gt={toc:[]};function xt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Notify all current and future subscribers."))}xt.isMDXComponent=!0;const Ct={toc:[]};function Tt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ct,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Stop notifying future subscribers."))}Tt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Lt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}Zt.isMDXComponent=!0;const vt={toc:[]};function bt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}bt.isMDXComponent=!0;const Nt={toc:[]};function Et(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}Et.isMDXComponent=!0;const At={toc:[]};function Rt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}Rt.isMDXComponent=!0;const zt={toc:[]};function St(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}St.isMDXComponent=!0;const It={toc:[]};function Wt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},It,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Wt.isMDXComponent=!0;const Pt={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,r.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Gt.isMDXComponent=!0;const Ft={toc:[]};function Ut(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ft,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A callback function that cancels the subscription."))}Ut.isMDXComponent=!0;const jt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."))}Vt.isMDXComponent=!0;const qt={toc:[]};function Bt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}Bt.isMDXComponent=!0;const Ot={toc:[]};function $t(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ot,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}$t.isMDXComponent=!0;const Ht={toc:[]};function Yt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ht,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}Yt.isMDXComponent=!0;const Kt={toc:[]};function Jt(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Kt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}Jt.isMDXComponent=!0;const Qt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qt,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the callback function."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,r.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}pn.isMDXComponent=!0;const cn={toc:[]};function rn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the most recent value of this dispatcher."))}rn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Callback function that cancels the subscription."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."),(0,r.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}dn.isMDXComponent=!0;const hn={toc:[]};function kn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}kn.isMDXComponent=!0;const yn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Callback function that cancels the subscription."))}fn.isMDXComponent=!0;const Mn={toc:[]};function wn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."),(0,r.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}wn.isMDXComponent=!0;const Dn={toc:[]};function _n(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Dn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}gn.isMDXComponent=!0;const xn={toc:[]};function Cn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the value passed to subscribers."))}Cn.isMDXComponent=!0;const Tn={toc:[]};function Ln(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function vn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}vn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Dispatches a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,r.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Nn.isMDXComponent=!0;const En={toc:[]};function An(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},En,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The initial value."))}An.isMDXComponent=!0;const Rn={toc:[]};function zn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the most recent value of this dispatcher."))}zn.isMDXComponent=!0;const Sn={toc:[]};function In(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Setting the value will immediately notify all subscribers."))}In.isMDXComponent=!0;const Wn={toc:[]};function Pn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Wn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Set the current value of this dispatcher."))}Pn.isMDXComponent=!0;const Gn={toc:[]};function Fn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new value."))}Fn.isMDXComponent=!0;const Un={toc:[]};function jn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe all subscribers from the event."))}jn.isMDXComponent=!0;const Vn={toc:[]};function qn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Callback function that cancels the subscription."))}qn.isMDXComponent=!0;const Bn={toc:[]};function On(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscribe to the event."),(0,r.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}On.isMDXComponent=!0;const $n={toc:[]};function Hn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$n,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to invoke when the event occurs."))}Hn.isMDXComponent=!0;const Yn={toc:[]};function Kn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Kn.isMDXComponent=!0;const Jn={toc:[]};function Qn(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jn,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unsubscribe from the event."))}Qn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the value passed to subscribers."))}oe.isMDXComponent=!0;const pe={toc:[]};function ce(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ce.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},re,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,r.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}se.isMDXComponent=!0;const ae={toc:[]};function ie(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}ie.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,r.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}de.isMDXComponent=!0;const he={toc:[]};function ke(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the argument passed to subscribers."))}ke.isMDXComponent=!0;const ye={toc:[]};function fe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ye,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fe.isMDXComponent=!0;const Me={toc:[]};function we(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Me,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provides safe access to the public interface of ",(0,r.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,r.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}we.isMDXComponent=!0;const De={toc:[]};function _e(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},De,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}_e.isMDXComponent=!0;const Xe={toc:[]};function ge(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xe,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The amount of times the timer has ticked."))}ge.isMDXComponent=!0;const xe={toc:[]};function Ce(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xe,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The generator responsible for running this timer."))}Ce.isMDXComponent=!0;const Te={toc:[]};function Le(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Te,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait until the timer ticks."))}Le.isMDXComponent=!0;const Ze={toc:[]};function ve(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The current iteration index."))}ve.isMDXComponent=!0;const be={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},be,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Ne.isMDXComponent=!0;const Ee={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ee,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Ae.isMDXComponent=!0;const Re={toc:[]};function ze(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Re,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to run."))}ze.isMDXComponent=!0;const Se={toc:[]};function Ie(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Se,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Ie.isMDXComponent=!0;const We={toc:[]};function Pe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},We,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Pe.isMDXComponent=!0;const Ge={toc:[]};function Fe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to run."))}Fe.isMDXComponent=!0;const Ue={toc:[]};function je(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,r.kt)("p",null,"Note that the same animation can be written as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,r.kt)("p",null,"The reason ",(0,r.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}je.isMDXComponent=!0;const Ve={toc:[]};function qe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run tasks one after another."))}qe.isMDXComponent=!0;const Be={toc:[]};function Oe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Be,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to run."))}Oe.isMDXComponent=!0;const $e={toc:[]};function He(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$e,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,r.kt)("p",null,"Note that the same animation can be written as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,r.kt)("p",null,"The reason ",(0,r.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}He.isMDXComponent=!0;const Ye={toc:[]};function Ke(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ye,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Ke.isMDXComponent=!0;const Je={toc:[]};function Qe(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Je,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The delay in seconds"))}Qe.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The task or callback to run after the delay."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}oo.isMDXComponent=!0;const po={toc:[]};function co(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Call the given callback every N seconds."))}co.isMDXComponent=!0;const ro={toc:[]};function so(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ro,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The interval between subsequent calls."))}so.isMDXComponent=!0;const ao={toc:[]};function io(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The callback to be called."))}io.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Each time iteration waits until the previous one is completed."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}ho.isMDXComponent=!0;const ko={toc:[]};function yo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ko,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Run the given generator N times."))}yo.isMDXComponent=!0;const fo={toc:[]};function Mo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The number of iterations."))}Mo.isMDXComponent=!0;const wo={toc:[]};function Do(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}Do.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_o,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Do nothing."))}Xo.isMDXComponent=!0;const go={toc:[]};function xo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}xo.isMDXComponent=!0;const Co={toc:[]};function To(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Co,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Turn the given generator function into a threadable generator."))}To.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Lo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A generator function or a factory that creates the generator."))}Zo.isMDXComponent=!0;const vo={toc:[]};function bo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}bo.isMDXComponent=!0;const No={toc:[]};function Eo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Turn the given generator function into a threadable generator."))}Eo.isMDXComponent=!0;const Ao={toc:[]};function Ro(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Ro.isMDXComponent=!0;const zo={toc:[]};function So(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A generator function or a factory that creates the generator."))}So.isMDXComponent=!0;const Io={toc:[]};function Wo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Io,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Wo.isMDXComponent=!0;const Po={toc:[]};function Go(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Po,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Go.isMDXComponent=!0;const Fo={toc:[]};function Uo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Uo.isMDXComponent=!0;const jo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The delay between each of the tasks."))}Vo.isMDXComponent=!0;const qo={toc:[]};function Bo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to be run in a sequence."))}Bo.isMDXComponent=!0;const Oo={toc:[]};function $o(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Oo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}$o.isMDXComponent=!0;const Ho={toc:[]};function Yo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ho,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for the given amount of time."))}Yo.isMDXComponent=!0;const Ko={toc:[]};function Jo(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ko,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The relative time in seconds."))}Jo.isMDXComponent=!0;const Qo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qo,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An optional task to be run after the function completes."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}pp.isMDXComponent=!0;const cp={toc:[]};function rp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait until the given time event."))}rp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The name of the time event."))}ap.isMDXComponent=!0;const ip={toc:[]};function lp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ip,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An optional task to be run after the function completes."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Main Motion Canvas classes."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when a new message is logged."))}hp.isMDXComponent=!0;const kp={toc:[]};function yp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},kp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the meta file of a given entity."))}yp.isMDXComponent=!0;const fp={toc:[]};function Mp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when metadata changes."))}Mp.isMDXComponent=!0;const wp={toc:[]};function Dp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Load new metadata from a file."))}Dp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_p,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"New metadata."))}Xp.isMDXComponent=!0;const gp={toc:[]};function xp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Any possible errors will be logged to the console."))}xp.isMDXComponent=!0;const Cp={toc:[]};function Tp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Cp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Set data without waiting for confirmation."))}Tp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Lp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"New data."))}Zp.isMDXComponent=!0;const vp={toc:[]};function bp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the data stored in the meta file."))}bp.isMDXComponent=!0;const Np={toc:[]};function Ep(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,r.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}Ep.isMDXComponent=!0;const Ap={toc:[]};function Rp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}))}Rp.isMDXComponent=!0;const zp={toc:[]};function Sp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The project configuration."))}Sp.isMDXComponent=!0;const Ip={toc:[]};function Wp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ip,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the current scene changes."))}Wp.isMDXComponent=!0;const Pp={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Gp.isMDXComponent=!0;const Fp={toc:[]};function Up(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered after the scenes were recalculated."))}Up.isMDXComponent=!0;const jp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the contents of a meta file."))}Vp.isMDXComponent=!0;const qp={toc:[]};function Bp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Multi-media management."))}Bp.isMDXComponent=!0;const Op={toc:[]};function $p(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Op,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}$p.isMDXComponent=!0;const Hp={toc:[]};function Yp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Pause/resume the audio."))}Yp.isMDXComponent=!0;const Kp={toc:[]};function Jp(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Kp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the audio should be paused or resumed."))}Jp.isMDXComponent=!0;const Qp={toc:[]};function tc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qp,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The absolute biggest value from the peaks array."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The amount of samples taken."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}pc.isMDXComponent=!0;const cc={toc:[]};function rc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Samples per seconds."))}rc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Playback control."))}ac.isMDXComponent=!0;const ic={toc:[]};function lc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ic,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Abstract scene representations and related utilities."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Signifies the various stages of a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,r.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Occurs after a render ends."))}hc.isMDXComponent=!0;const kc={toc:[]};function yc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},kc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}yc.isMDXComponent=!0;const fc={toc:[]};function Mc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,r.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Mc.isMDXComponent=!0;const wc={toc:[]};function Dc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,r.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}Dc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_c,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Describes the state of a scene."))}Xc.isMDXComponent=!0;const gc={toc:[]};function xc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}xc.isMDXComponent=!0;const Cc={toc:[]};function Tc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Cc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene has finished transitioning in."))}Tc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Lc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,r.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Zc.isMDXComponent=!0;const vc={toc:[]};function bc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene is ready to transition out."))}bc.isMDXComponent=!0;const Nc={toc:[]};function Ec(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Invoking ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,r.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Ec.isMDXComponent=!0;const Ac={toc:[]};function Rc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene has finished."))}Rc.isMDXComponent=!0;const zc={toc:[]};function Sc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene has just been created/reset."))}Sc.isMDXComponent=!0;const Ic={toc:[]};function Wc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ic,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The default implementation of the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,r.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,r.kt)("p",null,"Uses generators to control the animation."))}Wc.isMDXComponent=!0;const Pc={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will be passed as the second argument to the constructor."))}Gc.isMDXComponent=!0;const Fc={toc:[]};function Uc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Name of the scene."))}Uc.isMDXComponent=!0;const jc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reference to the project."))}Vc.isMDXComponent=!0;const qc={toc:[]};function Bc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The frame at which this scene starts."))}Bc.isMDXComponent=!0;const Oc={toc:[]};function $c(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Oc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The frame at which this scene ends."))}$c.isMDXComponent=!0;const Hc={toc:[]};function Yc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the cached data changes."))}Yc.isMDXComponent=!0;const Kc={toc:[]};function Jc(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Kc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered after scene is recalculated."))}Jc.isMDXComponent=!0;const Qc={toc:[]};function tr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qc,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the scene is reloaded."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the scene is reset."))}pr.isMDXComponent=!0;const cr={toc:[]};function rr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the main thread changes."))}rr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ar.isMDXComponent=!0;const ir={toc:[]};function lr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ir,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,r.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,r.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hr.isMDXComponent=!0;const kr={toc:[]};function yr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},kr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the size of this scene."),(0,r.kt)("p",null,"Usually return ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}yr.isMDXComponent=!0;const fr={toc:[]};function Mr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Mr.isMDXComponent=!0;const wr={toc:[]};function Dr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene cached?"),(0,r.kt)("p",null,"Used only by ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,r.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,r.kt)("p",null,"Should always return ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}Dr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_r,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,r.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Xr.isMDXComponent=!0;const gr={toc:[]};function xr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Progress this scene one frame forward."))}xr.isMDXComponent=!0;const Cr={toc:[]};function Tr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Cr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,r.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,r.kt)("p",null,"At the end of execution, this method should set ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,r.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,r.kt)("p",null,"Should trigger ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,r.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Tr.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Lr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Recalculate the scene."))}Zr.isMDXComponent=!0;const vr={toc:[]};function br(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,r.kt)("p",null,"Should trigger ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,r.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}br.isMDXComponent=!0;const Nr={toc:[]};function Er(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reload the scene."))}Er.isMDXComponent=!0;const Ar={toc:[]};function Rr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If present, a new configuration object."))}Rr.isMDXComponent=!0;const zr={toc:[]};function Sr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render the scene onto a canvas."))}Sr.isMDXComponent=!0;const Ir={toc:[]};function Wr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ir,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to used when rendering."))}Wr.isMDXComponent=!0;const Pr={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset this scene to its initial state."))}Gr.isMDXComponent=!0;const Fr={toc:[]};function Ur(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If present, the previous scene."))}Ur.isMDXComponent=!0;const jr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the view."),(0,r.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,r.kt)("p",null,"Can modify the state of the view."))}Vr.isMDXComponent=!0;const qr={toc:[]};function Br(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Lifecycle events for ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,r.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Br.isMDXComponent=!0;const Or={toc:[]};function $r(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Or,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A random number generator based on\n",(0,r.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,r.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}$r.isMDXComponent=!0;const Hr={toc:[]};function Yr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get an array filled with random floats in the given range."))}Yr.isMDXComponent=!0;const Kr={toc:[]};function Jr(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Kr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The size of the array."))}Jr.isMDXComponent=!0;const Qr={toc:[]};function ts(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qr,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get an array filled with random integers in the given range."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"}),(0,r.kt)("li",{parentName:"ul"})))}ps.isMDXComponent=!0;const cs={toc:[]};function rs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The size of the array."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"})))}rs.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"})))}as.isMDXComponent=!0;const is={toc:[]};function ls(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},is,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range. Exclusive."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the next random float in the given range."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."))}hs.isMDXComponent=!0;const ks={toc:[]};function ys(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ks,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range."))}ys.isMDXComponent=!0;const fs={toc:[]};function Ms(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the next random integer in the given range."))}Ms.isMDXComponent=!0;const ws={toc:[]};function Ds(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ws,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."))}Ds.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_s,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range. Exclusive."))}Xs.isMDXComponent=!0;const gs={toc:[]};function xs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a new independent generator."))}xs.isMDXComponent=!0;const Cs={toc:[]};function Ts(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Cs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Manages time events for a given scene."))}Ts.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ls,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when time events change."))}Zs.isMDXComponent=!0;const vs={toc:[]};function bs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the time offset of the given event."))}bs.isMDXComponent=!0;const Ns={toc:[]};function Es(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The name of the event."))}Es.isMDXComponent=!0;const As={toc:[]};function Rs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The time offset in seconds."))}Rs.isMDXComponent=!0;const zs={toc:[]};function Ss(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}Ss.isMDXComponent=!0;const Is={toc:[]};function Ws(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Is,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get variable signal if exists or create signal if not"))}Ws.isMDXComponent=!0;const Ps={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ps,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The name of the variable."))}Gs.isMDXComponent=!0;const Fs={toc:[]};function Us(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset all stored signals."))}Us.isMDXComponent=!0;const js={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update all signals with new project variable values."))}Vs.isMDXComponent=!0;const qs={toc:[]};function Bs(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Describes cached information about the timing of a scene."))}Bs.isMDXComponent=!0;const Os={toc:[]};function $s(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Os,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Describes a complete scene together with the meta file."))}$s.isMDXComponent=!0;const Hs={toc:[]};function Ys(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Configuration object."))}Ys.isMDXComponent=!0;const Ks={toc:[]};function Js(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ks,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The class used to instantiate the scene."))}Js.isMDXComponent=!0;const Qs={toc:[]};function ta(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qs,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The stack trace at the moment of creation."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the configuration object."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}pa.isMDXComponent=!0;const ca={toc:[]};function ra(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}ra.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for the inspected element."))}aa.isMDXComponent=!0;const ia={toc:[]};function la(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ia,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The element for which to draw an overlay."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}ha.isMDXComponent=!0;const ka={toc:[]};function ya(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ka,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}ya.isMDXComponent=!0;const fa={toc:[]};function Ma(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Return the attributes of the inspected element."))}Ma.isMDXComponent=!0;const wa={toc:[]};function Da(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The element to inspect."))}Da.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_a,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a possible element to inspect at a given position."))}Xa.isMDXComponent=!0;const ga={toc:[]};function xa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The x coordinate."))}xa.isMDXComponent=!0;const Ca={toc:[]};function Ta(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ca,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The y coordinate."))}Ta.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},La,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}Za.isMDXComponent=!0;const va={toc:[]};function ba(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the inspected element is still valid."))}ba.isMDXComponent=!0;const Na={toc:[]};function Ea(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The element to validate."))}Ea.isMDXComponent=!0;const Aa={toc:[]};function Ra(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents a time event stored in a meta file."))}Ra.isMDXComponent=!0;const za={toc:[]};function Sa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},za,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,r.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Sa.isMDXComponent=!0;const Ia={toc:[]};function Wa(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ia,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The main interface for scenes."))}Wa.isMDXComponent=!0;const Pa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Will be passed as the second argument to the constructor."))}Ga.isMDXComponent=!0;const Fa={toc:[]};function Ua(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Name of the scene."))}Ua.isMDXComponent=!0;const ja={toc:[]};function Va(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reference to the project."))}Va.isMDXComponent=!0;const qa={toc:[]};function Ba(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene's ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,r.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Ba.isMDXComponent=!0;const Oa={toc:[]};function $a(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Oa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The frame at which this scene starts."))}$a.isMDXComponent=!0;const Ha={toc:[]};function Ya(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ha,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The frame at which this scene ends."))}Ya.isMDXComponent=!0;const Ka={toc:[]};function Ja(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ka,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the cached data changes."))}Ja.isMDXComponent=!0;const Qa={toc:[]};function ti(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qa,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered after scene is recalculated."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the scene is reloaded."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}pi.isMDXComponent=!0;const ci={toc:[]};function ri(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the scene is reset."))}ri.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ai.isMDXComponent=!0;const ii={toc:[]};function li(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ii,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,r.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Enter the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,r.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hi.isMDXComponent=!0;const ki={toc:[]};function yi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ki,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the size of this scene."),(0,r.kt)("p",null,"Usually return ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}yi.isMDXComponent=!0;const fi={toc:[]};function Mi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,r.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Mi.isMDXComponent=!0;const wi={toc:[]};function Di(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene cached?"),(0,r.kt)("p",null,"Used only by ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,r.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,r.kt)("p",null,"Should always return ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))}Di.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_i,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Is this scene in the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,r.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Xi.isMDXComponent=!0;const gi={toc:[]};function xi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Progress this scene one frame forward."))}xi.isMDXComponent=!0;const Ci={toc:[]};function Ti(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ci,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,r.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,r.kt)("p",null,"At the end of execution, this method should set ",(0,r.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,r.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,r.kt)("p",null,"Should trigger ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,r.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ti.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Li,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Recalculate the scene."))}Zi.isMDXComponent=!0;const vi={toc:[]};function bi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,r.kt)("p",null,"Should trigger ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,r.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}bi.isMDXComponent=!0;const Ni={toc:[]};function Ei(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reload the scene."))}Ei.isMDXComponent=!0;const Ai={toc:[]};function Ri(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If present, a new configuration object."))}Ri.isMDXComponent=!0;const zi={toc:[]};function Si(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render the scene onto a canvas."))}Si.isMDXComponent=!0;const Ii={toc:[]};function Wi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ii,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to used when rendering."))}Wi.isMDXComponent=!0;const Pi={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset this scene to its initial state."))}Gi.isMDXComponent=!0;const Fi={toc:[]};function Ui(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If present, the previous scene."))}Ui.isMDXComponent=!0;const ji={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the configuration object."))}Vi.isMDXComponent=!0;const qi={toc:[]};function Bi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Each class implementing the ",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,r.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Bi.isMDXComponent=!0;const Oi={toc:[]};function $i(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Oi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The constructor used when creating new scenes."))}$i.isMDXComponent=!0;const Hi={toc:[]};function Yi(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,r.kt)("inlineCode",{parentName:"a"},"config")),"."))}Yi.isMDXComponent=!0;const Ki={toc:[]};function Ji(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ki,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Describes a scene exposed by scene files."))}Ji.isMDXComponent=!0;const Qi={toc:[]};function tl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qi,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Configuration object."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The class used to instantiate the scene."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The stack trace at the moment of creation."))}pl.isMDXComponent=!0;const cl={toc:[]};function rl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type of the configuration object."))}rl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the contents of a meta file."))}al.isMDXComponent=!0;const il={toc:[]};function ll(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},il,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Triggered when the main thread changes."))}hl.isMDXComponent=!0;const kl={toc:[]};function yl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},kl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents a time event at runtime."))}yl.isMDXComponent=!0;const fl={toc:[]};function Ml(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In other words, the moment at which ",(0,r.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,r.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}Ml.isMDXComponent=!0;const wl={toc:[]};function Dl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}Dl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_l,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Name of the event."))}Xl.isMDXComponent=!0;const gl={toc:[]};function xl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Duration of the event in seconds."))}xl.isMDXComponent=!0;const Cl={toc:[]};function Tl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Cl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Stack trace at the moment of registration."))}Tl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ll,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}Zl.isMDXComponent=!0;const vl={toc:[]};function bl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents attributes of an inspected element."))}bl.isMDXComponent=!0;const Nl={toc:[]};function El(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}El.isMDXComponent=!0;const Al={toc:[]};function Rl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents an element to inspect."))}Rl.isMDXComponent=!0;const zl={toc:[]};function Sl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Sl.isMDXComponent=!0;const Il={toc:[]};function Wl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Il,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,r.kt)("p",null,"This method can be used to create copies of signals."))}Wl.isMDXComponent=!0;const Pl={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Gl.isMDXComponent=!0;const Fl={toc:[]};function Ul(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the raw value of this signal."))}Ul.isMDXComponent=!0;const jl={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Vl.isMDXComponent=!0;const ql={toc:[]};function Bl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Bl.isMDXComponent=!0;const Ol={toc:[]};function $l(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ol,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}$l.isMDXComponent=!0;const Hl={toc:[]};function Yl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Yl.isMDXComponent=!0;const Kl={toc:[]};function Jl(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Kl,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Jl.isMDXComponent=!0;const Ql={toc:[]};function tu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ql,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,r.kt)("p",null,"This method can be used to create copies of signals."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the raw value of this signal."))}pu.isMDXComponent=!0;const cu={toc:[]};function ru(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}ru.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}au.isMDXComponent=!0;const iu={toc:[]};function lu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},iu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Compute the current value of the signal and immediately set it."))}hu.isMDXComponent=!0;const ku={toc:[]};function yu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ku,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}yu.isMDXComponent=!0;const fu={toc:[]};function Mu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Mu.isMDXComponent=!0;const wu={toc:[]};function Du(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Du.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_u,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Thread management."))}Xu.isMDXComponent=!0;const gu={toc:[]};function xu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,r.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}xu.isMDXComponent=!0;const Cu={toc:[]};function Tu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Cu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A class representing an individual thread."))}Tu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Lu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The generator wrapped by this thread."))}Zu.isMDXComponent=!0;const vu={toc:[]};function bu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The generator wrapped by this thread."))}bu.isMDXComponent=!0;const Nu={toc:[]};function Eu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Used by ",(0,r.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,r.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}Eu.isMDXComponent=!0;const Au={toc:[]};function Ru(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The current time of this thread."))}Ru.isMDXComponent=!0;const zu={toc:[]};function Su(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The next value to be passed to the wrapped generator."))}Su.isMDXComponent=!0;const Iu={toc:[]};function Wu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Iu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}Wu.isMDXComponent=!0;const Pu={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Progress the wrapped generator once."))}Gu.isMDXComponent=!0;const Fu={toc:[]};function Uu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the thread for the next update cycle."))}Uu.isMDXComponent=!0;const ju={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A generator function or a normal function that returns a generator."))}Vu.isMDXComponent=!0;const qu={toc:[]};function Bu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,r.kt)("p",null,"Progress to the next frame:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,r.kt)("p",null,"Run another generator synchronously:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,r.kt)("p",null,"Run another generator concurrently:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,r.kt)("p",null,"Await a Promise:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Bu.isMDXComponent=!0;const Ou={toc:[]};function $u(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ou,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}$u.isMDXComponent=!0;const Hu={toc:[]};function Yu(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Cancel all listed tasks."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Yu.isMDXComponent=!0;const Ku={toc:[]};function Ju(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ku,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to cancel."))}Ju.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qu,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A possible ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Check if the given value is a ",(0,r.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,r.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}pm.isMDXComponent=!0;const cm={toc:[]};function rm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A possible thread ",(0,r.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,r.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}rm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}am.isMDXComponent=!0;const im={toc:[]};function lm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},im,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to join."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}hm.isMDXComponent=!0;const km={toc:[]};function ym(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},km,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Pause the current generator until listed tasks are finished."))}ym.isMDXComponent=!0;const fm={toc:[]};function Mm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Mm.isMDXComponent=!0;const wm={toc:[]};function Dm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A list of tasks to join."))}Dm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_m,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"From the perspective of the external generator, ",(0,r.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,r.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}Xm.isMDXComponent=!0;const gm={toc:[]};function xm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}xm.isMDXComponent=!0;const Cm={toc:[]};function Tm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Cm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a context in which generators can be run concurrently."))}Tm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Lm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A function that returns the generator to run."))}Zm.isMDXComponent=!0;const vm={toc:[]};function bm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}bm.isMDXComponent=!0;const Nm={toc:[]};function Em(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Transitions between scenes."))}Em.isMDXComponent=!0;const Am={toc:[]};function Rm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}Rm.isMDXComponent=!0;const zm={toc:[]};function Sm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The direction in which to slide."))}Sm.isMDXComponent=!0;const Im={toc:[]};function Wm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Im,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition."))}Wm.isMDXComponent=!0;const Pm={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Gm.isMDXComponent=!0;const Fm={toc:[]};function Um(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The callback to use before the current scene is rendered."))}Um.isMDXComponent=!0;const jm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The callback to use before the previous scene is rendered."))}Vm.isMDXComponent=!0;const qm={toc:[]};function Bm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}Bm.isMDXComponent=!0;const Om={toc:[]};function $m(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Om,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The area on which to zoom in."))}$m.isMDXComponent=!0;const Hm={toc:[]};function Ym(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition."))}Ym.isMDXComponent=!0;const Km={toc:[]};function Jm(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Km,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}Jm.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qm,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The area from which to zoom out."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the transition."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Interpolation and timing of tweens."))}pd.isMDXComponent=!0;const cd={toc:[]};function rd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Any old key that is missing in ",(0,r.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"})))}rd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A value matching the structure of from and to."))}ad.isMDXComponent=!0;const id={toc:[]};function ld(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},id,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The input to favor when value is 0."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The input to favor when value is 1."))}hd.isMDXComponent=!0;const kd={toc:[]};function yd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},kd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}yd.isMDXComponent=!0;const fd={toc:[]};function Md(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A value matching the structure of from and to."))}Md.isMDXComponent=!0;const wd={toc:[]};function Dd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Dd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_d,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The input to favor when value is 0."))}Xd.isMDXComponent=!0;const gd={toc:[]};function xd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The input to favor when value is 1."))}xd.isMDXComponent=!0;const Cd={toc:[]};function Td(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Cd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Td.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ld,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Complex types used in animations."))}Zd.isMDXComponent=!0;const vd={toc:[]};function bd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents a two-dimensional vector."))}bd.isMDXComponent=!0;const Nd={toc:[]};function Ed(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}Ed.isMDXComponent=!0;const Ad={toc:[]};function Rd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The unclipped RGB components."))}Rd.isMDXComponent=!0;const zd={toc:[]};function Sd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}Sd.isMDXComponent=!0;const Id={toc:[]};function Wd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Id,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}Wd.isMDXComponent=!0;const Pd={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Gd.isMDXComponent=!0;const Fd={toc:[]};function Ud(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Ud.isMDXComponent=!0;const jd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}Vd.isMDXComponent=!0;const qd={toc:[]};function Bd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Bd.isMDXComponent=!0;const Od={toc:[]};function $d(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Od,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}$d.isMDXComponent=!0;const Hd={toc:[]};function Yd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Alias of ",(0,r.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Yd.isMDXComponent=!0;const Kd={toc:[]};function Jd(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Kd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Jd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qd,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,r.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,r.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}ph.isMDXComponent=!0;const ch={toc:[]};function rh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}rh.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,r.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,r.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}ah.isMDXComponent=!0;const ih={toc:[]};function lh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ih,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("strong",{parentName:"p"},"L"),", ",(0,r.kt)("strong",{parentName:"p"},"a"),", and ",(0,r.kt)("strong",{parentName:"p"},"b")," components."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}hh.isMDXComponent=!0;const kh={toc:[]};function yh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},kh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the ",(0,r.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,r.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,r.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}yh.isMDXComponent=!0;const fh={toc:[]};function Mh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}Mh.isMDXComponent=!0;const wh={toc:[]};function Dh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}Dh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_h,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Xh.isMDXComponent=!0;const gh={toc:[]};function xh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}xh.isMDXComponent=!0;const Ch={toc:[]};function Th(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ch,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get and set the color opacity."))}Th.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Lh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,r.kt)("code",null,"'rgb'")))}Zh.isMDXComponent=!0;const vh={toc:[]};function bh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Similar to saturate, but the opposite direction."))}bh.isMDXComponent=!0;const Nh={toc:[]};function Eh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"set"))}Eh.isMDXComponent=!0;const Ah={toc:[]};function Rh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns a single channel value.\nAlso"))}Rh.isMDXComponent=!0;const zh={toc:[]};function Sh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}Sh.isMDXComponent=!0;const Ih={toc:[]};function Wh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ih,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color as hexadecimal string."))}Wh.isMDXComponent=!0;const Ph={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ph,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,r.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,r.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}Gh.isMDXComponent=!0;const Fh={toc:[]};function Uh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,r.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Uh.isMDXComponent=!0;const jh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}Vh.isMDXComponent=!0;const qh={toc:[]};function Bh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Bh.isMDXComponent=!0;const Oh={toc:[]};function $h(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Oh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}$h.isMDXComponent=!0;const Hh={toc:[]};function Yh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Yh.isMDXComponent=!0;const Kh={toc:[]};function Jh(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Kh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Jh.isMDXComponent=!0;const Qh={toc:[]};function tk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qh,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}pk.isMDXComponent=!0;const ck={toc:[]};function rk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ck,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}rk.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}ak.isMDXComponent=!0;const ik={toc:[]};function lk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Convert the given origin to a vector representing its offset."))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The origin to convert."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"General utilities and helper functions."))}hk.isMDXComponent=!0;const kk={toc:[]};function yk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},kk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}yk.isMDXComponent=!0;const fk={toc:[]};function Mk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Optional override for formatting stack traces"))}Mk.isMDXComponent=!0;const wk={toc:[]};function Dk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create .stack property on a target object"))}Dk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_k,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is a shortcut for calling ",(0,r.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}Xk.isMDXComponent=!0;const gk={toc:[]};function xk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}xk.isMDXComponent=!0;const Ck={toc:[]};function Tk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ck,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Logs a debug message with an arbitrary payload."))}Tk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The payload to log"))}Zk.isMDXComponent=!0;const vk={toc:[]};function bk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Mark the given function as deprecated."))}bk.isMDXComponent=!0;const Nk={toc:[]};function Ek(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The function to deprecate."))}Ek.isMDXComponent=!0;const Ak={toc:[]};function Rk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ak,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The log message."))}Rk.isMDXComponent=!0;const zk={toc:[]};function Sk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The optional log remarks."))}Sk.isMDXComponent=!0;const Ik={toc:[]};function Wk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ik,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}Wk.isMDXComponent=!0;const Pk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Pk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Mark the current scene as ready to transition out."))}Gk.isMDXComponent=!0;const Fk={toc:[]};function Uk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}Uk.isMDXComponent=!0;const jk={toc:[]};function Vk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an array containing a range of numbers."))}Vk.isMDXComponent=!0;const qk={toc:[]};function Bk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The length of the array."))}Bk.isMDXComponent=!0;const Ok={toc:[]};function $k(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ok,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}$k.isMDXComponent=!0;const Hk={toc:[]};function Yk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an array containing a range of numbers."))}Yk.isMDXComponent=!0;const Kk={toc:[]};function Jk(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Kk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The start of the range."))}Jk.isMDXComponent=!0;const Qk={toc:[]};function ty(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qk,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The end of the range. ",(0,r.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The function that will be provided the context before render."))}py.isMDXComponent=!0;const cy={toc:[]};function ry(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}ry.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The function that will be provided the context after render."))}ay.isMDXComponent=!0;const iy={toc:[]};function ly(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The duration of the event in seconds."))}hy.isMDXComponent=!0;const ky={toc:[]};function yy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ky,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Register a time event and get its duration in seconds."))}yy.isMDXComponent=!0;const fy={toc:[]};function My(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The name of the event."))}My.isMDXComponent=!0;const wy={toc:[]};function Dy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},wy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a reference to the current project."))}Dy.isMDXComponent=!0;const _y={toc:[]};function Xy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},_y,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the random number generator for the current scene."))}Xy.isMDXComponent=!0;const gy={toc:[]};function xy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the random number generator for the given seed."))}xy.isMDXComponent=!0;const Cy={toc:[]};function Ty(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Cy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The seed for the generator."))}Ty.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}Zy.isMDXComponent=!0;const vy={toc:[]};function by(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},vy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a reference to the current scene."))}by.isMDXComponent=!0;const Ny={toc:[]};function Ey(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a reference to the current thread."))}Ey.isMDXComponent=!0;const Ay={toc:[]};function Ry(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ay,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,r.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,r.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}Ry.isMDXComponent=!0;const zy={toc:[]};function Sy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},zy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}Sy.isMDXComponent=!0;const Iy={toc:[]};function Wy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Iy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the real time since the start of the animation."))}Wy.isMDXComponent=!0;const Py={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}Gy.isMDXComponent=!0;const Fy={toc:[]};function Uy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Fy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}Uy.isMDXComponent=!0;const jy={toc:[]};function Vy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},jy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Vy.isMDXComponent=!0;const qy={toc:[]};function By(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},qy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}By.isMDXComponent=!0;const Oy={toc:[]};function $y(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Oy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}$y.isMDXComponent=!0;const Hy={toc:[]};function Yy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Hy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}Yy.isMDXComponent=!0;const Ky={toc:[]};function Jy(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ky,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Jy.isMDXComponent=!0;const Qy={toc:[]};function tf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Qy,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}pf.isMDXComponent=!0;const cf={toc:[]};function rf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}rf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}df.isMDXComponent=!0;const hf={toc:[]};function kf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}kf.isMDXComponent=!0;const yf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}ff.isMDXComponent=!0;const Mf={toc:[]};function wf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}wf.isMDXComponent=!0;const Df={toc:[]};function _f(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Df,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}gf.isMDXComponent=!0;const xf={toc:[]};function Cf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}Cf.isMDXComponent=!0;const Tf={toc:[]};function Lf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function vf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Nf.isMDXComponent=!0;const Ef={toc:[]};function Af(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ef,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Af.isMDXComponent=!0;const Rf={toc:[]};function zf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}zf.isMDXComponent=!0;const Sf={toc:[]};function If(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}If.isMDXComponent=!0;const Wf={toc:[]};function Pf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Wf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}Pf.isMDXComponent=!0;const Gf={toc:[]};function Ff(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Ff.isMDXComponent=!0;const Uf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Uf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}jf.isMDXComponent=!0;const Vf={toc:[]};function qf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qf.isMDXComponent=!0;const Bf={toc:[]};function Of(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}Of.isMDXComponent=!0;const $f={toc:[]};function Hf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$f,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Hf.isMDXComponent=!0;const Yf={toc:[]};function Kf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kf.isMDXComponent=!0;const Jf={toc:[]};function Qf(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jf,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}Qf.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}oM.isMDXComponent=!0;const pM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}cM.isMDXComponent=!0;const rM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}sM.isMDXComponent=!0;const aM={toc:[]};function iM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}iM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}dM.isMDXComponent=!0;const hM={toc:[]};function kM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}kM.isMDXComponent=!0;const yM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fM.isMDXComponent=!0;const MM={toc:[]};function wM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wM.isMDXComponent=!0;const DM={toc:[]};function _M(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}gM.isMDXComponent=!0;const xM={toc:[]};function CM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}CM.isMDXComponent=!0;const TM={toc:[]};function LM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}LM.isMDXComponent=!0;const ZM={toc:[]};function vM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}vM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}NM.isMDXComponent=!0;const EM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}AM.isMDXComponent=!0;const RM={toc:[]};function zM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}zM.isMDXComponent=!0;const SM={toc:[]};function IM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}IM.isMDXComponent=!0;const WM={toc:[]};function PM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PM.isMDXComponent=!0;const GM={toc:[]};function FM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}FM.isMDXComponent=!0;const UM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}jM.isMDXComponent=!0;const VM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}qM.isMDXComponent=!0;const BM={toc:[]};function OM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}OM.isMDXComponent=!0;const $M={toc:[]};function HM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$M,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}HM.isMDXComponent=!0;const YM={toc:[]};function KM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}KM.isMDXComponent=!0;const JM={toc:[]};function QM(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JM,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}QM.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}ow.isMDXComponent=!0;const pw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}cw.isMDXComponent=!0;const rw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sw.isMDXComponent=!0;const aw={toc:[]};function iw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}iw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}dw.isMDXComponent=!0;const hw={toc:[]};function kw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kw.isMDXComponent=!0;const yw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}fw.isMDXComponent=!0;const Mw={toc:[]};function ww(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}ww.isMDXComponent=!0;const Dw={toc:[]};function _w(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Dw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}gw.isMDXComponent=!0;const xw={toc:[]};function Cw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}Cw.isMDXComponent=!0;const Tw={toc:[]};function Lw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function vw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}vw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}Nw.isMDXComponent=!0;const Ew={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ew,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}Aw.isMDXComponent=!0;const Rw={toc:[]};function zw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}zw.isMDXComponent=!0;const Sw={toc:[]};function Iw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Iw.isMDXComponent=!0;const Ww={toc:[]};function Pw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ww,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}Pw.isMDXComponent=!0;const Gw={toc:[]};function Fw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Fw.isMDXComponent=!0;const Uw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Uw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}jw.isMDXComponent=!0;const Vw={toc:[]};function qw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}qw.isMDXComponent=!0;const Bw={toc:[]};function Ow(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ow.isMDXComponent=!0;const $w={toc:[]};function Hw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$w,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Hw.isMDXComponent=!0;const Yw={toc:[]};function Kw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Kw.isMDXComponent=!0;const Jw={toc:[]};function Qw(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jw,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Qw.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}oD.isMDXComponent=!0;const pD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}cD.isMDXComponent=!0;const rD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}sD.isMDXComponent=!0;const aD={toc:[]};function iD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}iD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}dD.isMDXComponent=!0;const hD={toc:[]};function kD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}kD.isMDXComponent=!0;const yD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}fD.isMDXComponent=!0;const MD={toc:[]};function wD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}wD.isMDXComponent=!0;const DD={toc:[]};function _D(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}gD.isMDXComponent=!0;const xD={toc:[]};function CD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}CD.isMDXComponent=!0;const TD={toc:[]};function LD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}LD.isMDXComponent=!0;const ZD={toc:[]};function vD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}vD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}ND.isMDXComponent=!0;const ED={toc:[]};function AD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ED,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}AD.isMDXComponent=!0;const RD={toc:[]};function zD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}zD.isMDXComponent=!0;const SD={toc:[]};function ID(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ID.isMDXComponent=!0;const WD={toc:[]};function PD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}PD.isMDXComponent=!0;const GD={toc:[]};function FD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}FD.isMDXComponent=!0;const UD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}jD.isMDXComponent=!0;const VD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}qD.isMDXComponent=!0;const BD={toc:[]};function OD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}OD.isMDXComponent=!0;const $D={toc:[]};function HD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$D,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}HD.isMDXComponent=!0;const YD={toc:[]};function KD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}KD.isMDXComponent=!0;const JD={toc:[]};function QD(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JD,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}QD.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}o_.isMDXComponent=!0;const p_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}c_.isMDXComponent=!0;const r_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},r_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}s_.isMDXComponent=!0;const a_={toc:[]};function i_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}i_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}d_.isMDXComponent=!0;const h_={toc:[]};function k_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}k_.isMDXComponent=!0;const y_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},y_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}f_.isMDXComponent=!0;const M_={toc:[]};function w_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},M_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}w_.isMDXComponent=!0;const D_={toc:[]};function __(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},D_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},X_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}g_.isMDXComponent=!0;const x_={toc:[]};function C_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},x_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}C_.isMDXComponent=!0;const T_={toc:[]};function L_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},T_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}L_.isMDXComponent=!0;const Z_={toc:[]};function v_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Z_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}v_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},b_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}N_.isMDXComponent=!0;const E_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},E_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}A_.isMDXComponent=!0;const R_={toc:[]};function z_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},R_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}z_.isMDXComponent=!0;const S_={toc:[]};function I_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},S_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}I_.isMDXComponent=!0;const W_={toc:[]};function P_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},W_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}P_.isMDXComponent=!0;const G_={toc:[]};function F_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}F_.isMDXComponent=!0;const U_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},U_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}j_.isMDXComponent=!0;const V_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}q_.isMDXComponent=!0;const B_={toc:[]};function O_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},B_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}O_.isMDXComponent=!0;const $_={toc:[]};function H_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}H_.isMDXComponent=!0;const Y_={toc:[]};function K_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Y_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}K_.isMDXComponent=!0;const J_={toc:[]};function Q_(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},J_,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}Q_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}oX.isMDXComponent=!0;const pX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}cX.isMDXComponent=!0;const rX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}sX.isMDXComponent=!0;const aX={toc:[]};function iX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}iX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}dX.isMDXComponent=!0;const hX={toc:[]};function kX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}kX.isMDXComponent=!0;const yX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}fX.isMDXComponent=!0;const MX={toc:[]};function wX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}wX.isMDXComponent=!0;const DX={toc:[]};function _X(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gX.isMDXComponent=!0;const xX={toc:[]};function CX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}CX.isMDXComponent=!0;const TX={toc:[]};function LX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}LX.isMDXComponent=!0;const ZX={toc:[]};function vX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}vX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NX.isMDXComponent=!0;const EX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}AX.isMDXComponent=!0;const RX={toc:[]};function zX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}zX.isMDXComponent=!0;const SX={toc:[]};function IX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}IX.isMDXComponent=!0;const WX={toc:[]};function PX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}PX.isMDXComponent=!0;const GX={toc:[]};function FX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}FX.isMDXComponent=!0;const UX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jX.isMDXComponent=!0;const VX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}qX.isMDXComponent=!0;const BX={toc:[]};function OX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}OX.isMDXComponent=!0;const $X={toc:[]};function HX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$X,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}HX.isMDXComponent=!0;const YX={toc:[]};function KX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}KX.isMDXComponent=!0;const JX={toc:[]};function QX(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JX,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}QX.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}og.isMDXComponent=!0;const pg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}cg.isMDXComponent=!0;const rg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}sg.isMDXComponent=!0;const ag={toc:[]};function ig(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ig.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}dg.isMDXComponent=!0;const hg={toc:[]};function kg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kg.isMDXComponent=!0;const yg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}fg.isMDXComponent=!0;const Mg={toc:[]};function wg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}wg.isMDXComponent=!0;const Dg={toc:[]};function _g(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Dg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}gg.isMDXComponent=!0;const xg={toc:[]};function Cg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Cg.isMDXComponent=!0;const Tg={toc:[]};function Lg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function vg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}vg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ng.isMDXComponent=!0;const Eg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Eg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Ag.isMDXComponent=!0;const Rg={toc:[]};function zg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}zg.isMDXComponent=!0;const Sg={toc:[]};function Ig(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}Ig.isMDXComponent=!0;const Wg={toc:[]};function Pg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Wg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}Pg.isMDXComponent=!0;const Gg={toc:[]};function Fg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}Fg.isMDXComponent=!0;const Ug={toc:[]};function jg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ug,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Image#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}jg.isMDXComponent=!0;const Vg={toc:[]};function qg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}qg.isMDXComponent=!0;const Bg={toc:[]};function Og(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}Og.isMDXComponent=!0;const $g={toc:[]};function Hg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$g,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Hg.isMDXComponent=!0;const Yg={toc:[]};function Kg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Image#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}Kg.isMDXComponent=!0;const Jg={toc:[]};function Qg(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jg,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}Qg.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}ox.isMDXComponent=!0;const px={toc:[]};function cx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}cx.isMDXComponent=!0;const rx={toc:[]};function sx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}sx.isMDXComponent=!0;const ax={toc:[]};function ix(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}ix.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}dx.isMDXComponent=!0;const hx={toc:[]};function kx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kx.isMDXComponent=!0;const yx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}fx.isMDXComponent=!0;const Mx={toc:[]};function wx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}wx.isMDXComponent=!0;const Dx={toc:[]};function _x(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Dx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}gx.isMDXComponent=!0;const xx={toc:[]};function Cx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}Cx.isMDXComponent=!0;const Tx={toc:[]};function Lx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function vx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}vx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Nx.isMDXComponent=!0;const Ex={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ex,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Ax.isMDXComponent=!0;const Rx={toc:[]};function zx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}zx.isMDXComponent=!0;const Sx={toc:[]};function Ix(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}Ix.isMDXComponent=!0;const Wx={toc:[]};function Px(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Wx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Px.isMDXComponent=!0;const Gx={toc:[]};function Fx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}Fx.isMDXComponent=!0;const Ux={toc:[]};function jx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ux,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jx.isMDXComponent=!0;const Vx={toc:[]};function qx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}qx.isMDXComponent=!0;const Bx={toc:[]};function Ox(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Ox.isMDXComponent=!0;const $x={toc:[]};function Hx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$x,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}Hx.isMDXComponent=!0;const Yx={toc:[]};function Kx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Kx.isMDXComponent=!0;const Jx={toc:[]};function Qx(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jx,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Qx.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}oC.isMDXComponent=!0;const pC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}cC.isMDXComponent=!0;const rC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}sC.isMDXComponent=!0;const aC={toc:[]};function iC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}iC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}dC.isMDXComponent=!0;const hC={toc:[]};function kC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given position."))}kC.isMDXComponent=!0;const yC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The position in local space at which to sample the color."))}fC.isMDXComponent=!0;const MC={toc:[]};function wC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given pixel."))}wC.isMDXComponent=!0;const DC={toc:[]};function _C(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The pixel's position."))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}gC.isMDXComponent=!0;const xC={toc:[]};function CC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}CC.isMDXComponent=!0;const TC={toc:[]};function LC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}LC.isMDXComponent=!0;const ZC={toc:[]};function vC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}vC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}NC.isMDXComponent=!0;const EC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}AC.isMDXComponent=!0;const RC={toc:[]};function zC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}zC.isMDXComponent=!0;const SC={toc:[]};function IC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}IC.isMDXComponent=!0;const WC={toc:[]};function PC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}PC.isMDXComponent=!0;const GC={toc:[]};function FC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}FC.isMDXComponent=!0;const UC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}jC.isMDXComponent=!0;const VC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}qC.isMDXComponent=!0;const BC={toc:[]};function OC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}OC.isMDXComponent=!0;const $C={toc:[]};function HC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$C,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}HC.isMDXComponent=!0;const YC={toc:[]};function KC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}KC.isMDXComponent=!0;const JC={toc:[]};function QC(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JC,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}QC.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}oT.isMDXComponent=!0;const pT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}cT.isMDXComponent=!0;const rT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}sT.isMDXComponent=!0;const aT={toc:[]};function iT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}iT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dT.isMDXComponent=!0;const hT={toc:[]};function kT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}kT.isMDXComponent=!0;const yT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}fT.isMDXComponent=!0;const MT={toc:[]};function wT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}wT.isMDXComponent=!0;const DT={toc:[]};function _T(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}gT.isMDXComponent=!0;const xT={toc:[]};function CT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}CT.isMDXComponent=!0;const TT={toc:[]};function LT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}LT.isMDXComponent=!0;const ZT={toc:[]};function vT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}vT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}NT.isMDXComponent=!0;const ET={toc:[]};function AT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ET,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}AT.isMDXComponent=!0;const RT={toc:[]};function zT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}zT.isMDXComponent=!0;const ST={toc:[]};function IT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ST,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}IT.isMDXComponent=!0;const WT={toc:[]};function PT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}PT.isMDXComponent=!0;const GT={toc:[]};function FT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}FT.isMDXComponent=!0;const UT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}jT.isMDXComponent=!0;const VT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qT.isMDXComponent=!0;const BT={toc:[]};function OT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}OT.isMDXComponent=!0;const $T={toc:[]};function HT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$T,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}HT.isMDXComponent=!0;const YT={toc:[]};function KT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}KT.isMDXComponent=!0;const JT={toc:[]};function QT(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JT,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}QT.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oL.isMDXComponent=!0;const pL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}cL.isMDXComponent=!0;const rL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}sL.isMDXComponent=!0;const aL={toc:[]};function iL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}iL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}dL.isMDXComponent=!0;const hL={toc:[]};function kL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}kL.isMDXComponent=!0;const yL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}fL.isMDXComponent=!0;const ML={toc:[]};function wL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ML,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}wL.isMDXComponent=!0;const DL={toc:[]};function _L(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}gL.isMDXComponent=!0;const xL={toc:[]};function CL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}CL.isMDXComponent=!0;const TL={toc:[]};function LL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}LL.isMDXComponent=!0;const ZL={toc:[]};function vL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}vL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}NL.isMDXComponent=!0;const EL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}AL.isMDXComponent=!0;const RL={toc:[]};function zL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}zL.isMDXComponent=!0;const SL={toc:[]};function IL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}IL.isMDXComponent=!0;const WL={toc:[]};function PL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}PL.isMDXComponent=!0;const GL={toc:[]};function FL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}FL.isMDXComponent=!0;const UL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}jL.isMDXComponent=!0;const VL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}qL.isMDXComponent=!0;const BL={toc:[]};function OL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}OL.isMDXComponent=!0;const $L={toc:[]};function HL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$L,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}HL.isMDXComponent=!0;const YL={toc:[]};function KL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}KL.isMDXComponent=!0;const JL={toc:[]};function QL(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JL,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}QL.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}cZ.isMDXComponent=!0;const rZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function iZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}iZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function kZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}kZ.isMDXComponent=!0;const yZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}fZ.isMDXComponent=!0;const MZ={toc:[]};function wZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}wZ.isMDXComponent=!0;const DZ={toc:[]};function _Z(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}gZ.isMDXComponent=!0;const xZ={toc:[]};function CZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}CZ.isMDXComponent=!0;const TZ={toc:[]};function LZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function vZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}vZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}NZ.isMDXComponent=!0;const EZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}AZ.isMDXComponent=!0;const RZ={toc:[]};function zZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}zZ.isMDXComponent=!0;const SZ={toc:[]};function IZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}IZ.isMDXComponent=!0;const WZ={toc:[]};function PZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}PZ.isMDXComponent=!0;const GZ={toc:[]};function FZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}FZ.isMDXComponent=!0;const UZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}jZ.isMDXComponent=!0;const VZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}qZ.isMDXComponent=!0;const BZ={toc:[]};function OZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}OZ.isMDXComponent=!0;const $Z={toc:[]};function HZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$Z,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}HZ.isMDXComponent=!0;const YZ={toc:[]};function KZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given position."))}KZ.isMDXComponent=!0;const JZ={toc:[]};function QZ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JZ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The position in local space at which to sample the color."))}QZ.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get color of the image at the given pixel."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The pixel's position."))}ov.isMDXComponent=!0;const pv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}cv.isMDXComponent=!0;const rv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}sv.isMDXComponent=!0;const av={toc:[]};function iv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}iv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}dv.isMDXComponent=!0;const hv={toc:[]};function kv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}kv.isMDXComponent=!0;const yv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}fv.isMDXComponent=!0;const Mv={toc:[]};function wv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}wv.isMDXComponent=!0;const Dv={toc:[]};function _v(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Dv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}gv.isMDXComponent=!0;const xv={toc:[]};function Cv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}Cv.isMDXComponent=!0;const Tv={toc:[]};function Lv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function vv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}vv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}Nv.isMDXComponent=!0;const Ev={toc:[]};function Av(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ev,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}Av.isMDXComponent=!0;const Rv={toc:[]};function zv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}zv.isMDXComponent=!0;const Sv={toc:[]};function Iv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}Iv.isMDXComponent=!0;const Wv={toc:[]};function Pv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Wv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}Pv.isMDXComponent=!0;const Gv={toc:[]};function Fv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Fv.isMDXComponent=!0;const Uv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Uv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}jv.isMDXComponent=!0;const Vv={toc:[]};function qv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qv.isMDXComponent=!0;const Bv={toc:[]};function Ov(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}Ov.isMDXComponent=!0;const $v={toc:[]};function Hv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$v,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Hv.isMDXComponent=!0;const Yv={toc:[]};function Kv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Kv.isMDXComponent=!0;const Jv={toc:[]};function Qv(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jv,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Qv.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ob.isMDXComponent=!0;const pb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}cb.isMDXComponent=!0;const rb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sb.isMDXComponent=!0;const ab={toc:[]};function ib(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}ib.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}db.isMDXComponent=!0;const hb={toc:[]};function kb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}kb.isMDXComponent=!0;const yb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}fb.isMDXComponent=!0;const Mb={toc:[]};function wb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}wb.isMDXComponent=!0;const Db={toc:[]};function _b(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Db,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gb.isMDXComponent=!0;const xb={toc:[]};function Cb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}Cb.isMDXComponent=!0;const Tb={toc:[]};function Lb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function vb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}vb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}Nb.isMDXComponent=!0;const Eb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Eb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ab.isMDXComponent=!0;const Rb={toc:[]};function zb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}zb.isMDXComponent=!0;const Sb={toc:[]};function Ib(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}Ib.isMDXComponent=!0;const Wb={toc:[]};function Pb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Wb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Pb.isMDXComponent=!0;const Gb={toc:[]};function Fb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Fb.isMDXComponent=!0;const Ub={toc:[]};function jb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ub,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}jb.isMDXComponent=!0;const Vb={toc:[]};function qb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qb.isMDXComponent=!0;const Bb={toc:[]};function Ob(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Ob.isMDXComponent=!0;const $b={toc:[]};function Hb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$b,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}Hb.isMDXComponent=!0;const Yb={toc:[]};function Kb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Kb.isMDXComponent=!0;const Jb={toc:[]};function Qb(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jb,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Qb.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oN.isMDXComponent=!0;const pN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}cN.isMDXComponent=!0;const rN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}sN.isMDXComponent=!0;const aN={toc:[]};function iN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}iN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dN.isMDXComponent=!0;const hN={toc:[]};function kN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}kN.isMDXComponent=!0;const yN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}fN.isMDXComponent=!0;const MN={toc:[]};function wN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}wN.isMDXComponent=!0;const DN={toc:[]};function _N(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gN.isMDXComponent=!0;const xN={toc:[]};function CN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}CN.isMDXComponent=!0;const TN={toc:[]};function LN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}LN.isMDXComponent=!0;const ZN={toc:[]};function vN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}vN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NN.isMDXComponent=!0;const EN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}AN.isMDXComponent=!0;const RN={toc:[]};function zN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}zN.isMDXComponent=!0;const SN={toc:[]};function IN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}IN.isMDXComponent=!0;const WN={toc:[]};function PN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}PN.isMDXComponent=!0;const GN={toc:[]};function FN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FN.isMDXComponent=!0;const UN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}jN.isMDXComponent=!0;const VN={toc:[]};function qN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}qN.isMDXComponent=!0;const BN={toc:[]};function ON(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}ON.isMDXComponent=!0;const $N={toc:[]};function HN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$N,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}HN.isMDXComponent=!0;const YN={toc:[]};function KN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}KN.isMDXComponent=!0;const JN={toc:[]};function QN(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JN,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}QN.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}oE.isMDXComponent=!0;const pE={toc:[]};function cE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}cE.isMDXComponent=!0;const rE={toc:[]};function sE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}sE.isMDXComponent=!0;const aE={toc:[]};function iE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}iE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}dE.isMDXComponent=!0;const hE={toc:[]};function kE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}kE.isMDXComponent=!0;const yE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}fE.isMDXComponent=!0;const ME={toc:[]};function wE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ME,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}wE.isMDXComponent=!0;const DE={toc:[]};function _E(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}gE.isMDXComponent=!0;const xE={toc:[]};function CE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}CE.isMDXComponent=!0;const TE={toc:[]};function LE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}LE.isMDXComponent=!0;const ZE={toc:[]};function vE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}vE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}NE.isMDXComponent=!0;const EE={toc:[]};function AE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}AE.isMDXComponent=!0;const RE={toc:[]};function zE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}zE.isMDXComponent=!0;const SE={toc:[]};function IE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}IE.isMDXComponent=!0;const WE={toc:[]};function PE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}PE.isMDXComponent=!0;const GE={toc:[]};function FE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}FE.isMDXComponent=!0;const UE={toc:[]};function jE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}jE.isMDXComponent=!0;const VE={toc:[]};function qE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}qE.isMDXComponent=!0;const BE={toc:[]};function OE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}OE.isMDXComponent=!0;const $E={toc:[]};function HE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$E,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}HE.isMDXComponent=!0;const YE={toc:[]};function KE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}KE.isMDXComponent=!0;const JE={toc:[]};function QE(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JE,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}QE.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}oA.isMDXComponent=!0;const pA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}cA.isMDXComponent=!0;const rA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}sA.isMDXComponent=!0;const aA={toc:[]};function iA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}iA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}dA.isMDXComponent=!0;const hA={toc:[]};function kA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}kA.isMDXComponent=!0;const yA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}fA.isMDXComponent=!0;const MA={toc:[]};function wA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}wA.isMDXComponent=!0;const DA={toc:[]};function _A(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gA.isMDXComponent=!0;const xA={toc:[]};function CA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}CA.isMDXComponent=!0;const TA={toc:[]};function LA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}LA.isMDXComponent=!0;const ZA={toc:[]};function vA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}vA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NA.isMDXComponent=!0;const EA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}AA.isMDXComponent=!0;const RA={toc:[]};function zA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zA.isMDXComponent=!0;const SA={toc:[]};function IA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}IA.isMDXComponent=!0;const WA={toc:[]};function PA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}PA.isMDXComponent=!0;const GA={toc:[]};function FA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}FA.isMDXComponent=!0;const UA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}jA.isMDXComponent=!0;const VA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}qA.isMDXComponent=!0;const BA={toc:[]};function OA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}OA.isMDXComponent=!0;const $A={toc:[]};function HA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$A,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}HA.isMDXComponent=!0;const YA={toc:[]};function KA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}KA.isMDXComponent=!0;const JA={toc:[]};function QA(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JA,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}QA.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oR.isMDXComponent=!0;const pR={toc:[]};function cR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}cR.isMDXComponent=!0;const rR={toc:[]};function sR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sR.isMDXComponent=!0;const aR={toc:[]};function iR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dR.isMDXComponent=!0;const hR={toc:[]};function kR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}kR.isMDXComponent=!0;const yR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}fR.isMDXComponent=!0;const MR={toc:[]};function wR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}wR.isMDXComponent=!0;const DR={toc:[]};function _R(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}gR.isMDXComponent=!0;const xR={toc:[]};function CR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}CR.isMDXComponent=!0;const TR={toc:[]};function LR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}LR.isMDXComponent=!0;const ZR={toc:[]};function vR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}vR.isMDXComponent=!0;const bR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NR.isMDXComponent=!0;const ER={toc:[]};function AR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ER,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}AR.isMDXComponent=!0;const RR={toc:[]};function zR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}zR.isMDXComponent=!0;const SR={toc:[]};function IR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}IR.isMDXComponent=!0;const WR={toc:[]};function PR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PR.isMDXComponent=!0;const GR={toc:[]};function FR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}FR.isMDXComponent=!0;const UR={toc:[]};function jR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}jR.isMDXComponent=!0;const VR={toc:[]};function qR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}qR.isMDXComponent=!0;const BR={toc:[]};function OR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}OR.isMDXComponent=!0;const $R={toc:[]};function HR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$R,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}HR.isMDXComponent=!0;const YR={toc:[]};function KR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}KR.isMDXComponent=!0;const JR={toc:[]};function QR(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JR,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}QR.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oz.isMDXComponent=!0;const pz={toc:[]};function cz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}cz.isMDXComponent=!0;const rz={toc:[]};function sz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}sz.isMDXComponent=!0;const az={toc:[]};function iz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},az,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}iz.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}dz.isMDXComponent=!0;const hz={toc:[]};function kz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}kz.isMDXComponent=!0;const yz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}fz.isMDXComponent=!0;const Mz={toc:[]};function wz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}wz.isMDXComponent=!0;const Dz={toc:[]};function _z(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Dz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gz.isMDXComponent=!0;const xz={toc:[]};function Cz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Cz.isMDXComponent=!0;const Tz={toc:[]};function Lz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Lz.isMDXComponent=!0;const Zz={toc:[]};function vz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}vz.isMDXComponent=!0;const bz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Nz.isMDXComponent=!0;const Ez={toc:[]};function Az(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ez,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}Az.isMDXComponent=!0;const Rz={toc:[]};function zz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}zz.isMDXComponent=!0;const Sz={toc:[]};function Iz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}Iz.isMDXComponent=!0;const Wz={toc:[]};function Pz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Wz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Pz.isMDXComponent=!0;const Gz={toc:[]};function Fz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}Fz.isMDXComponent=!0;const Uz={toc:[]};function jz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Uz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}jz.isMDXComponent=!0;const Vz={toc:[]};function qz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qz.isMDXComponent=!0;const Bz={toc:[]};function Oz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}Oz.isMDXComponent=!0;const $z={toc:[]};function Hz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$z,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Hz.isMDXComponent=!0;const Yz={toc:[]};function Kz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}Kz.isMDXComponent=!0;const Jz={toc:[]};function Qz(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jz,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}Qz.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}oS.isMDXComponent=!0;const pS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}cS.isMDXComponent=!0;const rS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}sS.isMDXComponent=!0;const aS={toc:[]};function iS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}iS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dS.isMDXComponent=!0;const hS={toc:[]};function kS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}kS.isMDXComponent=!0;const yS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}fS.isMDXComponent=!0;const MS={toc:[]};function wS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}wS.isMDXComponent=!0;const DS={toc:[]};function _S(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gS.isMDXComponent=!0;const xS={toc:[]};function CS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}CS.isMDXComponent=!0;const TS={toc:[]};function LS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}LS.isMDXComponent=!0;const ZS={toc:[]};function vS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}vS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}NS.isMDXComponent=!0;const ES={toc:[]};function AS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ES,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}AS.isMDXComponent=!0;const RS={toc:[]};function zS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}zS.isMDXComponent=!0;const SS={toc:[]};function IS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}IS.isMDXComponent=!0;const WS={toc:[]};function PS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}PS.isMDXComponent=!0;const GS={toc:[]};function FS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}FS.isMDXComponent=!0;const US={toc:[]};function jS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},US,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jS.isMDXComponent=!0;const VS={toc:[]};function qS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}qS.isMDXComponent=!0;const BS={toc:[]};function OS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}OS.isMDXComponent=!0;const $S={toc:[]};function HS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$S,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}HS.isMDXComponent=!0;const YS={toc:[]};function KS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}KS.isMDXComponent=!0;const JS={toc:[]};function QS(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JS,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}QS.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}oI.isMDXComponent=!0;const pI={toc:[]};function cI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}cI.isMDXComponent=!0;const rI={toc:[]};function sI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}sI.isMDXComponent=!0;const aI={toc:[]};function iI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}iI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}dI.isMDXComponent=!0;const hI={toc:[]};function kI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}kI.isMDXComponent=!0;const yI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}fI.isMDXComponent=!0;const MI={toc:[]};function wI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}wI.isMDXComponent=!0;const DI={toc:[]};function _I(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}gI.isMDXComponent=!0;const xI={toc:[]};function CI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}CI.isMDXComponent=!0;const TI={toc:[]};function LI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}LI.isMDXComponent=!0;const ZI={toc:[]};function vI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vI.isMDXComponent=!0;const bI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}NI.isMDXComponent=!0;const EI={toc:[]};function AI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}AI.isMDXComponent=!0;const RI={toc:[]};function zI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zI.isMDXComponent=!0;const SI={toc:[]};function II(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}II.isMDXComponent=!0;const WI={toc:[]};function PI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}PI.isMDXComponent=!0;const GI={toc:[]};function FI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}FI.isMDXComponent=!0;const UI={toc:[]};function jI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}jI.isMDXComponent=!0;const VI={toc:[]};function qI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}qI.isMDXComponent=!0;const BI={toc:[]};function OI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}OI.isMDXComponent=!0;const $I={toc:[]};function HI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$I,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}HI.isMDXComponent=!0;const YI={toc:[]};function KI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}KI.isMDXComponent=!0;const JI={toc:[]};function QI(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JI,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}QI.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}oW.isMDXComponent=!0;const pW={toc:[]};function cW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}cW.isMDXComponent=!0;const rW={toc:[]};function sW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}sW.isMDXComponent=!0;const aW={toc:[]};function iW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}iW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}dW.isMDXComponent=!0;const hW={toc:[]};function kW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}kW.isMDXComponent=!0;const yW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}fW.isMDXComponent=!0;const MW={toc:[]};function wW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}wW.isMDXComponent=!0;const DW={toc:[]};function _W(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}gW.isMDXComponent=!0;const xW={toc:[]};function CW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}CW.isMDXComponent=!0;const TW={toc:[]};function LW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}LW.isMDXComponent=!0;const ZW={toc:[]};function vW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}vW.isMDXComponent=!0;const bW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}NW.isMDXComponent=!0;const EW={toc:[]};function AW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}AW.isMDXComponent=!0;const RW={toc:[]};function zW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}zW.isMDXComponent=!0;const SW={toc:[]};function IW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}IW.isMDXComponent=!0;const WW={toc:[]};function PW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}PW.isMDXComponent=!0;const GW={toc:[]};function FW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}FW.isMDXComponent=!0;const UW={toc:[]};function jW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}jW.isMDXComponent=!0;const VW={toc:[]};function qW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}qW.isMDXComponent=!0;const BW={toc:[]};function OW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}OW.isMDXComponent=!0;const $W={toc:[]};function HW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$W,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}HW.isMDXComponent=!0;const YW={toc:[]};function KW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}KW.isMDXComponent=!0;const JW={toc:[]};function QW(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JW,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}QW.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}oP.isMDXComponent=!0;const pP={toc:[]};function cP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}cP.isMDXComponent=!0;const rP={toc:[]};function sP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}sP.isMDXComponent=!0;const aP={toc:[]};function iP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}iP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}dP.isMDXComponent=!0;const hP={toc:[]};function kP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}kP.isMDXComponent=!0;const yP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}fP.isMDXComponent=!0;const MP={toc:[]};function wP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}wP.isMDXComponent=!0;const DP={toc:[]};function _P(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}gP.isMDXComponent=!0;const xP={toc:[]};function CP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}CP.isMDXComponent=!0;const TP={toc:[]};function LP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}LP.isMDXComponent=!0;const ZP={toc:[]};function vP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}vP.isMDXComponent=!0;const bP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}NP.isMDXComponent=!0;const EP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}AP.isMDXComponent=!0;const RP={toc:[]};function zP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}zP.isMDXComponent=!0;const SP={toc:[]};function IP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}IP.isMDXComponent=!0;const WP={toc:[]};function PP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}PP.isMDXComponent=!0;const GP={toc:[]};function FP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}FP.isMDXComponent=!0;const UP={toc:[]};function jP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}jP.isMDXComponent=!0;const VP={toc:[]};function qP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}qP.isMDXComponent=!0;const BP={toc:[]};function OP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}OP.isMDXComponent=!0;const $P={toc:[]};function HP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$P,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}HP.isMDXComponent=!0;const YP={toc:[]};function KP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}KP.isMDXComponent=!0;const JP={toc:[]};function QP(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JP,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}QP.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}oG.isMDXComponent=!0;const pG={toc:[]};function cG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}cG.isMDXComponent=!0;const rG={toc:[]};function sG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sG.isMDXComponent=!0;const aG={toc:[]};function iG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}iG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}dG.isMDXComponent=!0;const hG={toc:[]};function kG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}kG.isMDXComponent=!0;const yG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}fG.isMDXComponent=!0;const MG={toc:[]};function wG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}wG.isMDXComponent=!0;const DG={toc:[]};function _G(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}gG.isMDXComponent=!0;const xG={toc:[]};function CG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}CG.isMDXComponent=!0;const TG={toc:[]};function LG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}LG.isMDXComponent=!0;const ZG={toc:[]};function vG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}vG.isMDXComponent=!0;const bG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}NG.isMDXComponent=!0;const EG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}AG.isMDXComponent=!0;const RG={toc:[]};function zG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zG.isMDXComponent=!0;const SG={toc:[]};function IG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}IG.isMDXComponent=!0;const WG={toc:[]};function PG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}PG.isMDXComponent=!0;const GG={toc:[]};function FG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}FG.isMDXComponent=!0;const UG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}jG.isMDXComponent=!0;const VG={toc:[]};function qG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}qG.isMDXComponent=!0;const BG={toc:[]};function OG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}OG.isMDXComponent=!0;const $G={toc:[]};function HG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$G,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}HG.isMDXComponent=!0;const YG={toc:[]};function KG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}KG.isMDXComponent=!0;const JG={toc:[]};function QG(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JG,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}QG.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}oF.isMDXComponent=!0;const pF={toc:[]};function cF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}cF.isMDXComponent=!0;const rF={toc:[]};function sF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}sF.isMDXComponent=!0;const aF={toc:[]};function iF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}iF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}dF.isMDXComponent=!0;const hF={toc:[]};function kF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}kF.isMDXComponent=!0;const yF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}fF.isMDXComponent=!0;const MF={toc:[]};function wF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}wF.isMDXComponent=!0;const DF={toc:[]};function _F(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}gF.isMDXComponent=!0;const xF={toc:[]};function CF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}CF.isMDXComponent=!0;const TF={toc:[]};function LF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}LF.isMDXComponent=!0;const ZF={toc:[]};function vF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}vF.isMDXComponent=!0;const bF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}NF.isMDXComponent=!0;const EF={toc:[]};function AF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}AF.isMDXComponent=!0;const RF={toc:[]};function zF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}zF.isMDXComponent=!0;const SF={toc:[]};function IF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}IF.isMDXComponent=!0;const WF={toc:[]};function PF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}PF.isMDXComponent=!0;const GF={toc:[]};function FF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}FF.isMDXComponent=!0;const UF={toc:[]};function jF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}jF.isMDXComponent=!0;const VF={toc:[]};function qF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}qF.isMDXComponent=!0;const BF={toc:[]};function OF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}OF.isMDXComponent=!0;const $F={toc:[]};function HF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$F,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}HF.isMDXComponent=!0;const YF={toc:[]};function KF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}KF.isMDXComponent=!0;const JF={toc:[]};function QF(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JF,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}QF.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}oU.isMDXComponent=!0;const pU={toc:[]};function cU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}cU.isMDXComponent=!0;const rU={toc:[]};function sU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}sU.isMDXComponent=!0;const aU={toc:[]};function iU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}iU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dU.isMDXComponent=!0;const hU={toc:[]};function kU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}kU.isMDXComponent=!0;const yU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}fU.isMDXComponent=!0;const MU={toc:[]};function wU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}wU.isMDXComponent=!0;const DU={toc:[]};function _U(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}gU.isMDXComponent=!0;const xU={toc:[]};function CU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}CU.isMDXComponent=!0;const TU={toc:[]};function LU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}LU.isMDXComponent=!0;const ZU={toc:[]};function vU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}vU.isMDXComponent=!0;const bU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}NU.isMDXComponent=!0;const EU={toc:[]};function AU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}AU.isMDXComponent=!0;const RU={toc:[]};function zU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}zU.isMDXComponent=!0;const SU={toc:[]};function IU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}IU.isMDXComponent=!0;const WU={toc:[]};function PU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}PU.isMDXComponent=!0;const GU={toc:[]};function FU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}FU.isMDXComponent=!0;const UU={toc:[]};function jU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jU.isMDXComponent=!0;const VU={toc:[]};function qU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qU.isMDXComponent=!0;const BU={toc:[]};function OU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}OU.isMDXComponent=!0;const $U={toc:[]};function HU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$U,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}HU.isMDXComponent=!0;const YU={toc:[]};function KU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}KU.isMDXComponent=!0;const JU={toc:[]};function QU(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JU,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}QU.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}oj.isMDXComponent=!0;const pj={toc:[]};function cj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}cj.isMDXComponent=!0;const rj={toc:[]};function sj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}sj.isMDXComponent=!0;const aj={toc:[]};function ij(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}ij.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}dj.isMDXComponent=!0;const hj={toc:[]};function kj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}kj.isMDXComponent=!0;const yj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}fj.isMDXComponent=!0;const Mj={toc:[]};function wj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}wj.isMDXComponent=!0;const Dj={toc:[]};function _j(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Dj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}gj.isMDXComponent=!0;const xj={toc:[]};function Cj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Cj.isMDXComponent=!0;const Tj={toc:[]};function Lj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function vj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}vj.isMDXComponent=!0;const bj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Nj.isMDXComponent=!0;const Ej={toc:[]};function Aj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Ej,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Aj.isMDXComponent=!0;const Rj={toc:[]};function zj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}zj.isMDXComponent=!0;const Sj={toc:[]};function Ij(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Ij.isMDXComponent=!0;const Wj={toc:[]};function Pj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Wj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}Pj.isMDXComponent=!0;const Gj={toc:[]};function Fj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Fj.isMDXComponent=!0;const Uj={toc:[]};function jj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Uj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}jj.isMDXComponent=!0;const Vj={toc:[]};function qj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}qj.isMDXComponent=!0;const Bj={toc:[]};function Oj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}Oj.isMDXComponent=!0;const $j={toc:[]};function Hj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$j,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}Hj.isMDXComponent=!0;const Yj={toc:[]};function Kj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}Kj.isMDXComponent=!0;const Jj={toc:[]};function Qj(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jj,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Qj.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}oV.isMDXComponent=!0;const pV={toc:[]};function cV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}cV.isMDXComponent=!0;const rV={toc:[]};function sV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}sV.isMDXComponent=!0;const aV={toc:[]};function iV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}iV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dV.isMDXComponent=!0;const hV={toc:[]};function kV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}kV.isMDXComponent=!0;const yV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}fV.isMDXComponent=!0;const MV={toc:[]};function wV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}wV.isMDXComponent=!0;const DV={toc:[]};function _V(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}gV.isMDXComponent=!0;const xV={toc:[]};function CV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}CV.isMDXComponent=!0;const TV={toc:[]};function LV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}LV.isMDXComponent=!0;const ZV={toc:[]};function vV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}vV.isMDXComponent=!0;const bV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}NV.isMDXComponent=!0;const EV={toc:[]};function AV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}AV.isMDXComponent=!0;const RV={toc:[]};function zV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}zV.isMDXComponent=!0;const SV={toc:[]};function IV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}IV.isMDXComponent=!0;const WV={toc:[]};function PV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}PV.isMDXComponent=!0;const GV={toc:[]};function FV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}FV.isMDXComponent=!0;const UV={toc:[]};function jV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}jV.isMDXComponent=!0;const VV={toc:[]};function qV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}qV.isMDXComponent=!0;const BV={toc:[]};function OV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}OV.isMDXComponent=!0;const $V={toc:[]};function HV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$V,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}HV.isMDXComponent=!0;const YV={toc:[]};function KV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}KV.isMDXComponent=!0;const JV={toc:[]};function QV(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JV,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}QV.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}oq.isMDXComponent=!0;const pq={toc:[]};function cq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}cq.isMDXComponent=!0;const rq={toc:[]};function sq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}sq.isMDXComponent=!0;const aq={toc:[]};function iq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}iq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}dq.isMDXComponent=!0;const hq={toc:[]};function kq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}kq.isMDXComponent=!0;const yq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}fq.isMDXComponent=!0;const Mq={toc:[]};function wq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Mq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}wq.isMDXComponent=!0;const Dq={toc:[]};function _q(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Dq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Xq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}gq.isMDXComponent=!0;const xq={toc:[]};function Cq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}Cq.isMDXComponent=!0;const Tq={toc:[]};function Lq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Tq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Lq.isMDXComponent=!0;const Zq={toc:[]};function vq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Zq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}vq.isMDXComponent=!0;const bq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}Nq.isMDXComponent=!0;const Eq={toc:[]};function Aq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Eq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Aq.isMDXComponent=!0;const Rq={toc:[]};function zq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Rq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}zq.isMDXComponent=!0;const Sq={toc:[]};function Iq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Sq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Iq.isMDXComponent=!0;const Wq={toc:[]};function Pq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Wq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}Pq.isMDXComponent=!0;const Gq={toc:[]};function Fq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Gq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Fq.isMDXComponent=!0;const Uq={toc:[]};function jq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Uq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}jq.isMDXComponent=!0;const Vq={toc:[]};function qq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Vq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qq.isMDXComponent=!0;const Bq={toc:[]};function Oq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Bq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}Oq.isMDXComponent=!0;const $q={toc:[]};function Hq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$q,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}Hq.isMDXComponent=!0;const Yq={toc:[]};function Kq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Yq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Kq.isMDXComponent=!0;const Jq={toc:[]};function Qq(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Jq,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}Qq.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}oB.isMDXComponent=!0;const pB={toc:[]};function cB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}cB.isMDXComponent=!0;const rB={toc:[]};function sB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}sB.isMDXComponent=!0;const aB={toc:[]};function iB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}iB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}dB.isMDXComponent=!0;const hB={toc:[]};function kB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}kB.isMDXComponent=!0;const yB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fB.isMDXComponent=!0;const MB={toc:[]};function wB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}wB.isMDXComponent=!0;const DB={toc:[]};function _B(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}gB.isMDXComponent=!0;const xB={toc:[]};function CB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}CB.isMDXComponent=!0;const TB={toc:[]};function LB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}LB.isMDXComponent=!0;const ZB={toc:[]};function vB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}vB.isMDXComponent=!0;const bB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}NB.isMDXComponent=!0;const EB={toc:[]};function AB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}AB.isMDXComponent=!0;const RB={toc:[]};function zB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}zB.isMDXComponent=!0;const SB={toc:[]};function IB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}IB.isMDXComponent=!0;const WB={toc:[]};function PB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}PB.isMDXComponent=!0;const GB={toc:[]};function FB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}FB.isMDXComponent=!0;const UB={toc:[]};function jB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}jB.isMDXComponent=!0;const VB={toc:[]};function qB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}qB.isMDXComponent=!0;const BB={toc:[]};function OB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}OB.isMDXComponent=!0;const $B={toc:[]};function HB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$B,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}HB.isMDXComponent=!0;const YB={toc:[]};function KB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}KB.isMDXComponent=!0;const JB={toc:[]};function QB(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JB,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}QB.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}oO.isMDXComponent=!0;const pO={toc:[]};function cO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}cO.isMDXComponent=!0;const rO={toc:[]};function sO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}sO.isMDXComponent=!0;const aO={toc:[]};function iO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}iO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}dO.isMDXComponent=!0;const hO={toc:[]};function kO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}kO.isMDXComponent=!0;const yO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}fO.isMDXComponent=!0;const MO={toc:[]};function wO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}wO.isMDXComponent=!0;const DO={toc:[]};function _O(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}gO.isMDXComponent=!0;const xO={toc:[]};function CO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}CO.isMDXComponent=!0;const TO={toc:[]};function LO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}LO.isMDXComponent=!0;const ZO={toc:[]};function vO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}vO.isMDXComponent=!0;const bO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}NO.isMDXComponent=!0;const EO={toc:[]};function AO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}AO.isMDXComponent=!0;const RO={toc:[]};function zO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}zO.isMDXComponent=!0;const SO={toc:[]};function IO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}IO.isMDXComponent=!0;const WO={toc:[]};function PO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}PO.isMDXComponent=!0;const GO={toc:[]};function FO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}FO.isMDXComponent=!0;const UO={toc:[]};function jO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}jO.isMDXComponent=!0;const VO={toc:[]};function qO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}qO.isMDXComponent=!0;const BO={toc:[]};function OO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}OO.isMDXComponent=!0;const $O={toc:[]};function HO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$O,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}HO.isMDXComponent=!0;const YO={toc:[]};function KO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}KO.isMDXComponent=!0;const JO={toc:[]};function QO(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JO,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}QO.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}o$.isMDXComponent=!0;const p$={toc:[]};function c$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}c$.isMDXComponent=!0;const r$={toc:[]};function s$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},r$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}s$.isMDXComponent=!0;const a$={toc:[]};function i$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},a$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}i$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}d$.isMDXComponent=!0;const h$={toc:[]};function k$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Text#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}k$.isMDXComponent=!0;const y$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},y$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}f$.isMDXComponent=!0;const M$={toc:[]};function w$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},M$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}w$.isMDXComponent=!0;const D$={toc:[]};function _$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},D$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},X$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Text#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}g$.isMDXComponent=!0;const x$={toc:[]};function C$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},x$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}C$.isMDXComponent=!0;const T$={toc:[]};function L$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},T$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}L$.isMDXComponent=!0;const Z$={toc:[]};function v$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Z$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}v$.isMDXComponent=!0;const b$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},b$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}N$.isMDXComponent=!0;const E$={toc:[]};function A$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},E$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}A$.isMDXComponent=!0;const R$={toc:[]};function z$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},R$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}z$.isMDXComponent=!0;const S$={toc:[]};function I$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},S$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}I$.isMDXComponent=!0;const W$={toc:[]};function P$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},W$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}P$.isMDXComponent=!0;const G$={toc:[]};function F$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},G$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}F$.isMDXComponent=!0;const U$={toc:[]};function j$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},U$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}j$.isMDXComponent=!0;const V$={toc:[]};function q$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},V$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}q$.isMDXComponent=!0;const B$={toc:[]};function O$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},B$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}O$.isMDXComponent=!0;const $$={toc:[]};function H$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}H$.isMDXComponent=!0;const Y$={toc:[]};function K$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Y$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}K$.isMDXComponent=!0;const J$={toc:[]};function Q$(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},J$,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}Q$.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}oH.isMDXComponent=!0;const pH={toc:[]};function cH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}cH.isMDXComponent=!0;const rH={toc:[]};function sH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}sH.isMDXComponent=!0;const aH={toc:[]};function iH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}iH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}dH.isMDXComponent=!0;const hH={toc:[]};function kH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}kH.isMDXComponent=!0;const yH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}fH.isMDXComponent=!0;const MH={toc:[]};function wH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wH.isMDXComponent=!0;const DH={toc:[]};function _H(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}gH.isMDXComponent=!0;const xH={toc:[]};function CH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}CH.isMDXComponent=!0;const TH={toc:[]};function LH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}LH.isMDXComponent=!0;const ZH={toc:[]};function vH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}vH.isMDXComponent=!0;const bH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}NH.isMDXComponent=!0;const EH={toc:[]};function AH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}AH.isMDXComponent=!0;const RH={toc:[]};function zH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}zH.isMDXComponent=!0;const SH={toc:[]};function IH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}IH.isMDXComponent=!0;const WH={toc:[]};function PH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}PH.isMDXComponent=!0;const GH={toc:[]};function FH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}FH.isMDXComponent=!0;const UH={toc:[]};function jH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}jH.isMDXComponent=!0;const VH={toc:[]};function qH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}qH.isMDXComponent=!0;const BH={toc:[]};function OH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}OH.isMDXComponent=!0;const $H={toc:[]};function HH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$H,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}HH.isMDXComponent=!0;const YH={toc:[]};function KH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}KH.isMDXComponent=!0;const JH={toc:[]};function QH(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JH,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}QH.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}oY.isMDXComponent=!0;const pY={toc:[]};function cY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}cY.isMDXComponent=!0;const rY={toc:[]};function sY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}sY.isMDXComponent=!0;const aY={toc:[]};function iY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}iY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}dY.isMDXComponent=!0;const hY={toc:[]};function kY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}kY.isMDXComponent=!0;const yY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}fY.isMDXComponent=!0;const MY={toc:[]};function wY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}wY.isMDXComponent=!0;const DY={toc:[]};function _Y(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gY.isMDXComponent=!0;const xY={toc:[]};function CY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}CY.isMDXComponent=!0;const TY={toc:[]};function LY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}LY.isMDXComponent=!0;const ZY={toc:[]};function vY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}vY.isMDXComponent=!0;const bY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}NY.isMDXComponent=!0;const EY={toc:[]};function AY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}AY.isMDXComponent=!0;const RY={toc:[]};function zY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}zY.isMDXComponent=!0;const SY={toc:[]};function IY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}IY.isMDXComponent=!0;const WY={toc:[]};function PY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}PY.isMDXComponent=!0;const GY={toc:[]};function FY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}FY.isMDXComponent=!0;const UY={toc:[]};function jY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jY.isMDXComponent=!0;const VY={toc:[]};function qY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}qY.isMDXComponent=!0;const BY={toc:[]};function OY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}OY.isMDXComponent=!0;const $Y={toc:[]};function HY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$Y,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}HY.isMDXComponent=!0;const YY={toc:[]};function KY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}KY.isMDXComponent=!0;const JY={toc:[]};function QY(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JY,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}QY.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}oK.isMDXComponent=!0;const pK={toc:[]};function cK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}cK.isMDXComponent=!0;const rK={toc:[]};function sK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}sK.isMDXComponent=!0;const aK={toc:[]};function iK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}iK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}dK.isMDXComponent=!0;const hK={toc:[]};function kK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}kK.isMDXComponent=!0;const yK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}fK.isMDXComponent=!0;const MK={toc:[]};function wK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}wK.isMDXComponent=!0;const DK={toc:[]};function _K(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}gK.isMDXComponent=!0;const xK={toc:[]};function CK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}CK.isMDXComponent=!0;const TK={toc:[]};function LK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LK.isMDXComponent=!0;const ZK={toc:[]};function vK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}vK.isMDXComponent=!0;const bK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}NK.isMDXComponent=!0;const EK={toc:[]};function AK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}AK.isMDXComponent=!0;const RK={toc:[]};function zK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}zK.isMDXComponent=!0;const SK={toc:[]};function IK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}IK.isMDXComponent=!0;const WK={toc:[]};function PK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}PK.isMDXComponent=!0;const GK={toc:[]};function FK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}FK.isMDXComponent=!0;const UK={toc:[]};function jK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}jK.isMDXComponent=!0;const VK={toc:[]};function qK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}qK.isMDXComponent=!0;const BK={toc:[]};function OK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}OK.isMDXComponent=!0;const $K={toc:[]};function HK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$K,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}HK.isMDXComponent=!0;const YK={toc:[]};function KK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}KK.isMDXComponent=!0;const JK={toc:[]};function QK(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JK,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}QK.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function cJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}cJ.isMDXComponent=!0;const rJ={toc:[]};function sJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}sJ.isMDXComponent=!0;const aJ={toc:[]};function iJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}iJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function kJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}kJ.isMDXComponent=!0;const yJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}fJ.isMDXComponent=!0;const MJ={toc:[]};function wJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}wJ.isMDXComponent=!0;const DJ={toc:[]};function _J(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}gJ.isMDXComponent=!0;const xJ={toc:[]};function CJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}CJ.isMDXComponent=!0;const TJ={toc:[]};function LJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}LJ.isMDXComponent=!0;const ZJ={toc:[]};function vJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}vJ.isMDXComponent=!0;const bJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}NJ.isMDXComponent=!0;const EJ={toc:[]};function AJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}AJ.isMDXComponent=!0;const RJ={toc:[]};function zJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}zJ.isMDXComponent=!0;const SJ={toc:[]};function IJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}IJ.isMDXComponent=!0;const WJ={toc:[]};function PJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}PJ.isMDXComponent=!0;const GJ={toc:[]};function FJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}FJ.isMDXComponent=!0;const UJ={toc:[]};function jJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jJ.isMDXComponent=!0;const VJ={toc:[]};function qJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}qJ.isMDXComponent=!0;const BJ={toc:[]};function OJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}OJ.isMDXComponent=!0;const $J={toc:[]};function HJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$J,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}HJ.isMDXComponent=!0;const YJ={toc:[]};function KJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}KJ.isMDXComponent=!0;const JJ={toc:[]};function QJ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JJ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QJ.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function cQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}cQ.isMDXComponent=!0;const rQ={toc:[]};function sQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},rQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}sQ.isMDXComponent=!0;const aQ={toc:[]};function iQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},aQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}iQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function kQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}kQ.isMDXComponent=!0;const yQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},yQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}fQ.isMDXComponent=!0;const MQ={toc:[]};function wQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},MQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}wQ.isMDXComponent=!0;const DQ={toc:[]};function _Q(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},DQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},XQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}gQ.isMDXComponent=!0;const xQ={toc:[]};function CQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},xQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}CQ.isMDXComponent=!0;const TQ={toc:[]};function LQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},TQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}LQ.isMDXComponent=!0;const ZQ={toc:[]};function vQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},ZQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}vQ.isMDXComponent=!0;const bQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},bQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}NQ.isMDXComponent=!0;const EQ={toc:[]};function AQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},EQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}AQ.isMDXComponent=!0;const RQ={toc:[]};function zQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},RQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}zQ.isMDXComponent=!0;const SQ={toc:[]};function IQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},SQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}IQ.isMDXComponent=!0;const WQ={toc:[]};function PQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},WQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}PQ.isMDXComponent=!0;const GQ={toc:[]};function FQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},GQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}FQ.isMDXComponent=!0;const UQ={toc:[]};function jQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},UQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}jQ.isMDXComponent=!0;const VQ={toc:[]};function qQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},VQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}qQ.isMDXComponent=!0;const BQ={toc:[]};function OQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},BQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}OQ.isMDXComponent=!0;const $Q={toc:[]};function HQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$Q,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}HQ.isMDXComponent=!0;const YQ={toc:[]};function KQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},YQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}KQ.isMDXComponent=!0;const JQ={toc:[]};function QQ(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},JQ,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}QQ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}o0.isMDXComponent=!0;const p0={toc:[]};function c0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}c0.isMDXComponent=!0;const r0={toc:[]};function s0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},r0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}s0.isMDXComponent=!0;const a0={toc:[]};function i0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},a0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}i0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}d0.isMDXComponent=!0;const h0={toc:[]};function k0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}k0.isMDXComponent=!0;const y0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},y0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}f0.isMDXComponent=!0;const M0={toc:[]};function w0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},M0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}w0.isMDXComponent=!0;const D0={toc:[]};function _0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},D0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},X0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}g0.isMDXComponent=!0;const x0={toc:[]};function C0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},x0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}C0.isMDXComponent=!0;const T0={toc:[]};function L0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},T0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}L0.isMDXComponent=!0;const Z0={toc:[]};function v0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Z0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}v0.isMDXComponent=!0;const b0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},b0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}N0.isMDXComponent=!0;const E0={toc:[]};function A0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},E0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}A0.isMDXComponent=!0;const R0={toc:[]};function z0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},R0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}z0.isMDXComponent=!0;const S0={toc:[]};function I0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},S0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}I0.isMDXComponent=!0;const W0={toc:[]};function P0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},W0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}P0.isMDXComponent=!0;const G0={toc:[]};function F0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},G0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}F0.isMDXComponent=!0;const U0={toc:[]};function j0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},U0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}j0.isMDXComponent=!0;const V0={toc:[]};function q0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},V0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}q0.isMDXComponent=!0;const B0={toc:[]};function O0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},B0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}O0.isMDXComponent=!0;const $0={toc:[]};function H0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}H0.isMDXComponent=!0;const Y0={toc:[]};function K0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Y0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}K0.isMDXComponent=!0;const J0={toc:[]};function Q0(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},J0,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}Q0.isMDXComponent=!0;const t2={toc:[]};function n2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}n2.isMDXComponent=!0;const e2={toc:[]};function o2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}o2.isMDXComponent=!0;const p2={toc:[]};function c2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},p2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}c2.isMDXComponent=!0;const r2={toc:[]};function s2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},r2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}s2.isMDXComponent=!0;const a2={toc:[]};function i2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},a2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}i2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},l2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},m2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}d2.isMDXComponent=!0;const h2={toc:[]};function k2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},h2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}k2.isMDXComponent=!0;const y2={toc:[]};function f2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},y2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,r.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}f2.isMDXComponent=!0;const M2={toc:[]};function w2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},M2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the position in world space."))}w2.isMDXComponent=!0;const D2={toc:[]};function _2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},D2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,r.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},X2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the rotation in world space."))}g2.isMDXComponent=!0;const x2={toc:[]};function C2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},x2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,r.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,r.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," components."))}C2.isMDXComponent=!0;const T2={toc:[]};function L2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},T2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A helper signal for operating on the scale in world space."))}L2.isMDXComponent=!0;const Z2={toc:[]};function v2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Z2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,r.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}v2.isMDXComponent=!0;const b2={toc:[]};function N2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},b2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the offset of this node's origin."))}N2.isMDXComponent=!0;const E2={toc:[]};function A2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},E2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,r.kt)("p",null,"Accessing the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,r.kt)("p",null,"Setting the position:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}A2.isMDXComponent=!0;const R2={toc:[]};function z2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},R2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the position of this node in local space of its parent."))}z2.isMDXComponent=!0;const S2={toc:[]};function I2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},S2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}I2.isMDXComponent=!0;const W2={toc:[]};function P2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},W2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,r.kt)("p",null,"Accessing the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,r.kt)("p",null,"Setting the scale:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}P2.isMDXComponent=!0;const G2={toc:[]};function F2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},G2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the scale of this node in local space of its parent."))}F2.isMDXComponent=!0;const U2={toc:[]};function j2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},U2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A size is a two-dimensional vector, where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,r.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,r.kt)("p",null,"The value of both x and y is of type ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,r.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,r.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,r.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,r.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,r.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,r.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}j2.isMDXComponent=!0;const V2={toc:[]};function q2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},V2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Initializing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,r.kt)("p",null,"Accessing the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,r.kt)("p",null,"Setting the size:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}q2.isMDXComponent=!0;const B2={toc:[]};function O2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},B2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents the size of this node."))}O2.isMDXComponent=!0;const $2={toc:[]};function H2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The nodes will be appended at the end of the children list."))}H2.isMDXComponent=!0;const Y2={toc:[]};function K2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Y2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}K2.isMDXComponent=!0;const J2={toc:[]};function Q2(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},J2,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Add the given node(s) as the children of this node."))}Q2.isMDXComponent=!0;const t7={toc:[]};function n7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to append."))}n7.isMDXComponent=!0;const e7={toc:[]};function o7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}o7.isMDXComponent=!0;const p7={toc:[]};function c7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},p7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}c7.isMDXComponent=!0;const r7={toc:[]};function s7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},r7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}s7.isMDXComponent=!0;const a7={toc:[]};function i7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},a7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}i7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},l7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Collect all asynchronous resources used by this node."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},m7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}d7.isMDXComponent=!0;const h7={toc:[]};function k7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},h7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A matrix mapping composite space to world space."))}k7.isMDXComponent=!0;const y7={toc:[]};function f7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},y7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,r.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}f7.isMDXComponent=!0;const M7={toc:[]};function w7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},M7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare this node to be disposed of."))}w7.isMDXComponent=!0;const D7={toc:[]};function _7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},D7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},X7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw this node onto the canvas."))}g7.isMDXComponent=!0;const x7={toc:[]};function C7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},x7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}C7.isMDXComponent=!0;const T7={toc:[]};function L7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},T7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,r.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}L7.isMDXComponent=!0;const Z7={toc:[]};function v7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Z7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Draw an overlay for this node."))}v7.isMDXComponent=!0;const b7={toc:[]};function N7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},b7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}N7.isMDXComponent=!0;const E7={toc:[]};function A7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},E7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A local-to-screen matrix."))}A7.isMDXComponent=!0;const R7={toc:[]};function z7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},R7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}z7.isMDXComponent=!0;const S7={toc:[]};function I7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},S7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}I7.isMDXComponent=!0;const W7={toc:[]};function P7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},W7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The returned rectangle should be in local space."))}P7.isMDXComponent=!0;const G7={toc:[]};function F7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},G7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}F7.isMDXComponent=!0;const U7={toc:[]};function j7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},U7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Try to find a node intersecting the given position."))}j7.isMDXComponent=!0;const V7={toc:[]};function q7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},V7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The searched position."))}q7.isMDXComponent=!0;const B7={toc:[]};function O7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},B7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,r.kt)("p",null,"Result:"),(0,r.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}O7.isMDXComponent=!0;const $7={toc:[]};function H7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}H7.isMDXComponent=!0;const Y7={toc:[]};function K7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Y7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A node or an array of nodes to insert."))}K7.isMDXComponent=!0;const J7={toc:[]};function Q7(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},J7,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An index at which to insert the node(s)."))}Q7.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an instance of this node's class."))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to pass to the constructor."))}o1.isMDXComponent=!0;const p1={toc:[]};function c1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"When the mode is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,r.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}c1.isMDXComponent=!0;const r1={toc:[]};function s1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},r1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the resolved layout mode of this node."))}s1.isMDXComponent=!0;const a1={toc:[]};function i1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},a1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}i1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-parent matrix for this node."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}d1.isMDXComponent=!0;const h1={toc:[]};function k1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}k1.isMDXComponent=!0;const y1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},y1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the local-to-world matrix for this node."))}f1.isMDXComponent=!0;const M1={toc:[]};function w1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},M1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,r.kt)("p",null,"A positive ",(0,r.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}w1.isMDXComponent=!0;const D1={toc:[]};function _1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},D1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Rearrange this node in relation to its siblings."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},X1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Number of places by which the node should be moved."))}g1.isMDXComponent=!0;const x1={toc:[]};function C1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},x1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}C1.isMDXComponent=!0;const T1={toc:[]};function L1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},T1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node down in relation to its siblings."))}L1.isMDXComponent=!0;const Z1={toc:[]};function v1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Z1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}v1.isMDXComponent=!0;const b1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},b1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new offset."))}N1.isMDXComponent=!0;const E1={toc:[]};function A1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},E1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}A1.isMDXComponent=!0;const R1={toc:[]};function z1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},R1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}z1.isMDXComponent=!0;const S1={toc:[]};function I1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},S1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}I1.isMDXComponent=!0;const W1={toc:[]};function P1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},W1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node to the top in relation to its siblings."))}P1.isMDXComponent=!0;const G1={toc:[]};function F1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},G1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}F1.isMDXComponent=!0;const U1={toc:[]};function j1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},U1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Move the node up in relation to its siblings."))}j1.isMDXComponent=!0;const V1={toc:[]};function q1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},V1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}q1.isMDXComponent=!0;const B1={toc:[]};function O1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},B1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a reactive copy of this node."))}O1.isMDXComponent=!0;const $1={toc:[]};function H1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}H1.isMDXComponent=!0;const Y1={toc:[]};function K1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Y1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove this node from the tree."))}K1.isMDXComponent=!0;const J1={toc:[]};function Q1(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},J1,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Remove all children of this node."))}Q1.isMDXComponent=!0;const t4={toc:[]};function n4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Render this node onto the given canvas."))}n4.isMDXComponent=!0;const e4={toc:[]};function o4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context to draw with."))}o4.isMDXComponent=!0;const p4={toc:[]};function c4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},p4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}c4.isMDXComponent=!0;const r4={toc:[]};function s4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},r4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}s4.isMDXComponent=!0;const a4={toc:[]};function i4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},a4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The new parent of this node."))}i4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},l4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},m4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}d4.isMDXComponent=!0;const h4={toc:[]};function k4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},h4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether this node should be cached or not."))}k4.isMDXComponent=!0;const y4={toc:[]};function f4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},y4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,r.kt)("p",null,"Whether the node is cached is decided by the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,r.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}f4.isMDXComponent=!0;const M4={toc:[]};function w4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},M4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}w4.isMDXComponent=!0;const D4={toc:[]};function _4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},D4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The context using which the cache will be drawn."))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},X4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Unlike ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,r.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}g4.isMDXComponent=!0;const x4={toc:[]};function C4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},x4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a copy of this node."))}C4.isMDXComponent=!0;const T4={toc:[]};function L4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},T4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Properties to override."))}L4.isMDXComponent=!0;const Z4={toc:[]};function v4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Z4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}v4.isMDXComponent=!0;const b4={toc:[]};function N4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},b4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}N4.isMDXComponent=!0;const E4={toc:[]};function A4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},E4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Apply any new layout changes to this node and its children."))}A4.isMDXComponent=!0;const R4={toc:[]};function z4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},R4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}z4.isMDXComponent=!0;const S4={toc:[]};function I4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},S4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}I4.isMDXComponent=!0;const W4={toc:[]};function P4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},W4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-local matrix for this node."))}P4.isMDXComponent=!0;const G4={toc:[]};function F4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},G4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}F4.isMDXComponent=!0;const U4={toc:[]};function j4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},U4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the world-to-parent matrix for this node."))}j4.isMDXComponent=!0;const V4={toc:[]};function q4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},V4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,r.kt)("p",null,"This method can be used to create copies of signals."))}q4.isMDXComponent=!0;const B4={toc:[]};function O4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},B4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}O4.isMDXComponent=!0;const $4={toc:[]};function H4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Get the raw value of this signal."))}H4.isMDXComponent=!0;const Y4={toc:[]};function K4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Y4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}K4.isMDXComponent=!0;const J4={toc:[]};function Q4(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},J4,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Q4.isMDXComponent=!0;const t8={toc:[]};function n8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}n8.isMDXComponent=!0;const e8={toc:[]};function o8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}o8.isMDXComponent=!0;const p8={toc:[]};function c8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},p8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Compute the current value of the signal and immediately set it."))}c8.isMDXComponent=!0;const r8={toc:[]};function s8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},r8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,r.kt)("p",null,"By default, any property is cloneable."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}s8.isMDXComponent=!0;const a8={toc:[]};function i8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},a8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}i8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},l8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a cloneable property decorator."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},m8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the property should be cloneable."))}d8.isMDXComponent=!0;const h8={toc:[]};function k8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},h8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}k8.isMDXComponent=!0;const y8={toc:[]};function f8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},y8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}f8.isMDXComponent=!0;const M8={toc:[]};function w8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},M8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a compound property decorator."))}w8.isMDXComponent=!0;const D8={toc:[]};function _8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},D8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},X8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,r.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,r.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}g8.isMDXComponent=!0;const x8={toc:[]};function C8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},x8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a computed method decorator."))}C8.isMDXComponent=!0;const T8={toc:[]};function L8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},T8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies the initial value of a property."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}L8.isMDXComponent=!0;const Z8={toc:[]};function v8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Z8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}v8.isMDXComponent=!0;const b8={toc:[]};function N8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},b8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an initial signal value decorator."))}N8.isMDXComponent=!0;const E8={toc:[]};function A8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},E8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The initial value of the property."))}A8.isMDXComponent=!0;const R8={toc:[]};function z8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},R8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,r.kt)("p",null,"By default, any property is inspectable."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}z8.isMDXComponent=!0;const S8={toc:[]};function I8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},S8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}I8.isMDXComponent=!0;const W8={toc:[]};function P8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},W8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an inspectable property decorator."))}P8.isMDXComponent=!0;const G8={toc:[]};function F8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},G8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Whether the property should be inspectable."))}F8.isMDXComponent=!0;const U8={toc:[]};function j8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},U8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}j8.isMDXComponent=!0;const V8={toc:[]};function q8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},V8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}q8.isMDXComponent=!0;const B8={toc:[]};function O8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},B8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a signal interpolation function decorator."))}O8.isMDXComponent=!0;const $8={toc:[]};function H8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The interpolation function for the property."))}H8.isMDXComponent=!0;const Y8={toc:[]};function K8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Y8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,r.kt)("p",null,"If the wrapper class has a method called ",(0,r.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}K8.isMDXComponent=!0;const J8={toc:[]};function Q8(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},J8,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Q8.isMDXComponent=!0;const t6={toc:[]};function n6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a signal parser decorator."))}n6.isMDXComponent=!0;const e6={toc:[]};function o6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The wrapper class for the property."))}o6.isMDXComponent=!0;const p6={toc:[]};function c6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},p6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This decorator turns the given property into a signal."),(0,r.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}c6.isMDXComponent=!0;const r6={toc:[]};function s6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},r6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}s6.isMDXComponent=!0;const a6={toc:[]};function i6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},a6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a signal decorator."))}i6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},l6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,r.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,r.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,r.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,r.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,r.kt)("p",null,"Must be specified before the ",(0,r.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,r.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},m6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}d6.isMDXComponent=!0;const h6={toc:[]};function k6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},h6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a signal wrapper decorator."))}k6.isMDXComponent=!0;const y6={toc:[]};function f6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},y6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The wrapper class for the property."))}f6.isMDXComponent=!0;const M6={toc:[]};function w6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},M6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A unified abstraction for all CSS filters."))}w6.isMDXComponent=!0;const D6={toc:[]};function _6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},D6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value can be either:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,r.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length (equivalent to ",(0,r.kt)("inlineCode",{parentName:"li"},"auto")," in CSS)")))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},X6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Represents a length used by most layout properties."))}g6.isMDXComponent=!0;const x6={toc:[]};function C6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},x6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,r.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}C6.isMDXComponent=!0;const T6={toc:[]};function L6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},T6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter in pixels."))}L6.isMDXComponent=!0;const Z6={toc:[]};function v6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Z6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,r.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}v6.isMDXComponent=!0;const b6={toc:[]};function N6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},b6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}N6.isMDXComponent=!0;const E6={toc:[]};function A6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},E6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,r.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}A6.isMDXComponent=!0;const R6={toc:[]};function z6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},R6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}z6.isMDXComponent=!0;const S6={toc:[]};function I6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},S6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,r.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}I6.isMDXComponent=!0;const W6={toc:[]};function P6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},W6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}P6.isMDXComponent=!0;const G6={toc:[]};function F6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},G6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,r.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}F6.isMDXComponent=!0;const U6={toc:[]};function j6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},U6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter in degrees."))}j6.isMDXComponent=!0;const V6={toc:[]};function q6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},V6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create an ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,r.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}q6.isMDXComponent=!0;const B6={toc:[]};function O6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},B6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}O6.isMDXComponent=!0;const $6={toc:[]};function H6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},$6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,r.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}H6.isMDXComponent=!0;const Y6={toc:[]};function K6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},Y6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}K6.isMDXComponent=!0;const J6={toc:[]};function Q6(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},J6,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Create a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,r.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}Q6.isMDXComponent=!0;const t3={toc:[]};function n3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},t3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The value of the filter."))}n3.isMDXComponent=!0;const e3={toc:[]};function o3(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,c.Z)({},e3,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Update the view."),(0,r.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,r.kt)("p",null,"Can modify the state of the view."))}function p3(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}o3.isMDXComponent=!0},9322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(5728),c=e(8698);const r="toggle_S_IX",s="collapsed_wdUB",a="collapse_TjTN",i="inverse_g6vW",l="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const c=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==c?void 0:c.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),h=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),k=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(r,e&&s),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(c.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:a},d.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,i)})),h&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:h.contentId})),k&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:k.contentId})))}},1836:(t,n,e)=>{e.d(n,{Z:()=>Rt});var o=e(2784),p=e(7390),c=e(6835),r=e(68),s=e(6277),a=e(8569);const i={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:l}=t;const m=(0,c.F)(),d=(0,r.s2)();return o.createElement("div",{className:(0,s.Z)(a.Z.codeBlockContent,i.codeBlock,e&&i.highlight,p&&i.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,s.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},n)),l&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(9318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,s.Z)(i.codeBlockContainer,"language-typescript")},n)}var k=e(9817);function y(t){let{children:n,type:e,to:p,id:c,tooltip:s}=t;const a=(0,r.Ld)(e);return p?o.createElement(k.Z,(0,l.Z)({id:c,to:p,"data-tooltip":s},a),n):o.createElement("span",(0,l.Z)({id:c},a),n)}let f,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const w={[f.None]:i.none,[f.Angle]:i.angle,[f.Curly]:i.curly,[f.Square]:i.square,[f.Parentheses]:i.parentheses};function D(t){let{children:n,type:e,separator:p=M.Comma}=t;return o.createElement("span",{className:(0,s.Z)(i.list,w[e??f.None])},o.createElement("span",{className:(0,s.Z)(i.elements,p!==M.Comma&&i.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:i.element},t)))))}var _=e(8617);function X(t){var n;let{type:e}=t;const p=(0,_.RU)(e.project),c=null==p?void 0:p[e.id],r=e.externalUrl??(0,_.Gr)(c);return o.createElement(o.Fragment,null,o.createElement(y,{to:r,type:r?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(D,{type:f.Angle},e.typeArguments.map(((t,n)=>o.createElement(P,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(y,{type:"keyword"},n.name)}function x(t){let{type:n}=t;return n.elements?o.createElement(D,{type:f.Square},n.elements.map(((t,n)=>o.createElement(P,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function C(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.elementType}),"[]")}function T(t){let{type:n}=t;return o.createElement(D,{type:f.Parentheses,separator:M.Pipe},n.types.map(((t,n)=>o.createElement(P,{key:n,type:t}))))}function L(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(y,{type:p},e)}function Z(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"asserts "),o.createElement(y,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(y,null,n.name," "),o.createElement(y,{type:"keyword"},"is "),o.createElement(P,{type:n.targetType}))}function v(t){let{type:n}=t;const e=(0,_.in)();return o.createElement(Y,{reflection:e(n.declaration)})}function b(t){let{type:n}=t;return o.createElement(D,{type:f.Parentheses,separator:M.Ampersand},n.types.map(((t,n)=>o.createElement(P,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(P,{key:n,type:e}),"}",o.createElement(y,{type:"string"},p))})),o.createElement(y,{type:"string"},"`"))}function E(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"typeof "),o.createElement(P,{type:n.queryType}))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.checkType}),o.createElement(y,{type:"keyword"}," extends "),o.createElement(P,{type:n.extendsType})," ? ",o.createElement(P,{type:n.trueType})," : ",o.createElement(P,{type:n.falseType}))}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"infer "),o.createElement(y,{type:"constant"},n.name))}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.objectType}),"[",o.createElement(P,{type:n.indexType}),"]")}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},n.operator," "),o.createElement(P,{type:n.target}))}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(D,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(y,{type:"class"},n.parameter),o.createElement(y,{type:"keyword"}," in "),o.createElement(P,{type:n.parameterType}),"]: ",o.createElement(P,{type:n.templateType}))))}function W(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(P,{type:n.element}))}function P(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return S;case"conditional":return A;case"reflection":return v;case"query":return E;case"named-tuple-member":return W;case"union":return T;case"intrinsic":return g;case"literal":return L;case"reference":return X;case"predicate":return Z;case"tuple":return x;case"array":return C;case"intersection":return b;case"inferred":return R;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return z}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function G(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(y,{key:t,type:"keyword"},t," "))))}function F(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(P,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(y,{type:"plain"},n.defaultValue)))}function U(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.varianceModifier&&o.createElement(y,{type:"keyword"},n.varianceModifier," "),o.createElement(y,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(P,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(P,{type:n.default})))}function j(t){var n,e;let{reflection:c,flags:r}=t;const s=(0,_.in)(),a="__type"===c.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:r??c.flags,explicitAccessModifier:!a}),c.kind===p.W.GetSignature&&o.createElement(y,{type:"keyword"},"get "),c.kind===p.W.SetSignature&&o.createElement(y,{type:"keyword"},"set "),c.overwrites&&o.createElement(o.Fragment,null,o.createElement(y,{to:c.overwrites.externalUrl??(0,_.Gr)(s(c.overwrites.id)),type:"keyword"},"override")," "),c.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(y,{to:"#",type:"keyword"},"new")," ",o.createElement(y,{type:"plain"},c.type.name)):a?"":o.createElement(y,{type:"function"},c.name),!(null==(n=c.typeParameter)||!n.length)&&o.createElement(D,{type:f.Angle},c.typeParameter.map((t=>o.createElement(U,{key:t.id,reflection:s(t)})))),null!=(e=c.parameters)&&e.length?o.createElement(D,{type:f.Parentheses},c.parameters.map((t=>o.createElement(F,{key:t,reflection:s(t)})))):"()",c.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(P,{type:c.type})))}function V(t){let{reflection:n}=t;return o.createElement(F,{reflection:n})}const q={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function B(t){var n,e,p;let{reflection:c}=t;const r=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:c.flags}),o.createElement(y,{type:"keyword"},q[c.kind]," "),o.createElement(y,{type:"class-name"},c.name),!(null==(n=c.typeParameters)||!n.length)&&o.createElement(D,{type:f.Angle},c.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:r(t)}))))," ",!(null==(e=c.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"extends "),o.createElement(D,null,c.extendedTypes.map(((t,n)=>o.createElement(P,{key:n,type:t}))))),!(null==(p=c.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"implements "),o.createElement(D,null,c.implementedTypes.map(((t,n)=>o.createElement(P,{key:n,type:t}))))))}function O(t){let{reflection:n}=t;const e=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),o.createElement(y,{type:"keyword"},"type "),o.createElement(y,{type:"class-name"},n.name),n.typeParameters&&o.createElement(D,{type:f.Angle},n.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:e(t)}))))," = ",o.createElement(P,{type:n.type}))}function $(t){let{reflection:n}=t;const e=(0,_.in)();return n.signatures?o.createElement(j,{reflection:n.signatures[0]}):n.children?o.createElement(D,{type:f.Curly},n.children.map((t=>o.createElement(Y,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(y,{type:"keyword"},"unknown"))}function H(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(j,{reflection:p})}function Y(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return B;case p.W.Constructor:return j;case p.W.Property:return V;case p.W.Method:return H;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return $;case p.W.TypeParameter:return U;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return O;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function K(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${i.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(i.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,s.Z)(i.line,"token-line")},n),o.createElement("br",null))}var J=e(9322),Q=e(5728);function tt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(U,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(F,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const c=(0,_.in)(),r=(0,o.useMemo)((()=>n.map(c)),[n]),[s,a]=(0,o.useState)(r[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,r.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===s.id,onClick:n.length>1?()=>a(t):void 0},o.createElement(K,null,o.createElement(j,{reflection:t,flags:e})))))),o.createElement(J.Z,{comment:s.comment}),o.createElement(tt,{parameters:s.typeParameter}),o.createElement(nt,{parameters:s.parameters}))}var ot=e(7708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const ct="header_nSmr",rt="filters_z1iC",st="icon_ROIU";function at(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,c]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,s.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:st})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,s.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{c({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,s.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{c({...p,inherited:t.target.checked})}}),"Inherited members")))))}function it(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,s.Z)("row",ct)},o.createElement("div",{className:(0,s.Z)("col",rt)},o.createElement(at,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var lt=e(3181),ut=e(8963),mt=e(3851),dt=e(9741),ht=e(2244),kt=e(4126);const yt="tabList_M0Dn",ft="tabItem_ysIP";function Mt(t){var n;const{lazy:e,block:p,defaultValue:c,values:r,groupId:a,className:i}=t,u=o.Children.map(t.children,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),m=r??u.map((t=>{let{props:{value:n,label:e,attributes:o}}=t;return{value:n,label:e,attributes:o}})),d=(0,ht.l)(m,((t,n)=>t.value===n.value));if(d.length>0)throw new Error(`Docusaurus error: Duplicate values "${d.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const h=null===c?c:c??(null==(n=u.find((t=>t.props.default)))?void 0:n.props.value)??u[0].props.value;if(null!==h&&!m.some((t=>t.value===h)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${h}" but none of its children has the corresponding value. Available values are: ${m.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:y}=(0,ut.U)(),[f,M]=(0,o.useState)(h),w=[],{blockElementScrollPositionUntilNextRender:D}=(0,kt.o5)();if(null!=a){const t=k[a];null!=t&&t!==f&&m.some((n=>n.value===t))&&M(t)}const _=t=>{const n=t.currentTarget,e=w.indexOf(n),o=m[e].value;o!==f&&(D(n),M(o),null!=a&&y(a,String(o)))},X=t=>{var n;let e=null;switch(t.key){case"Enter":_(t);break;case"ArrowRight":{const n=w.indexOf(t.currentTarget)+1;e=w[n]??w[0];break}case"ArrowLeft":{const n=w.indexOf(t.currentTarget)-1;e=w[n]??w[w.length-1];break}}null==(n=e)||n.focus()};return o.createElement("div",{className:(0,s.Z)("tabs-container",yt)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":p},i)},m.map((t=>{let{value:n,label:e,attributes:p}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:f===n?0:-1,"aria-selected":f===n,key:n,ref:t=>w.push(t),onKeyDown:X,onClick:_},p,{className:(0,s.Z)("tabs__item",ft,null==p?void 0:p.className,{"tabs__item--active":f===n})}),e??n)}))),e?(0,o.cloneElement)(u.filter((t=>t.props.value===f))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},u.map(((t,n)=>(0,o.cloneElement)(t,{key:n,hidden:t.props.value!==f})))))}function wt(t){const n=(0,dt.Z)();return o.createElement(Mt,(0,l.Z)({key:String(n)},t))}const Dt="tabItem_OMyP";function _t(t){let{children:n,hidden:e,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,s.Z)(Dt,p),hidden:e},n)}function Xt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(Rt,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(Rt,{reflection:t})))))}function gt(t){let{group:n,project:e}=t;const p=(0,lt.TH)(),c=(0,_.RU)(e),{setTabGroupChoices:r}=(0,ut.U)(),s=p.hash.split("-")[0].slice(1),[a]=(0,ot.mN)(),i=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],c=[];for(const r of t.children){const t=n[r];t&&(0,ot.It)(e,t)&&(c.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:c}}(t,c,a))).filter((t=>!!t))),[n,c,a]);return(0,o.useEffect)((()=>{if(1===i.length)return;const t=p.hash.split("-")[0].slice(1);for(const e of i)if(e.anchors.includes(t))return void r(n.title,e.title)}),[p.hash,i]),0===i.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h2",id:n.title},n.title),i.length>1?o.createElement(wt,{groupId:n.title},i.map((t=>o.createElement(_t,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Xt,{group:t}))))):o.createElement(Xt,{group:i[0]}))}function xt(t){var n,e,p,c,r;let{reflection:s}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=s.sources)||null==(e=n[0])?void 0:e.url},o.createElement(K,null,o.createElement(Y,{reflection:s})))),o.createElement(it,{kind:s.kind},o.createElement(J.Z,{comment:s.comment})),o.createElement(tt,{parameters:s.typeParameters}),(null==(p=s.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,s.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(c=s.extendedBy)?void 0:c.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,s.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),s.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:s.signatures})),null==(r=s.groups)?void 0:r.map((t=>o.createElement(gt,{group:t,key:t.title,project:s.project}))))}function Ct(t){var n;let{reflection:e,headless:p}=t;const c=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(mt.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:c,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:e.overwrites}))))}function Tt(t){var n,e;let{reflection:p,headless:c}=t;return o.createElement(o.Fragment,null,!c&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(mt.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement(K,null,o.createElement(V,{reflection:p})))),o.createElement(J.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function Lt(t){var n,e,p;let{reflection:c}=t;const r=(0,_.RU)(c.project);return o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h3",id:c.anchor},o.createElement("code",null,c.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=c.sources)||null==(e=n[0])?void 0:e.url},o.createElement(K,null,o.createElement(Y,{reflection:c})))),o.createElement(J.Z,{comment:c.comment}),o.createElement(tt,{parameters:c.typeParameters}),c.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:c.signatures})),null==(p=c.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>r[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Rt,{key:t.id,reflection:t})))))))}var Zt=e(8128);function vt(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(Zt.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(it,{kind:e.kind},o.createElement(J.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(gt,{group:t,key:t.title,project:e.project}))))}const bt="cardContainer_ybwo",Nt="cardTitle_Ehd1",Et="cardDescription_b6wr";function At(t){let{reflection:n}=t;const e=(0,_.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,s.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(k.Z,{href:t.href,className:(0,s.Z)("card padding--lg",bt)},o.createElement("h2",{className:(0,s.Z)("text--truncate",Nt)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,s.Z)("text--truncate",Et)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function Rt(t){let{reflection:n,headless:e=!1}=t;const c=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return At;case p.W.Module:return vt;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return xt;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return Ct;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return Tt;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return Lt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(c,{reflection:n,headless:e})}},7390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},532:(t,n,e)=>{e.d(n,{Z:()=>l});var o=e(2784),p=e(9741);const c="tooltip_lI6R",r="active_DOSD";var s=e(6277),a=e(8617),i=e(9322);function l(t){let{children:n}=t;const e=(0,p.Z)(),l=(0,a.rG)(),[u,m]=(0,o.useState)(!1),[d,h]=(0,o.useState)(null),k=(0,o.useRef)(),y=(0,o.useRef)(),f=(0,o.useRef)(),M=(0,o.useCallback)((()=>{if(!y.current||!f.current)return;const t=y.current.getBoundingClientRect();let n=window.innerWidth-t.left-496;n<0&&(n=0),f.current.style.right=`${n}px`,f.current.style.top=`${t.bottom}px`}),[]);return(0,o.useEffect)((()=>{if(!e)return;const t=t=>{var n,e,o;if(!t.target.href||null==(n=k.current)||!n.contains(t.target)||null!=(e=f.current)&&e.contains(t.target))return;const p=new URL(t.target.href,document.baseURI);if(p.pathname===window.location.pathname)return;const c=l(p.pathname+p.hash);null!=c&&null!=(o=c.comment)&&o.summary&&(y.current=t.target,m(!0),h(c.comment),M())},n=t=>{t.target===y.current&&m(!1)};return document.addEventListener("mouseenter",t,!0),document.addEventListener("focus",t,!0),document.addEventListener("mouseleave",n,!0),document.addEventListener("blur",n,!0),document.addEventListener("scroll",M),()=>{document.removeEventListener("mouseenter",t,!0),document.removeEventListener("focus",t,!0),document.removeEventListener("mouseleave",n,!0),document.removeEventListener("blur",n,!0),document.removeEventListener("scroll",M)}}),[e]),(0,o.useEffect)((()=>{M()})),o.createElement("div",{ref:k},n,o.createElement("div",{ref:f,className:(0,s.Z)(c,"padding--md margin-horiz--md",u&&r)},d&&o.createElement(i.Z,{comment:d,full:!1})))}},8617:(t,n,e)=>{e.d(n,{Gr:()=>i,RU:()=>r,gs:()=>c,in:()=>s,rG:()=>a});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function c(t){let{children:n,lookup:e,urlLookup:c}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:c}},n)}function r(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function s(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function a(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function i(t){if(t)return t.href}},68:(t,n,e)=>{e.d(n,{Ld:()=>s,Y0:()=>r,s2:()=>a});var o=e(2784),p=e(822);const c=o.createContext(null);function r(t){let{children:n}=t;const e=(0,p.p)(),r=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(c.Provider,{value:r},n)}function s(t){void 0===t&&(t="plain");const n=(0,o.useContext)(c);return{className:`token ${t}`,style:n[t]??n.plain}}function a(t){void 0===t&&(t="plain");const n=(0,o.useContext)(c);return n[t]??n.plain}},7708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(2784),p=e(1263),c=e(9741);const r="api-filters",s=p.Z.canUseDOM?localStorage.getItem(r):null,a=s?JSON.parse(s):{inherited:!0,private:!1},i=o.createContext([a,()=>{}]);function l(t){let{children:n}=t;const[e,p]=(0,o.useState)(a),s=(0,c.Z)();return o.createElement(i.Provider,{value:[e,t=>{s&&localStorage.setItem(r,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(i)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const c=!!n.inheritedFrom;return!(!t.inherited&&c)}},6047:(t,n,e)=>{e.d(n,{Z:()=>u});var o=e(7896),p=e(2784),c=e(9055);const r="icon_Fw4I";function s(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"}))}function a(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),p.createElement("path",{d:"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"}))}function i(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),p.createElement("path",{d:"M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"}))}function l(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",fill:"currentColor"},t),p.createElement("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"}))}function u(t){const n=(0,p.useMemo)((()=>{switch(t.type){case"tip":return l;case"caution":return a;case"danger":return i;default:return s}}),[t.type]);return p.createElement(p.Fragment,null,p.createElement(c.Z,(0,o.Z)({icon:p.createElement(n,{className:r})},t)))}},4141:(t,n,e)=>{e.d(n,{Z:()=>s});var o=e(7896),p=e(2784),c=e(6277);const r="iconEdit_N_05";function s(t){let{className:n,...e}=t;return p.createElement("svg",(0,o.Z)({fill:"currentColor",width:"24px",height:"24px",viewBox:"0 0 24 24",className:(0,c.Z)(r,n),"aria-hidden":"true"},e),p.createElement("path",{d:"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"}))}},4648:(t,n,e)=>{e.d(n,{Z:()=>c});var o=e(7896),p=e(2784);function c(t){return p.createElement("svg",(0,o.Z)({viewBox:"0 0 24 24",style:{width:16,height:16,marginTop:"0.1rem"}},t),p.createElement("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z",fill:"currentColor"}))}}}]);
"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[9430],{876:(t,e,n)=>{n.d(e,{Zo:()=>i,kt:()=>h});var o=n(2784);function c(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function p(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){c(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,o,c=function(t,e){if(null==t)return{};var n,o,c={},r=Object.keys(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||(c[n]=t[n]);return c}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(c[n]=t[n])}return c}var a=o.createContext({}),l=function(t){var e=o.useContext(a),n=e;return t&&(n="function"==typeof t?t(e):p(p({},e),t)),n},i=function(t){var e=l(t.components);return o.createElement(a.Provider,{value:e},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(t,e){var n=t.components,c=t.mdxType,r=t.originalType,a=t.parentName,i=s(t,["components","mdxType","originalType","parentName"]),u=l(n),d=c,h=u["".concat(a,".").concat(d)]||u[d]||m[d]||r;return n?o.createElement(h,p(p({ref:e},i),{},{components:n})):o.createElement(h,p({ref:e},i))}));function h(t,e){var n=arguments,c=e&&e.mdxType;if("string"==typeof t||c){var r=n.length,p=new Array(r);p[0]=d;var s={};for(var a in e)hasOwnProperty.call(e,a)&&(s[a]=e[a]);s.originalType=t,s[u]="string"==typeof t?t:c,p[1]=s;for(var l=2;l<r;l++)p[l]=n[l];return o.createElement.apply(null,p)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3851:(t,e,n)=>{n.d(e,{Z:()=>i});var o=n(7896),c=n(2784),r=n(6277),p=n(1077),s=n(7683);const a="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function i(t){let{as:e,id:n,...i}=t;const{navbar:{hideOnScroll:u}}=(0,s.L)();return"h1"!==e&&n?c.createElement(e,(0,o.Z)({},i,{className:(0,r.Z)("anchor",u?l:a),id:n}),i.children,c.createElement("a",{className:"hash-link",href:`#${n}`,title:(0,p.I)({id:"theme.common.headingLinkTitle",message:"Direct link to heading",description:"Title for link to heading"})},"\u200b")):c.createElement(e,(0,o.Z)({},i,{id:void 0}))}},2072:(t,e,n)=>{n.d(e,{Z:()=>s});var o=n(2784),c=n(8617),r=n(1836),p=n(9817);function s(t){let{url:e}=t;const n=(0,c.rG)()(e);return o.createElement(o.Fragment,null,o.createElement(r.Z,{reflection:n,headless:!0}),o.createElement(p.Z,{to:n.href},o.createElement("small",null,"Got to the API documentation")))}},2366:(t,e,n)=>{n.d(e,{Z:()=>Gz});var o={};n.r(o),n.d(o,{content_0_0:()=>a,content_0_10:()=>M,content_0_100:()=>te,content_0_102:()=>ne,content_0_104:()=>ce,content_0_106:()=>pe,content_0_108:()=>ae,content_0_110:()=>ie,content_0_112:()=>me,content_0_114:()=>he,content_0_116:()=>ke,content_0_118:()=>Me,content_0_12:()=>_,content_0_120:()=>_e,content_0_122:()=>we,content_0_124:()=>Ce,content_0_126:()=>xe,content_0_128:()=>Ze,content_0_130:()=>ve,content_0_132:()=>Ee,content_0_134:()=>Se,content_0_136:()=>Pe,content_0_138:()=>Ie,content_0_14:()=>w,content_0_140:()=>Ge,content_0_142:()=>Ue,content_0_144:()=>ze,content_0_146:()=>Ve,content_0_148:()=>$e,content_0_150:()=>Ye,content_0_152:()=>Ke,content_0_154:()=>tn,content_0_156:()=>nn,content_0_158:()=>cn,content_0_16:()=>C,content_0_160:()=>pn,content_0_162:()=>an,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>yn,content_0_170:()=>fn,content_0_172:()=>Dn,content_0_174:()=>Xn,content_0_176:()=>Tn,content_0_178:()=>gn,content_0_18:()=>x,content_0_180:()=>Ln,content_0_182:()=>bn,content_0_184:()=>Nn,content_0_186:()=>An,content_0_188:()=>Rn,content_0_190:()=>Wn,content_0_192:()=>Fn,content_0_194:()=>jn,content_0_196:()=>On,content_0_198:()=>qn,content_0_2:()=>i,content_0_20:()=>Z,content_0_200:()=>Bn,content_0_202:()=>Hn,content_0_204:()=>Jn,content_0_206:()=>Qn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>so,content_0_216:()=>lo,content_0_218:()=>uo,content_0_22:()=>v,content_0_220:()=>ho,content_0_222:()=>ko,content_0_224:()=>Mo,content_0_226:()=>_o,content_0_228:()=>wo,content_0_230:()=>Co,content_0_232:()=>xo,content_0_234:()=>Zo,content_0_236:()=>vo,content_0_238:()=>Eo,content_0_24:()=>E,content_0_240:()=>So,content_0_242:()=>Po,content_0_244:()=>Io,content_0_246:()=>Go,content_0_248:()=>Uo,content_0_250:()=>zo,content_0_252:()=>Vo,content_0_254:()=>$o,content_0_256:()=>Yo,content_0_258:()=>Ko,content_0_26:()=>S,content_0_260:()=>tc,content_0_262:()=>nc,content_0_264:()=>cc,content_0_266:()=>pc,content_0_268:()=>ac,content_0_270:()=>ic,content_0_272:()=>mc,content_0_274:()=>hc,content_0_276:()=>kc,content_0_278:()=>Mc,content_0_28:()=>P,content_0_280:()=>_c,content_0_282:()=>wc,content_0_284:()=>Cc,content_0_286:()=>xc,content_0_288:()=>Zc,content_0_290:()=>vc,content_0_292:()=>Ec,content_0_294:()=>Sc,content_0_296:()=>Pc,content_0_298:()=>Ic,content_0_30:()=>I,content_0_300:()=>Gc,content_0_302:()=>Uc,content_0_304:()=>zc,content_0_306:()=>Vc,content_0_308:()=>$c,content_0_310:()=>Yc,content_0_312:()=>Kc,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>cr,content_0_32:()=>G,content_0_320:()=>pr,content_0_322:()=>ar,content_0_324:()=>ir,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>kr,content_0_332:()=>Mr,content_0_334:()=>_r,content_0_336:()=>wr,content_0_338:()=>Cr,content_0_34:()=>U,content_0_340:()=>xr,content_0_342:()=>Zr,content_0_344:()=>vr,content_0_346:()=>Er,content_0_348:()=>Sr,content_0_350:()=>Pr,content_0_352:()=>Ir,content_0_354:()=>Gr,content_0_356:()=>Ur,content_0_358:()=>zr,content_0_36:()=>z,content_0_360:()=>Vr,content_0_362:()=>$r,content_0_364:()=>Yr,content_0_366:()=>Kr,content_0_368:()=>tp,content_0_370:()=>np,content_0_372:()=>cp,content_0_374:()=>pp,content_0_376:()=>ap,content_0_378:()=>ip,content_0_38:()=>V,content_0_380:()=>mp,content_0_382:()=>hp,content_0_384:()=>kp,content_0_386:()=>Mp,content_0_388:()=>_p,content_0_390:()=>wp,content_0_392:()=>Cp,content_0_394:()=>xp,content_0_396:()=>Zp,content_0_398:()=>vp,content_0_4:()=>m,content_0_40:()=>$,content_0_400:()=>Ep,content_0_402:()=>Sp,content_0_404:()=>Pp,content_0_406:()=>Ip,content_0_408:()=>Gp,content_0_410:()=>Up,content_0_412:()=>zp,content_0_414:()=>Vp,content_0_416:()=>$p,content_0_418:()=>Yp,content_0_42:()=>Y,content_0_420:()=>Kp,content_0_422:()=>ts,content_0_424:()=>ns,content_0_426:()=>cs,content_0_428:()=>ps,content_0_430:()=>as,content_0_432:()=>is,content_0_434:()=>ms,content_0_436:()=>hs,content_0_438:()=>ks,content_0_44:()=>K,content_0_440:()=>Ms,content_0_442:()=>_s,content_0_444:()=>ws,content_0_446:()=>Cs,content_0_448:()=>xs,content_0_450:()=>Zs,content_0_452:()=>vs,content_0_454:()=>Es,content_0_456:()=>Ss,content_0_458:()=>Ps,content_0_46:()=>tt,content_0_460:()=>Is,content_0_462:()=>Gs,content_0_464:()=>Us,content_0_466:()=>zs,content_0_468:()=>Vs,content_0_470:()=>$s,content_0_472:()=>Ys,content_0_474:()=>Ks,content_0_476:()=>ta,content_0_478:()=>na,content_0_48:()=>nt,content_0_480:()=>ca,content_0_482:()=>pa,content_0_484:()=>aa,content_0_486:()=>ia,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>ka,content_0_494:()=>Ma,content_0_496:()=>_a,content_0_498:()=>wa,content_0_50:()=>ct,content_0_500:()=>Ca,content_0_502:()=>xa,content_0_504:()=>Za,content_0_506:()=>va,content_0_508:()=>Ea,content_0_510:()=>Sa,content_0_512:()=>Pa,content_0_514:()=>Ia,content_0_516:()=>Ga,content_0_518:()=>Ua,content_0_52:()=>pt,content_0_520:()=>za,content_0_522:()=>Va,content_0_524:()=>$a,content_0_526:()=>Ya,content_0_528:()=>Ka,content_0_530:()=>tl,content_0_532:()=>nl,content_0_534:()=>cl,content_0_536:()=>pl,content_0_538:()=>al,content_0_54:()=>at,content_0_540:()=>il,content_0_542:()=>ml,content_0_544:()=>hl,content_0_546:()=>kl,content_0_548:()=>Ml,content_0_550:()=>_l,content_0_552:()=>wl,content_0_554:()=>Cl,content_0_556:()=>xl,content_0_558:()=>Zl,content_0_56:()=>it,content_0_560:()=>vl,content_0_562:()=>El,content_0_564:()=>Sl,content_0_566:()=>Pl,content_0_568:()=>Il,content_0_570:()=>Gl,content_0_572:()=>Ul,content_0_574:()=>zl,content_0_576:()=>Vl,content_0_578:()=>$l,content_0_58:()=>mt,content_0_580:()=>Yl,content_0_582:()=>Kl,content_0_584:()=>ti,content_0_586:()=>ni,content_0_588:()=>ci,content_0_590:()=>pi,content_0_592:()=>ai,content_0_594:()=>ii,content_0_596:()=>mi,content_0_598:()=>hi,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>ki,content_0_602:()=>Mi,content_0_604:()=>_i,content_0_606:()=>wi,content_0_608:()=>Ci,content_0_610:()=>xi,content_0_612:()=>Zi,content_0_614:()=>vi,content_0_616:()=>Ei,content_0_618:()=>Si,content_0_62:()=>kt,content_0_620:()=>Pi,content_0_622:()=>Ii,content_0_624:()=>Gi,content_0_626:()=>Ui,content_0_628:()=>zi,content_0_630:()=>Vi,content_0_632:()=>$i,content_0_634:()=>Yi,content_0_636:()=>Ki,content_0_638:()=>tu,content_0_64:()=>Mt,content_0_640:()=>nu,content_0_642:()=>cu,content_0_644:()=>pu,content_0_646:()=>au,content_0_648:()=>iu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>ku,content_0_656:()=>Mu,content_0_658:()=>_u,content_0_66:()=>_t,content_0_660:()=>wu,content_0_662:()=>Cu,content_0_664:()=>xu,content_0_666:()=>Zu,content_0_668:()=>vu,content_0_670:()=>Eu,content_0_672:()=>Su,content_0_674:()=>Pu,content_0_676:()=>Iu,content_0_678:()=>Gu,content_0_68:()=>wt,content_0_680:()=>Uu,content_0_682:()=>zu,content_0_684:()=>Vu,content_0_686:()=>$u,content_0_688:()=>Yu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>cm,content_0_698:()=>pm,content_0_70:()=>Ct,content_0_700:()=>am,content_0_702:()=>im,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>km,content_0_710:()=>Mm,content_0_712:()=>_m,content_0_714:()=>wm,content_0_716:()=>Cm,content_0_718:()=>xm,content_0_72:()=>xt,content_0_720:()=>Zm,content_0_722:()=>vm,content_0_724:()=>Em,content_0_726:()=>Sm,content_0_728:()=>Pm,content_0_730:()=>Im,content_0_732:()=>Gm,content_0_734:()=>Um,content_0_736:()=>zm,content_0_738:()=>Vm,content_0_74:()=>Zt,content_0_740:()=>$m,content_0_742:()=>Ym,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>cd,content_0_752:()=>pd,content_0_754:()=>ad,content_0_756:()=>id,content_0_758:()=>md,content_0_76:()=>vt,content_0_760:()=>hd,content_0_762:()=>kd,content_0_764:()=>Md,content_0_766:()=>_d,content_0_768:()=>wd,content_0_770:()=>Cd,content_0_772:()=>xd,content_0_774:()=>Zd,content_0_776:()=>vd,content_0_778:()=>Ed,content_0_78:()=>Et,content_0_780:()=>Sd,content_0_782:()=>Pd,content_0_784:()=>Id,content_0_786:()=>Gd,content_0_788:()=>Ud,content_0_790:()=>zd,content_0_792:()=>Vd,content_0_794:()=>$d,content_0_796:()=>Yd,content_0_798:()=>Kd,content_0_8:()=>k,content_0_80:()=>St,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>ch,content_0_806:()=>ph,content_0_808:()=>ah,content_0_810:()=>ih,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>kh,content_0_818:()=>Mh,content_0_82:()=>Pt,content_0_820:()=>_h,content_0_822:()=>wh,content_0_824:()=>Ch,content_0_826:()=>xh,content_0_828:()=>Zh,content_0_830:()=>vh,content_0_832:()=>Eh,content_0_834:()=>Sh,content_0_836:()=>Ph,content_0_838:()=>Ih,content_0_84:()=>It,content_0_840:()=>Gh,content_0_842:()=>Uh,content_0_844:()=>zh,content_0_846:()=>Vh,content_0_848:()=>$h,content_0_850:()=>Yh,content_0_852:()=>Kh,content_0_854:()=>ty,content_0_856:()=>ny,content_0_858:()=>cy,content_0_86:()=>Gt,content_0_860:()=>py,content_0_862:()=>ay,content_0_864:()=>iy,content_0_866:()=>my,content_0_868:()=>hy,content_0_870:()=>ky,content_0_872:()=>My,content_0_874:()=>_y,content_0_876:()=>wy,content_0_878:()=>Cy,content_0_88:()=>Ut,content_0_880:()=>xy,content_0_882:()=>Zy,content_0_884:()=>vy,content_0_886:()=>Ey,content_0_888:()=>Sy,content_0_890:()=>Py,content_0_892:()=>Iy,content_0_894:()=>Gy,content_0_896:()=>Uy,content_0_898:()=>zy,content_0_90:()=>zt,content_0_900:()=>Vy,content_0_902:()=>$y,content_0_92:()=>Vt,content_0_94:()=>$t,content_0_96:()=>Yt,content_0_98:()=>Kt,content_2112_0:()=>Yy,content_2112_10:()=>pk,content_2112_100:()=>Of,content_2112_1000:()=>gS,content_2112_1002:()=>LS,content_2112_1004:()=>bS,content_2112_1006:()=>NS,content_2112_1008:()=>AS,content_2112_1010:()=>RS,content_2112_1012:()=>WS,content_2112_1014:()=>FS,content_2112_1016:()=>jS,content_2112_1018:()=>OS,content_2112_102:()=>qf,content_2112_1020:()=>qS,content_2112_1022:()=>BS,content_2112_1024:()=>HS,content_2112_1026:()=>JS,content_2112_1028:()=>QS,content_2112_1030:()=>eR,content_2112_1032:()=>oR,content_2112_1034:()=>rR,content_2112_1036:()=>sR,content_2112_1038:()=>lR,content_2112_104:()=>Bf,content_2112_1040:()=>uR,content_2112_1042:()=>dR,content_2112_1044:()=>yR,content_2112_1046:()=>fR,content_2112_1048:()=>DR,content_2112_1050:()=>XR,content_2112_1052:()=>TR,content_2112_1054:()=>gR,content_2112_1056:()=>LR,content_2112_1058:()=>bR,content_2112_106:()=>Hf,content_2112_1060:()=>NR,content_2112_1062:()=>AR,content_2112_1064:()=>RR,content_2112_1066:()=>WR,content_2112_1068:()=>FR,content_2112_1070:()=>jR,content_2112_1072:()=>OR,content_2112_1074:()=>qR,content_2112_1076:()=>BR,content_2112_1078:()=>HR,content_2112_108:()=>Jf,content_2112_1080:()=>JR,content_2112_1082:()=>QR,content_2112_1084:()=>eP,content_2112_1086:()=>oP,content_2112_1088:()=>rP,content_2112_1090:()=>sP,content_2112_1092:()=>lP,content_2112_1094:()=>uP,content_2112_1096:()=>dP,content_2112_1098:()=>yP,content_2112_110:()=>Qf,content_2112_1100:()=>fP,content_2112_1102:()=>DP,content_2112_1104:()=>XP,content_2112_1106:()=>TP,content_2112_1108:()=>gP,content_2112_1110:()=>LP,content_2112_1112:()=>bP,content_2112_1114:()=>NP,content_2112_1116:()=>AP,content_2112_1118:()=>RP,content_2112_112:()=>eM,content_2112_1120:()=>WP,content_2112_1122:()=>FP,content_2112_1124:()=>jP,content_2112_1126:()=>OP,content_2112_1128:()=>qP,content_2112_1130:()=>BP,content_2112_1132:()=>HP,content_2112_1134:()=>JP,content_2112_1136:()=>QP,content_2112_1138:()=>eW,content_2112_114:()=>oM,content_2112_1140:()=>oW,content_2112_1142:()=>rW,content_2112_1144:()=>sW,content_2112_1146:()=>lW,content_2112_1148:()=>uW,content_2112_1150:()=>dW,content_2112_1152:()=>yW,content_2112_1154:()=>fW,content_2112_1156:()=>DW,content_2112_1158:()=>XW,content_2112_116:()=>rM,content_2112_1160:()=>TW,content_2112_1162:()=>gW,content_2112_1164:()=>LW,content_2112_1166:()=>bW,content_2112_1168:()=>NW,content_2112_1170:()=>AW,content_2112_1172:()=>RW,content_2112_1174:()=>WW,content_2112_1176:()=>FW,content_2112_1178:()=>jW,content_2112_118:()=>sM,content_2112_1180:()=>OW,content_2112_1182:()=>qW,content_2112_1184:()=>BW,content_2112_1186:()=>HW,content_2112_1188:()=>JW,content_2112_1190:()=>QW,content_2112_1192:()=>eI,content_2112_1194:()=>oI,content_2112_1196:()=>rI,content_2112_1198:()=>sI,content_2112_12:()=>ak,content_2112_120:()=>lM,content_2112_1200:()=>lI,content_2112_1202:()=>uI,content_2112_1204:()=>dI,content_2112_1206:()=>yI,content_2112_1208:()=>fI,content_2112_1210:()=>DI,content_2112_1212:()=>XI,content_2112_1214:()=>TI,content_2112_1216:()=>gI,content_2112_1218:()=>LI,content_2112_122:()=>uM,content_2112_1220:()=>bI,content_2112_1222:()=>NI,content_2112_1224:()=>AI,content_2112_1226:()=>RI,content_2112_1228:()=>WI,content_2112_1230:()=>FI,content_2112_1232:()=>jI,content_2112_1234:()=>OI,content_2112_1236:()=>qI,content_2112_1238:()=>BI,content_2112_124:()=>dM,content_2112_1240:()=>HI,content_2112_1242:()=>JI,content_2112_1244:()=>QI,content_2112_1246:()=>eF,content_2112_1248:()=>oF,content_2112_1250:()=>rF,content_2112_1252:()=>sF,content_2112_1254:()=>lF,content_2112_1256:()=>uF,content_2112_1258:()=>dF,content_2112_126:()=>yM,content_2112_1260:()=>yF,content_2112_1262:()=>fF,content_2112_1264:()=>DF,content_2112_1266:()=>XF,content_2112_1268:()=>TF,content_2112_1270:()=>gF,content_2112_1272:()=>LF,content_2112_1274:()=>bF,content_2112_1276:()=>NF,content_2112_1278:()=>AF,content_2112_128:()=>fM,content_2112_1280:()=>RF,content_2112_1282:()=>WF,content_2112_1284:()=>FF,content_2112_1286:()=>jF,content_2112_1288:()=>OF,content_2112_1290:()=>qF,content_2112_1292:()=>BF,content_2112_1294:()=>HF,content_2112_1296:()=>JF,content_2112_1298:()=>QF,content_2112_130:()=>DM,content_2112_1300:()=>eG,content_2112_1302:()=>oG,content_2112_1304:()=>rG,content_2112_1306:()=>sG,content_2112_1308:()=>lG,content_2112_1310:()=>uG,content_2112_1312:()=>dG,content_2112_1314:()=>yG,content_2112_1316:()=>fG,content_2112_1318:()=>DG,content_2112_132:()=>XM,content_2112_1320:()=>XG,content_2112_1322:()=>TG,content_2112_1324:()=>gG,content_2112_1326:()=>LG,content_2112_1328:()=>bG,content_2112_1330:()=>NG,content_2112_1332:()=>AG,content_2112_1334:()=>RG,content_2112_1336:()=>WG,content_2112_1338:()=>FG,content_2112_134:()=>TM,content_2112_1340:()=>jG,content_2112_1342:()=>OG,content_2112_1344:()=>qG,content_2112_1346:()=>BG,content_2112_1348:()=>HG,content_2112_1350:()=>JG,content_2112_1352:()=>QG,content_2112_1354:()=>ej,content_2112_1356:()=>oj,content_2112_1358:()=>rj,content_2112_136:()=>gM,content_2112_1360:()=>sj,content_2112_1362:()=>lj,content_2112_1364:()=>uj,content_2112_1366:()=>dj,content_2112_1368:()=>yj,content_2112_1370:()=>fj,content_2112_1372:()=>Dj,content_2112_1374:()=>Xj,content_2112_1376:()=>Tj,content_2112_1378:()=>gj,content_2112_138:()=>LM,content_2112_1380:()=>Lj,content_2112_1382:()=>bj,content_2112_1384:()=>Nj,content_2112_1386:()=>Aj,content_2112_1388:()=>Rj,content_2112_1390:()=>Wj,content_2112_1392:()=>Fj,content_2112_1394:()=>jj,content_2112_1396:()=>Oj,content_2112_1398:()=>qj,content_2112_14:()=>ik,content_2112_140:()=>bM,content_2112_1400:()=>Bj,content_2112_1402:()=>Hj,content_2112_1404:()=>Jj,content_2112_1406:()=>Qj,content_2112_1408:()=>eU,content_2112_1410:()=>oU,content_2112_1412:()=>rU,content_2112_1414:()=>sU,content_2112_1416:()=>lU,content_2112_1418:()=>uU,content_2112_142:()=>NM,content_2112_1420:()=>dU,content_2112_1422:()=>yU,content_2112_1424:()=>fU,content_2112_1426:()=>DU,content_2112_1428:()=>XU,content_2112_1430:()=>TU,content_2112_1432:()=>gU,content_2112_1434:()=>LU,content_2112_1436:()=>bU,content_2112_1438:()=>NU,content_2112_144:()=>AM,content_2112_1440:()=>AU,content_2112_1442:()=>RU,content_2112_1444:()=>WU,content_2112_1446:()=>FU,content_2112_1448:()=>jU,content_2112_1450:()=>OU,content_2112_1452:()=>qU,content_2112_1454:()=>BU,content_2112_1456:()=>HU,content_2112_1458:()=>JU,content_2112_146:()=>RM,content_2112_1460:()=>QU,content_2112_1462:()=>eO,content_2112_1464:()=>oO,content_2112_1466:()=>rO,content_2112_1468:()=>sO,content_2112_1470:()=>lO,content_2112_1472:()=>uO,content_2112_1474:()=>dO,content_2112_1476:()=>yO,content_2112_1478:()=>fO,content_2112_148:()=>WM,content_2112_1480:()=>DO,content_2112_1482:()=>XO,content_2112_1484:()=>TO,content_2112_1486:()=>gO,content_2112_1488:()=>LO,content_2112_1490:()=>bO,content_2112_1492:()=>NO,content_2112_1494:()=>AO,content_2112_1496:()=>RO,content_2112_1498:()=>WO,content_2112_150:()=>FM,content_2112_1500:()=>FO,content_2112_1502:()=>jO,content_2112_1504:()=>OO,content_2112_1506:()=>qO,content_2112_1508:()=>BO,content_2112_1510:()=>HO,content_2112_1512:()=>JO,content_2112_1514:()=>QO,content_2112_1516:()=>ez,content_2112_1518:()=>oz,content_2112_152:()=>jM,content_2112_1520:()=>rz,content_2112_1522:()=>sz,content_2112_1524:()=>lz,content_2112_1526:()=>uz,content_2112_1528:()=>dz,content_2112_1530:()=>yz,content_2112_1532:()=>fz,content_2112_1534:()=>Dz,content_2112_1536:()=>Xz,content_2112_1538:()=>Tz,content_2112_154:()=>OM,content_2112_1540:()=>gz,content_2112_1542:()=>Lz,content_2112_1544:()=>bz,content_2112_1546:()=>Nz,content_2112_1548:()=>Az,content_2112_1550:()=>Rz,content_2112_1552:()=>Wz,content_2112_1554:()=>Fz,content_2112_156:()=>qM,content_2112_158:()=>BM,content_2112_16:()=>mk,content_2112_160:()=>HM,content_2112_162:()=>JM,content_2112_164:()=>QM,content_2112_166:()=>eD,content_2112_168:()=>oD,content_2112_170:()=>rD,content_2112_172:()=>sD,content_2112_174:()=>lD,content_2112_176:()=>uD,content_2112_178:()=>dD,content_2112_18:()=>hk,content_2112_180:()=>yD,content_2112_182:()=>fD,content_2112_184:()=>DD,content_2112_186:()=>XD,content_2112_188:()=>TD,content_2112_190:()=>gD,content_2112_192:()=>LD,content_2112_194:()=>bD,content_2112_196:()=>ND,content_2112_198:()=>AD,content_2112_2:()=>Ky,content_2112_20:()=>kk,content_2112_200:()=>RD,content_2112_202:()=>WD,content_2112_204:()=>FD,content_2112_206:()=>jD,content_2112_208:()=>OD,content_2112_210:()=>qD,content_2112_212:()=>BD,content_2112_214:()=>HD,content_2112_216:()=>JD,content_2112_218:()=>QD,content_2112_22:()=>Mk,content_2112_220:()=>e_,content_2112_222:()=>o_,content_2112_224:()=>r_,content_2112_226:()=>s_,content_2112_228:()=>l_,content_2112_230:()=>u_,content_2112_232:()=>d_,content_2112_234:()=>y_,content_2112_236:()=>f_,content_2112_238:()=>D_,content_2112_24:()=>_k,content_2112_240:()=>X_,content_2112_242:()=>T_,content_2112_244:()=>g_,content_2112_246:()=>L_,content_2112_248:()=>b_,content_2112_250:()=>N_,content_2112_252:()=>A_,content_2112_254:()=>R_,content_2112_256:()=>W_,content_2112_258:()=>F_,content_2112_26:()=>wk,content_2112_260:()=>j_,content_2112_262:()=>O_,content_2112_264:()=>q_,content_2112_266:()=>B_,content_2112_268:()=>H_,content_2112_270:()=>J_,content_2112_272:()=>Q_,content_2112_274:()=>eX,content_2112_276:()=>oX,content_2112_278:()=>rX,content_2112_28:()=>Ck,content_2112_280:()=>sX,content_2112_282:()=>lX,content_2112_284:()=>uX,content_2112_286:()=>dX,content_2112_288:()=>yX,content_2112_290:()=>fX,content_2112_292:()=>DX,content_2112_294:()=>XX,content_2112_296:()=>TX,content_2112_298:()=>gX,content_2112_30:()=>xk,content_2112_300:()=>LX,content_2112_302:()=>bX,content_2112_304:()=>NX,content_2112_306:()=>AX,content_2112_308:()=>RX,content_2112_310:()=>WX,content_2112_312:()=>FX,content_2112_314:()=>jX,content_2112_316:()=>OX,content_2112_318:()=>qX,content_2112_32:()=>Zk,content_2112_320:()=>BX,content_2112_322:()=>HX,content_2112_324:()=>JX,content_2112_326:()=>QX,content_2112_328:()=>ew,content_2112_330:()=>ow,content_2112_332:()=>rw,content_2112_334:()=>sw,content_2112_336:()=>lw,content_2112_338:()=>uw,content_2112_34:()=>vk,content_2112_340:()=>dw,content_2112_342:()=>yw,content_2112_344:()=>fw,content_2112_346:()=>Dw,content_2112_348:()=>Xw,content_2112_350:()=>Tw,content_2112_352:()=>gw,content_2112_354:()=>Lw,content_2112_356:()=>bw,content_2112_358:()=>Nw,content_2112_36:()=>Ek,content_2112_360:()=>Aw,content_2112_362:()=>Rw,content_2112_364:()=>Ww,content_2112_366:()=>Fw,content_2112_368:()=>jw,content_2112_370:()=>Ow,content_2112_372:()=>qw,content_2112_374:()=>Bw,content_2112_376:()=>Hw,content_2112_378:()=>Jw,content_2112_38:()=>Sk,content_2112_380:()=>Qw,content_2112_382:()=>eT,content_2112_384:()=>oT,content_2112_386:()=>rT,content_2112_388:()=>sT,content_2112_390:()=>lT,content_2112_392:()=>uT,content_2112_394:()=>dT,content_2112_396:()=>yT,content_2112_398:()=>fT,content_2112_4:()=>tk,content_2112_40:()=>Pk,content_2112_400:()=>DT,content_2112_402:()=>XT,content_2112_404:()=>TT,content_2112_406:()=>gT,content_2112_408:()=>LT,content_2112_410:()=>bT,content_2112_412:()=>NT,content_2112_414:()=>AT,content_2112_416:()=>RT,content_2112_418:()=>WT,content_2112_42:()=>Ik,content_2112_420:()=>FT,content_2112_422:()=>jT,content_2112_424:()=>OT,content_2112_426:()=>qT,content_2112_428:()=>BT,content_2112_430:()=>HT,content_2112_432:()=>JT,content_2112_434:()=>QT,content_2112_436:()=>eC,content_2112_438:()=>oC,content_2112_44:()=>Gk,content_2112_440:()=>rC,content_2112_442:()=>sC,content_2112_444:()=>lC,content_2112_446:()=>uC,content_2112_448:()=>dC,content_2112_450:()=>yC,content_2112_452:()=>fC,content_2112_454:()=>DC,content_2112_456:()=>XC,content_2112_458:()=>TC,content_2112_46:()=>Uk,content_2112_460:()=>gC,content_2112_462:()=>LC,content_2112_464:()=>bC,content_2112_466:()=>NC,content_2112_468:()=>AC,content_2112_470:()=>RC,content_2112_472:()=>WC,content_2112_474:()=>FC,content_2112_476:()=>jC,content_2112_478:()=>OC,content_2112_48:()=>zk,content_2112_480:()=>qC,content_2112_482:()=>BC,content_2112_484:()=>HC,content_2112_486:()=>JC,content_2112_488:()=>QC,content_2112_490:()=>eg,content_2112_492:()=>og,content_2112_494:()=>rg,content_2112_496:()=>sg,content_2112_498:()=>lg,content_2112_50:()=>Vk,content_2112_500:()=>ug,content_2112_502:()=>dg,content_2112_504:()=>yg,content_2112_506:()=>fg,content_2112_508:()=>Dg,content_2112_510:()=>Xg,content_2112_512:()=>Tg,content_2112_514:()=>gg,content_2112_516:()=>Lg,content_2112_518:()=>bg,content_2112_52:()=>$k,content_2112_520:()=>Ng,content_2112_522:()=>Ag,content_2112_524:()=>Rg,content_2112_526:()=>Wg,content_2112_528:()=>Fg,content_2112_530:()=>jg,content_2112_532:()=>Og,content_2112_534:()=>qg,content_2112_536:()=>Bg,content_2112_538:()=>Hg,content_2112_54:()=>Yk,content_2112_540:()=>Jg,content_2112_542:()=>Qg,content_2112_544:()=>ex,content_2112_546:()=>ox,content_2112_548:()=>rx,content_2112_550:()=>sx,content_2112_552:()=>lx,content_2112_554:()=>ux,content_2112_556:()=>dx,content_2112_558:()=>yx,content_2112_56:()=>Kk,content_2112_560:()=>fx,content_2112_562:()=>Dx,content_2112_564:()=>Xx,content_2112_566:()=>Tx,content_2112_568:()=>gx,content_2112_570:()=>Lx,content_2112_572:()=>bx,content_2112_574:()=>Nx,content_2112_576:()=>Ax,content_2112_578:()=>Rx,content_2112_58:()=>tf,content_2112_580:()=>Wx,content_2112_582:()=>Fx,content_2112_584:()=>jx,content_2112_586:()=>Ox,content_2112_588:()=>qx,content_2112_590:()=>Bx,content_2112_592:()=>Hx,content_2112_594:()=>Jx,content_2112_596:()=>Qx,content_2112_598:()=>eL,content_2112_6:()=>nk,content_2112_60:()=>nf,content_2112_600:()=>oL,content_2112_602:()=>rL,content_2112_604:()=>sL,content_2112_606:()=>lL,content_2112_608:()=>uL,content_2112_610:()=>dL,content_2112_612:()=>yL,content_2112_614:()=>fL,content_2112_616:()=>DL,content_2112_618:()=>XL,content_2112_62:()=>cf,content_2112_620:()=>TL,content_2112_622:()=>gL,content_2112_624:()=>LL,content_2112_626:()=>bL,content_2112_628:()=>NL,content_2112_630:()=>AL,content_2112_632:()=>RL,content_2112_634:()=>WL,content_2112_636:()=>FL,content_2112_638:()=>jL,content_2112_64:()=>pf,content_2112_640:()=>OL,content_2112_642:()=>qL,content_2112_644:()=>BL,content_2112_646:()=>HL,content_2112_648:()=>JL,content_2112_650:()=>QL,content_2112_652:()=>eZ,content_2112_654:()=>oZ,content_2112_656:()=>rZ,content_2112_658:()=>sZ,content_2112_66:()=>af,content_2112_660:()=>lZ,content_2112_662:()=>uZ,content_2112_664:()=>dZ,content_2112_666:()=>yZ,content_2112_668:()=>fZ,content_2112_670:()=>DZ,content_2112_672:()=>XZ,content_2112_674:()=>TZ,content_2112_676:()=>gZ,content_2112_678:()=>LZ,content_2112_68:()=>uf,content_2112_680:()=>bZ,content_2112_682:()=>NZ,content_2112_684:()=>AZ,content_2112_686:()=>RZ,content_2112_688:()=>WZ,content_2112_690:()=>FZ,content_2112_692:()=>jZ,content_2112_694:()=>OZ,content_2112_696:()=>qZ,content_2112_698:()=>BZ,content_2112_70:()=>df,content_2112_700:()=>HZ,content_2112_702:()=>JZ,content_2112_704:()=>QZ,content_2112_706:()=>eb,content_2112_708:()=>ob,content_2112_710:()=>rb,content_2112_712:()=>sb,content_2112_714:()=>lb,content_2112_716:()=>ub,content_2112_718:()=>db,content_2112_72:()=>yf,content_2112_720:()=>yb,content_2112_722:()=>fb,content_2112_724:()=>Db,content_2112_726:()=>Xb,content_2112_728:()=>Tb,content_2112_730:()=>gb,content_2112_732:()=>Lb,content_2112_734:()=>bb,content_2112_736:()=>Nb,content_2112_738:()=>Ab,content_2112_74:()=>ff,content_2112_740:()=>Rb,content_2112_742:()=>Wb,content_2112_744:()=>Fb,content_2112_746:()=>jb,content_2112_748:()=>Ob,content_2112_750:()=>qb,content_2112_752:()=>Bb,content_2112_754:()=>Hb,content_2112_756:()=>Jb,content_2112_758:()=>Qb,content_2112_76:()=>Df,content_2112_760:()=>ev,content_2112_762:()=>ov,content_2112_764:()=>rv,content_2112_766:()=>sv,content_2112_768:()=>lv,content_2112_770:()=>uv,content_2112_772:()=>dv,content_2112_774:()=>yv,content_2112_776:()=>fv,content_2112_778:()=>Dv,content_2112_78:()=>Xf,content_2112_780:()=>Xv,content_2112_782:()=>Tv,content_2112_784:()=>gv,content_2112_786:()=>Lv,content_2112_788:()=>bv,content_2112_790:()=>Nv,content_2112_792:()=>Av,content_2112_794:()=>Rv,content_2112_796:()=>Wv,content_2112_798:()=>Fv,content_2112_8:()=>ck,content_2112_80:()=>Tf,content_2112_800:()=>jv,content_2112_802:()=>Ov,content_2112_804:()=>qv,content_2112_806:()=>Bv,content_2112_808:()=>Hv,content_2112_810:()=>Jv,content_2112_812:()=>Qv,content_2112_814:()=>eN,content_2112_816:()=>oN,content_2112_818:()=>rN,content_2112_82:()=>gf,content_2112_820:()=>sN,content_2112_822:()=>lN,content_2112_824:()=>uN,content_2112_826:()=>dN,content_2112_828:()=>yN,content_2112_830:()=>fN,content_2112_832:()=>DN,content_2112_834:()=>XN,content_2112_836:()=>TN,content_2112_838:()=>gN,content_2112_84:()=>Lf,content_2112_840:()=>LN,content_2112_842:()=>bN,content_2112_844:()=>NN,content_2112_846:()=>AN,content_2112_848:()=>RN,content_2112_850:()=>WN,content_2112_852:()=>FN,content_2112_854:()=>jN,content_2112_856:()=>ON,content_2112_858:()=>qN,content_2112_86:()=>bf,content_2112_860:()=>BN,content_2112_862:()=>HN,content_2112_864:()=>JN,content_2112_866:()=>QN,content_2112_868:()=>eE,content_2112_870:()=>oE,content_2112_872:()=>rE,content_2112_874:()=>sE,content_2112_876:()=>lE,content_2112_878:()=>uE,content_2112_88:()=>Nf,content_2112_880:()=>dE,content_2112_882:()=>yE,content_2112_884:()=>fE,content_2112_886:()=>DE,content_2112_888:()=>XE,content_2112_890:()=>TE,content_2112_892:()=>gE,content_2112_894:()=>LE,content_2112_896:()=>bE,content_2112_898:()=>NE,content_2112_90:()=>Af,content_2112_900:()=>AE,content_2112_902:()=>RE,content_2112_904:()=>WE,content_2112_906:()=>FE,content_2112_908:()=>jE,content_2112_910:()=>OE,content_2112_912:()=>qE,content_2112_914:()=>BE,content_2112_916:()=>HE,content_2112_918:()=>JE,content_2112_92:()=>Rf,content_2112_920:()=>QE,content_2112_922:()=>eA,content_2112_924:()=>oA,content_2112_926:()=>rA,content_2112_928:()=>sA,content_2112_930:()=>lA,content_2112_932:()=>uA,content_2112_934:()=>dA,content_2112_936:()=>yA,content_2112_938:()=>fA,content_2112_94:()=>Wf,content_2112_940:()=>DA,content_2112_942:()=>XA,content_2112_944:()=>TA,content_2112_946:()=>gA,content_2112_948:()=>LA,content_2112_950:()=>bA,content_2112_952:()=>NA,content_2112_954:()=>AA,content_2112_956:()=>RA,content_2112_958:()=>WA,content_2112_96:()=>Ff,content_2112_960:()=>FA,content_2112_962:()=>jA,content_2112_964:()=>OA,content_2112_966:()=>qA,content_2112_968:()=>BA,content_2112_970:()=>HA,content_2112_972:()=>JA,content_2112_974:()=>QA,content_2112_976:()=>eS,content_2112_978:()=>oS,content_2112_98:()=>jf,content_2112_980:()=>rS,content_2112_982:()=>sS,content_2112_984:()=>lS,content_2112_986:()=>uS,content_2112_988:()=>dS,content_2112_990:()=>yS,content_2112_992:()=>fS,content_2112_994:()=>DS,content_2112_996:()=>XS,content_2112_998:()=>TS});var c=n(2784),r=n(7896),p=n(876);const s={toc:[]};function a(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const l={toc:[]};function i(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscriptions and triggering of events."))}i.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,p.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}h.isMDXComponent=!0;const y={toc:[]};function k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches an asynchronous ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}k.isMDXComponent=!0;const f={toc:[]};function M(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}M.isMDXComponent=!0;const D={toc:[]};function _(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}_.isMDXComponent=!0;const X={toc:[]};function w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}w.isMDXComponent=!0;const T={toc:[]};function C(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}C.isMDXComponent=!0;const g={toc:[]};function x(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}x.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Z.isMDXComponent=!0;const b={toc:[]};function v(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}v.isMDXComponent=!0;const N={toc:[]};function E(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}E.isMDXComponent=!0;const A={toc:[]};function S(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}S.isMDXComponent=!0;const R={toc:[]};function P(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}P.isMDXComponent=!0;const W={toc:[]};function I(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}I.isMDXComponent=!0;const F={toc:[]};function G(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}G.isMDXComponent=!0;const j={toc:[]};function U(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}U.isMDXComponent=!0;const O={toc:[]};function z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}z.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}V.isMDXComponent=!0;const B={toc:[]};function $(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value argument to subscribers."))}$.isMDXComponent=!0;const H={toc:[]};function Y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A base for dispatching ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,p.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Y.isMDXComponent=!0;const J={toc:[]};function K(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}K.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}nt.isMDXComponent=!0;const ot={toc:[]};function ct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}ct.isMDXComponent=!0;const rt={toc:[]};function pt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}pt.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},st,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}at.isMDXComponent=!0;const lt={toc:[]};function it(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}it.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,p.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,p.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}ht.isMDXComponent=!0;const yt={toc:[]};function kt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}kt.isMDXComponent=!0;const ft={toc:[]};function Mt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}Mt.isMDXComponent=!0;const Dt={toc:[]};function _t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}_t.isMDXComponent=!0;const Xt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Are subscribers being notified?"))}wt.isMDXComponent=!0;const Tt={toc:[]};function Ct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Notify all current and future subscribers."))}Ct.isMDXComponent=!0;const gt={toc:[]};function xt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stop notifying future subscribers."))}xt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Zt.isMDXComponent=!0;const bt={toc:[]};function vt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}vt.isMDXComponent=!0;const Nt={toc:[]};function Et(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Et.isMDXComponent=!0;const At={toc:[]};function St(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},At,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}St.isMDXComponent=!0;const Rt={toc:[]};function Pt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Pt.isMDXComponent=!0;const Wt={toc:[]};function It(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}It.isMDXComponent=!0;const Ft={toc:[]};function Gt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Gt.isMDXComponent=!0;const jt={toc:[]};function Ut(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Ut.isMDXComponent=!0;const Ot={toc:[]};function zt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}zt.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Vt.isMDXComponent=!0;const Bt={toc:[]};function $t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}$t.isMDXComponent=!0;const Ht={toc:[]};function Yt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ht,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Yt.isMDXComponent=!0;const Jt={toc:[]};function Kt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}Kt.isMDXComponent=!0;const Qt={toc:[]};function te(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ne.isMDXComponent=!0;const oe={toc:[]};function ce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}ce.isMDXComponent=!0;const re={toc:[]};function pe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}pe.isMDXComponent=!0;const se={toc:[]};function ae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},se,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}ae.isMDXComponent=!0;const le={toc:[]};function ie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}ie.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}he.isMDXComponent=!0;const ye={toc:[]};function ke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}ke.isMDXComponent=!0;const fe={toc:[]};function Me(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Me.isMDXComponent=!0;const De={toc:[]};function _e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},De,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}_e.isMDXComponent=!0;const Xe={toc:[]};function we(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}we.isMDXComponent=!0;const Te={toc:[]};function Ce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Te,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Ce.isMDXComponent=!0;const ge={toc:[]};function xe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}xe.isMDXComponent=!0;const Le={toc:[]};function Ze(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Ze.isMDXComponent=!0;const be={toc:[]};function ve(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},be,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}ve.isMDXComponent=!0;const Ne={toc:[]};function Ee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value."))}Ee.isMDXComponent=!0;const Ae={toc:[]};function Se(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}Se.isMDXComponent=!0;const Re={toc:[]};function Pe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Pe.isMDXComponent=!0;const We={toc:[]};function Ie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},We,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set the current value of this dispatcher."))}Ie.isMDXComponent=!0;const Fe={toc:[]};function Ge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new value."))}Ge.isMDXComponent=!0;const je={toc:[]};function Ue(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},je,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}Ue.isMDXComponent=!0;const Oe={toc:[]};function ze(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}ze.isMDXComponent=!0;const qe={toc:[]};function Ve(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ve.isMDXComponent=!0;const Be={toc:[]};function $e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Be,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}$e.isMDXComponent=!0;const He={toc:[]};function Ye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},He,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Ye.isMDXComponent=!0;const Je={toc:[]};function Ke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Je,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Ke.isMDXComponent=!0;const Qe={toc:[]};function tn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}nn.isMDXComponent=!0;const on={toc:[]};function cn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}cn.isMDXComponent=!0;const rn={toc:[]};function pn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}pn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}yn.isMDXComponent=!0;const kn={toc:[]};function fn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fn.isMDXComponent=!0;const Mn={toc:[]};function Dn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}Dn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_n,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}Xn.isMDXComponent=!0;const wn={toc:[]};function Tn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of times the timer has ticked."))}Tn.isMDXComponent=!0;const Cn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator responsible for running this timer."))}gn.isMDXComponent=!0;const xn={toc:[]};function Ln(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the timer ticks."))}Ln.isMDXComponent=!0;const Zn={toc:[]};function bn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current iteration index."))}bn.isMDXComponent=!0;const vn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Nn.isMDXComponent=!0;const En={toc:[]};function An(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}An.isMDXComponent=!0;const Sn={toc:[]};function Rn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Rn.isMDXComponent=!0;const Pn={toc:[]};function Wn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Wn.isMDXComponent=!0;const In={toc:[]};function Fn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},In,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Fn.isMDXComponent=!0;const Gn={toc:[]};function jn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}jn.isMDXComponent=!0;const Un={toc:[]};function On(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Un,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.corenerRadius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}On.isMDXComponent=!0;const zn={toc:[]};function qn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run tasks one after another."))}qn.isMDXComponent=!0;const Vn={toc:[]};function Bn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Bn.isMDXComponent=!0;const $n={toc:[]};function Hn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$n,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Hn.isMDXComponent=!0;const Yn={toc:[]};function Jn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Jn.isMDXComponent=!0;const Kn={toc:[]};function Qn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay in seconds"))}Qn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task or callback to run after the delay."))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}oo.isMDXComponent=!0;const co={toc:[]};function ro(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},co,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Call the given callback every N seconds."))}ro.isMDXComponent=!0;const po={toc:[]};function so(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interval between subsequent calls."))}so.isMDXComponent=!0;const ao={toc:[]};function lo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ao,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to be called."))}lo.isMDXComponent=!0;const io={toc:[]};function uo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each time iteration waits until the previous one is completed."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}ho.isMDXComponent=!0;const yo={toc:[]};function ko(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator N times."))}ko.isMDXComponent=!0;const fo={toc:[]};function Mo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of iterations."))}Mo.isMDXComponent=!0;const Do={toc:[]};function _o(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Do,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}_o.isMDXComponent=!0;const Xo={toc:[]};function wo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Do nothing."))}wo.isMDXComponent=!0;const To={toc:[]};function Co(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},To,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Co.isMDXComponent=!0;const go={toc:[]};function xo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}xo.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}Zo.isMDXComponent=!0;const bo={toc:[]};function vo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}vo.isMDXComponent=!0;const No={toc:[]};function Eo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}Eo.isMDXComponent=!0;const Ao={toc:[]};function So(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ao,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional name used when displaying this generator in the UI."))}So.isMDXComponent=!0;const Ro={toc:[]};function Po(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ro,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}Po.isMDXComponent=!0;const Wo={toc:[]};function Io(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Io.isMDXComponent=!0;const Fo={toc:[]};function Go(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Go.isMDXComponent=!0;const jo={toc:[]};function Uo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Uo.isMDXComponent=!0;const Oo={toc:[]};function zo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay between each of the tasks."))}zo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to be run in a sequence."))}Vo.isMDXComponent=!0;const Bo={toc:[]};function $o(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}$o.isMDXComponent=!0;const Ho={toc:[]};function Yo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ho,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the given amount of time."))}Yo.isMDXComponent=!0;const Jo={toc:[]};function Ko(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The relative time in seconds."))}Ko.isMDXComponent=!0;const Qo={toc:[]};function tc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}nc.isMDXComponent=!0;const oc={toc:[]};function cc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}cc.isMDXComponent=!0;const rc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the given time event."))}pc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the time event."))}ac.isMDXComponent=!0;const lc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}ic.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Main Motion Canvas classes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when a new message is logged."))}hc.isMDXComponent=!0;const yc={toc:[]};function kc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the meta file of a given entity."))}kc.isMDXComponent=!0;const fc={toc:[]};function Mc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when metadata changes."))}Mc.isMDXComponent=!0;const Dc={toc:[]};function _c(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Load new metadata from a file."))}_c.isMDXComponent=!0;const Xc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New metadata."))}wc.isMDXComponent=!0;const Tc={toc:[]};function Cc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any possible errors will be logged to the console."))}Cc.isMDXComponent=!0;const gc={toc:[]};function xc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set data without waiting for confirmation."))}xc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New data."))}Zc.isMDXComponent=!0;const bc={toc:[]};function vc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the data stored in the meta file."))}vc.isMDXComponent=!0;const Nc={toc:[]};function Ec(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,p.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}Ec.isMDXComponent=!0;const Ac={toc:[]};function Sc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ac,n,{components:e,mdxType:"MDXLayout"}))}Sc.isMDXComponent=!0;const Rc={toc:[]};function Pc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The project configuration."))}Pc.isMDXComponent=!0;const Wc={toc:[]};function Ic(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the current scene changes."))}Ic.isMDXComponent=!0;const Fc={toc:[]};function Gc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Gc.isMDXComponent=!0;const jc={toc:[]};function Uc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after the scenes were recalculated."))}Uc.isMDXComponent=!0;const Oc={toc:[]};function zc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}zc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Multi-media management."))}Vc.isMDXComponent=!0;const Bc={toc:[]};function $c(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}$c.isMDXComponent=!0;const Hc={toc:[]};function Yc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause/resume the audio."))}Yc.isMDXComponent=!0;const Jc={toc:[]};function Kc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the audio should be paused or resumed."))}Kc.isMDXComponent=!0;const Qc={toc:[]};function tr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The absolute biggest value from the peaks array."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of samples taken."))}nr.isMDXComponent=!0;const or={toc:[]};function cr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}cr.isMDXComponent=!0;const rr={toc:[]};function pr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Samples per seconds."))}pr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Playback control."))}ar.isMDXComponent=!0;const lr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Abstract scene representations and related utilities."))}ir.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Signifies the various stages of a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs after a render ends."))}hr.isMDXComponent=!0;const yr={toc:[]};function kr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}kr.isMDXComponent=!0;const fr={toc:[]};function Mr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,p.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Mr.isMDXComponent=!0;const Dr={toc:[]};function _r(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,p.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}_r.isMDXComponent=!0;const Xr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes the state of a scene."))}wr.isMDXComponent=!0;const Tr={toc:[]};function Cr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Cr.isMDXComponent=!0;const gr={toc:[]};function xr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished transitioning in."))}xr.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Zr.isMDXComponent=!0;const br={toc:[]};function vr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},br,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene is ready to transition out."))}vr.isMDXComponent=!0;const Nr={toc:[]};function Er(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoking ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Er.isMDXComponent=!0;const Ar={toc:[]};function Sr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ar,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished."))}Sr.isMDXComponent=!0;const Rr={toc:[]};function Pr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has just been created/reset."))}Pr.isMDXComponent=!0;const Wr={toc:[]};function Ir(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The default implementation of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,p.kt)("p",null,"Uses generators to control the animation."))}Ir.isMDXComponent=!0;const Fr={toc:[]};function Gr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Gr.isMDXComponent=!0;const jr={toc:[]};function Ur(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Ur.isMDXComponent=!0;const Or={toc:[]};function zr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}zr.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Vr.isMDXComponent=!0;const Br={toc:[]};function $r(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}$r.isMDXComponent=!0;const Hr={toc:[]};function Yr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Yr.isMDXComponent=!0;const Jr={toc:[]};function Kr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Kr.isMDXComponent=!0;const Qr={toc:[]};function tp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}np.isMDXComponent=!0;const op={toc:[]};function cp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}cp.isMDXComponent=!0;const rp={toc:[]};function pp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}pp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ap.isMDXComponent=!0;const lp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ip.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hp.isMDXComponent=!0;const yp={toc:[]};function kp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}kp.isMDXComponent=!0;const fp={toc:[]};function Mp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Mp.isMDXComponent=!0;const Dp={toc:[]};function _p(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}_p.isMDXComponent=!0;const Xp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}wp.isMDXComponent=!0;const Tp={toc:[]};function Cp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}Cp.isMDXComponent=!0;const gp={toc:[]};function xp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}xp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}Zp.isMDXComponent=!0;const bp={toc:[]};function vp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}vp.isMDXComponent=!0;const Np={toc:[]};function Ep(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Ep.isMDXComponent=!0;const Ap={toc:[]};function Sp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ap,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}Sp.isMDXComponent=!0;const Rp={toc:[]};function Pp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Pp.isMDXComponent=!0;const Wp={toc:[]};function Ip(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Ip.isMDXComponent=!0;const Fp={toc:[]};function Gp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Gp.isMDXComponent=!0;const jp={toc:[]};function Up(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Up.isMDXComponent=!0;const Op={toc:[]};function zp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}zp.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Lifecycle events for ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Vp.isMDXComponent=!0;const Bp={toc:[]};function $p(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A random number generator based on\n",(0,p.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,p.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}$p.isMDXComponent=!0;const Hp={toc:[]};function Yp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random floats in the given range."))}Yp.isMDXComponent=!0;const Jp={toc:[]};function Kp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."))}Kp.isMDXComponent=!0;const Qp={toc:[]};function ts(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}ns.isMDXComponent=!0;const os={toc:[]};function cs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random integers in the given range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"}),(0,p.kt)("li",{parentName:"ul"})))}cs.isMDXComponent=!0;const rs={toc:[]};function ps(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}ps.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ss,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}as.isMDXComponent=!0;const ls={toc:[]};function is(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ls,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}is.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random float in the given range."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}hs.isMDXComponent=!0;const ys={toc:[]};function ks(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}ks.isMDXComponent=!0;const fs={toc:[]};function Ms(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random integer in the given range."))}Ms.isMDXComponent=!0;const Ds={toc:[]};function _s(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ds,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}_s.isMDXComponent=!0;const Xs={toc:[]};function ws(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}ws.isMDXComponent=!0;const Ts={toc:[]};function Cs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ts,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a new independent generator."))}Cs.isMDXComponent=!0;const gs={toc:[]};function xs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Manages time events for a given scene."))}xs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ls,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when time events change."))}Zs.isMDXComponent=!0;const bs={toc:[]};function vs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the time offset of the given event."))}vs.isMDXComponent=!0;const Ns={toc:[]};function Es(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the event."))}Es.isMDXComponent=!0;const As={toc:[]};function Ss(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},As,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The time offset in seconds."))}Ss.isMDXComponent=!0;const Rs={toc:[]};function Ps(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}Ps.isMDXComponent=!0;const Ws={toc:[]};function Is(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ws,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes cached information about the timing of a scene."))}Is.isMDXComponent=!0;const Fs={toc:[]};function Gs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a complete scene together with the meta file."))}Gs.isMDXComponent=!0;const js={toc:[]};function Us(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},js,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Us.isMDXComponent=!0;const Os={toc:[]};function zs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}zs.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Vs.isMDXComponent=!0;const Bs={toc:[]};function $s(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}$s.isMDXComponent=!0;const Hs={toc:[]};function Ys(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Ys.isMDXComponent=!0;const Js={toc:[]};function Ks(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Js,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Ks.isMDXComponent=!0;const Qs={toc:[]};function ta(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for the inspected element."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element for which to draw an overlay."))}na.isMDXComponent=!0;const oa={toc:[]};function ca(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}ca.isMDXComponent=!0;const ra={toc:[]};function pa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}pa.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}aa.isMDXComponent=!0;const la={toc:[]};function ia(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},la,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the attributes of the inspected element."))}ia.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to inspect."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a possible element to inspect at a given position."))}ha.isMDXComponent=!0;const ya={toc:[]};function ka(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x coordinate."))}ka.isMDXComponent=!0;const fa={toc:[]};function Ma(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y coordinate."))}Ma.isMDXComponent=!0;const Da={toc:[]};function _a(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Da,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}_a.isMDXComponent=!0;const Xa={toc:[]};function wa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the inspected element is still valid."))}wa.isMDXComponent=!0;const Ta={toc:[]};function Ca(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ta,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to validate."))}Ca.isMDXComponent=!0;const ga={toc:[]};function xa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event stored in a meta file."))}xa.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},La,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Za.isMDXComponent=!0;const ba={toc:[]};function va(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ba,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main interface for scenes."))}va.isMDXComponent=!0;const Na={toc:[]};function Ea(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Ea.isMDXComponent=!0;const Aa={toc:[]};function Sa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Aa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Sa.isMDXComponent=!0;const Ra={toc:[]};function Pa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ra,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Pa.isMDXComponent=!0;const Wa={toc:[]};function Ia(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene's ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Ia.isMDXComponent=!0;const Fa={toc:[]};function Ga(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Ga.isMDXComponent=!0;const ja={toc:[]};function Ua(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ja,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}Ua.isMDXComponent=!0;const Oa={toc:[]};function za(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}za.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Va.isMDXComponent=!0;const Ba={toc:[]};function $a(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}$a.isMDXComponent=!0;const Ha={toc:[]};function Ya(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ha,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ya.isMDXComponent=!0;const Ja={toc:[]};function Ka(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ja,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Ka.isMDXComponent=!0;const Qa={toc:[]};function tl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}nl.isMDXComponent=!0;const ol={toc:[]};function cl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}cl.isMDXComponent=!0;const rl={toc:[]};function pl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}pl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}al.isMDXComponent=!0;const ll={toc:[]};function il(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ll,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}il.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}hl.isMDXComponent=!0;const yl={toc:[]};function kl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}kl.isMDXComponent=!0;const fl={toc:[]};function Ml(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ml.isMDXComponent=!0;const Dl={toc:[]};function _l(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}_l.isMDXComponent=!0;const Xl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}wl.isMDXComponent=!0;const Tl={toc:[]};function Cl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Cl.isMDXComponent=!0;const gl={toc:[]};function xl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}xl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ll,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Zl.isMDXComponent=!0;const bl={toc:[]};function vl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}vl.isMDXComponent=!0;const Nl={toc:[]};function El(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}El.isMDXComponent=!0;const Al={toc:[]};function Sl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Al,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Sl.isMDXComponent=!0;const Rl={toc:[]};function Pl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Pl.isMDXComponent=!0;const Wl={toc:[]};function Il(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each class implementing the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Il.isMDXComponent=!0;const Fl={toc:[]};function Gl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constructor used when creating new scenes."))}Gl.isMDXComponent=!0;const jl={toc:[]};function Ul(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,p.kt)("inlineCode",{parentName:"a"},"config")),"."))}Ul.isMDXComponent=!0;const Ol={toc:[]};function zl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a scene exposed by scene files."))}zl.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ql,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Vl.isMDXComponent=!0;const Bl={toc:[]};function $l(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}$l.isMDXComponent=!0;const Hl={toc:[]};function Yl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Yl.isMDXComponent=!0;const Jl={toc:[]};function Kl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Kl.isMDXComponent=!0;const Ql={toc:[]};function ti(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ql,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ni.isMDXComponent=!0;const oi={toc:[]};function ci(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ci.isMDXComponent=!0;const ri={toc:[]};function pi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}pi.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},si,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event at runtime."))}ai.isMDXComponent=!0;const li={toc:[]};function ii(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},li,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"In other words, the moment at which ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,p.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}ii.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the event."))}hi.isMDXComponent=!0;const yi={toc:[]};function ki(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Duration of the event in seconds."))}ki.isMDXComponent=!0;const fi={toc:[]};function Mi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stack trace at the moment of registration."))}Mi.isMDXComponent=!0;const Di={toc:[]};function _i(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Di,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}_i.isMDXComponent=!0;const Xi={toc:[]};function wi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents attributes of an inspected element."))}wi.isMDXComponent=!0;const Ti={toc:[]};function Ci(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ti,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Ci.isMDXComponent=!0;const gi={toc:[]};function xi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents an element to inspect."))}xi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Li,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Zi.isMDXComponent=!0;const bi={toc:[]};function vi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}vi.isMDXComponent=!0;const Ni={toc:[]};function Ei(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Ei.isMDXComponent=!0;const Ai={toc:[]};function Si(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ai,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Si.isMDXComponent=!0;const Ri={toc:[]};function Pi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ri,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Pi.isMDXComponent=!0;const Wi={toc:[]};function Ii(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Ii.isMDXComponent=!0;const Fi={toc:[]};function Gi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Gi.isMDXComponent=!0;const ji={toc:[]};function Ui(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ji,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Ui.isMDXComponent=!0;const Oi={toc:[]};function zi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}zi.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Vi.isMDXComponent=!0;const Bi={toc:[]};function $i(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}$i.isMDXComponent=!0;const Hi={toc:[]};function Yi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Yi.isMDXComponent=!0;const Ji={toc:[]};function Ki(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ji,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Ki.isMDXComponent=!0;const Qi={toc:[]};function tu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}nu.isMDXComponent=!0;const ou={toc:[]};function cu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}cu.isMDXComponent=!0;const ru={toc:[]};function pu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}pu.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},su,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}au.isMDXComponent=!0;const lu={toc:[]};function iu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}iu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread management."))}hu.isMDXComponent=!0;const yu={toc:[]};function ku(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,p.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}ku.isMDXComponent=!0;const fu={toc:[]};function Mu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A class representing an individual thread."))}Mu.isMDXComponent=!0;const Du={toc:[]};function _u(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Du,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}_u.isMDXComponent=!0;const Xu={toc:[]};function wu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}wu.isMDXComponent=!0;const Tu={toc:[]};function Cu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Used by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}Cu.isMDXComponent=!0;const gu={toc:[]};function xu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current time of this thread."))}xu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The next value to be passed to the wrapped generator."))}Zu.isMDXComponent=!0;const bu={toc:[]};function vu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}vu.isMDXComponent=!0;const Nu={toc:[]};function Eu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress the wrapped generator once."))}Eu.isMDXComponent=!0;const Au={toc:[]};function Su(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Au,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the thread for the next update cycle."))}Su.isMDXComponent=!0;const Ru={toc:[]};function Pu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ru,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a normal function that returns a generator."))}Pu.isMDXComponent=!0;const Wu={toc:[]};function Iu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,p.kt)("p",null,"Progress to the next frame:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,p.kt)("p",null,"Run another generator synchronously:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,p.kt)("p",null,"Run another generator concurrently:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,p.kt)("p",null,"Await a Promise:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Iu.isMDXComponent=!0;const Fu={toc:[]};function Gu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Gu.isMDXComponent=!0;const ju={toc:[]};function Uu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ju,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Cancel all listed tasks."),(0,p.kt)("p",null,"Example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Uu.isMDXComponent=!0;const Ou={toc:[]};function zu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to cancel."))}zu.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Vu.isMDXComponent=!0;const Bu={toc:[]};function $u(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}$u.isMDXComponent=!0;const Hu={toc:[]};function Yu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Yu.isMDXComponent=!0;const Ju={toc:[]};function Ku(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ju,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible thread ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Ku.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}nm.isMDXComponent=!0;const om={toc:[]};function cm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}cm.isMDXComponent=!0;const rm={toc:[]};function pm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}pm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until listed tasks are finished."))}am.isMDXComponent=!0;const lm={toc:[]};function im(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}im.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"From the perspective of the external generator, ",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}hm.isMDXComponent=!0;const ym={toc:[]};function km(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}km.isMDXComponent=!0;const fm={toc:[]};function Mm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a context in which generators can be run concurrently."))}Mm.isMDXComponent=!0;const Dm={toc:[]};function _m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the generator to run."))}_m.isMDXComponent=!0;const Xm={toc:[]};function wm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}wm.isMDXComponent=!0;const Tm={toc:[]};function Cm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transitions between scenes."))}Cm.isMDXComponent=!0;const gm={toc:[]};function xm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}xm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the current scene is rendered."))}Zm.isMDXComponent=!0;const bm={toc:[]};function vm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the previous scene is rendered."))}vm.isMDXComponent=!0;const Nm={toc:[]};function Em(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolation and timing of tweens."))}Em.isMDXComponent=!0;const Am={toc:[]};function Sm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Am,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any old key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"})))}Sm.isMDXComponent=!0;const Rm={toc:[]};function Pm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Pm.isMDXComponent=!0;const Wm={toc:[]};function Im(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Im.isMDXComponent=!0;const Fm={toc:[]};function Gm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Gm.isMDXComponent=!0;const jm={toc:[]};function Um(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Um.isMDXComponent=!0;const Om={toc:[]};function zm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}zm.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Vm.isMDXComponent=!0;const Bm={toc:[]};function $m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}$m.isMDXComponent=!0;const Hm={toc:[]};function Ym(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Ym.isMDXComponent=!0;const Jm={toc:[]};function Km(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Km.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Complex types used in animations."))}nd.isMDXComponent=!0;const od={toc:[]};function cd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a two-dimensional vector."))}cd.isMDXComponent=!0;const rd={toc:[]};function pd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}pd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The unclipped RGB components."))}ad.isMDXComponent=!0;const ld={toc:[]};function id(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ld,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}id.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}hd.isMDXComponent=!0;const yd={toc:[]};function kd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}kd.isMDXComponent=!0;const fd={toc:[]};function Md(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}Md.isMDXComponent=!0;const Dd={toc:[]};function _d(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}_d.isMDXComponent=!0;const Xd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}wd.isMDXComponent=!0;const Td={toc:[]};function Cd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Td,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Alias of ",(0,p.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Cd.isMDXComponent=!0;const gd={toc:[]};function xd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}xd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ld,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Zd.isMDXComponent=!0;const bd={toc:[]};function vd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}vd.isMDXComponent=!0;const Nd={toc:[]};function Ed(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Ed.isMDXComponent=!0;const Ad={toc:[]};function Sd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ad,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Sd.isMDXComponent=!0;const Rd={toc:[]};function Pd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Pd.isMDXComponent=!0;const Wd={toc:[]};function Id(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}Id.isMDXComponent=!0;const Fd={toc:[]};function Gd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"L"),", ",(0,p.kt)("strong",{parentName:"p"},"a"),", and ",(0,p.kt)("strong",{parentName:"p"},"b")," components."))}Gd.isMDXComponent=!0;const jd={toc:[]};function Ud(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}Ud.isMDXComponent=!0;const Od={toc:[]};function zd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,p.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,p.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}zd.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}Vd.isMDXComponent=!0;const Bd={toc:[]};function $d(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}$d.isMDXComponent=!0;const Hd={toc:[]};function Yd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Yd.isMDXComponent=!0;const Jd={toc:[]};function Kd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}Kd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get and set the color opacity."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,p.kt)("code",null,"'rgb'")))}nh.isMDXComponent=!0;const oh={toc:[]};function ch(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Similar to saturate, but the opposite direction."))}ch.isMDXComponent=!0;const rh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"set"))}ph.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a single channel value.\nAlso"))}ah.isMDXComponent=!0;const lh={toc:[]};function ih(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}ih.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color as hexadecimal string."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}hh.isMDXComponent=!0;const yh={toc:[]};function kh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,p.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}kh.isMDXComponent=!0;const fh={toc:[]};function Mh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}Mh.isMDXComponent=!0;const Dh={toc:[]};function _h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}_h.isMDXComponent=!0;const Xh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}wh.isMDXComponent=!0;const Th={toc:[]};function Ch(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Th,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Ch.isMDXComponent=!0;const gh={toc:[]};function xh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}xh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}Zh.isMDXComponent=!0;const bh={toc:[]};function vh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}vh.isMDXComponent=!0;const Nh={toc:[]};function Eh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Eh.isMDXComponent=!0;const Ah={toc:[]};function Sh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ah,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Sh.isMDXComponent=!0;const Rh={toc:[]};function Ph(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Ph.isMDXComponent=!0;const Wh={toc:[]};function Ih(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Ih.isMDXComponent=!0;const Fh={toc:[]};function Gh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The origin to convert."))}Gh.isMDXComponent=!0;const jh={toc:[]};function Uh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"General utilities and helper functions."))}Uh.isMDXComponent=!0;const Oh={toc:[]};function zh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}zh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Optional override for formatting stack traces"))}Vh.isMDXComponent=!0;const Bh={toc:[]};function $h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create .stack property on a target object"))}$h.isMDXComponent=!0;const Hh={toc:[]};function Yh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the reference instead."))}Yh.isMDXComponent=!0;const Jh={toc:[]};function Kh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jh,n,{components:e,mdxType:"MDXLayout"}))}Kh.isMDXComponent=!0;const Qh={toc:[]};function ty(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mark the given function as deprecated."))}ty.isMDXComponent=!0;const ey={toc:[]};function ny(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function to deprecate."))}ny.isMDXComponent=!0;const oy={toc:[]};function cy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The log message."))}cy.isMDXComponent=!0;const ry={toc:[]};function py(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ry,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The optional log remarks."))}py.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}ay.isMDXComponent=!0;const ly={toc:[]};function iy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}iy.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The length of the array."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}hy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}ky.isMDXComponent=!0;const fy={toc:[]};function My(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}My.isMDXComponent=!0;const Dy={toc:[]};function _y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}_y.isMDXComponent=!0;const Xy={toc:[]};function wy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}wy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context before render."))}Cy.isMDXComponent=!0;const gy={toc:[]};function xy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}xy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ly,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context after render."))}Zy.isMDXComponent=!0;const by={toc:[]};function vy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},by,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current project."))}vy.isMDXComponent=!0;const Ny={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the current scene."))}Ey.isMDXComponent=!0;const Ay={toc:[]};function Sy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ay,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the given seed."))}Sy.isMDXComponent=!0;const Ry={toc:[]};function Py(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ry,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The seed for the generator."))}Py.isMDXComponent=!0;const Wy={toc:[]};function Iy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}Iy.isMDXComponent=!0;const Fy={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current scene."))}Gy.isMDXComponent=!0;const jy={toc:[]};function Uy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current thread."))}Uy.isMDXComponent=!0;const Oy={toc:[]};function zy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}zy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}Vy.isMDXComponent=!0;const By={toc:[]};function $y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},By,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the real time since the start of the animation."))}$y.isMDXComponent=!0;const Hy={toc:[]};function Yy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Yy.isMDXComponent=!0;const Jy={toc:[]};function Ky(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Ky.isMDXComponent=!0;const Qy={toc:[]};function tk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}tk.isMDXComponent=!0;const ek={toc:[]};function nk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ek,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}nk.isMDXComponent=!0;const ok={toc:[]};function ck(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ok,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}ck.isMDXComponent=!0;const rk={toc:[]};function pk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}pk.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ak.isMDXComponent=!0;const lk={toc:[]};function ik(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ik.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}hk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}kk.isMDXComponent=!0;const fk={toc:[]};function Mk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Mk.isMDXComponent=!0;const Dk={toc:[]};function _k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}_k.isMDXComponent=!0;const Xk={toc:[]};function wk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}wk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Ck.isMDXComponent=!0;const gk={toc:[]};function xk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}xk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Zk.isMDXComponent=!0;const bk={toc:[]};function vk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}vk.isMDXComponent=!0;const Nk={toc:[]};function Ek(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ek.isMDXComponent=!0;const Ak={toc:[]};function Sk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ak,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Sk.isMDXComponent=!0;const Rk={toc:[]};function Pk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Pk.isMDXComponent=!0;const Wk={toc:[]};function Ik(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Ik.isMDXComponent=!0;const Fk={toc:[]};function Gk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Gk.isMDXComponent=!0;const jk={toc:[]};function Uk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Uk.isMDXComponent=!0;const Ok={toc:[]};function zk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ok,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}zk.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Vk.isMDXComponent=!0;const Bk={toc:[]};function $k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}$k.isMDXComponent=!0;const Hk={toc:[]};function Yk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Yk.isMDXComponent=!0;const Jk={toc:[]};function Kk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}Kk.isMDXComponent=!0;const Qk={toc:[]};function tf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}nf.isMDXComponent=!0;const of={toc:[]};function cf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}cf.isMDXComponent=!0;const rf={toc:[]};function pf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}pf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}yf.isMDXComponent=!0;const kf={toc:[]};function ff(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ff.isMDXComponent=!0;const Mf={toc:[]};function Df(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Df.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Xf.isMDXComponent=!0;const wf={toc:[]};function Tf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Tf.isMDXComponent=!0;const Cf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gf.isMDXComponent=!0;const xf={toc:[]};function Lf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function bf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}bf.isMDXComponent=!0;const vf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Nf.isMDXComponent=!0;const Ef={toc:[]};function Af(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ef,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Af.isMDXComponent=!0;const Sf={toc:[]};function Rf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}Rf.isMDXComponent=!0;const Pf={toc:[]};function Wf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Wf.isMDXComponent=!0;const If={toc:[]};function Ff(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},If,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Ff.isMDXComponent=!0;const Gf={toc:[]};function jf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}jf.isMDXComponent=!0;const Uf={toc:[]};function Of(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Of.isMDXComponent=!0;const zf={toc:[]};function qf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}qf.isMDXComponent=!0;const Vf={toc:[]};function Bf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Bf.isMDXComponent=!0;const $f={toc:[]};function Hf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Hf.isMDXComponent=!0;const Yf={toc:[]};function Jf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Jf.isMDXComponent=!0;const Kf={toc:[]};function Qf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Qf.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oM.isMDXComponent=!0;const cM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rM.isMDXComponent=!0;const pM={toc:[]};function sM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}sM.isMDXComponent=!0;const aM={toc:[]};function lM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lM.isMDXComponent=!0;const iM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}yM.isMDXComponent=!0;const kM={toc:[]};function fM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fM.isMDXComponent=!0;const MM={toc:[]};function DM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}DM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_M,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}XM.isMDXComponent=!0;const wM={toc:[]};function TM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}TM.isMDXComponent=!0;const CM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}gM.isMDXComponent=!0;const xM={toc:[]};function LM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}LM.isMDXComponent=!0;const ZM={toc:[]};function bM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}bM.isMDXComponent=!0;const vM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}NM.isMDXComponent=!0;const EM={toc:[]};function AM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}AM.isMDXComponent=!0;const SM={toc:[]};function RM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}RM.isMDXComponent=!0;const PM={toc:[]};function WM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}WM.isMDXComponent=!0;const IM={toc:[]};function FM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}FM.isMDXComponent=!0;const GM={toc:[]};function jM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}jM.isMDXComponent=!0;const UM={toc:[]};function OM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}OM.isMDXComponent=!0;const zM={toc:[]};function qM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}qM.isMDXComponent=!0;const VM={toc:[]};function BM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}BM.isMDXComponent=!0;const $M={toc:[]};function HM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$M,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}HM.isMDXComponent=!0;const YM={toc:[]};function JM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}JM.isMDXComponent=!0;const KM={toc:[]};function QM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QM.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}oD.isMDXComponent=!0;const cD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}rD.isMDXComponent=!0;const pD={toc:[]};function sD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}sD.isMDXComponent=!0;const aD={toc:[]};function lD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}lD.isMDXComponent=!0;const iD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}yD.isMDXComponent=!0;const kD={toc:[]};function fD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}fD.isMDXComponent=!0;const MD={toc:[]};function DD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}DD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_D,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}XD.isMDXComponent=!0;const wD={toc:[]};function TD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}TD.isMDXComponent=!0;const CD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}gD.isMDXComponent=!0;const xD={toc:[]};function LD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}LD.isMDXComponent=!0;const ZD={toc:[]};function bD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}bD.isMDXComponent=!0;const vD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ND.isMDXComponent=!0;const ED={toc:[]};function AD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ED,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}AD.isMDXComponent=!0;const SD={toc:[]};function RD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}RD.isMDXComponent=!0;const PD={toc:[]};function WD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}WD.isMDXComponent=!0;const ID={toc:[]};function FD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ID,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}FD.isMDXComponent=!0;const GD={toc:[]};function jD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}jD.isMDXComponent=!0;const UD={toc:[]};function OD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}OD.isMDXComponent=!0;const zD={toc:[]};function qD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qD.isMDXComponent=!0;const VD={toc:[]};function BD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}BD.isMDXComponent=!0;const $D={toc:[]};function HD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$D,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}HD.isMDXComponent=!0;const YD={toc:[]};function JD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}JD.isMDXComponent=!0;const KD={toc:[]};function QD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}QD.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}o_.isMDXComponent=!0;const c_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}r_.isMDXComponent=!0;const p_={toc:[]};function s_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}s_.isMDXComponent=!0;const a_={toc:[]};function l_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}l_.isMDXComponent=!0;const i_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}y_.isMDXComponent=!0;const k_={toc:[]};function f_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}f_.isMDXComponent=!0;const M_={toc:[]};function D_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}D_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},__,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}X_.isMDXComponent=!0;const w_={toc:[]};function T_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}T_.isMDXComponent=!0;const C_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}g_.isMDXComponent=!0;const x_={toc:[]};function L_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}L_.isMDXComponent=!0;const Z_={toc:[]};function b_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}b_.isMDXComponent=!0;const v_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}N_.isMDXComponent=!0;const E_={toc:[]};function A_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}A_.isMDXComponent=!0;const S_={toc:[]};function R_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}R_.isMDXComponent=!0;const P_={toc:[]};function W_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}W_.isMDXComponent=!0;const I_={toc:[]};function F_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}F_.isMDXComponent=!0;const G_={toc:[]};function j_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}j_.isMDXComponent=!0;const U_={toc:[]};function O_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}O_.isMDXComponent=!0;const z_={toc:[]};function q_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}q_.isMDXComponent=!0;const V_={toc:[]};function B_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}B_.isMDXComponent=!0;const $_={toc:[]};function H_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}H_.isMDXComponent=!0;const Y_={toc:[]};function J_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}J_.isMDXComponent=!0;const K_={toc:[]};function Q_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Q_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}oX.isMDXComponent=!0;const cX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}rX.isMDXComponent=!0;const pX={toc:[]};function sX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}sX.isMDXComponent=!0;const aX={toc:[]};function lX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}lX.isMDXComponent=!0;const iX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}yX.isMDXComponent=!0;const kX={toc:[]};function fX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}fX.isMDXComponent=!0;const MX={toc:[]};function DX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}DX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_X,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XX.isMDXComponent=!0;const wX={toc:[]};function TX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}TX.isMDXComponent=!0;const CX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}gX.isMDXComponent=!0;const xX={toc:[]};function LX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}LX.isMDXComponent=!0;const ZX={toc:[]};function bX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}bX.isMDXComponent=!0;const vX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}NX.isMDXComponent=!0;const EX={toc:[]};function AX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}AX.isMDXComponent=!0;const SX={toc:[]};function RX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}RX.isMDXComponent=!0;const PX={toc:[]};function WX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}WX.isMDXComponent=!0;const IX={toc:[]};function FX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}FX.isMDXComponent=!0;const GX={toc:[]};function jX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}jX.isMDXComponent=!0;const UX={toc:[]};function OX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}OX.isMDXComponent=!0;const zX={toc:[]};function qX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}qX.isMDXComponent=!0;const VX={toc:[]};function BX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}BX.isMDXComponent=!0;const $X={toc:[]};function HX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$X,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}HX.isMDXComponent=!0;const YX={toc:[]};function JX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}JX.isMDXComponent=!0;const KX={toc:[]};function QX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}QX.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}ow.isMDXComponent=!0;const cw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}rw.isMDXComponent=!0;const pw={toc:[]};function sw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}sw.isMDXComponent=!0;const aw={toc:[]};function lw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}lw.isMDXComponent=!0;const iw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yw.isMDXComponent=!0;const kw={toc:[]};function fw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}fw.isMDXComponent=!0;const Mw={toc:[]};function Dw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Dw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_w,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Xw.isMDXComponent=!0;const ww={toc:[]};function Tw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Tw.isMDXComponent=!0;const Cw={toc:[]};function gw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}gw.isMDXComponent=!0;const xw={toc:[]};function Lw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function bw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}bw.isMDXComponent=!0;const vw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Nw.isMDXComponent=!0;const Ew={toc:[]};function Aw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ew,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Aw.isMDXComponent=!0;const Sw={toc:[]};function Rw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Rw.isMDXComponent=!0;const Pw={toc:[]};function Ww(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Ww.isMDXComponent=!0;const Iw={toc:[]};function Fw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}Fw.isMDXComponent=!0;const Gw={toc:[]};function jw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}jw.isMDXComponent=!0;const Uw={toc:[]};function Ow(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ow.isMDXComponent=!0;const zw={toc:[]};function qw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qw.isMDXComponent=!0;const Vw={toc:[]};function Bw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Bw.isMDXComponent=!0;const $w={toc:[]};function Hw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$w,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Hw.isMDXComponent=!0;const Yw={toc:[]};function Jw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Jw.isMDXComponent=!0;const Kw={toc:[]};function Qw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Qw.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}oT.isMDXComponent=!0;const cT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}rT.isMDXComponent=!0;const pT={toc:[]};function sT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}sT.isMDXComponent=!0;const aT={toc:[]};function lT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}lT.isMDXComponent=!0;const iT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}yT.isMDXComponent=!0;const kT={toc:[]};function fT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}fT.isMDXComponent=!0;const MT={toc:[]};function DT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}DT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_T,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}XT.isMDXComponent=!0;const wT={toc:[]};function TT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}TT.isMDXComponent=!0;const CT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gT.isMDXComponent=!0;const xT={toc:[]};function LT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}LT.isMDXComponent=!0;const ZT={toc:[]};function bT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bT.isMDXComponent=!0;const vT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}NT.isMDXComponent=!0;const ET={toc:[]};function AT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ET,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}AT.isMDXComponent=!0;const ST={toc:[]};function RT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ST,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}RT.isMDXComponent=!0;const PT={toc:[]};function WT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}WT.isMDXComponent=!0;const IT={toc:[]};function FT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}FT.isMDXComponent=!0;const GT={toc:[]};function jT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}jT.isMDXComponent=!0;const UT={toc:[]};function OT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}OT.isMDXComponent=!0;const zT={toc:[]};function qT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}qT.isMDXComponent=!0;const VT={toc:[]};function BT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}BT.isMDXComponent=!0;const $T={toc:[]};function HT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$T,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}HT.isMDXComponent=!0;const YT={toc:[]};function JT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}JT.isMDXComponent=!0;const KT={toc:[]};function QT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}QT.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}oC.isMDXComponent=!0;const cC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}rC.isMDXComponent=!0;const pC={toc:[]};function sC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}sC.isMDXComponent=!0;const aC={toc:[]};function lC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}lC.isMDXComponent=!0;const iC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}yC.isMDXComponent=!0;const kC={toc:[]};function fC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}fC.isMDXComponent=!0;const MC={toc:[]};function DC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}DC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_C,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}XC.isMDXComponent=!0;const wC={toc:[]};function TC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}TC.isMDXComponent=!0;const CC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}gC.isMDXComponent=!0;const xC={toc:[]};function LC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}LC.isMDXComponent=!0;const ZC={toc:[]};function bC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}bC.isMDXComponent=!0;const vC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}NC.isMDXComponent=!0;const EC={toc:[]};function AC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}AC.isMDXComponent=!0;const SC={toc:[]};function RC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}RC.isMDXComponent=!0;const PC={toc:[]};function WC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}WC.isMDXComponent=!0;const IC={toc:[]};function FC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}FC.isMDXComponent=!0;const GC={toc:[]};function jC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}jC.isMDXComponent=!0;const UC={toc:[]};function OC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}OC.isMDXComponent=!0;const zC={toc:[]};function qC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}qC.isMDXComponent=!0;const VC={toc:[]};function BC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}BC.isMDXComponent=!0;const $C={toc:[]};function HC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$C,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}HC.isMDXComponent=!0;const YC={toc:[]};function JC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}JC.isMDXComponent=!0;const KC={toc:[]};function QC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}QC.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}og.isMDXComponent=!0;const cg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}rg.isMDXComponent=!0;const pg={toc:[]};function sg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}sg.isMDXComponent=!0;const ag={toc:[]};function lg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ag,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}lg.isMDXComponent=!0;const ig={toc:[]};function ug(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}yg.isMDXComponent=!0;const kg={toc:[]};function fg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}fg.isMDXComponent=!0;const Mg={toc:[]};function Dg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Dg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_g,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Xg.isMDXComponent=!0;const wg={toc:[]};function Tg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Tg.isMDXComponent=!0;const Cg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}gg.isMDXComponent=!0;const xg={toc:[]};function Lg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function bg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}bg.isMDXComponent=!0;const vg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Ng.isMDXComponent=!0;const Eg={toc:[]};function Ag(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ag.isMDXComponent=!0;const Sg={toc:[]};function Rg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Rg.isMDXComponent=!0;const Pg={toc:[]};function Wg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Wg.isMDXComponent=!0;const Ig={toc:[]};function Fg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ig,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Fg.isMDXComponent=!0;const Gg={toc:[]};function jg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}jg.isMDXComponent=!0;const Ug={toc:[]};function Og(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ug,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Og.isMDXComponent=!0;const zg={toc:[]};function qg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}qg.isMDXComponent=!0;const Vg={toc:[]};function Bg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Bg.isMDXComponent=!0;const $g={toc:[]};function Hg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$g,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Hg.isMDXComponent=!0;const Yg={toc:[]};function Jg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Jg.isMDXComponent=!0;const Kg={toc:[]};function Qg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Qg.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ox.isMDXComponent=!0;const cx={toc:[]};function rx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}rx.isMDXComponent=!0;const px={toc:[]};function sx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}sx.isMDXComponent=!0;const ax={toc:[]};function lx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ax,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}lx.isMDXComponent=!0;const ix={toc:[]};function ux(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yx.isMDXComponent=!0;const kx={toc:[]};function fx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}fx.isMDXComponent=!0;const Mx={toc:[]};function Dx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Dx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_x,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Xx.isMDXComponent=!0;const wx={toc:[]};function Tx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Tx.isMDXComponent=!0;const Cx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}gx.isMDXComponent=!0;const xx={toc:[]};function Lx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function bx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}bx.isMDXComponent=!0;const vx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Nx.isMDXComponent=!0;const Ex={toc:[]};function Ax(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ex,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Ax.isMDXComponent=!0;const Sx={toc:[]};function Rx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Rx.isMDXComponent=!0;const Px={toc:[]};function Wx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Px,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Wx.isMDXComponent=!0;const Ix={toc:[]};function Fx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ix,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}Fx.isMDXComponent=!0;const Gx={toc:[]};function jx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}jx.isMDXComponent=!0;const Ux={toc:[]};function Ox(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ux,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}Ox.isMDXComponent=!0;const zx={toc:[]};function qx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}qx.isMDXComponent=!0;const Vx={toc:[]};function Bx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Bx.isMDXComponent=!0;const $x={toc:[]};function Hx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$x,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Hx.isMDXComponent=!0;const Yx={toc:[]};function Jx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Jx.isMDXComponent=!0;const Kx={toc:[]};function Qx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Qx.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}oL.isMDXComponent=!0;const cL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}rL.isMDXComponent=!0;const pL={toc:[]};function sL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}sL.isMDXComponent=!0;const aL={toc:[]};function lL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}lL.isMDXComponent=!0;const iL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}yL.isMDXComponent=!0;const kL={toc:[]};function fL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}fL.isMDXComponent=!0;const ML={toc:[]};function DL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ML,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}DL.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_L,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}XL.isMDXComponent=!0;const wL={toc:[]};function TL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}TL.isMDXComponent=!0;const CL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}gL.isMDXComponent=!0;const xL={toc:[]};function LL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}LL.isMDXComponent=!0;const ZL={toc:[]};function bL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bL.isMDXComponent=!0;const vL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}NL.isMDXComponent=!0;const EL={toc:[]};function AL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}AL.isMDXComponent=!0;const SL={toc:[]};function RL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}RL.isMDXComponent=!0;const PL={toc:[]};function WL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}WL.isMDXComponent=!0;const IL={toc:[]};function FL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}FL.isMDXComponent=!0;const GL={toc:[]};function jL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}jL.isMDXComponent=!0;const UL={toc:[]};function OL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}OL.isMDXComponent=!0;const zL={toc:[]};function qL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qL.isMDXComponent=!0;const VL={toc:[]};function BL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}BL.isMDXComponent=!0;const $L={toc:[]};function HL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$L,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}HL.isMDXComponent=!0;const YL={toc:[]};function JL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JL.isMDXComponent=!0;const KL={toc:[]};function QL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}QL.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}oZ.isMDXComponent=!0;const cZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}rZ.isMDXComponent=!0;const pZ={toc:[]};function sZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function lZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}lZ.isMDXComponent=!0;const iZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}yZ.isMDXComponent=!0;const kZ={toc:[]};function fZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}fZ.isMDXComponent=!0;const MZ={toc:[]};function DZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}DZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}XZ.isMDXComponent=!0;const wZ={toc:[]};function TZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}TZ.isMDXComponent=!0;const CZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}gZ.isMDXComponent=!0;const xZ={toc:[]};function LZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function bZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}bZ.isMDXComponent=!0;const vZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}NZ.isMDXComponent=!0;const EZ={toc:[]};function AZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}AZ.isMDXComponent=!0;const SZ={toc:[]};function RZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}RZ.isMDXComponent=!0;const PZ={toc:[]};function WZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}WZ.isMDXComponent=!0;const IZ={toc:[]};function FZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}FZ.isMDXComponent=!0;const GZ={toc:[]};function jZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jZ.isMDXComponent=!0;const UZ={toc:[]};function OZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}OZ.isMDXComponent=!0;const zZ={toc:[]};function qZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function BZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}BZ.isMDXComponent=!0;const $Z={toc:[]};function HZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$Z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}HZ.isMDXComponent=!0;const YZ={toc:[]};function JZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}JZ.isMDXComponent=!0;const KZ={toc:[]};function QZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}QZ.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}ob.isMDXComponent=!0;const cb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}rb.isMDXComponent=!0;const pb={toc:[]};function sb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sb.isMDXComponent=!0;const ab={toc:[]};function lb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ab,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}lb.isMDXComponent=!0;const ib={toc:[]};function ub(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}yb.isMDXComponent=!0;const kb={toc:[]};function fb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}fb.isMDXComponent=!0;const Mb={toc:[]};function Db(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Db.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_b,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Xb.isMDXComponent=!0;const wb={toc:[]};function Tb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}Tb.isMDXComponent=!0;const Cb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}gb.isMDXComponent=!0;const xb={toc:[]};function Lb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function bb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}bb.isMDXComponent=!0;const vb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Nb.isMDXComponent=!0;const Eb={toc:[]};function Ab(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Ab.isMDXComponent=!0;const Sb={toc:[]};function Rb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}Rb.isMDXComponent=!0;const Pb={toc:[]};function Wb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Wb.isMDXComponent=!0;const Ib={toc:[]};function Fb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ib,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}Fb.isMDXComponent=!0;const Gb={toc:[]};function jb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jb.isMDXComponent=!0;const Ub={toc:[]};function Ob(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ub,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Ob.isMDXComponent=!0;const zb={toc:[]};function qb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}qb.isMDXComponent=!0;const Vb={toc:[]};function Bb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Bb.isMDXComponent=!0;const $b={toc:[]};function Hb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$b,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}Hb.isMDXComponent=!0;const Yb={toc:[]};function Jb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Jb.isMDXComponent=!0;const Kb={toc:[]};function Qb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Qb.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}ov.isMDXComponent=!0;const cv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}rv.isMDXComponent=!0;const pv={toc:[]};function sv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}sv.isMDXComponent=!0;const av={toc:[]};function lv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},av,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}lv.isMDXComponent=!0;const iv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}yv.isMDXComponent=!0;const kv={toc:[]};function fv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}fv.isMDXComponent=!0;const Mv={toc:[]};function Dv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}Dv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_v,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Xv.isMDXComponent=!0;const wv={toc:[]};function Tv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}Tv.isMDXComponent=!0;const Cv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}gv.isMDXComponent=!0;const xv={toc:[]};function Lv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function bv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}bv.isMDXComponent=!0;const vv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Nv.isMDXComponent=!0;const Ev={toc:[]};function Av(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ev,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Av.isMDXComponent=!0;const Sv={toc:[]};function Rv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Rv.isMDXComponent=!0;const Pv={toc:[]};function Wv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Wv.isMDXComponent=!0;const Iv={toc:[]};function Fv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Fv.isMDXComponent=!0;const Gv={toc:[]};function jv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}jv.isMDXComponent=!0;const Uv={toc:[]};function Ov(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}Ov.isMDXComponent=!0;const zv={toc:[]};function qv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qv.isMDXComponent=!0;const Vv={toc:[]};function Bv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Bv.isMDXComponent=!0;const $v={toc:[]};function Hv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$v,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Hv.isMDXComponent=!0;const Yv={toc:[]};function Jv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Jv.isMDXComponent=!0;const Kv={toc:[]};function Qv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Qv.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}oN.isMDXComponent=!0;const cN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}rN.isMDXComponent=!0;const pN={toc:[]};function sN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}sN.isMDXComponent=!0;const aN={toc:[]};function lN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}lN.isMDXComponent=!0;const iN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}yN.isMDXComponent=!0;const kN={toc:[]};function fN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}fN.isMDXComponent=!0;const MN={toc:[]};function DN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}DN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}XN.isMDXComponent=!0;const wN={toc:[]};function TN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}TN.isMDXComponent=!0;const CN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}gN.isMDXComponent=!0;const xN={toc:[]};function LN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}LN.isMDXComponent=!0;const ZN={toc:[]};function bN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}bN.isMDXComponent=!0;const vN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}NN.isMDXComponent=!0;const EN={toc:[]};function AN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}AN.isMDXComponent=!0;const SN={toc:[]};function RN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}RN.isMDXComponent=!0;const PN={toc:[]};function WN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}WN.isMDXComponent=!0;const IN={toc:[]};function FN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}FN.isMDXComponent=!0;const GN={toc:[]};function jN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}jN.isMDXComponent=!0;const UN={toc:[]};function ON(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ON.isMDXComponent=!0;const zN={toc:[]};function qN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}qN.isMDXComponent=!0;const VN={toc:[]};function BN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}BN.isMDXComponent=!0;const $N={toc:[]};function HN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}HN.isMDXComponent=!0;const YN={toc:[]};function JN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}JN.isMDXComponent=!0;const KN={toc:[]};function QN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}QN.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}oE.isMDXComponent=!0;const cE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}rE.isMDXComponent=!0;const pE={toc:[]};function sE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}sE.isMDXComponent=!0;const aE={toc:[]};function lE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}lE.isMDXComponent=!0;const iE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}dE.isMDXComponent=!0;const hE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}yE.isMDXComponent=!0;const kE={toc:[]};function fE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}fE.isMDXComponent=!0;const ME={toc:[]};function DE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ME,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}DE.isMDXComponent=!0;const _E={toc:[]};function XE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_E,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}XE.isMDXComponent=!0;const wE={toc:[]};function TE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}TE.isMDXComponent=!0;const CE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}gE.isMDXComponent=!0;const xE={toc:[]};function LE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}LE.isMDXComponent=!0;const ZE={toc:[]};function bE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}bE.isMDXComponent=!0;const vE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}NE.isMDXComponent=!0;const EE={toc:[]};function AE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}AE.isMDXComponent=!0;const SE={toc:[]};function RE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}RE.isMDXComponent=!0;const PE={toc:[]};function WE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}WE.isMDXComponent=!0;const IE={toc:[]};function FE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FE.isMDXComponent=!0;const GE={toc:[]};function jE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}jE.isMDXComponent=!0;const UE={toc:[]};function OE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}OE.isMDXComponent=!0;const zE={toc:[]};function qE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}qE.isMDXComponent=!0;const VE={toc:[]};function BE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}BE.isMDXComponent=!0;const $E={toc:[]};function HE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$E,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}HE.isMDXComponent=!0;const YE={toc:[]};function JE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}JE.isMDXComponent=!0;const KE={toc:[]};function QE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}QE.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oA.isMDXComponent=!0;const cA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}rA.isMDXComponent=!0;const pA={toc:[]};function sA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}sA.isMDXComponent=!0;const aA={toc:[]};function lA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}lA.isMDXComponent=!0;const iA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yA.isMDXComponent=!0;const kA={toc:[]};function fA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}fA.isMDXComponent=!0;const MA={toc:[]};function DA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}DA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_A,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}XA.isMDXComponent=!0;const wA={toc:[]};function TA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}TA.isMDXComponent=!0;const CA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}gA.isMDXComponent=!0;const xA={toc:[]};function LA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}LA.isMDXComponent=!0;const ZA={toc:[]};function bA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}bA.isMDXComponent=!0;const vA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}NA.isMDXComponent=!0;const EA={toc:[]};function AA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}AA.isMDXComponent=!0;const SA={toc:[]};function RA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}RA.isMDXComponent=!0;const PA={toc:[]};function WA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}WA.isMDXComponent=!0;const IA={toc:[]};function FA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}FA.isMDXComponent=!0;const GA={toc:[]};function jA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}jA.isMDXComponent=!0;const UA={toc:[]};function OA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}OA.isMDXComponent=!0;const zA={toc:[]};function qA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}qA.isMDXComponent=!0;const VA={toc:[]};function BA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}BA.isMDXComponent=!0;const $A={toc:[]};function HA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$A,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}HA.isMDXComponent=!0;const YA={toc:[]};function JA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}JA.isMDXComponent=!0;const KA={toc:[]};function QA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QA.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}oS.isMDXComponent=!0;const cS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}rS.isMDXComponent=!0;const pS={toc:[]};function sS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}sS.isMDXComponent=!0;const aS={toc:[]};function lS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}lS.isMDXComponent=!0;const iS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}yS.isMDXComponent=!0;const kS={toc:[]};function fS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}fS.isMDXComponent=!0;const MS={toc:[]};function DS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}DS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_S,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}XS.isMDXComponent=!0;const wS={toc:[]};function TS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}TS.isMDXComponent=!0;const CS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gS.isMDXComponent=!0;const xS={toc:[]};function LS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}LS.isMDXComponent=!0;const ZS={toc:[]};function bS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}bS.isMDXComponent=!0;const vS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}NS.isMDXComponent=!0;const ES={toc:[]};function AS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ES,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}AS.isMDXComponent=!0;const SS={toc:[]};function RS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}RS.isMDXComponent=!0;const PS={toc:[]};function WS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}WS.isMDXComponent=!0;const IS={toc:[]};function FS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}FS.isMDXComponent=!0;const GS={toc:[]};function jS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}jS.isMDXComponent=!0;const US={toc:[]};function OS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},US,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}OS.isMDXComponent=!0;const zS={toc:[]};function qS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}qS.isMDXComponent=!0;const VS={toc:[]};function BS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}BS.isMDXComponent=!0;const $S={toc:[]};function HS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$S,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}HS.isMDXComponent=!0;const YS={toc:[]};function JS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}JS.isMDXComponent=!0;const KS={toc:[]};function QS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}QS.isMDXComponent=!0;const tR={toc:[]};function eR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}eR.isMDXComponent=!0;const nR={toc:[]};function oR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}oR.isMDXComponent=!0;const cR={toc:[]};function rR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}rR.isMDXComponent=!0;const pR={toc:[]};function sR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}sR.isMDXComponent=!0;const aR={toc:[]};function lR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lR.isMDXComponent=!0;const iR={toc:[]};function uR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}dR.isMDXComponent=!0;const hR={toc:[]};function yR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yR.isMDXComponent=!0;const kR={toc:[]};function fR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}fR.isMDXComponent=!0;const MR={toc:[]};function DR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}DR.isMDXComponent=!0;const _R={toc:[]};function XR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_R,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}XR.isMDXComponent=!0;const wR={toc:[]};function TR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}TR.isMDXComponent=!0;const CR={toc:[]};function gR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}gR.isMDXComponent=!0;const xR={toc:[]};function LR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}LR.isMDXComponent=!0;const ZR={toc:[]};function bR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}bR.isMDXComponent=!0;const vR={toc:[]};function NR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}NR.isMDXComponent=!0;const ER={toc:[]};function AR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ER,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}AR.isMDXComponent=!0;const SR={toc:[]};function RR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}RR.isMDXComponent=!0;const PR={toc:[]};function WR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}WR.isMDXComponent=!0;const IR={toc:[]};function FR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}FR.isMDXComponent=!0;const GR={toc:[]};function jR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}jR.isMDXComponent=!0;const UR={toc:[]};function OR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}OR.isMDXComponent=!0;const zR={toc:[]};function qR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}qR.isMDXComponent=!0;const VR={toc:[]};function BR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}BR.isMDXComponent=!0;const $R={toc:[]};function HR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$R,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}HR.isMDXComponent=!0;const YR={toc:[]};function JR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}JR.isMDXComponent=!0;const KR={toc:[]};function QR(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KR,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}QR.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}oP.isMDXComponent=!0;const cP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}rP.isMDXComponent=!0;const pP={toc:[]};function sP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}sP.isMDXComponent=!0;const aP={toc:[]};function lP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}lP.isMDXComponent=!0;const iP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}dP.isMDXComponent=!0;const hP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}yP.isMDXComponent=!0;const kP={toc:[]};function fP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}fP.isMDXComponent=!0;const MP={toc:[]};function DP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}DP.isMDXComponent=!0;const _P={toc:[]};function XP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_P,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}XP.isMDXComponent=!0;const wP={toc:[]};function TP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}TP.isMDXComponent=!0;const CP={toc:[]};function gP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}gP.isMDXComponent=!0;const xP={toc:[]};function LP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}LP.isMDXComponent=!0;const ZP={toc:[]};function bP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}bP.isMDXComponent=!0;const vP={toc:[]};function NP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}NP.isMDXComponent=!0;const EP={toc:[]};function AP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}AP.isMDXComponent=!0;const SP={toc:[]};function RP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}RP.isMDXComponent=!0;const PP={toc:[]};function WP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}WP.isMDXComponent=!0;const IP={toc:[]};function FP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}FP.isMDXComponent=!0;const GP={toc:[]};function jP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}jP.isMDXComponent=!0;const UP={toc:[]};function OP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}OP.isMDXComponent=!0;const zP={toc:[]};function qP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}qP.isMDXComponent=!0;const VP={toc:[]};function BP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}BP.isMDXComponent=!0;const $P={toc:[]};function HP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$P,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}HP.isMDXComponent=!0;const YP={toc:[]};function JP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}JP.isMDXComponent=!0;const KP={toc:[]};function QP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}QP.isMDXComponent=!0;const tW={toc:[]};function eW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}eW.isMDXComponent=!0;const nW={toc:[]};function oW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oW.isMDXComponent=!0;const cW={toc:[]};function rW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}rW.isMDXComponent=!0;const pW={toc:[]};function sW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}sW.isMDXComponent=!0;const aW={toc:[]};function lW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}lW.isMDXComponent=!0;const iW={toc:[]};function uW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}dW.isMDXComponent=!0;const hW={toc:[]};function yW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}yW.isMDXComponent=!0;const kW={toc:[]};function fW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}fW.isMDXComponent=!0;const MW={toc:[]};function DW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}DW.isMDXComponent=!0;const _W={toc:[]};function XW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_W,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}XW.isMDXComponent=!0;const wW={toc:[]};function TW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}TW.isMDXComponent=!0;const CW={toc:[]};function gW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}gW.isMDXComponent=!0;const xW={toc:[]};function LW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}LW.isMDXComponent=!0;const ZW={toc:[]};function bW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bW.isMDXComponent=!0;const vW={toc:[]};function NW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}NW.isMDXComponent=!0;const EW={toc:[]};function AW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}AW.isMDXComponent=!0;const SW={toc:[]};function RW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}RW.isMDXComponent=!0;const PW={toc:[]};function WW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}WW.isMDXComponent=!0;const IW={toc:[]};function FW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FW.isMDXComponent=!0;const GW={toc:[]};function jW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}jW.isMDXComponent=!0;const UW={toc:[]};function OW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}OW.isMDXComponent=!0;const zW={toc:[]};function qW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}qW.isMDXComponent=!0;const VW={toc:[]};function BW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}BW.isMDXComponent=!0;const $W={toc:[]};function HW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$W,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}HW.isMDXComponent=!0;const YW={toc:[]};function JW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}JW.isMDXComponent=!0;const KW={toc:[]};function QW(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KW,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}QW.isMDXComponent=!0;const tI={toc:[]};function eI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}eI.isMDXComponent=!0;const nI={toc:[]};function oI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}oI.isMDXComponent=!0;const cI={toc:[]};function rI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}rI.isMDXComponent=!0;const pI={toc:[]};function sI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}sI.isMDXComponent=!0;const aI={toc:[]};function lI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}lI.isMDXComponent=!0;const iI={toc:[]};function uI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}dI.isMDXComponent=!0;const hI={toc:[]};function yI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}yI.isMDXComponent=!0;const kI={toc:[]};function fI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}fI.isMDXComponent=!0;const MI={toc:[]};function DI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}DI.isMDXComponent=!0;const _I={toc:[]};function XI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_I,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}XI.isMDXComponent=!0;const wI={toc:[]};function TI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}TI.isMDXComponent=!0;const CI={toc:[]};function gI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}gI.isMDXComponent=!0;const xI={toc:[]};function LI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}LI.isMDXComponent=!0;const ZI={toc:[]};function bI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}bI.isMDXComponent=!0;const vI={toc:[]};function NI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}NI.isMDXComponent=!0;const EI={toc:[]};function AI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}AI.isMDXComponent=!0;const SI={toc:[]};function RI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}RI.isMDXComponent=!0;const PI={toc:[]};function WI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}WI.isMDXComponent=!0;const II={toc:[]};function FI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},II,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}FI.isMDXComponent=!0;const GI={toc:[]};function jI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}jI.isMDXComponent=!0;const UI={toc:[]};function OI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}OI.isMDXComponent=!0;const zI={toc:[]};function qI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}qI.isMDXComponent=!0;const VI={toc:[]};function BI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}BI.isMDXComponent=!0;const $I={toc:[]};function HI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$I,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}HI.isMDXComponent=!0;const YI={toc:[]};function JI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}JI.isMDXComponent=!0;const KI={toc:[]};function QI(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KI,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}QI.isMDXComponent=!0;const tF={toc:[]};function eF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}eF.isMDXComponent=!0;const nF={toc:[]};function oF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}oF.isMDXComponent=!0;const cF={toc:[]};function rF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}rF.isMDXComponent=!0;const pF={toc:[]};function sF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}sF.isMDXComponent=!0;const aF={toc:[]};function lF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}lF.isMDXComponent=!0;const iF={toc:[]};function uF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}dF.isMDXComponent=!0;const hF={toc:[]};function yF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}yF.isMDXComponent=!0;const kF={toc:[]};function fF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}fF.isMDXComponent=!0;const MF={toc:[]};function DF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}DF.isMDXComponent=!0;const _F={toc:[]};function XF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_F,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}XF.isMDXComponent=!0;const wF={toc:[]};function TF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}TF.isMDXComponent=!0;const CF={toc:[]};function gF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}gF.isMDXComponent=!0;const xF={toc:[]};function LF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}LF.isMDXComponent=!0;const ZF={toc:[]};function bF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}bF.isMDXComponent=!0;const vF={toc:[]};function NF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}NF.isMDXComponent=!0;const EF={toc:[]};function AF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}AF.isMDXComponent=!0;const SF={toc:[]};function RF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}RF.isMDXComponent=!0;const PF={toc:[]};function WF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WF.isMDXComponent=!0;const IF={toc:[]};function FF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}FF.isMDXComponent=!0;const GF={toc:[]};function jF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}jF.isMDXComponent=!0;const UF={toc:[]};function OF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}OF.isMDXComponent=!0;const zF={toc:[]};function qF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qF.isMDXComponent=!0;const VF={toc:[]};function BF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}BF.isMDXComponent=!0;const $F={toc:[]};function HF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$F,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}HF.isMDXComponent=!0;const YF={toc:[]};function JF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}JF.isMDXComponent=!0;const KF={toc:[]};function QF(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KF,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}QF.isMDXComponent=!0;const tG={toc:[]};function eG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}eG.isMDXComponent=!0;const nG={toc:[]};function oG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oG.isMDXComponent=!0;const cG={toc:[]};function rG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}rG.isMDXComponent=!0;const pG={toc:[]};function sG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The nodes will be appended at the end of the children list."))}sG.isMDXComponent=!0;const aG={toc:[]};function lG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}lG.isMDXComponent=!0;const iG={toc:[]};function uG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Add the given node(s) as the children of this node."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to append."))}dG.isMDXComponent=!0;const hG={toc:[]};function yG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}yG.isMDXComponent=!0;const kG={toc:[]};function fG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}fG.isMDXComponent=!0;const MG={toc:[]};function DG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}DG.isMDXComponent=!0;const _G={toc:[]};function XG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_G,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}XG.isMDXComponent=!0;const wG={toc:[]};function TG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}TG.isMDXComponent=!0;const CG={toc:[]};function gG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}gG.isMDXComponent=!0;const xG={toc:[]};function LG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}LG.isMDXComponent=!0;const ZG={toc:[]};function bG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,p.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}bG.isMDXComponent=!0;const vG={toc:[]};function NG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare this node to be disposed of."))}NG.isMDXComponent=!0;const EG={toc:[]};function AG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}AG.isMDXComponent=!0;const SG={toc:[]};function RG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}RG.isMDXComponent=!0;const PG={toc:[]};function WG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}WG.isMDXComponent=!0;const IG={toc:[]};function FG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FG.isMDXComponent=!0;const GG={toc:[]};function jG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}jG.isMDXComponent=!0;const UG={toc:[]};function OG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}OG.isMDXComponent=!0;const zG={toc:[]};function qG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}qG.isMDXComponent=!0;const VG={toc:[]};function BG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}BG.isMDXComponent=!0;const $G={toc:[]};function HG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$G,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}HG.isMDXComponent=!0;const YG={toc:[]};function JG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}JG.isMDXComponent=!0;const KG={toc:[]};function QG(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KG,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}QG.isMDXComponent=!0;const tj={toc:[]};function ej(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}ej.isMDXComponent=!0;const nj={toc:[]};function oj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}oj.isMDXComponent=!0;const cj={toc:[]};function rj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,p.kt)("p",null,"Result:"),(0,p.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}rj.isMDXComponent=!0;const pj={toc:[]};function sj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}sj.isMDXComponent=!0;const aj={toc:[]};function lj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A node or an array of nodes to insert."))}lj.isMDXComponent=!0;const ij={toc:[]};function uj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ij,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An index at which to insert the node(s)."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}dj.isMDXComponent=!0;const hj={toc:[]};function yj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}yj.isMDXComponent=!0;const kj={toc:[]};function fj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}fj.isMDXComponent=!0;const Mj={toc:[]};function Dj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Dj.isMDXComponent=!0;const _j={toc:[]};function Xj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_j,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,p.kt)("p",null,"A positive ",(0,p.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Xj.isMDXComponent=!0;const wj={toc:[]};function Tj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Rearrange this node in relation to its siblings."))}Tj.isMDXComponent=!0;const Cj={toc:[]};function gj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Number of places by which the node should be moved."))}gj.isMDXComponent=!0;const xj={toc:[]};function Lj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}Lj.isMDXComponent=!0;const Zj={toc:[]};function bj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node down in relation to its siblings."))}bj.isMDXComponent=!0;const vj={toc:[]};function Nj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Nj.isMDXComponent=!0;const Ej={toc:[]};function Aj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ej,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Aj.isMDXComponent=!0;const Sj={toc:[]};function Rj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}Rj.isMDXComponent=!0;const Pj={toc:[]};function Wj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Wj.isMDXComponent=!0;const Ij={toc:[]};function Fj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ij,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Fj.isMDXComponent=!0;const Gj={toc:[]};function jj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node to the top in relation to its siblings."))}jj.isMDXComponent=!0;const Uj={toc:[]};function Oj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}Oj.isMDXComponent=!0;const zj={toc:[]};function qj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Move the node up in relation to its siblings."))}qj.isMDXComponent=!0;const Vj={toc:[]};function Bj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Bj.isMDXComponent=!0;const $j={toc:[]};function Hj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$j,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Hj.isMDXComponent=!0;const Yj={toc:[]};function Jj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Jj.isMDXComponent=!0;const Kj={toc:[]};function Qj(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kj,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove this node from the tree."))}Qj.isMDXComponent=!0;const tU={toc:[]};function eU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Remove all children of this node."))}eU.isMDXComponent=!0;const nU={toc:[]};function oU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}oU.isMDXComponent=!0;const cU={toc:[]};function rU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}rU.isMDXComponent=!0;const pU={toc:[]};function sU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}sU.isMDXComponent=!0;const aU={toc:[]};function lU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}lU.isMDXComponent=!0;const iU={toc:[]};function uU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dU.isMDXComponent=!0;const hU={toc:[]};function yU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}yU.isMDXComponent=!0;const kU={toc:[]};function fU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}fU.isMDXComponent=!0;const MU={toc:[]};function DU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}DU.isMDXComponent=!0;const _U={toc:[]};function XU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_U,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}XU.isMDXComponent=!0;const wU={toc:[]};function TU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}TU.isMDXComponent=!0;const CU={toc:[]};function gU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}gU.isMDXComponent=!0;const xU={toc:[]};function LU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LU.isMDXComponent=!0;const ZU={toc:[]};function bU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bU.isMDXComponent=!0;const vU={toc:[]};function NU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}NU.isMDXComponent=!0;const EU={toc:[]};function AU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}AU.isMDXComponent=!0;const SU={toc:[]};function RU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}RU.isMDXComponent=!0;const PU={toc:[]};function WU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}WU.isMDXComponent=!0;const IU={toc:[]};function FU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}FU.isMDXComponent=!0;const GU={toc:[]};function jU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}jU.isMDXComponent=!0;const UU={toc:[]};function OU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}OU.isMDXComponent=!0;const zU={toc:[]};function qU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}qU.isMDXComponent=!0;const VU={toc:[]};function BU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,p.kt)("p",null,"By default, any property is cloneable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}BU.isMDXComponent=!0;const $U={toc:[]};function HU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$U,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}HU.isMDXComponent=!0;const YU={toc:[]};function JU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a cloneable property decorator."))}JU.isMDXComponent=!0;const KU={toc:[]};function QU(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KU,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be cloneable."))}QU.isMDXComponent=!0;const tO={toc:[]};function eO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}eO.isMDXComponent=!0;const nO={toc:[]};function oO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}oO.isMDXComponent=!0;const cO={toc:[]};function rO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a compound property decorator."))}rO.isMDXComponent=!0;const pO={toc:[]};function sO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}sO.isMDXComponent=!0;const aO={toc:[]};function lO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,p.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,p.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}lO.isMDXComponent=!0;const iO={toc:[]};function uO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a computed method decorator."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the initial value of a property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}dO.isMDXComponent=!0;const hO={toc:[]};function yO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}yO.isMDXComponent=!0;const kO={toc:[]};function fO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an initial signal value decorator."))}fO.isMDXComponent=!0;const MO={toc:[]};function DO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},MO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the property."))}DO.isMDXComponent=!0;const _O={toc:[]};function XO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_O,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,p.kt)("p",null,"By default, any property is inspectable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}XO.isMDXComponent=!0;const wO={toc:[]};function TO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}TO.isMDXComponent=!0;const CO={toc:[]};function gO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an inspectable property decorator."))}gO.isMDXComponent=!0;const xO={toc:[]};function LO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be inspectable."))}LO.isMDXComponent=!0;const ZO={toc:[]};function bO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ZO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}bO.isMDXComponent=!0;const vO={toc:[]};function NO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}NO.isMDXComponent=!0;const EO={toc:[]};function AO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal interpolation function decorator."))}AO.isMDXComponent=!0;const SO={toc:[]};function RO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},SO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function for the property."))}RO.isMDXComponent=!0;const PO={toc:[]};function WO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},PO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,p.kt)("p",null,"If the wrapper class has a method called ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}WO.isMDXComponent=!0;const IO={toc:[]};function FO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},IO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}FO.isMDXComponent=!0;const GO={toc:[]};function jO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal parser decorator."))}jO.isMDXComponent=!0;const UO={toc:[]};function OO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},UO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}OO.isMDXComponent=!0;const zO={toc:[]};function qO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given property into a signal."),(0,p.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}qO.isMDXComponent=!0;const VO={toc:[]};function BO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}BO.isMDXComponent=!0;const $O={toc:[]};function HO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$O,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal decorator."))}HO.isMDXComponent=!0;const YO={toc:[]};function JO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,p.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,p.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,p.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}JO.isMDXComponent=!0;const KO={toc:[]};function QO(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},KO,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}QO.isMDXComponent=!0;const tz={toc:[]};function ez(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal wrapper decorator."))}ez.isMDXComponent=!0;const nz={toc:[]};function oz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}oz.isMDXComponent=!0;const cz={toc:[]};function rz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A unified abstraction for all CSS filters."))}rz.isMDXComponent=!0;const pz={toc:[]};function sz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,p.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}sz.isMDXComponent=!0;const az={toc:[]};function lz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},az,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in pixels."))}lz.isMDXComponent=!0;const iz={toc:[]};function uz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,p.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}dz.isMDXComponent=!0;const hz={toc:[]};function yz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,p.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}yz.isMDXComponent=!0;const kz={toc:[]};function fz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}fz.isMDXComponent=!0;const Mz={toc:[]};function Dz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,p.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}Dz.isMDXComponent=!0;const _z={toc:[]};function Xz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}Xz.isMDXComponent=!0;const wz={toc:[]};function Tz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,p.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}Tz.isMDXComponent=!0;const Cz={toc:[]};function gz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in degrees."))}gz.isMDXComponent=!0;const xz={toc:[]};function Lz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,p.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}Lz.isMDXComponent=!0;const Zz={toc:[]};function bz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}bz.isMDXComponent=!0;const vz={toc:[]};function Nz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,p.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}Nz.isMDXComponent=!0;const Ez={toc:[]};function Az(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ez,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}Az.isMDXComponent=!0;const Sz={toc:[]};function Rz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,p.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}Rz.isMDXComponent=!0;const Pz={toc:[]};function Wz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}Wz.isMDXComponent=!0;const Iz={toc:[]};function Fz(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iz,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}function Gz(t){let{id:e}=t;const n=o[e]??c.Fragment;return c.createElement(n,null)}Fz.isMDXComponent=!0},9322:(t,e,n)=>{n.d(e,{Z:()=>m});var o=n(2784),c=n(2366),r=n(8698);const p="toggle_S_IX",s="collapsed_wdUB",a="collapse_TjTN",l="inverse_g6vW",i="clearFix_HQ1T";var u=n(6277);function m(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(c.Z,{id:null==e?void 0:e.summaryId}),o.createElement(c.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(d,{comment:e}))}function d(t){let{comment:e}=t;const[n,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),h=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),y=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(p,n&&s),onClick:t=>{t.preventDefault(),m(!n)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:n},o.createElement("div",{className:a},d.map((t=>o.createElement(c.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:i})),o.createElement("div",{className:(0,u.Z)(i,l)})),h&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(c.Z,{id:h.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(c.Z,{id:y.contentId})))}},1836:(t,e,n)=>{n.d(e,{Z:()=>St});var o=n(2784),c=n(7390),r=n(6835),p=n(68),s=n(6277),a=n(8569);const l={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=n(7896);function u(t){let{width:e=24,height:n=24,...c}=t;return o.createElement("svg",(0,i.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},c),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:c,link:i}=t;const m=(0,r.F)(),d=(0,p.s2)();return o.createElement("div",{className:(0,s.Z)(a.Z.codeBlockContent,l.codeBlock,n&&l.highlight,c&&l.pointer)},o.createElement("pre",{onClick:c,onKeyDown:t=>{"Enter"===t.key&&(null==c||c())},tabIndex:0,ref:m.codeBlockRef,className:(0,s.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},e)),i&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(i,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(9318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,s.Z)(l.codeBlockContainer,"language-typescript")},e)}var y=n(9817);function k(t){let{children:e,type:n,to:c,id:r,tooltip:s}=t;const a=(0,p.Ld)(n);return c?o.createElement(y.Z,(0,i.Z)({id:r,to:c,"data-tooltip":s},a),e):o.createElement("span",(0,i.Z)({id:r},a),e)}let f,M;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(M||(M={}));const D={[f.None]:l.none,[f.Angle]:l.angle,[f.Curly]:l.curly,[f.Square]:l.square,[f.Parentheses]:l.parentheses};function _(t){let{children:e,type:n,separator:c=M.Comma}=t;return o.createElement("span",{className:(0,s.Z)(l.list,D[n??f.None])},o.createElement("span",{className:(0,s.Z)(l.elements,c!==M.Comma&&l.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":c,key:e,className:l.element},t)))))}var X=n(8617);function w(t){var e;let{type:n}=t;const c=(0,X.RU)(n.project),r=null==c?void 0:c[n.id],p=n.externalUrl??(0,X.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(k,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(_,{type:f.Angle},n.typeArguments.map(((t,e)=>o.createElement(F,{key:e,type:t})))))}function T(t){let{type:e}=t;return o.createElement(k,{type:"keyword"},e.name)}function C(t){let{type:e}=t;return e.elements?o.createElement(_,{type:f.Square},e.elements.map(((t,e)=>o.createElement(F,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function g(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.elementType}),"[]")}function x(t){let{type:e}=t;return o.createElement(_,{type:f.Parentheses,separator:M.Pipe},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function L(t){let{type:e}=t;const[n,c]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(k,{type:c},n)}function Z(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"asserts "),o.createElement(k,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(k,null,e.name," "),o.createElement(k,{type:"keyword"},"is "),o.createElement(F,{type:e.targetType}))}function b(t){let{type:e}=t;const n=(0,X.in)();return o.createElement(Y,{reflection:n(e.declaration)})}function v(t){let{type:e}=t;return o.createElement(_,{type:f.Parentheses,separator:M.Ampersand},e.types.map(((t,e)=>o.createElement(F,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,c]=t;return o.createElement(o.Fragment,null,"${",o.createElement(F,{key:e,type:n}),"}",o.createElement(k,{type:"string"},c))})),o.createElement(k,{type:"string"},"`"))}function E(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"typeof "),o.createElement(F,{type:e.queryType}))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.checkType}),o.createElement(k,{type:"keyword"}," extends "),o.createElement(F,{type:e.extendsType})," ? ",o.createElement(F,{type:e.trueType})," : ",o.createElement(F,{type:e.falseType}))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"infer "),o.createElement(k,{type:"constant"},e.name))}function R(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(F,{type:e.objectType}),"[",o.createElement(F,{type:e.indexType}),"]")}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},e.operator," "),o.createElement(F,{type:e.target}))}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(_,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(k,{type:"class"},e.parameter),o.createElement(k,{type:"keyword"}," in "),o.createElement(F,{type:e.parameterType}),"]: ",o.createElement(F,{type:e.templateType}))))}function I(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(F,{type:e.element}))}function F(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return P;case"conditional":return A;case"reflection":return b;case"query":return E;case"named-tuple-member":return I;case"union":return x;case"intrinsic":return T;case"literal":return L;case"reference":return w;case"predicate":return Z;case"tuple":return C;case"array":return g;case"intersection":return v;case"inferred":return S;case"mapped":return W;case"template-literal":return N;case"indexedAccess":return R}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function G(t){let{flags:e,explicitAccessModifier:n}=t;const c=[];return null!=e&&e.isAbstract&&c.push("abstract"),null!=e&&e.isStatic&&c.push("static"),null!=e&&e.isConst&&c.push("const"),null!=e&&e.isReadonly&&c.push("readonly"),null!=e&&e.isPrivate&&c.push("private"),null!=e&&e.isProtected&&c.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||c.push("public"),o.createElement(o.Fragment,null,c.map((t=>o.createElement(k,{key:t,type:"keyword"},t," "))))}function j(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(F,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(k,{type:"plain"},e.defaultValue)))}function U(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(G,{flags:e.flags}),e.varianceModifier&&o.createElement(k,{type:"keyword"},e.varianceModifier," "),o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(F,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(F,{type:e.default})))}function O(t){var e,n;let{reflection:r,flags:p}=t;const s=(0,X.in)(),a="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:p??r.flags,explicitAccessModifier:!a}),r.kind===c.W.GetSignature&&o.createElement(k,{type:"keyword"},"get "),r.kind===c.W.SetSignature&&o.createElement(k,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(k,{to:r.overwrites.externalUrl??(0,X.Gr)(s(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===c.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(k,{to:"#",type:"keyword"},"new")," ",o.createElement(k,{type:"plain"},r.type.name)):a?"":o.createElement(k,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(_,{type:f.Angle},r.typeParameter.map((t=>o.createElement(U,{key:t.id,reflection:s(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(_,{type:f.Parentheses},r.parameters.map((t=>o.createElement(j,{key:t,reflection:s(t)})))):"()",r.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(F,{type:r.type})))}function z(t){let{reflection:e}=t;return o.createElement(j,{reflection:e})}const q={[c.W.Namespace]:"namespace",[c.W.Enum]:"enum",[c.W.Class]:"class",[c.W.Interface]:"interface"};function V(t){var e,n,c;let{reflection:r}=t;const p=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:r.flags}),o.createElement(k,{type:"keyword"},q[r.kind]," "),o.createElement(k,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(_,{type:f.Angle},r.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:p(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"extends "),o.createElement(_,null,r.extendedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))),!(null==(c=r.implementedTypes)||!c.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"implements "),o.createElement(_,null,r.implementedTypes.map(((t,e)=>o.createElement(F,{key:e,type:t}))))))}function B(t){let{reflection:e}=t;const n=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:e.flags}),o.createElement(k,{type:"keyword"},"type "),o.createElement(k,{type:"class-name"},e.name),e.typeParameters&&o.createElement(_,{type:f.Angle},e.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:n(t)}))))," = ",o.createElement(F,{type:e.type}))}function $(t){let{reflection:e}=t;const n=(0,X.in)();return e.signatures?o.createElement(O,{reflection:e.signatures[0]}):e.children?o.createElement(_,{type:f.Curly},e.children.map((t=>o.createElement(Y,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"unknown"))}function H(t){var e;let{reflection:n}=t;const c=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(O,{reflection:c})}function Y(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case c.W.Project:case c.W.Module:case c.W.EnumMember:case c.W.Variable:case c.W.Function:break;case c.W.Namespace:case c.W.Enum:case c.W.Class:case c.W.Interface:return V;case c.W.Constructor:return O;case c.W.Property:return z;case c.W.Method:return H;case c.W.CallSignature:case c.W.IndexSignature:case c.W.ConstructorSignature:case c.W.Parameter:break;case c.W.TypeLiteral:return $;case c.W.TypeParameter:return U;case c.W.Accessor:case c.W.GetSignature:case c.W.SetSignature:case c.W.ObjectLiteral:break;case c.W.TypeAlias:return B;case c.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function J(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${l.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(l.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,s.Z)(l.line,"token-line")},e),o.createElement("br",null))}var K=n(9322),Q=n(2366);function tt(t){let{parameters:e}=t;const n=(0,X.in)(),c=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=c&&c.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,c.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(U,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,X.in)(),c=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=c&&c.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,c.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(j,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:c}=t;const r=(0,X.in)(),p=(0,o.useMemo)((()=>e.map(r)),[e]),[s,a]=(0,o.useState)(p[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,p.map((t=>o.createElement(m,{link:null==c?void 0:c.url,key:t.id,highlight:e.length>1&&t.id===s.id,onClick:e.length>1?()=>a(t):void 0},o.createElement(J,null,o.createElement(O,{reflection:t,flags:n})))))),o.createElement(K.Z,{comment:s.comment}),o.createElement(tt,{parameters:s.typeParameter}),o.createElement(et,{parameters:s.parameters}))}var ot=n(7708);function ct(t){let{width:e=24,height:n=24,...c}=t;return o.createElement("svg",(0,i.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},c),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",pt="filters_z1iC",st="icon_ROIU";function at(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[c,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,s.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(ct,{className:st})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,s.Z)("dropdown__link",c.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:c.private,onChange:t=>{r({...c,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,s.Z)("dropdown__link",c.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:c.inherited,onChange:t=>{r({...c,inherited:t.target.checked})}}),"Inherited members")))))}function lt(t){let{children:e,kind:n}=t;return n===c.W.Class||n===c.W.Interface?o.createElement("div",{className:(0,s.Z)("row",rt)},o.createElement("div",{className:(0,s.Z)("col",pt)},o.createElement(at,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var it=n(3181),ut=n(8963),mt=n(3851),dt=n(9741),ht=n(2244),yt=n(4126);const kt="tabList_M0Dn",ft="tabItem_ysIP";function Mt(t){var e;const{lazy:n,block:c,defaultValue:r,values:p,groupId:a,className:l}=t,u=o.Children.map(t.children,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),m=p??u.map((t=>{let{props:{value:e,label:n,attributes:o}}=t;return{value:e,label:n,attributes:o}})),d=(0,ht.l)(m,((t,e)=>t.value===e.value));if(d.length>0)throw new Error(`Docusaurus error: Duplicate values "${d.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const h=null===r?r:r??(null==(e=u.find((t=>t.props.default)))?void 0:e.props.value)??u[0].props.value;if(null!==h&&!m.some((t=>t.value===h)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${h}" but none of its children has the corresponding value. Available values are: ${m.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:k}=(0,ut.U)(),[f,M]=(0,o.useState)(h),D=[],{blockElementScrollPositionUntilNextRender:_}=(0,yt.o5)();if(null!=a){const t=y[a];null!=t&&t!==f&&m.some((e=>e.value===t))&&M(t)}const X=t=>{const e=t.currentTarget,n=D.indexOf(e),o=m[n].value;o!==f&&(_(e),M(o),null!=a&&k(a,String(o)))},w=t=>{var e;let n=null;switch(t.key){case"Enter":X(t);break;case"ArrowRight":{const e=D.indexOf(t.currentTarget)+1;n=D[e]??D[0];break}case"ArrowLeft":{const e=D.indexOf(t.currentTarget)-1;n=D[e]??D[D.length-1];break}}null==(e=n)||e.focus()};return o.createElement("div",{className:(0,s.Z)("tabs-container",kt)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":c},l)},m.map((t=>{let{value:e,label:n,attributes:c}=t;return o.createElement("li",(0,i.Z)({role:"tab",tabIndex:f===e?0:-1,"aria-selected":f===e,key:e,ref:t=>D.push(t),onKeyDown:w,onClick:X},c,{className:(0,s.Z)("tabs__item",ft,null==c?void 0:c.className,{"tabs__item--active":f===e})}),n??e)}))),n?(0,o.cloneElement)(u.filter((t=>t.props.value===f))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},u.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==f})))))}function Dt(t){const e=(0,dt.Z)();return o.createElement(Mt,(0,i.Z)({key:String(e)},t))}const _t="tabItem_OMyP";function Xt(t){let{children:e,hidden:n,className:c}=t;return o.createElement("div",{role:"tabpanel",className:(0,s.Z)(_t,c),hidden:n},e)}function wt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(St,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(St,{reflection:t})))))}function Tt(t){let{group:e,project:n}=t;const c=(0,it.TH)(),r=(0,X.RU)(n),{setTabGroupChoices:p}=(0,ut.U)(),s=c.hash.split("-")[0].slice(1),[a]=(0,ot.mN)(),l=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],c=[],r=[];for(const p of t.children){const t=e[p];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):c.push(t))}if(o.length>0||c.length>0)return{title:t.title,external:o,nested:c,anchors:r}}(t,r,a))).filter((t=>!!t))),[e,r,a]);return(0,o.useEffect)((()=>{if(1===l.length)return;const t=c.hash.split("-")[0].slice(1);for(const n of l)if(n.anchors.includes(t))return void p(e.title,n.title)}),[c.hash,l]),0===l.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h2",id:e.title},e.title),l.length>1?o.createElement(Dt,{groupId:e.title},l.map((t=>o.createElement(Xt,{default:t.anchors.includes(s),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(wt,{group:t}))))):o.createElement(wt,{group:l[0]}))}function Ct(t){var e,n,c,r,p;let{reflection:s}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=s.sources)||null==(n=e[0])?void 0:n.url},o.createElement(J,null,o.createElement(Y,{reflection:s})))),o.createElement(lt,{kind:s.kind},o.createElement(K.Z,{comment:s.comment})),o.createElement(tt,{parameters:s.typeParameters}),(null==(c=s.implementedBy)?void 0:c.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,s.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),(null==(r=s.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,s.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),s.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:s.signatures})),null==(p=s.groups)?void 0:p.map((t=>o.createElement(Tt,{group:t,key:t.title,project:s.project}))))}function gt(t){var e;let{reflection:n,headless:c}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!c&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(mt.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(w,{type:n.overwrites}))))}function xt(t){var e,n;let{reflection:c}=t;return o.createElement(o.Fragment,null,c.hasOwnPage?o.createElement("h1",null,c.name):o.createElement(mt.Z,{as:"h3",id:c.anchor},o.createElement("code",null,c.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=c.sources)||null==(n=e[0])?void 0:n.url},o.createElement(J,null,o.createElement(z,{reflection:c})))),o.createElement(K.Z,{comment:c.comment}),c.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:c.inheritedFrom}))))}function Lt(t){var e,n,c;let{reflection:r}=t;const p=(0,X.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement(J,null,o.createElement(Y,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(c=r.groups)?void 0:c.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>p[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(St,{key:t.id,reflection:t})))))))}var Zt=n(8128);function bt(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(Zt.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(lt,{kind:n.kind},o.createElement(K.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Tt,{group:t,key:t.title,project:n.project}))))}const vt="cardContainer_ybwo",Nt="cardTitle_Ehd1",Et="cardDescription_b6wr";function At(t){let{reflection:e}=t;const n=(0,X.RU)(e.project),c=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,s.Z)("row")},c.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(y.Z,{href:t.href,className:(0,s.Z)("card padding--lg",vt)},o.createElement("h2",{className:(0,s.Z)("text--truncate",Nt)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,s.Z)("text--truncate",Et)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function St(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case c.W.Project:return At;case c.W.Module:return bt;case c.W.Namespace:case c.W.Enum:case c.W.Class:case c.W.Interface:return Ct;case c.W.Function:case c.W.Accessor:case c.W.Constructor:case c.W.Method:return gt;case c.W.Variable:case c.W.Property:case c.W.EnumMember:return xt;case c.W.CallSignature:case c.W.IndexSignature:case c.W.ConstructorSignature:case c.W.Parameter:case c.W.TypeLiteral:case c.W.TypeParameter:case c.W.GetSignature:case c.W.SetSignature:case c.W.ObjectLiteral:break;case c.W.TypeAlias:return Lt;case c.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},7390:(t,e,n)=>{let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,e,n)=>{n.d(e,{Gr:()=>l,RU:()=>p,gs:()=>r,in:()=>s,rG:()=>a});var o=n(2784);const c=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(c.Provider,{value:{lookup:n,urlLookup:r}},e)}function p(t){const{lookup:e}=(0,o.useContext)(c);return e[t]}function s(){const{lookup:t}=(0,o.useContext)(c);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function a(){const{urlLookup:t,lookup:e}=(0,o.useContext)(c);return n=>{var o;const c=t[n];return c?(null==(o=e[c.projectId])?void 0:o[c.id])??null:null}}function l(t){if(t)return t.href}},68:(t,e,n)=>{n.d(e,{Ld:()=>s,Y0:()=>p,s2:()=>a});var o=n(2784),c=n(822);const r=o.createContext(null);function p(t){let{children:e}=t;const n=(0,c.p)(),p=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),c=t.styles.reduce(((t,n)=>{const{languages:o,style:c}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...c}})),t}),o);return c.root=n,c.plain={...n,backgroundColor:null},c}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:p},e)}function s(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function a(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>i,mN:()=>u});var o=n(2784),c=n(1263),r=n(9741);const p="api-filters",s=c.Z.canUseDOM?localStorage.getItem(p):null,a=s?JSON.parse(s):{inherited:!0,private:!1},l=o.createContext([a,()=>{}]);function i(t){let{children:e}=t;const[n,c]=(0,o.useState)(a),s=(0,r.Z)();return o.createElement(l.Provider,{value:[n,t=>{s&&localStorage.setItem(p,JSON.stringify(t)),c(t)}]},e)}function u(){return(0,o.useContext)(l)}function m(t,e){var n,o;const c=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&c)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},2253:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>p,metadata:()=>a,toc:()=>i});var o=n(7896),c=(n(2784),n(876)),r=n(2072);const p={sidebar_position:2,slug:"/flow"},s="Animation flow",a={unversionedId:"getting-started/flow",id:"getting-started/flow",title:"Animation flow",description:"Motion Canvas uses generator functions to describe animations.",source:"@site/docs/getting-started/flow.mdx",sourceDirName:"getting-started",slug:"/flow",permalink:"/docs/flow",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/docs/getting-started/flow.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"/flow"},sidebar:"docs",previous:{title:"Quickstart",permalink:"/docs/quickstart"},next:{title:"Scene hierarchy",permalink:"/docs/hierarchy"}},l={},i=[{value:"<code>all</code>",id:"all",level:2},{value:"<code>any</code>",id:"any",level:2},{value:"<code>chain</code>",id:"chain",level:2},{value:"<code>delay</code>",id:"delay",level:2},{value:"<code>sequence</code>",id:"sequence",level:2},{value:"<code>loop</code>",id:"loop",level:2}],u={toc:i};function m(t){let{components:e,...n}=t;return(0,c.kt)("wrapper",(0,o.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,c.kt)("h1",{id:"animation-flow"},"Animation flow"),(0,c.kt)("p",null,"Motion Canvas uses generator functions to describe animations."),(0,c.kt)("p",null,"A generator function is a function that can return multiple values:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"function* example() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst generator = example();\n\nconsole.log(generator.next()); // 1;\nconsole.log(generator.next()); // 2;\nconsole.log(generator.next()); // 3;\n")),(0,c.kt)("p",null,"When the ",(0,c.kt)("inlineCode",{parentName:"p"},"yield")," keyword is encountered, the execution of the function pauses,\nand resumes only when the caller requests another value. This is particularly\nuseful when declaring animations - usually we want to change the things on the\nscreen in incremental steps to create an illusion of movement. We also want to\nwait a constant amount of time between these updates so that our eyes can\nregister what's happening. With generators, we can update things in-between the\n",(0,c.kt)("inlineCode",{parentName:"p"},"yield")," keywords, and then wait for a bit whenever the function yields."),(0,c.kt)("p",null,"This is the fundamental idea of Motion Canvas. ",(0,c.kt)("inlineCode",{parentName:"p"},"yield"),' means: "The current frame\nis ready, display it on the screen and come back to me later."'),(0,c.kt)("p",null,"With that in mind, we can make a circle flicker on the screen using the\nfollowing code:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  circle().fill('red');\n  yield;\n  circle().fill('blue');\n  yield;\n  circle().fill('red');\n  yield;\n});\n")),(0,c.kt)("p",null,"Needless to say, it would be extremely cumbersome if we had to write all\nanimations like that. Fortunately, JavaScript has another keyword for use within\ngenerators - ",(0,c.kt)("inlineCode",{parentName:"p"},"yield*"),". It allows us to delegate the yielding to another\ngenerator."),(0,c.kt)("p",null,"For instance, we could extract the flickering code from the above example to a\nseparate generator and delegate our scene function to it:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n  view.add(<Circle ref={circle} width={100} height={100} />);\n\n  yield* flicker(circle());\n});\n\nfunction* flicker(circle: Circle) {\n  circle.fill('red');\n  yield;\n  circle.fill('blue');\n  yield;\n  circle.fill('red');\n  yield;\n}\n")),(0,c.kt)("p",null,"The resulting animation is exactly the same, but now we have a reusable function\nthat we can use whenever we need some flickering."),(0,c.kt)("p",null,"Motion Canvas provides a lot of useful generators like this. You may remember\nthis snippet from ",(0,c.kt)("a",{parentName:"p",href:"/docs/quickstart"},"quickstart"),":"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield * myCircle().fill('#e6a700', 1);\n")),(0,c.kt)("p",null,"It animates the fill color of the circle from its current value to ",(0,c.kt)("inlineCode",{parentName:"p"},"#e6a700"),"\nover a span of one second. As you may guess, the result of calling\n",(0,c.kt)("inlineCode",{parentName:"p"},"fill('#e6a700', 1)")," is another generator to which we can redirect our scene\nfunction. Generators like this are called tweens, because they animate\nbe",(0,c.kt)("strong",{parentName:"p"},"tween")," two values. You can read more about them in the\n",(0,c.kt)("a",{parentName:"p",href:"/docs/tweening"},"tweening")," section."),(0,c.kt)("p",null,"Another kind of generators are ",(0,c.kt)("em",{parentName:"p"},"flow generators"),". They take one or more\ngenerators as their input and combine them together. We've mentioned the ",(0,c.kt)("inlineCode",{parentName:"p"},"all()"),"\ngenerator in the quickstart section, there's a few more:"),(0,c.kt)("h2",{id:"all"},(0,c.kt)("inlineCode",{parentName:"h2"},"all")),(0,c.kt)(r.Z,{url:"/api/core/flow#all",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"any"},(0,c.kt)("inlineCode",{parentName:"h2"},"any")),(0,c.kt)(r.Z,{url:"/api/core/flow#any",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"chain"},(0,c.kt)("inlineCode",{parentName:"h2"},"chain")),(0,c.kt)(r.Z,{url:"/api/core/flow#chain",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"delay"},(0,c.kt)("inlineCode",{parentName:"h2"},"delay")),(0,c.kt)(r.Z,{url:"/api/core/flow#delay",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"sequence"},(0,c.kt)("inlineCode",{parentName:"h2"},"sequence")),(0,c.kt)(r.Z,{url:"/api/core/flow#sequence",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"loop"},(0,c.kt)("inlineCode",{parentName:"h2"},"loop")),(0,c.kt)(r.Z,{url:"/api/core/flow#loop",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null))}m.isMDXComponent=!0}}]);
"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[1276],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function r(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function c(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?r(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},r=Object.keys(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var a=o.createContext({}),i=function(t){var n=o.useContext(a),e=n;return t&&(e="function"==typeof t?t(n):c(c({},n),t)),e},l=function(t){var n=i(t.components);return o.createElement(a.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,r=t.originalType,a=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),u=i(e),d=p,h=u["".concat(a,".").concat(d)]||u[d]||m[d]||r;return e?o.createElement(h,c(c({ref:n},l),{},{components:e})):o.createElement(h,c({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var r=e.length,c=new Array(r);c[0]=d;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=t,s[u]="string"==typeof t?t:p,c[1]=s;for(var i=2;i<r;i++)c[i]=e[i];return o.createElement.apply(null,c)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},3851:(t,n,e)=>{e.d(n,{Z:()=>u});var o=e(7896),p=e(2784),r=e(6277),c=e(1077),s=e(7683),a=e(9817);const i="anchorWithStickyNavbar_fF9Z",l="anchorWithHideOnScrollNavbar_Yh18";function u(t){let{as:n,id:e,...u}=t;const{navbar:{hideOnScroll:m}}=(0,s.L)();if("h1"===n||!e)return p.createElement(n,(0,o.Z)({},u,{id:void 0}));const d=(0,c.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof u.children?u.children:e});return p.createElement(n,(0,o.Z)({},u,{className:(0,r.Z)("anchor",m?l:i,u.className),id:e}),u.children,p.createElement(a.Z,{className:"hash-link",to:`#${e}`,"aria-label":d,title:d},"\u200b"))}},2072:(t,n,e)=>{e.d(n,{Z:()=>c});var o=e(2784),p=e(8617),r=e(1930);function c(t){let{url:n}=t;const e=(0,p.rG)()(n);return o.createElement(r.Z,{reflection:e,headless:!0})}},4903:(t,n,e)=>{e.d(n,{Z:()=>Npt});var o={};e.r(o),e.d(o,{content_0_0:()=>a,content_0_10:()=>w,content_0_100:()=>tn,content_0_1000:()=>Pf,content_0_1002:()=>Ff,content_0_1004:()=>jf,content_0_1006:()=>Vf,content_0_1008:()=>qf,content_0_1010:()=>$f,content_0_1012:()=>Jf,content_0_1014:()=>Qf,content_0_1016:()=>nw,content_0_1018:()=>ow,content_0_102:()=>en,content_0_1020:()=>rw,content_0_1022:()=>sw,content_0_1024:()=>iw,content_0_1026:()=>uw,content_0_1028:()=>dw,content_0_1030:()=>yw,content_0_1032:()=>fw,content_0_104:()=>pn,content_0_106:()=>cn,content_0_108:()=>an,content_0_110:()=>un,content_0_112:()=>dn,content_0_114:()=>yn,content_0_116:()=>fn,content_0_118:()=>Mn,content_0_12:()=>D,content_0_120:()=>_n,content_0_122:()=>gn,content_0_124:()=>Tn,content_0_126:()=>vn,content_0_128:()=>bn,content_0_130:()=>Nn,content_0_132:()=>An,content_0_134:()=>zn,content_0_136:()=>In,content_0_138:()=>Pn,content_0_14:()=>X,content_0_140:()=>Fn,content_0_142:()=>jn,content_0_144:()=>Vn,content_0_146:()=>qn,content_0_148:()=>$n,content_0_150:()=>Jn,content_0_152:()=>Qn,content_0_154:()=>ne,content_0_156:()=>oe,content_0_158:()=>re,content_0_16:()=>x,content_0_160:()=>se,content_0_162:()=>ie,content_0_164:()=>ue,content_0_166:()=>de,content_0_168:()=>ye,content_0_170:()=>fe,content_0_172:()=>Me,content_0_174:()=>_e,content_0_176:()=>ge,content_0_178:()=>Te,content_0_18:()=>C,content_0_180:()=>ve,content_0_182:()=>be,content_0_184:()=>Ne,content_0_186:()=>Ae,content_0_188:()=>ze,content_0_190:()=>Ie,content_0_192:()=>Pe,content_0_194:()=>Fe,content_0_196:()=>je,content_0_198:()=>Ve,content_0_2:()=>l,content_0_20:()=>L,content_0_200:()=>qe,content_0_202:()=>$e,content_0_204:()=>Je,content_0_206:()=>Qe,content_0_208:()=>no,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>so,content_0_216:()=>io,content_0_218:()=>uo,content_0_22:()=>Z,content_0_220:()=>ho,content_0_222:()=>ko,content_0_224:()=>wo,content_0_226:()=>Do,content_0_228:()=>Xo,content_0_230:()=>xo,content_0_232:()=>Co,content_0_234:()=>Lo,content_0_236:()=>Zo,content_0_238:()=>Eo,content_0_24:()=>E,content_0_240:()=>So,content_0_242:()=>Ro,content_0_244:()=>Wo,content_0_246:()=>Go,content_0_248:()=>Uo,content_0_250:()=>Bo,content_0_252:()=>Oo,content_0_254:()=>Ho,content_0_256:()=>Yo,content_0_258:()=>Ko,content_0_26:()=>S,content_0_260:()=>tp,content_0_262:()=>ep,content_0_264:()=>pp,content_0_266:()=>cp,content_0_268:()=>ap,content_0_270:()=>lp,content_0_272:()=>mp,content_0_274:()=>hp,content_0_276:()=>kp,content_0_278:()=>wp,content_0_28:()=>R,content_0_280:()=>Dp,content_0_282:()=>Xp,content_0_284:()=>xp,content_0_286:()=>Cp,content_0_288:()=>Lp,content_0_290:()=>Zp,content_0_292:()=>Ep,content_0_294:()=>Sp,content_0_296:()=>Rp,content_0_298:()=>Wp,content_0_30:()=>W,content_0_300:()=>Gp,content_0_302:()=>Up,content_0_304:()=>Bp,content_0_306:()=>Op,content_0_308:()=>Hp,content_0_310:()=>Yp,content_0_312:()=>Kp,content_0_314:()=>tr,content_0_316:()=>er,content_0_318:()=>pr,content_0_32:()=>G,content_0_320:()=>cr,content_0_322:()=>ar,content_0_324:()=>lr,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>kr,content_0_332:()=>wr,content_0_334:()=>Dr,content_0_336:()=>Xr,content_0_338:()=>xr,content_0_34:()=>U,content_0_340:()=>Cr,content_0_342:()=>Lr,content_0_344:()=>Zr,content_0_346:()=>Er,content_0_348:()=>Sr,content_0_350:()=>Rr,content_0_352:()=>Wr,content_0_354:()=>Gr,content_0_356:()=>Ur,content_0_358:()=>Br,content_0_36:()=>B,content_0_360:()=>Or,content_0_362:()=>Hr,content_0_364:()=>Yr,content_0_366:()=>Kr,content_0_368:()=>tc,content_0_370:()=>ec,content_0_372:()=>pc,content_0_374:()=>cc,content_0_376:()=>ac,content_0_378:()=>lc,content_0_38:()=>O,content_0_380:()=>mc,content_0_382:()=>hc,content_0_384:()=>kc,content_0_386:()=>wc,content_0_388:()=>Dc,content_0_390:()=>Xc,content_0_392:()=>xc,content_0_394:()=>Cc,content_0_396:()=>Lc,content_0_398:()=>Zc,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>Ec,content_0_402:()=>Sc,content_0_404:()=>Rc,content_0_406:()=>Wc,content_0_408:()=>Gc,content_0_410:()=>Uc,content_0_412:()=>Bc,content_0_414:()=>Oc,content_0_416:()=>Hc,content_0_418:()=>Yc,content_0_42:()=>Y,content_0_420:()=>Kc,content_0_422:()=>ts,content_0_424:()=>es,content_0_426:()=>ps,content_0_428:()=>cs,content_0_430:()=>as,content_0_432:()=>ls,content_0_434:()=>ms,content_0_436:()=>hs,content_0_438:()=>ks,content_0_44:()=>K,content_0_440:()=>ws,content_0_442:()=>Ds,content_0_444:()=>Xs,content_0_446:()=>xs,content_0_448:()=>Cs,content_0_450:()=>Ls,content_0_452:()=>Zs,content_0_454:()=>Es,content_0_456:()=>Ss,content_0_458:()=>Rs,content_0_46:()=>tt,content_0_460:()=>Ws,content_0_462:()=>Gs,content_0_464:()=>Us,content_0_466:()=>Bs,content_0_468:()=>Os,content_0_470:()=>Hs,content_0_472:()=>Ys,content_0_474:()=>Ks,content_0_476:()=>ta,content_0_478:()=>ea,content_0_48:()=>et,content_0_480:()=>pa,content_0_482:()=>ca,content_0_484:()=>aa,content_0_486:()=>la,content_0_488:()=>ma,content_0_490:()=>ha,content_0_492:()=>ka,content_0_494:()=>wa,content_0_496:()=>Da,content_0_498:()=>Xa,content_0_50:()=>pt,content_0_500:()=>xa,content_0_502:()=>Ca,content_0_504:()=>La,content_0_506:()=>Za,content_0_508:()=>Ea,content_0_510:()=>Sa,content_0_512:()=>Ra,content_0_514:()=>Wa,content_0_516:()=>Ga,content_0_518:()=>Ua,content_0_52:()=>ct,content_0_520:()=>Ba,content_0_522:()=>Oa,content_0_524:()=>Ha,content_0_526:()=>Ya,content_0_528:()=>Ka,content_0_530:()=>ti,content_0_532:()=>ei,content_0_534:()=>pi,content_0_536:()=>ci,content_0_538:()=>ai,content_0_54:()=>at,content_0_540:()=>li,content_0_542:()=>mi,content_0_544:()=>hi,content_0_546:()=>ki,content_0_548:()=>wi,content_0_550:()=>Di,content_0_552:()=>Xi,content_0_554:()=>xi,content_0_556:()=>Ci,content_0_558:()=>Li,content_0_56:()=>lt,content_0_560:()=>Zi,content_0_562:()=>Ei,content_0_564:()=>Si,content_0_566:()=>Ri,content_0_568:()=>Wi,content_0_570:()=>Gi,content_0_572:()=>Ui,content_0_574:()=>Bi,content_0_576:()=>Oi,content_0_578:()=>Hi,content_0_58:()=>mt,content_0_580:()=>Yi,content_0_582:()=>Ki,content_0_584:()=>tl,content_0_586:()=>el,content_0_588:()=>pl,content_0_590:()=>cl,content_0_592:()=>al,content_0_594:()=>ll,content_0_596:()=>ml,content_0_598:()=>hl,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>kl,content_0_602:()=>wl,content_0_604:()=>Dl,content_0_606:()=>Xl,content_0_608:()=>xl,content_0_610:()=>Cl,content_0_612:()=>Ll,content_0_614:()=>Zl,content_0_616:()=>El,content_0_618:()=>Sl,content_0_62:()=>kt,content_0_620:()=>Rl,content_0_622:()=>Wl,content_0_624:()=>Gl,content_0_626:()=>Ul,content_0_628:()=>Bl,content_0_630:()=>Ol,content_0_632:()=>Hl,content_0_634:()=>Yl,content_0_636:()=>Kl,content_0_638:()=>tu,content_0_64:()=>wt,content_0_640:()=>eu,content_0_642:()=>pu,content_0_644:()=>cu,content_0_646:()=>au,content_0_648:()=>lu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>ku,content_0_656:()=>wu,content_0_658:()=>Du,content_0_66:()=>Dt,content_0_660:()=>Xu,content_0_662:()=>xu,content_0_664:()=>Cu,content_0_666:()=>Lu,content_0_668:()=>Zu,content_0_670:()=>Eu,content_0_672:()=>Su,content_0_674:()=>Ru,content_0_676:()=>Wu,content_0_678:()=>Gu,content_0_68:()=>Xt,content_0_680:()=>Uu,content_0_682:()=>Bu,content_0_684:()=>Ou,content_0_686:()=>Hu,content_0_688:()=>Yu,content_0_690:()=>Ku,content_0_692:()=>tm,content_0_694:()=>em,content_0_696:()=>pm,content_0_698:()=>cm,content_0_70:()=>xt,content_0_700:()=>am,content_0_702:()=>lm,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>km,content_0_710:()=>wm,content_0_712:()=>Dm,content_0_714:()=>Xm,content_0_716:()=>xm,content_0_718:()=>Cm,content_0_72:()=>Ct,content_0_720:()=>Lm,content_0_722:()=>Zm,content_0_724:()=>Em,content_0_726:()=>Sm,content_0_728:()=>Rm,content_0_730:()=>Wm,content_0_732:()=>Gm,content_0_734:()=>Um,content_0_736:()=>Bm,content_0_738:()=>Om,content_0_74:()=>Lt,content_0_740:()=>Hm,content_0_742:()=>Ym,content_0_744:()=>Km,content_0_746:()=>td,content_0_748:()=>ed,content_0_750:()=>pd,content_0_752:()=>cd,content_0_754:()=>ad,content_0_756:()=>ld,content_0_758:()=>md,content_0_76:()=>Zt,content_0_760:()=>hd,content_0_762:()=>kd,content_0_764:()=>wd,content_0_766:()=>Dd,content_0_768:()=>Xd,content_0_770:()=>xd,content_0_772:()=>Cd,content_0_774:()=>Ld,content_0_776:()=>Zd,content_0_778:()=>Ed,content_0_78:()=>Et,content_0_780:()=>Sd,content_0_782:()=>Rd,content_0_784:()=>Wd,content_0_786:()=>Gd,content_0_788:()=>Ud,content_0_790:()=>Bd,content_0_792:()=>Od,content_0_794:()=>Hd,content_0_796:()=>Yd,content_0_798:()=>Kd,content_0_8:()=>k,content_0_80:()=>St,content_0_800:()=>th,content_0_802:()=>eh,content_0_804:()=>ph,content_0_806:()=>ch,content_0_808:()=>ah,content_0_810:()=>lh,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>kh,content_0_818:()=>wh,content_0_82:()=>Rt,content_0_820:()=>Dh,content_0_822:()=>Xh,content_0_824:()=>xh,content_0_826:()=>Ch,content_0_828:()=>Lh,content_0_830:()=>Zh,content_0_832:()=>Eh,content_0_834:()=>Sh,content_0_836:()=>Rh,content_0_838:()=>Wh,content_0_84:()=>Wt,content_0_840:()=>Gh,content_0_842:()=>Uh,content_0_844:()=>Bh,content_0_846:()=>Oh,content_0_848:()=>Hh,content_0_850:()=>Yh,content_0_852:()=>Kh,content_0_854:()=>ty,content_0_856:()=>ey,content_0_858:()=>py,content_0_86:()=>Gt,content_0_860:()=>cy,content_0_862:()=>ay,content_0_864:()=>ly,content_0_866:()=>my,content_0_868:()=>hy,content_0_870:()=>ky,content_0_872:()=>wy,content_0_874:()=>Dy,content_0_876:()=>Xy,content_0_878:()=>xy,content_0_88:()=>Ut,content_0_880:()=>Cy,content_0_882:()=>Ly,content_0_884:()=>Zy,content_0_886:()=>Ey,content_0_888:()=>Sy,content_0_890:()=>Ry,content_0_892:()=>Wy,content_0_894:()=>Gy,content_0_896:()=>Uy,content_0_898:()=>By,content_0_90:()=>Bt,content_0_900:()=>Oy,content_0_902:()=>Hy,content_0_904:()=>Yy,content_0_906:()=>Ky,content_0_908:()=>tk,content_0_910:()=>ek,content_0_912:()=>pk,content_0_914:()=>ck,content_0_916:()=>ak,content_0_918:()=>lk,content_0_92:()=>Ot,content_0_920:()=>mk,content_0_922:()=>hk,content_0_924:()=>kk,content_0_926:()=>wk,content_0_928:()=>Dk,content_0_930:()=>Xk,content_0_932:()=>xk,content_0_934:()=>Ck,content_0_936:()=>Lk,content_0_938:()=>Zk,content_0_94:()=>Ht,content_0_940:()=>Ek,content_0_942:()=>Sk,content_0_944:()=>Rk,content_0_946:()=>Wk,content_0_948:()=>Gk,content_0_950:()=>Uk,content_0_952:()=>Bk,content_0_954:()=>Ok,content_0_956:()=>Hk,content_0_958:()=>Yk,content_0_96:()=>Yt,content_0_960:()=>Kk,content_0_962:()=>tf,content_0_964:()=>ef,content_0_966:()=>pf,content_0_968:()=>cf,content_0_970:()=>af,content_0_972:()=>uf,content_0_974:()=>df,content_0_976:()=>yf,content_0_978:()=>ff,content_0_98:()=>Kt,content_0_980:()=>Mf,content_0_982:()=>_f,content_0_984:()=>gf,content_0_986:()=>Tf,content_0_988:()=>vf,content_0_990:()=>bf,content_0_992:()=>Nf,content_0_994:()=>Af,content_0_996:()=>zf,content_0_998:()=>If,content_2383_0:()=>Mw,content_2383_10:()=>bw,content_2383_100:()=>uD,content_2383_1000:()=>qR,content_2383_1002:()=>$R,content_2383_1004:()=>JR,content_2383_1006:()=>QR,content_2383_1008:()=>nI,content_2383_1010:()=>oI,content_2383_1012:()=>rI,content_2383_1014:()=>sI,content_2383_1016:()=>iI,content_2383_1018:()=>uI,content_2383_102:()=>dD,content_2383_1020:()=>dI,content_2383_1022:()=>yI,content_2383_1024:()=>fI,content_2383_1026:()=>MI,content_2383_1028:()=>_I,content_2383_1030:()=>gI,content_2383_1032:()=>TI,content_2383_1034:()=>vI,content_2383_1036:()=>bI,content_2383_1038:()=>NI,content_2383_104:()=>yD,content_2383_1040:()=>AI,content_2383_1042:()=>zI,content_2383_1044:()=>II,content_2383_1046:()=>PI,content_2383_1048:()=>FI,content_2383_1050:()=>jI,content_2383_1052:()=>VI,content_2383_1054:()=>qI,content_2383_1056:()=>$I,content_2383_1058:()=>JI,content_2383_106:()=>fD,content_2383_1060:()=>QI,content_2383_1062:()=>nW,content_2383_1064:()=>oW,content_2383_1066:()=>rW,content_2383_1068:()=>sW,content_2383_1070:()=>iW,content_2383_1072:()=>uW,content_2383_1074:()=>dW,content_2383_1076:()=>yW,content_2383_1078:()=>fW,content_2383_108:()=>MD,content_2383_1080:()=>MW,content_2383_1082:()=>_W,content_2383_1084:()=>gW,content_2383_1086:()=>TW,content_2383_1088:()=>vW,content_2383_1090:()=>bW,content_2383_1092:()=>NW,content_2383_1094:()=>AW,content_2383_1096:()=>zW,content_2383_1098:()=>IW,content_2383_110:()=>_D,content_2383_1100:()=>PW,content_2383_1102:()=>FW,content_2383_1104:()=>jW,content_2383_1106:()=>VW,content_2383_1108:()=>qW,content_2383_1110:()=>$W,content_2383_1112:()=>JW,content_2383_1114:()=>QW,content_2383_1116:()=>nP,content_2383_1118:()=>oP,content_2383_112:()=>gD,content_2383_1120:()=>rP,content_2383_1122:()=>sP,content_2383_1124:()=>iP,content_2383_1126:()=>uP,content_2383_1128:()=>dP,content_2383_1130:()=>yP,content_2383_1132:()=>fP,content_2383_1134:()=>MP,content_2383_1136:()=>_P,content_2383_1138:()=>gP,content_2383_114:()=>TD,content_2383_1140:()=>TP,content_2383_1142:()=>vP,content_2383_1144:()=>bP,content_2383_1146:()=>NP,content_2383_1148:()=>AP,content_2383_1150:()=>zP,content_2383_1152:()=>IP,content_2383_1154:()=>PP,content_2383_1156:()=>FP,content_2383_1158:()=>jP,content_2383_116:()=>vD,content_2383_1160:()=>VP,content_2383_1162:()=>qP,content_2383_1164:()=>$P,content_2383_1166:()=>JP,content_2383_1168:()=>QP,content_2383_1170:()=>nG,content_2383_1172:()=>oG,content_2383_1174:()=>rG,content_2383_1176:()=>sG,content_2383_1178:()=>iG,content_2383_118:()=>bD,content_2383_1180:()=>uG,content_2383_1182:()=>dG,content_2383_1184:()=>yG,content_2383_1186:()=>fG,content_2383_1188:()=>MG,content_2383_1190:()=>_G,content_2383_1192:()=>gG,content_2383_1194:()=>TG,content_2383_1196:()=>vG,content_2383_1198:()=>bG,content_2383_12:()=>Nw,content_2383_120:()=>ND,content_2383_1200:()=>NG,content_2383_1202:()=>AG,content_2383_1204:()=>zG,content_2383_1206:()=>IG,content_2383_1208:()=>PG,content_2383_1210:()=>FG,content_2383_1212:()=>jG,content_2383_1214:()=>VG,content_2383_1216:()=>qG,content_2383_1218:()=>$G,content_2383_122:()=>AD,content_2383_1220:()=>JG,content_2383_1222:()=>QG,content_2383_1224:()=>nF,content_2383_1226:()=>oF,content_2383_1228:()=>rF,content_2383_1230:()=>sF,content_2383_1232:()=>iF,content_2383_1234:()=>uF,content_2383_1236:()=>dF,content_2383_1238:()=>yF,content_2383_124:()=>zD,content_2383_1240:()=>fF,content_2383_1242:()=>MF,content_2383_1244:()=>_F,content_2383_1246:()=>gF,content_2383_1248:()=>TF,content_2383_1250:()=>vF,content_2383_1252:()=>bF,content_2383_1254:()=>NF,content_2383_1256:()=>AF,content_2383_1258:()=>zF,content_2383_126:()=>ID,content_2383_1260:()=>IF,content_2383_1262:()=>PF,content_2383_1264:()=>FF,content_2383_1266:()=>jF,content_2383_1268:()=>VF,content_2383_1270:()=>qF,content_2383_1272:()=>$F,content_2383_1274:()=>JF,content_2383_1276:()=>QF,content_2383_1278:()=>nU,content_2383_128:()=>PD,content_2383_1280:()=>oU,content_2383_1282:()=>rU,content_2383_1284:()=>sU,content_2383_1286:()=>iU,content_2383_1288:()=>uU,content_2383_1290:()=>dU,content_2383_1292:()=>yU,content_2383_1294:()=>fU,content_2383_1296:()=>MU,content_2383_1298:()=>_U,content_2383_130:()=>FD,content_2383_1300:()=>gU,content_2383_1302:()=>TU,content_2383_1304:()=>vU,content_2383_1306:()=>bU,content_2383_1308:()=>NU,content_2383_1310:()=>AU,content_2383_1312:()=>zU,content_2383_1314:()=>IU,content_2383_1316:()=>PU,content_2383_1318:()=>FU,content_2383_132:()=>jD,content_2383_1320:()=>jU,content_2383_1322:()=>VU,content_2383_1324:()=>qU,content_2383_1326:()=>$U,content_2383_1328:()=>JU,content_2383_1330:()=>QU,content_2383_1332:()=>nj,content_2383_1334:()=>oj,content_2383_1336:()=>rj,content_2383_1338:()=>sj,content_2383_134:()=>VD,content_2383_1340:()=>ij,content_2383_1342:()=>uj,content_2383_1344:()=>dj,content_2383_1346:()=>yj,content_2383_1348:()=>fj,content_2383_1350:()=>Mj,content_2383_1352:()=>_j,content_2383_1354:()=>gj,content_2383_1356:()=>Tj,content_2383_1358:()=>vj,content_2383_136:()=>qD,content_2383_1360:()=>bj,content_2383_1362:()=>Nj,content_2383_1364:()=>Aj,content_2383_1366:()=>zj,content_2383_1368:()=>Ij,content_2383_1370:()=>Pj,content_2383_1372:()=>Fj,content_2383_1374:()=>jj,content_2383_1376:()=>Vj,content_2383_1378:()=>qj,content_2383_138:()=>$D,content_2383_1380:()=>$j,content_2383_1382:()=>Jj,content_2383_1384:()=>Qj,content_2383_1386:()=>nB,content_2383_1388:()=>oB,content_2383_1390:()=>rB,content_2383_1392:()=>sB,content_2383_1394:()=>iB,content_2383_1396:()=>uB,content_2383_1398:()=>dB,content_2383_14:()=>Aw,content_2383_140:()=>JD,content_2383_1400:()=>yB,content_2383_1402:()=>fB,content_2383_1404:()=>MB,content_2383_1406:()=>_B,content_2383_1408:()=>gB,content_2383_1410:()=>TB,content_2383_1412:()=>vB,content_2383_1414:()=>bB,content_2383_1416:()=>NB,content_2383_1418:()=>AB,content_2383_142:()=>QD,content_2383_1420:()=>zB,content_2383_1422:()=>IB,content_2383_1424:()=>PB,content_2383_1426:()=>FB,content_2383_1428:()=>jB,content_2383_1430:()=>VB,content_2383_1432:()=>qB,content_2383_1434:()=>$B,content_2383_1436:()=>JB,content_2383_1438:()=>QB,content_2383_144:()=>n_,content_2383_1440:()=>nV,content_2383_1442:()=>oV,content_2383_1444:()=>rV,content_2383_1446:()=>sV,content_2383_1448:()=>iV,content_2383_1450:()=>uV,content_2383_1452:()=>dV,content_2383_1454:()=>yV,content_2383_1456:()=>fV,content_2383_1458:()=>MV,content_2383_146:()=>o_,content_2383_1460:()=>_V,content_2383_1462:()=>gV,content_2383_1464:()=>TV,content_2383_1466:()=>vV,content_2383_1468:()=>bV,content_2383_1470:()=>NV,content_2383_1472:()=>AV,content_2383_1474:()=>zV,content_2383_1476:()=>IV,content_2383_1478:()=>PV,content_2383_148:()=>r_,content_2383_1480:()=>FV,content_2383_1482:()=>jV,content_2383_1484:()=>VV,content_2383_1486:()=>qV,content_2383_1488:()=>$V,content_2383_1490:()=>JV,content_2383_1492:()=>QV,content_2383_1494:()=>nO,content_2383_1496:()=>oO,content_2383_1498:()=>rO,content_2383_150:()=>s_,content_2383_1500:()=>sO,content_2383_1502:()=>iO,content_2383_1504:()=>uO,content_2383_1506:()=>dO,content_2383_1508:()=>yO,content_2383_1510:()=>fO,content_2383_1512:()=>MO,content_2383_1514:()=>_O,content_2383_1516:()=>gO,content_2383_1518:()=>TO,content_2383_152:()=>i_,content_2383_1520:()=>vO,content_2383_1522:()=>bO,content_2383_1524:()=>NO,content_2383_1526:()=>AO,content_2383_1528:()=>zO,content_2383_1530:()=>IO,content_2383_1532:()=>PO,content_2383_1534:()=>FO,content_2383_1536:()=>jO,content_2383_1538:()=>VO,content_2383_154:()=>u_,content_2383_1540:()=>qO,content_2383_1542:()=>$O,content_2383_1544:()=>JO,content_2383_1546:()=>QO,content_2383_1548:()=>nq,content_2383_1550:()=>oq,content_2383_1552:()=>rq,content_2383_1554:()=>sq,content_2383_1556:()=>iq,content_2383_1558:()=>uq,content_2383_156:()=>d_,content_2383_1560:()=>dq,content_2383_1562:()=>yq,content_2383_1564:()=>fq,content_2383_1566:()=>Mq,content_2383_1568:()=>_q,content_2383_1570:()=>gq,content_2383_1572:()=>Tq,content_2383_1574:()=>vq,content_2383_1576:()=>bq,content_2383_1578:()=>Nq,content_2383_158:()=>y_,content_2383_1580:()=>Aq,content_2383_1582:()=>zq,content_2383_1584:()=>Iq,content_2383_1586:()=>Pq,content_2383_1588:()=>Fq,content_2383_1590:()=>jq,content_2383_1592:()=>Vq,content_2383_1594:()=>qq,content_2383_1596:()=>$q,content_2383_1598:()=>Jq,content_2383_16:()=>zw,content_2383_160:()=>f_,content_2383_1600:()=>Qq,content_2383_1602:()=>nH,content_2383_1604:()=>oH,content_2383_1606:()=>rH,content_2383_1608:()=>sH,content_2383_1610:()=>iH,content_2383_1612:()=>uH,content_2383_1614:()=>dH,content_2383_1616:()=>yH,content_2383_1618:()=>fH,content_2383_162:()=>M_,content_2383_1620:()=>MH,content_2383_1622:()=>_H,content_2383_1624:()=>gH,content_2383_1626:()=>TH,content_2383_1628:()=>vH,content_2383_1630:()=>bH,content_2383_1632:()=>NH,content_2383_1634:()=>AH,content_2383_1636:()=>zH,content_2383_1638:()=>IH,content_2383_164:()=>__,content_2383_1640:()=>PH,content_2383_1642:()=>FH,content_2383_1644:()=>jH,content_2383_1646:()=>VH,content_2383_1648:()=>qH,content_2383_1650:()=>$H,content_2383_1652:()=>JH,content_2383_1654:()=>QH,content_2383_1656:()=>n$,content_2383_1658:()=>o$,content_2383_166:()=>g_,content_2383_1660:()=>r$,content_2383_1662:()=>s$,content_2383_1664:()=>i$,content_2383_1666:()=>u$,content_2383_1668:()=>d$,content_2383_1670:()=>y$,content_2383_1672:()=>f$,content_2383_1674:()=>M$,content_2383_1676:()=>_$,content_2383_1678:()=>g$,content_2383_168:()=>T_,content_2383_1680:()=>T$,content_2383_1682:()=>v$,content_2383_1684:()=>b$,content_2383_1686:()=>N$,content_2383_1688:()=>A$,content_2383_1690:()=>z$,content_2383_1692:()=>I$,content_2383_1694:()=>P$,content_2383_1696:()=>F$,content_2383_1698:()=>j$,content_2383_170:()=>v_,content_2383_1700:()=>V$,content_2383_1702:()=>q$,content_2383_1704:()=>$$,content_2383_1706:()=>J$,content_2383_1708:()=>Q$,content_2383_1710:()=>nY,content_2383_1712:()=>oY,content_2383_1714:()=>rY,content_2383_1716:()=>sY,content_2383_1718:()=>iY,content_2383_172:()=>b_,content_2383_1720:()=>uY,content_2383_1722:()=>dY,content_2383_1724:()=>yY,content_2383_1726:()=>fY,content_2383_1728:()=>MY,content_2383_1730:()=>_Y,content_2383_1732:()=>gY,content_2383_1734:()=>TY,content_2383_1736:()=>vY,content_2383_1738:()=>bY,content_2383_174:()=>N_,content_2383_1740:()=>NY,content_2383_1742:()=>AY,content_2383_1744:()=>zY,content_2383_1746:()=>IY,content_2383_1748:()=>PY,content_2383_1750:()=>FY,content_2383_1752:()=>jY,content_2383_1754:()=>VY,content_2383_1756:()=>qY,content_2383_1758:()=>$Y,content_2383_176:()=>A_,content_2383_1760:()=>JY,content_2383_1762:()=>QY,content_2383_1764:()=>nJ,content_2383_1766:()=>oJ,content_2383_1768:()=>rJ,content_2383_1770:()=>sJ,content_2383_1772:()=>iJ,content_2383_1774:()=>uJ,content_2383_1776:()=>dJ,content_2383_1778:()=>yJ,content_2383_178:()=>z_,content_2383_1780:()=>fJ,content_2383_1782:()=>MJ,content_2383_1784:()=>_J,content_2383_1786:()=>gJ,content_2383_1788:()=>TJ,content_2383_1790:()=>vJ,content_2383_1792:()=>bJ,content_2383_1794:()=>NJ,content_2383_1796:()=>AJ,content_2383_1798:()=>zJ,content_2383_18:()=>Iw,content_2383_180:()=>I_,content_2383_1800:()=>IJ,content_2383_1802:()=>PJ,content_2383_1804:()=>FJ,content_2383_1806:()=>jJ,content_2383_1808:()=>VJ,content_2383_1810:()=>qJ,content_2383_1812:()=>$J,content_2383_1814:()=>JJ,content_2383_1816:()=>QJ,content_2383_1818:()=>nK,content_2383_182:()=>P_,content_2383_1820:()=>oK,content_2383_1822:()=>rK,content_2383_1824:()=>sK,content_2383_1826:()=>iK,content_2383_1828:()=>uK,content_2383_1830:()=>dK,content_2383_1832:()=>yK,content_2383_1834:()=>fK,content_2383_1836:()=>MK,content_2383_1838:()=>_K,content_2383_184:()=>F_,content_2383_1840:()=>gK,content_2383_1842:()=>TK,content_2383_1844:()=>vK,content_2383_1846:()=>bK,content_2383_1848:()=>NK,content_2383_1850:()=>AK,content_2383_1852:()=>zK,content_2383_1854:()=>IK,content_2383_1856:()=>PK,content_2383_1858:()=>FK,content_2383_186:()=>j_,content_2383_1860:()=>jK,content_2383_1862:()=>VK,content_2383_1864:()=>qK,content_2383_1866:()=>$K,content_2383_1868:()=>JK,content_2383_1870:()=>QK,content_2383_1872:()=>nQ,content_2383_1874:()=>oQ,content_2383_1876:()=>rQ,content_2383_1878:()=>sQ,content_2383_188:()=>V_,content_2383_1880:()=>iQ,content_2383_1882:()=>uQ,content_2383_1884:()=>dQ,content_2383_1886:()=>yQ,content_2383_1888:()=>fQ,content_2383_1890:()=>MQ,content_2383_1892:()=>_Q,content_2383_1894:()=>gQ,content_2383_1896:()=>TQ,content_2383_1898:()=>vQ,content_2383_190:()=>q_,content_2383_1900:()=>bQ,content_2383_1902:()=>NQ,content_2383_1904:()=>AQ,content_2383_1906:()=>zQ,content_2383_1908:()=>IQ,content_2383_1910:()=>PQ,content_2383_1912:()=>FQ,content_2383_1914:()=>jQ,content_2383_1916:()=>VQ,content_2383_1918:()=>qQ,content_2383_192:()=>$_,content_2383_1920:()=>$Q,content_2383_1922:()=>JQ,content_2383_1924:()=>QQ,content_2383_1926:()=>n0,content_2383_1928:()=>o0,content_2383_1930:()=>r0,content_2383_1932:()=>s0,content_2383_1934:()=>i0,content_2383_1936:()=>u0,content_2383_1938:()=>d0,content_2383_194:()=>J_,content_2383_1940:()=>y0,content_2383_1942:()=>f0,content_2383_1944:()=>M0,content_2383_1946:()=>_0,content_2383_1948:()=>g0,content_2383_1950:()=>T0,content_2383_1952:()=>v0,content_2383_1954:()=>b0,content_2383_1956:()=>N0,content_2383_1958:()=>A0,content_2383_196:()=>Q_,content_2383_1960:()=>z0,content_2383_1962:()=>I0,content_2383_1964:()=>P0,content_2383_1966:()=>F0,content_2383_1968:()=>j0,content_2383_1970:()=>V0,content_2383_1972:()=>q0,content_2383_1974:()=>$0,content_2383_1976:()=>J0,content_2383_1978:()=>Q0,content_2383_198:()=>nX,content_2383_1980:()=>n3,content_2383_1982:()=>o3,content_2383_1984:()=>r3,content_2383_1986:()=>s3,content_2383_1988:()=>i3,content_2383_1990:()=>u3,content_2383_1992:()=>d3,content_2383_1994:()=>y3,content_2383_1996:()=>f3,content_2383_1998:()=>M3,content_2383_2:()=>_w,content_2383_20:()=>Pw,content_2383_200:()=>oX,content_2383_2000:()=>_3,content_2383_2002:()=>g3,content_2383_2004:()=>T3,content_2383_2006:()=>v3,content_2383_2008:()=>b3,content_2383_2010:()=>N3,content_2383_2012:()=>A3,content_2383_2014:()=>z3,content_2383_2016:()=>I3,content_2383_2018:()=>P3,content_2383_202:()=>rX,content_2383_2020:()=>F3,content_2383_2022:()=>j3,content_2383_2024:()=>V3,content_2383_2026:()=>q3,content_2383_2028:()=>$3,content_2383_2030:()=>J3,content_2383_2032:()=>Q3,content_2383_2034:()=>n2,content_2383_2036:()=>o2,content_2383_2038:()=>r2,content_2383_204:()=>sX,content_2383_2040:()=>s2,content_2383_2042:()=>i2,content_2383_2044:()=>u2,content_2383_2046:()=>d2,content_2383_2048:()=>y2,content_2383_2050:()=>f2,content_2383_2052:()=>M2,content_2383_2054:()=>_2,content_2383_2056:()=>g2,content_2383_2058:()=>T2,content_2383_206:()=>iX,content_2383_2060:()=>v2,content_2383_2062:()=>b2,content_2383_2064:()=>N2,content_2383_2066:()=>A2,content_2383_2068:()=>z2,content_2383_2070:()=>I2,content_2383_2072:()=>P2,content_2383_2074:()=>F2,content_2383_2076:()=>j2,content_2383_2078:()=>V2,content_2383_208:()=>uX,content_2383_2080:()=>q2,content_2383_2082:()=>$2,content_2383_2084:()=>J2,content_2383_2086:()=>Q2,content_2383_2088:()=>n8,content_2383_2090:()=>o8,content_2383_2092:()=>r8,content_2383_2094:()=>s8,content_2383_2096:()=>i8,content_2383_2098:()=>u8,content_2383_210:()=>dX,content_2383_2100:()=>d8,content_2383_2102:()=>y8,content_2383_2104:()=>f8,content_2383_2106:()=>M8,content_2383_2108:()=>_8,content_2383_2110:()=>g8,content_2383_2112:()=>T8,content_2383_2114:()=>v8,content_2383_2116:()=>b8,content_2383_2118:()=>N8,content_2383_212:()=>yX,content_2383_2120:()=>A8,content_2383_2122:()=>z8,content_2383_2124:()=>I8,content_2383_2126:()=>P8,content_2383_2128:()=>F8,content_2383_2130:()=>j8,content_2383_2132:()=>V8,content_2383_2134:()=>q8,content_2383_2136:()=>$8,content_2383_2138:()=>J8,content_2383_214:()=>fX,content_2383_2140:()=>Q8,content_2383_2142:()=>n1,content_2383_2144:()=>o1,content_2383_2146:()=>r1,content_2383_2148:()=>s1,content_2383_2150:()=>i1,content_2383_2152:()=>u1,content_2383_2154:()=>d1,content_2383_2156:()=>y1,content_2383_2158:()=>f1,content_2383_216:()=>MX,content_2383_2160:()=>M1,content_2383_2162:()=>_1,content_2383_2164:()=>g1,content_2383_2166:()=>T1,content_2383_2168:()=>v1,content_2383_2170:()=>b1,content_2383_2172:()=>N1,content_2383_2174:()=>A1,content_2383_2176:()=>z1,content_2383_2178:()=>I1,content_2383_218:()=>_X,content_2383_2180:()=>P1,content_2383_2182:()=>F1,content_2383_2184:()=>j1,content_2383_2186:()=>V1,content_2383_2188:()=>q1,content_2383_2190:()=>$1,content_2383_2192:()=>J1,content_2383_2194:()=>Q1,content_2383_2196:()=>n4,content_2383_2198:()=>o4,content_2383_22:()=>Fw,content_2383_220:()=>gX,content_2383_2200:()=>r4,content_2383_2202:()=>s4,content_2383_2204:()=>i4,content_2383_2206:()=>u4,content_2383_2208:()=>d4,content_2383_2210:()=>y4,content_2383_2212:()=>f4,content_2383_2214:()=>M4,content_2383_2216:()=>_4,content_2383_2218:()=>g4,content_2383_222:()=>TX,content_2383_2220:()=>T4,content_2383_2222:()=>v4,content_2383_2224:()=>b4,content_2383_2226:()=>N4,content_2383_2228:()=>A4,content_2383_2230:()=>z4,content_2383_2232:()=>I4,content_2383_2234:()=>P4,content_2383_2236:()=>F4,content_2383_2238:()=>j4,content_2383_224:()=>vX,content_2383_2240:()=>V4,content_2383_2242:()=>q4,content_2383_2244:()=>$4,content_2383_2246:()=>J4,content_2383_2248:()=>Q4,content_2383_2250:()=>n6,content_2383_2252:()=>o6,content_2383_2254:()=>r6,content_2383_2256:()=>s6,content_2383_2258:()=>i6,content_2383_226:()=>bX,content_2383_2260:()=>u6,content_2383_2262:()=>d6,content_2383_2264:()=>y6,content_2383_2266:()=>f6,content_2383_2268:()=>M6,content_2383_2270:()=>_6,content_2383_2272:()=>g6,content_2383_2274:()=>T6,content_2383_2276:()=>v6,content_2383_2278:()=>b6,content_2383_228:()=>NX,content_2383_2280:()=>N6,content_2383_2282:()=>A6,content_2383_2284:()=>z6,content_2383_2286:()=>I6,content_2383_2288:()=>P6,content_2383_2290:()=>F6,content_2383_2292:()=>j6,content_2383_2294:()=>V6,content_2383_2296:()=>q6,content_2383_2298:()=>$6,content_2383_230:()=>AX,content_2383_2300:()=>J6,content_2383_2302:()=>Q6,content_2383_2304:()=>n5,content_2383_2306:()=>o5,content_2383_2308:()=>r5,content_2383_2310:()=>s5,content_2383_2312:()=>i5,content_2383_2314:()=>u5,content_2383_2316:()=>d5,content_2383_2318:()=>y5,content_2383_232:()=>zX,content_2383_2320:()=>f5,content_2383_2322:()=>M5,content_2383_2324:()=>_5,content_2383_2326:()=>g5,content_2383_2328:()=>T5,content_2383_2330:()=>v5,content_2383_2332:()=>b5,content_2383_2334:()=>N5,content_2383_2336:()=>A5,content_2383_2338:()=>z5,content_2383_234:()=>IX,content_2383_2340:()=>I5,content_2383_2342:()=>P5,content_2383_2344:()=>F5,content_2383_2346:()=>j5,content_2383_2348:()=>V5,content_2383_2350:()=>q5,content_2383_2352:()=>$5,content_2383_2354:()=>J5,content_2383_2356:()=>Q5,content_2383_2358:()=>n7,content_2383_236:()=>PX,content_2383_2360:()=>o7,content_2383_2362:()=>r7,content_2383_2364:()=>s7,content_2383_2366:()=>i7,content_2383_2368:()=>u7,content_2383_2370:()=>d7,content_2383_2372:()=>y7,content_2383_2374:()=>f7,content_2383_2376:()=>M7,content_2383_2378:()=>_7,content_2383_238:()=>FX,content_2383_2380:()=>g7,content_2383_2382:()=>T7,content_2383_2384:()=>v7,content_2383_2386:()=>b7,content_2383_2388:()=>N7,content_2383_2390:()=>A7,content_2383_2392:()=>z7,content_2383_2394:()=>I7,content_2383_2396:()=>P7,content_2383_2398:()=>F7,content_2383_24:()=>jw,content_2383_240:()=>jX,content_2383_2400:()=>j7,content_2383_2402:()=>V7,content_2383_2404:()=>q7,content_2383_2406:()=>$7,content_2383_2408:()=>J7,content_2383_2410:()=>Q7,content_2383_2412:()=>n9,content_2383_2414:()=>o9,content_2383_2416:()=>r9,content_2383_2418:()=>s9,content_2383_242:()=>VX,content_2383_2420:()=>i9,content_2383_2422:()=>u9,content_2383_2424:()=>d9,content_2383_2426:()=>y9,content_2383_2428:()=>f9,content_2383_2430:()=>M9,content_2383_2432:()=>_9,content_2383_2434:()=>g9,content_2383_2436:()=>T9,content_2383_2438:()=>v9,content_2383_244:()=>qX,content_2383_2440:()=>b9,content_2383_2442:()=>N9,content_2383_2444:()=>A9,content_2383_2446:()=>z9,content_2383_2448:()=>I9,content_2383_2450:()=>P9,content_2383_2452:()=>F9,content_2383_2454:()=>j9,content_2383_2456:()=>V9,content_2383_2458:()=>q9,content_2383_246:()=>$X,content_2383_2460:()=>$9,content_2383_2462:()=>J9,content_2383_2464:()=>Q9,content_2383_2466:()=>ntt,content_2383_2468:()=>ott,content_2383_2470:()=>rtt,content_2383_2472:()=>stt,content_2383_2474:()=>itt,content_2383_2476:()=>utt,content_2383_2478:()=>dtt,content_2383_248:()=>JX,content_2383_2480:()=>ytt,content_2383_2482:()=>ftt,content_2383_2484:()=>Mtt,content_2383_2486:()=>_tt,content_2383_2488:()=>gtt,content_2383_2490:()=>Ttt,content_2383_2492:()=>vtt,content_2383_2494:()=>btt,content_2383_2496:()=>Ntt,content_2383_2498:()=>Att,content_2383_250:()=>QX,content_2383_2500:()=>ztt,content_2383_2502:()=>Itt,content_2383_2504:()=>Ptt,content_2383_2506:()=>Ftt,content_2383_2508:()=>jtt,content_2383_2510:()=>Vtt,content_2383_2512:()=>qtt,content_2383_2514:()=>$tt,content_2383_2516:()=>Jtt,content_2383_2518:()=>Qtt,content_2383_252:()=>ng,content_2383_2520:()=>nnt,content_2383_2522:()=>ont,content_2383_2524:()=>rnt,content_2383_2526:()=>snt,content_2383_2528:()=>int,content_2383_2530:()=>unt,content_2383_2532:()=>dnt,content_2383_2534:()=>ynt,content_2383_2536:()=>fnt,content_2383_2538:()=>Mnt,content_2383_254:()=>og,content_2383_2540:()=>_nt,content_2383_2542:()=>gnt,content_2383_2544:()=>Tnt,content_2383_2546:()=>vnt,content_2383_2548:()=>bnt,content_2383_2550:()=>Nnt,content_2383_2552:()=>Ant,content_2383_2554:()=>znt,content_2383_2556:()=>Int,content_2383_2558:()=>Pnt,content_2383_256:()=>rg,content_2383_2560:()=>Fnt,content_2383_2562:()=>jnt,content_2383_2564:()=>Vnt,content_2383_2566:()=>qnt,content_2383_2568:()=>$nt,content_2383_2570:()=>Jnt,content_2383_2572:()=>Qnt,content_2383_2574:()=>net,content_2383_2576:()=>oet,content_2383_2578:()=>ret,content_2383_258:()=>sg,content_2383_2580:()=>set,content_2383_2582:()=>iet,content_2383_2584:()=>met,content_2383_2586:()=>het,content_2383_2588:()=>ket,content_2383_2590:()=>wet,content_2383_2592:()=>Det,content_2383_2594:()=>Xet,content_2383_2596:()=>xet,content_2383_2598:()=>Cet,content_2383_26:()=>Vw,content_2383_260:()=>ig,content_2383_2600:()=>Let,content_2383_2602:()=>Zet,content_2383_2604:()=>Eet,content_2383_2606:()=>Set,content_2383_2608:()=>Ret,content_2383_2610:()=>Wet,content_2383_2612:()=>Get,content_2383_2614:()=>Uet,content_2383_2616:()=>Bet,content_2383_2618:()=>Oet,content_2383_262:()=>ug,content_2383_2620:()=>Het,content_2383_2622:()=>Yet,content_2383_2624:()=>Ket,content_2383_2626:()=>tot,content_2383_2628:()=>eot,content_2383_2630:()=>pot,content_2383_2632:()=>cot,content_2383_2634:()=>aot,content_2383_2636:()=>lot,content_2383_2638:()=>mot,content_2383_264:()=>dg,content_2383_2640:()=>hot,content_2383_2642:()=>kot,content_2383_2644:()=>wot,content_2383_2646:()=>Dot,content_2383_2648:()=>Xot,content_2383_2650:()=>xot,content_2383_2652:()=>Cot,content_2383_2654:()=>Lot,content_2383_2656:()=>Zot,content_2383_2658:()=>Eot,content_2383_266:()=>yg,content_2383_2660:()=>Sot,content_2383_2662:()=>Rot,content_2383_2664:()=>Wot,content_2383_2666:()=>Got,content_2383_2668:()=>Uot,content_2383_2670:()=>Bot,content_2383_2672:()=>Oot,content_2383_2674:()=>Hot,content_2383_2676:()=>Yot,content_2383_2678:()=>Kot,content_2383_268:()=>fg,content_2383_2680:()=>tpt,content_2383_2682:()=>ept,content_2383_2684:()=>ppt,content_2383_2686:()=>cpt,content_2383_2688:()=>apt,content_2383_2690:()=>lpt,content_2383_2692:()=>mpt,content_2383_2694:()=>hpt,content_2383_2696:()=>kpt,content_2383_2698:()=>wpt,content_2383_270:()=>Mg,content_2383_2700:()=>Dpt,content_2383_2702:()=>Xpt,content_2383_2704:()=>xpt,content_2383_2706:()=>Cpt,content_2383_2708:()=>Lpt,content_2383_2710:()=>Zpt,content_2383_272:()=>_g,content_2383_274:()=>gg,content_2383_276:()=>Tg,content_2383_278:()=>vg,content_2383_28:()=>qw,content_2383_280:()=>bg,content_2383_282:()=>Ng,content_2383_284:()=>Ag,content_2383_286:()=>zg,content_2383_288:()=>Ig,content_2383_290:()=>Pg,content_2383_292:()=>Fg,content_2383_294:()=>jg,content_2383_296:()=>Vg,content_2383_298:()=>qg,content_2383_30:()=>$w,content_2383_300:()=>$g,content_2383_302:()=>Jg,content_2383_304:()=>Qg,content_2383_306:()=>nx,content_2383_308:()=>ox,content_2383_310:()=>rx,content_2383_312:()=>sx,content_2383_314:()=>ix,content_2383_316:()=>ux,content_2383_318:()=>dx,content_2383_32:()=>Jw,content_2383_320:()=>yx,content_2383_322:()=>fx,content_2383_324:()=>Mx,content_2383_326:()=>_x,content_2383_328:()=>gx,content_2383_330:()=>Tx,content_2383_332:()=>vx,content_2383_334:()=>bx,content_2383_336:()=>Nx,content_2383_338:()=>Ax,content_2383_34:()=>Qw,content_2383_340:()=>zx,content_2383_342:()=>Ix,content_2383_344:()=>Px,content_2383_346:()=>Fx,content_2383_348:()=>jx,content_2383_350:()=>Vx,content_2383_352:()=>qx,content_2383_354:()=>$x,content_2383_356:()=>Jx,content_2383_358:()=>Qx,content_2383_36:()=>nM,content_2383_360:()=>nT,content_2383_362:()=>oT,content_2383_364:()=>rT,content_2383_366:()=>sT,content_2383_368:()=>iT,content_2383_370:()=>uT,content_2383_372:()=>dT,content_2383_374:()=>yT,content_2383_376:()=>fT,content_2383_378:()=>MT,content_2383_38:()=>oM,content_2383_380:()=>_T,content_2383_382:()=>gT,content_2383_384:()=>TT,content_2383_386:()=>vT,content_2383_388:()=>bT,content_2383_390:()=>NT,content_2383_392:()=>AT,content_2383_394:()=>zT,content_2383_396:()=>IT,content_2383_398:()=>PT,content_2383_4:()=>gw,content_2383_40:()=>rM,content_2383_400:()=>FT,content_2383_402:()=>jT,content_2383_404:()=>VT,content_2383_406:()=>qT,content_2383_408:()=>$T,content_2383_410:()=>JT,content_2383_412:()=>QT,content_2383_414:()=>nC,content_2383_416:()=>oC,content_2383_418:()=>rC,content_2383_42:()=>sM,content_2383_420:()=>sC,content_2383_422:()=>iC,content_2383_424:()=>uC,content_2383_426:()=>dC,content_2383_428:()=>yC,content_2383_430:()=>fC,content_2383_432:()=>MC,content_2383_434:()=>_C,content_2383_436:()=>gC,content_2383_438:()=>TC,content_2383_44:()=>iM,content_2383_440:()=>vC,content_2383_442:()=>bC,content_2383_444:()=>NC,content_2383_446:()=>AC,content_2383_448:()=>zC,content_2383_450:()=>IC,content_2383_452:()=>PC,content_2383_454:()=>FC,content_2383_456:()=>jC,content_2383_458:()=>VC,content_2383_46:()=>uM,content_2383_460:()=>qC,content_2383_462:()=>$C,content_2383_464:()=>JC,content_2383_466:()=>QC,content_2383_468:()=>nv,content_2383_470:()=>ov,content_2383_472:()=>rv,content_2383_474:()=>sv,content_2383_476:()=>iv,content_2383_478:()=>uv,content_2383_48:()=>dM,content_2383_480:()=>dv,content_2383_482:()=>yv,content_2383_484:()=>fv,content_2383_486:()=>Mv,content_2383_488:()=>_v,content_2383_490:()=>gv,content_2383_492:()=>Tv,content_2383_494:()=>vv,content_2383_496:()=>bv,content_2383_498:()=>Nv,content_2383_50:()=>yM,content_2383_500:()=>Av,content_2383_502:()=>zv,content_2383_504:()=>Iv,content_2383_506:()=>Pv,content_2383_508:()=>Fv,content_2383_510:()=>jv,content_2383_512:()=>Vv,content_2383_514:()=>qv,content_2383_516:()=>$v,content_2383_518:()=>Jv,content_2383_52:()=>fM,content_2383_520:()=>Qv,content_2383_522:()=>nL,content_2383_524:()=>oL,content_2383_526:()=>rL,content_2383_528:()=>sL,content_2383_530:()=>iL,content_2383_532:()=>uL,content_2383_534:()=>dL,content_2383_536:()=>yL,content_2383_538:()=>fL,content_2383_54:()=>MM,content_2383_540:()=>ML,content_2383_542:()=>_L,content_2383_544:()=>gL,content_2383_546:()=>TL,content_2383_548:()=>vL,content_2383_550:()=>bL,content_2383_552:()=>NL,content_2383_554:()=>AL,content_2383_556:()=>zL,content_2383_558:()=>IL,content_2383_56:()=>_M,content_2383_560:()=>PL,content_2383_562:()=>FL,content_2383_564:()=>jL,content_2383_566:()=>VL,content_2383_568:()=>qL,content_2383_570:()=>$L,content_2383_572:()=>JL,content_2383_574:()=>QL,content_2383_576:()=>nb,content_2383_578:()=>ob,content_2383_58:()=>gM,content_2383_580:()=>rb,content_2383_582:()=>sb,content_2383_584:()=>ib,content_2383_586:()=>ub,content_2383_588:()=>db,content_2383_590:()=>yb,content_2383_592:()=>fb,content_2383_594:()=>Mb,content_2383_596:()=>_b,content_2383_598:()=>gb,content_2383_6:()=>Tw,content_2383_60:()=>TM,content_2383_600:()=>Tb,content_2383_602:()=>vb,content_2383_604:()=>bb,content_2383_606:()=>Nb,content_2383_608:()=>Ab,content_2383_610:()=>zb,content_2383_612:()=>Ib,content_2383_614:()=>Pb,content_2383_616:()=>Fb,content_2383_618:()=>jb,content_2383_62:()=>vM,content_2383_620:()=>Vb,content_2383_622:()=>qb,content_2383_624:()=>$b,content_2383_626:()=>Jb,content_2383_628:()=>Qb,content_2383_630:()=>nZ,content_2383_632:()=>oZ,content_2383_634:()=>rZ,content_2383_636:()=>sZ,content_2383_638:()=>iZ,content_2383_64:()=>bM,content_2383_640:()=>uZ,content_2383_642:()=>dZ,content_2383_644:()=>yZ,content_2383_646:()=>fZ,content_2383_648:()=>MZ,content_2383_650:()=>_Z,content_2383_652:()=>gZ,content_2383_654:()=>TZ,content_2383_656:()=>vZ,content_2383_658:()=>bZ,content_2383_66:()=>NM,content_2383_660:()=>NZ,content_2383_662:()=>AZ,content_2383_664:()=>zZ,content_2383_666:()=>IZ,content_2383_668:()=>PZ,content_2383_670:()=>FZ,content_2383_672:()=>jZ,content_2383_674:()=>VZ,content_2383_676:()=>qZ,content_2383_678:()=>$Z,content_2383_68:()=>AM,content_2383_680:()=>JZ,content_2383_682:()=>QZ,content_2383_684:()=>nN,content_2383_686:()=>oN,content_2383_688:()=>rN,content_2383_690:()=>sN,content_2383_692:()=>iN,content_2383_694:()=>uN,content_2383_696:()=>dN,content_2383_698:()=>yN,content_2383_70:()=>zM,content_2383_700:()=>fN,content_2383_702:()=>MN,content_2383_704:()=>_N,content_2383_706:()=>gN,content_2383_708:()=>TN,content_2383_710:()=>vN,content_2383_712:()=>bN,content_2383_714:()=>NN,content_2383_716:()=>AN,content_2383_718:()=>zN,content_2383_72:()=>IM,content_2383_720:()=>IN,content_2383_722:()=>PN,content_2383_724:()=>FN,content_2383_726:()=>jN,content_2383_728:()=>VN,content_2383_730:()=>qN,content_2383_732:()=>$N,content_2383_734:()=>JN,content_2383_736:()=>QN,content_2383_738:()=>nE,content_2383_74:()=>PM,content_2383_740:()=>oE,content_2383_742:()=>rE,content_2383_744:()=>sE,content_2383_746:()=>iE,content_2383_748:()=>uE,content_2383_750:()=>dE,content_2383_752:()=>yE,content_2383_754:()=>fE,content_2383_756:()=>ME,content_2383_758:()=>_E,content_2383_76:()=>FM,content_2383_760:()=>gE,content_2383_762:()=>TE,content_2383_764:()=>vE,content_2383_766:()=>bE,content_2383_768:()=>NE,content_2383_770:()=>AE,content_2383_772:()=>zE,content_2383_774:()=>IE,content_2383_776:()=>PE,content_2383_778:()=>FE,content_2383_78:()=>jM,content_2383_780:()=>jE,content_2383_782:()=>VE,content_2383_784:()=>qE,content_2383_786:()=>$E,content_2383_788:()=>JE,content_2383_790:()=>QE,content_2383_792:()=>nA,content_2383_794:()=>oA,content_2383_796:()=>rA,content_2383_798:()=>sA,content_2383_8:()=>vw,content_2383_80:()=>VM,content_2383_800:()=>iA,content_2383_802:()=>uA,content_2383_804:()=>dA,content_2383_806:()=>yA,content_2383_808:()=>fA,content_2383_810:()=>MA,content_2383_812:()=>_A,content_2383_814:()=>gA,content_2383_816:()=>TA,content_2383_818:()=>vA,content_2383_82:()=>qM,content_2383_820:()=>bA,content_2383_822:()=>NA,content_2383_824:()=>AA,content_2383_826:()=>zA,content_2383_828:()=>IA,content_2383_830:()=>PA,content_2383_832:()=>FA,content_2383_834:()=>jA,content_2383_836:()=>VA,content_2383_838:()=>qA,content_2383_84:()=>$M,content_2383_840:()=>$A,content_2383_842:()=>JA,content_2383_844:()=>QA,content_2383_846:()=>nS,content_2383_848:()=>oS,content_2383_850:()=>rS,content_2383_852:()=>sS,content_2383_854:()=>iS,content_2383_856:()=>uS,content_2383_858:()=>dS,content_2383_86:()=>JM,content_2383_860:()=>yS,content_2383_862:()=>fS,content_2383_864:()=>MS,content_2383_866:()=>_S,content_2383_868:()=>gS,content_2383_870:()=>TS,content_2383_872:()=>vS,content_2383_874:()=>bS,content_2383_876:()=>NS,content_2383_878:()=>AS,content_2383_88:()=>QM,content_2383_880:()=>zS,content_2383_882:()=>IS,content_2383_884:()=>PS,content_2383_886:()=>FS,content_2383_888:()=>jS,content_2383_890:()=>VS,content_2383_892:()=>qS,content_2383_894:()=>$S,content_2383_896:()=>JS,content_2383_898:()=>QS,content_2383_90:()=>nD,content_2383_900:()=>nz,content_2383_902:()=>oz,content_2383_904:()=>rz,content_2383_906:()=>sz,content_2383_908:()=>iz,content_2383_910:()=>uz,content_2383_912:()=>dz,content_2383_914:()=>yz,content_2383_916:()=>fz,content_2383_918:()=>Mz,content_2383_92:()=>oD,content_2383_920:()=>_z,content_2383_922:()=>gz,content_2383_924:()=>Tz,content_2383_926:()=>vz,content_2383_928:()=>bz,content_2383_930:()=>Nz,content_2383_932:()=>Az,content_2383_934:()=>zz,content_2383_936:()=>Iz,content_2383_938:()=>Pz,content_2383_94:()=>rD,content_2383_940:()=>Fz,content_2383_942:()=>jz,content_2383_944:()=>Vz,content_2383_946:()=>qz,content_2383_948:()=>$z,content_2383_950:()=>Jz,content_2383_952:()=>Qz,content_2383_954:()=>nR,content_2383_956:()=>oR,content_2383_958:()=>rR,content_2383_96:()=>sD,content_2383_960:()=>sR,content_2383_962:()=>iR,content_2383_964:()=>uR,content_2383_966:()=>dR,content_2383_968:()=>yR,content_2383_970:()=>fR,content_2383_972:()=>MR,content_2383_974:()=>_R,content_2383_976:()=>gR,content_2383_978:()=>TR,content_2383_98:()=>iD,content_2383_980:()=>vR,content_2383_982:()=>bR,content_2383_984:()=>NR,content_2383_986:()=>AR,content_2383_988:()=>zR,content_2383_990:()=>IR,content_2383_992:()=>PR,content_2383_994:()=>FR,content_2383_996:()=>jR,content_2383_998:()=>VR});var p=e(2784),r=e(7896),c=e(876);const s={toc:[]};function a(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Property decorators."))}a.isMDXComponent=!0;const i={toc:[]};function l(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},i,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscriptions and triggering of events."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,c.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}h.isMDXComponent=!0;const y={toc:[]};function k(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},y,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches an asynchronous ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}k.isMDXComponent=!0;const f={toc:[]};function w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}w.isMDXComponent=!0;const M={toc:[]};function D(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},M,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}D.isMDXComponent=!0;const _={toc:[]};function X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}X.isMDXComponent=!0;const g={toc:[]};function x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},g,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}x.isMDXComponent=!0;const T={toc:[]};function C(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},T,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}C.isMDXComponent=!0;const v={toc:[]};function L(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},v,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}L.isMDXComponent=!0;const b={toc:[]};function Z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},b,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}Z.isMDXComponent=!0;const N={toc:[]};function E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}E.isMDXComponent=!0;const A={toc:[]};function S(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}S.isMDXComponent=!0;const z={toc:[]};function R(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},z,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}R.isMDXComponent=!0;const I={toc:[]};function W(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},I,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}W.isMDXComponent=!0;const P={toc:[]};function G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}G.isMDXComponent=!0;const F={toc:[]};function U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},F,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}U.isMDXComponent=!0;const j={toc:[]};function B(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}B.isMDXComponent=!0;const V={toc:[]};function O(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},V,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}O.isMDXComponent=!0;const q={toc:[]};function H(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value argument to subscribers."))}H.isMDXComponent=!0;const $={toc:[]};function Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A base for dispatching ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,c.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}Y.isMDXComponent=!0;const J={toc:[]};function K(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},J,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}K.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Q,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}pt.isMDXComponent=!0;const rt={toc:[]};function ct(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}ct.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}at.isMDXComponent=!0;const it={toc:[]};function lt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},it,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the callback function."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,c.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,c.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}ht.isMDXComponent=!0;const yt={toc:[]};function kt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}kt.isMDXComponent=!0;const ft={toc:[]};function wt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}wt.isMDXComponent=!0;const Mt={toc:[]};function Dt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}Dt.isMDXComponent=!0;const _t={toc:[]};function Xt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_t,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Are subscribers being notified?"))}Xt.isMDXComponent=!0;const gt={toc:[]};function xt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Notify all current and future subscribers."))}xt.isMDXComponent=!0;const Tt={toc:[]};function Ct(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Stop notifying future subscribers."))}Ct.isMDXComponent=!0;const vt={toc:[]};function Lt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}Lt.isMDXComponent=!0;const bt={toc:[]};function Zt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}Zt.isMDXComponent=!0;const Nt={toc:[]};function Et(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}Et.isMDXComponent=!0;const At={toc:[]};function St(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}St.isMDXComponent=!0;const zt={toc:[]};function Rt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}Rt.isMDXComponent=!0;const It={toc:[]};function Wt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},It,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Wt.isMDXComponent=!0;const Pt={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,c.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Gt.isMDXComponent=!0;const Ft={toc:[]};function Ut(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ft,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A callback function that cancels the subscription."))}Ut.isMDXComponent=!0;const jt={toc:[]};function Bt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."))}Bt.isMDXComponent=!0;const Vt={toc:[]};function Ot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}Ot.isMDXComponent=!0;const qt={toc:[]};function Ht(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}Ht.isMDXComponent=!0;const $t={toc:[]};function Yt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$t,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}Yt.isMDXComponent=!0;const Jt={toc:[]};function Kt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}Kt.isMDXComponent=!0;const Qt={toc:[]};function tn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the callback function."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}pn.isMDXComponent=!0;const rn={toc:[]};function cn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the most recent value of this dispatcher."))}cn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}yn.isMDXComponent=!0;const kn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}fn.isMDXComponent=!0;const wn={toc:[]};function Mn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Mn.isMDXComponent=!0;const Dn={toc:[]};function _n(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}_n.isMDXComponent=!0;const Xn={toc:[]};function gn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}gn.isMDXComponent=!0;const xn={toc:[]};function Tn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value passed to subscribers."))}Tn.isMDXComponent=!0;const Cn={toc:[]};function vn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}vn.isMDXComponent=!0;const Ln={toc:[]};function bn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ln,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}bn.isMDXComponent=!0;const Zn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Dispatches a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,c.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}Nn.isMDXComponent=!0;const En={toc:[]};function An(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},En,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The initial value."))}An.isMDXComponent=!0;const Sn={toc:[]};function zn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the most recent value of this dispatcher."))}zn.isMDXComponent=!0;const Rn={toc:[]};function In(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Setting the value will immediately notify all subscribers."))}In.isMDXComponent=!0;const Wn={toc:[]};function Pn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set the current value of this dispatcher."))}Pn.isMDXComponent=!0;const Gn={toc:[]};function Fn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new value."))}Fn.isMDXComponent=!0;const Un={toc:[]};function jn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe all subscribers from the event."))}jn.isMDXComponent=!0;const Bn={toc:[]};function Vn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Callback function that cancels the subscription."))}Vn.isMDXComponent=!0;const On={toc:[]};function qn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},On,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subscribe to the event."),(0,c.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}qn.isMDXComponent=!0;const Hn={toc:[]};function $n(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to invoke when the event occurs."))}$n.isMDXComponent=!0;const Yn={toc:[]};function Jn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Jn.isMDXComponent=!0;const Kn={toc:[]};function Qn(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kn,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unsubscribe from the event."))}Qn.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The handler to unsubscribe."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the value passed to subscribers."))}oe.isMDXComponent=!0;const pe={toc:[]};function re(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}re.isMDXComponent=!0;const ce={toc:[]};function se(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ce,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}se.isMDXComponent=!0;const ae={toc:[]};function ie(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}ie.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}de.isMDXComponent=!0;const he={toc:[]};function ye(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the argument passed to subscribers."))}ye.isMDXComponent=!0;const ke={toc:[]};function fe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ke,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fe.isMDXComponent=!0;const we={toc:[]};function Me(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provides safe access to the public interface of ",(0,c.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,c.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}Me.isMDXComponent=!0;const De={toc:[]};function _e(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},De,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}_e.isMDXComponent=!0;const Xe={toc:[]};function ge(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The amount of times the timer has ticked."))}ge.isMDXComponent=!0;const xe={toc:[]};function Te(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator responsible for running this timer."))}Te.isMDXComponent=!0;const Ce={toc:[]};function ve(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ce,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait until the timer ticks."))}ve.isMDXComponent=!0;const Le={toc:[]};function be(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Le,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The current iteration index."))}be.isMDXComponent=!0;const Ze={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Ne.isMDXComponent=!0;const Ee={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ee,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Ae.isMDXComponent=!0;const Se={toc:[]};function ze(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Se,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}ze.isMDXComponent=!0;const Re={toc:[]};function Ie(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Re,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Ie.isMDXComponent=!0;const We={toc:[]};function Pe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},We,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Pe.isMDXComponent=!0;const Ge={toc:[]};function Fe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}Fe.isMDXComponent=!0;const Ue={toc:[]};function je(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,c.kt)("p",null,"Note that the same animation can be written as:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,c.kt)("p",null,"The reason ",(0,c.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.radius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}je.isMDXComponent=!0;const Be={toc:[]};function Ve(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Be,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run tasks one after another."))}Ve.isMDXComponent=!0;const Oe={toc:[]};function qe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to run."))}qe.isMDXComponent=!0;const He={toc:[]};function $e(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,c.kt)("p",null,"Note that the same animation can be written as:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,c.kt)("p",null,"The reason ",(0,c.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}$e.isMDXComponent=!0;const Ye={toc:[]};function Je(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ye,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Je.isMDXComponent=!0;const Ke={toc:[]};function Qe(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ke,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The delay in seconds"))}Qe.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task or callback to run after the delay."))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}oo.isMDXComponent=!0;const po={toc:[]};function ro(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Call the given callback every N seconds."))}ro.isMDXComponent=!0;const co={toc:[]};function so(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},co,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The interval between subsequent calls."))}so.isMDXComponent=!0;const ao={toc:[]};function io(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to be called."))}io.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Each time iteration waits until the previous one is completed."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}ho.isMDXComponent=!0;const yo={toc:[]};function ko(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Run the given generator N times."))}ko.isMDXComponent=!0;const fo={toc:[]};function wo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The number of iterations."))}wo.isMDXComponent=!0;const Mo={toc:[]};function Do(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}Do.isMDXComponent=!0;const _o={toc:[]};function Xo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_o,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Do nothing."))}Xo.isMDXComponent=!0;const go={toc:[]};function xo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},go,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}xo.isMDXComponent=!0;const To={toc:[]};function Co(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},To,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Turn the given generator function into a threadable generator."))}Co.isMDXComponent=!0;const vo={toc:[]};function Lo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a factory that creates the generator."))}Lo.isMDXComponent=!0;const bo={toc:[]};function Zo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Zo.isMDXComponent=!0;const No={toc:[]};function Eo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Turn the given generator function into a threadable generator."))}Eo.isMDXComponent=!0;const Ao={toc:[]};function So(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional name used when displaying this generator in the UI."))}So.isMDXComponent=!0;const zo={toc:[]};function Ro(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a factory that creates the generator."))}Ro.isMDXComponent=!0;const Io={toc:[]};function Wo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Io,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Wo.isMDXComponent=!0;const Po={toc:[]};function Go(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Po,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Go.isMDXComponent=!0;const Fo={toc:[]};function Uo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Uo.isMDXComponent=!0;const jo={toc:[]};function Bo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The delay between each of the tasks."))}Bo.isMDXComponent=!0;const Vo={toc:[]};function Oo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to be run in a sequence."))}Oo.isMDXComponent=!0;const qo={toc:[]};function Ho(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Ho.isMDXComponent=!0;const $o={toc:[]};function Yo(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for the given amount of time."))}Yo.isMDXComponent=!0;const Jo={toc:[]};function Ko(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The relative time in seconds."))}Ko.isMDXComponent=!0;const Qo={toc:[]};function tp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qo,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional task to be run after the function completes."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}pp.isMDXComponent=!0;const rp={toc:[]};function cp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait until the given time event."))}cp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the time event."))}ap.isMDXComponent=!0;const ip={toc:[]};function lp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ip,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An optional task to be run after the function completes."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Main Motion Canvas classes."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when a new message is logged."))}hp.isMDXComponent=!0;const yp={toc:[]};function kp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the meta file of a given entity."))}kp.isMDXComponent=!0;const fp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when metadata changes."))}wp.isMDXComponent=!0;const Mp={toc:[]};function Dp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Load new metadata from a file."))}Dp.isMDXComponent=!0;const _p={toc:[]};function Xp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_p,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"New metadata."))}Xp.isMDXComponent=!0;const gp={toc:[]};function xp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any possible errors will be logged to the console."))}xp.isMDXComponent=!0;const Tp={toc:[]};function Cp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set data without waiting for confirmation."))}Cp.isMDXComponent=!0;const vp={toc:[]};function Lp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"New data."))}Lp.isMDXComponent=!0;const bp={toc:[]};function Zp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the data stored in the meta file."))}Zp.isMDXComponent=!0;const Np={toc:[]};function Ep(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,c.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}Ep.isMDXComponent=!0;const Ap={toc:[]};function Sp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}))}Sp.isMDXComponent=!0;const zp={toc:[]};function Rp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The project configuration."))}Rp.isMDXComponent=!0;const Ip={toc:[]};function Wp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ip,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the current scene changes."))}Wp.isMDXComponent=!0;const Pp={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Gp.isMDXComponent=!0;const Fp={toc:[]};function Up(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after the scenes were recalculated."))}Up.isMDXComponent=!0;const jp={toc:[]};function Bp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the contents of a meta file."))}Bp.isMDXComponent=!0;const Vp={toc:[]};function Op(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Multi-media management."))}Op.isMDXComponent=!0;const qp={toc:[]};function Hp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Hp.isMDXComponent=!0;const $p={toc:[]};function Yp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause/resume the audio."))}Yp.isMDXComponent=!0;const Jp={toc:[]};function Kp(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the audio should be paused or resumed."))}Kp.isMDXComponent=!0;const Qp={toc:[]};function tr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qp,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The absolute biggest value from the peaks array."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The amount of samples taken."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}pr.isMDXComponent=!0;const rr={toc:[]};function cr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Samples per seconds."))}cr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Playback control."))}ar.isMDXComponent=!0;const ir={toc:[]};function lr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ir,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Abstract scene representations and related utilities."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Signifies the various stages of a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs after a render ends."))}hr.isMDXComponent=!0;const yr={toc:[]};function kr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}kr.isMDXComponent=!0;const fr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,c.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}wr.isMDXComponent=!0;const Mr={toc:[]};function Dr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,c.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}Dr.isMDXComponent=!0;const _r={toc:[]};function Xr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_r,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes the state of a scene."))}Xr.isMDXComponent=!0;const gr={toc:[]};function xr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}xr.isMDXComponent=!0;const Tr={toc:[]};function Cr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has finished transitioning in."))}Cr.isMDXComponent=!0;const vr={toc:[]};function Lr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,c.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Lr.isMDXComponent=!0;const br={toc:[]};function Zr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},br,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene is ready to transition out."))}Zr.isMDXComponent=!0;const Nr={toc:[]};function Er(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Invoking ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,c.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Er.isMDXComponent=!0;const Ar={toc:[]};function Sr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has finished."))}Sr.isMDXComponent=!0;const zr={toc:[]};function Rr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene has just been created/reset."))}Rr.isMDXComponent=!0;const Ir={toc:[]};function Wr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ir,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The default implementation of the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,c.kt)("p",null,"Uses generators to control the animation."))}Wr.isMDXComponent=!0;const Pr={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Will be passed as the second argument to the constructor."))}Gr.isMDXComponent=!0;const Fr={toc:[]};function Ur(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the scene."))}Ur.isMDXComponent=!0;const jr={toc:[]};function Br(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reference to the project."))}Br.isMDXComponent=!0;const Vr={toc:[]};function Or(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene starts."))}Or.isMDXComponent=!0;const qr={toc:[]};function Hr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene ends."))}Hr.isMDXComponent=!0;const $r={toc:[]};function Yr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the cached data changes."))}Yr.isMDXComponent=!0;const Jr={toc:[]};function Kr(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after scene is recalculated."))}Kr.isMDXComponent=!0;const Qr={toc:[]};function tc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qr,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reloaded."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reset."))}pc.isMDXComponent=!0;const rc={toc:[]};function cc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the main thread changes."))}cc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ac.isMDXComponent=!0;const ic={toc:[]};function lc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ic,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hc.isMDXComponent=!0;const yc={toc:[]};function kc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the size of this scene."),(0,c.kt)("p",null,"Usually return ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}kc.isMDXComponent=!0;const fc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}wc.isMDXComponent=!0;const Mc={toc:[]};function Dc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene cached?"),(0,c.kt)("p",null,"Used only by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,c.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,c.kt)("p",null,"Should always return ",(0,c.kt)("inlineCode",{parentName:"p"},"true"),"."))}Dc.isMDXComponent=!0;const _c={toc:[]};function Xc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_c,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,c.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Xc.isMDXComponent=!0;const gc={toc:[]};function xc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress this scene one frame forward."))}xc.isMDXComponent=!0;const Tc={toc:[]};function Cc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,c.kt)("p",null,"At the end of execution, this method should set ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,c.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Cc.isMDXComponent=!0;const vc={toc:[]};function Lc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Recalculate the scene."))}Lc.isMDXComponent=!0;const bc={toc:[]};function Zc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,c.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Zc.isMDXComponent=!0;const Nc={toc:[]};function Ec(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reload the scene."))}Ec.isMDXComponent=!0;const Ac={toc:[]};function Sc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, a new configuration object."))}Sc.isMDXComponent=!0;const zc={toc:[]};function Rc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render the scene onto a canvas."))}Rc.isMDXComponent=!0;const Ic={toc:[]};function Wc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ic,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to used when rendering."))}Wc.isMDXComponent=!0;const Pc={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset this scene to its initial state."))}Gc.isMDXComponent=!0;const Fc={toc:[]};function Uc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, the previous scene."))}Uc.isMDXComponent=!0;const jc={toc:[]};function Bc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the view."),(0,c.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,c.kt)("p",null,"Can modify the state of the view."))}Bc.isMDXComponent=!0;const Vc={toc:[]};function Oc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Lifecycle events for ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Oc.isMDXComponent=!0;const qc={toc:[]};function Hc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A random number generator based on\n",(0,c.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,c.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Hc.isMDXComponent=!0;const $c={toc:[]};function Yc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get an array filled with random floats in the given range."))}Yc.isMDXComponent=!0;const Jc={toc:[]};function Kc(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The size of the array."))}Kc.isMDXComponent=!0;const Qc={toc:[]};function ts(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qc,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range."))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get an array filled with random integers in the given range."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"}),(0,c.kt)("li",{parentName:"ul"})))}ps.isMDXComponent=!0;const rs={toc:[]};function cs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The size of the array."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"})))}cs.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"})))}as.isMDXComponent=!0;const is={toc:[]};function ls(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},is,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. Exclusive."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the next random float in the given range."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}hs.isMDXComponent=!0;const ys={toc:[]};function ks(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ys,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range."))}ks.isMDXComponent=!0;const fs={toc:[]};function ws(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the next random integer in the given range."))}ws.isMDXComponent=!0;const Ms={toc:[]};function Ds(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ms,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}Ds.isMDXComponent=!0;const _s={toc:[]};function Xs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. Exclusive."))}Xs.isMDXComponent=!0;const gs={toc:[]};function xs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a new independent generator."))}xs.isMDXComponent=!0;const Ts={toc:[]};function Cs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ts,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Manages time events for a given scene."))}Cs.isMDXComponent=!0;const vs={toc:[]};function Ls(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when time events change."))}Ls.isMDXComponent=!0;const bs={toc:[]};function Zs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the time offset of the given event."))}Zs.isMDXComponent=!0;const Ns={toc:[]};function Es(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the event."))}Es.isMDXComponent=!0;const As={toc:[]};function Ss(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The time offset in seconds."))}Ss.isMDXComponent=!0;const zs={toc:[]};function Rs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,c.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}Rs.isMDXComponent=!0;const Is={toc:[]};function Ws(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Is,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get variable signal if exists or create signal if not"))}Ws.isMDXComponent=!0;const Ps={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ps,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the variable."))}Gs.isMDXComponent=!0;const Fs={toc:[]};function Us(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset all stored signals."))}Us.isMDXComponent=!0;const js={toc:[]};function Bs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update all signals with new project variable values."))}Bs.isMDXComponent=!0;const Vs={toc:[]};function Os(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes cached information about the timing of a scene."))}Os.isMDXComponent=!0;const qs={toc:[]};function Hs(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes a complete scene together with the meta file."))}Hs.isMDXComponent=!0;const $s={toc:[]};function Ys(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Configuration object."))}Ys.isMDXComponent=!0;const Js={toc:[]};function Ks(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Js,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The class used to instantiate the scene."))}Ks.isMDXComponent=!0;const Qs={toc:[]};function ta(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qs,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The stack trace at the moment of creation."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}pa.isMDXComponent=!0;const ra={toc:[]};function ca(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ra,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}ca.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for the inspected element."))}aa.isMDXComponent=!0;const ia={toc:[]};function la(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ia,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element for which to draw an overlay."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}ha.isMDXComponent=!0;const ya={toc:[]};function ka(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ya,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}ka.isMDXComponent=!0;const fa={toc:[]};function wa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Return the attributes of the inspected element."))}wa.isMDXComponent=!0;const Ma={toc:[]};function Da(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ma,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element to inspect."))}Da.isMDXComponent=!0;const _a={toc:[]};function Xa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_a,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a possible element to inspect at a given position."))}Xa.isMDXComponent=!0;const ga={toc:[]};function xa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ga,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The x coordinate."))}xa.isMDXComponent=!0;const Ta={toc:[]};function Ca(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ta,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The y coordinate."))}Ca.isMDXComponent=!0;const va={toc:[]};function La(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},va,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}La.isMDXComponent=!0;const ba={toc:[]};function Za(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ba,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the inspected element is still valid."))}Za.isMDXComponent=!0;const Na={toc:[]};function Ea(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The element to validate."))}Ea.isMDXComponent=!0;const Aa={toc:[]};function Sa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a time event stored in a meta file."))}Sa.isMDXComponent=!0;const za={toc:[]};function Ra(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},za,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,c.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Ra.isMDXComponent=!0;const Ia={toc:[]};function Wa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ia,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The main interface for scenes."))}Wa.isMDXComponent=!0;const Pa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Will be passed as the second argument to the constructor."))}Ga.isMDXComponent=!0;const Fa={toc:[]};function Ua(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the scene."))}Ua.isMDXComponent=!0;const ja={toc:[]};function Ba(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reference to the project."))}Ba.isMDXComponent=!0;const Va={toc:[]};function Oa(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Va,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene's ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,c.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Oa.isMDXComponent=!0;const qa={toc:[]};function Ha(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene starts."))}Ha.isMDXComponent=!0;const $a={toc:[]};function Ya(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The frame at which this scene ends."))}Ya.isMDXComponent=!0;const Ja={toc:[]};function Ka(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ja,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the cached data changes."))}Ka.isMDXComponent=!0;const Qa={toc:[]};function ti(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qa,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered after scene is recalculated."))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reloaded."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}pi.isMDXComponent=!0;const ri={toc:[]};function ci(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ri,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the scene is reset."))}ci.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}ai.isMDXComponent=!0;const ii={toc:[]};function li(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ii,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Enter the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,c.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hi.isMDXComponent=!0;const yi={toc:[]};function ki(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the size of this scene."),(0,c.kt)("p",null,"Usually return ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ki.isMDXComponent=!0;const fi={toc:[]};function wi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,c.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}wi.isMDXComponent=!0;const Mi={toc:[]};function Di(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene cached?"),(0,c.kt)("p",null,"Used only by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,c.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,c.kt)("p",null,"Should always return ",(0,c.kt)("inlineCode",{parentName:"p"},"true"),"."))}Di.isMDXComponent=!0;const _i={toc:[]};function Xi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_i,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Is this scene in the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,c.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}Xi.isMDXComponent=!0;const gi={toc:[]};function xi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress this scene one frame forward."))}xi.isMDXComponent=!0;const Ti={toc:[]};function Ci(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ti,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,c.kt)("p",null,"At the end of execution, this method should set ",(0,c.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,c.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,c.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Ci.isMDXComponent=!0;const vi={toc:[]};function Li(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Recalculate the scene."))}Li.isMDXComponent=!0;const bi={toc:[]};function Zi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,c.kt)("p",null,"Should trigger ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,c.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Zi.isMDXComponent=!0;const Ni={toc:[]};function Ei(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reload the scene."))}Ei.isMDXComponent=!0;const Ai={toc:[]};function Si(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, a new configuration object."))}Si.isMDXComponent=!0;const zi={toc:[]};function Ri(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render the scene onto a canvas."))}Ri.isMDXComponent=!0;const Ii={toc:[]};function Wi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ii,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to used when rendering."))}Wi.isMDXComponent=!0;const Pi={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset this scene to its initial state."))}Gi.isMDXComponent=!0;const Fi={toc:[]};function Ui(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If present, the previous scene."))}Ui.isMDXComponent=!0;const ji={toc:[]};function Bi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}Bi.isMDXComponent=!0;const Vi={toc:[]};function Oi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Each class implementing the ",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,c.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Oi.isMDXComponent=!0;const qi={toc:[]};function Hi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The constructor used when creating new scenes."))}Hi.isMDXComponent=!0;const $i={toc:[]};function Yi(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,c.kt)("inlineCode",{parentName:"a"},"config")),"."))}Yi.isMDXComponent=!0;const Ji={toc:[]};function Ki(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ji,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Describes a scene exposed by scene files."))}Ki.isMDXComponent=!0;const Qi={toc:[]};function tl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qi,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Configuration object."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The class used to instantiate the scene."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The stack trace at the moment of creation."))}pl.isMDXComponent=!0;const rl={toc:[]};function cl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type of the configuration object."))}cl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the contents of a meta file."))}al.isMDXComponent=!0;const il={toc:[]};function ll(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},il,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Triggered when the main thread changes."))}hl.isMDXComponent=!0;const yl={toc:[]};function kl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a time event at runtime."))}kl.isMDXComponent=!0;const fl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"In other words, the moment at which ",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,c.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}wl.isMDXComponent=!0;const Ml={toc:[]};function Dl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ml,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}Dl.isMDXComponent=!0;const _l={toc:[]};function Xl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_l,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Name of the event."))}Xl.isMDXComponent=!0;const gl={toc:[]};function xl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Duration of the event in seconds."))}xl.isMDXComponent=!0;const Tl={toc:[]};function Cl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Stack trace at the moment of registration."))}Cl.isMDXComponent=!0;const vl={toc:[]};function Ll(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}Ll.isMDXComponent=!0;const bl={toc:[]};function Zl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents attributes of an inspected element."))}Zl.isMDXComponent=!0;const Nl={toc:[]};function El(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}El.isMDXComponent=!0;const Al={toc:[]};function Sl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents an element to inspect."))}Sl.isMDXComponent=!0;const zl={toc:[]};function Rl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Rl.isMDXComponent=!0;const Il={toc:[]};function Wl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Il,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}Wl.isMDXComponent=!0;const Pl={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the signal is currently using its initial value."))}Gl.isMDXComponent=!0;const Fl={toc:[]};function Ul(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}Ul.isMDXComponent=!0;const jl={toc:[]};function Bl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Bl.isMDXComponent=!0;const Vl={toc:[]};function Ol(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}Ol.isMDXComponent=!0;const ql={toc:[]};function Hl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Hl.isMDXComponent=!0;const $l={toc:[]};function Yl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Yl.isMDXComponent=!0;const Jl={toc:[]};function Kl(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jl,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Kl.isMDXComponent=!0;const Ql={toc:[]};function tu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ql,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}pu.isMDXComponent=!0;const ru={toc:[]};function cu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ru,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the signal is currently using its initial value."))}cu.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}au.isMDXComponent=!0;const iu={toc:[]};function lu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}hu.isMDXComponent=!0;const yu={toc:[]};function ku(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}ku.isMDXComponent=!0;const fu={toc:[]};function wu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}wu.isMDXComponent=!0;const Mu={toc:[]};function Du(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Du.isMDXComponent=!0;const _u={toc:[]};function Xu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Xu.isMDXComponent=!0;const gu={toc:[]};function xu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the signal is currently using its initial value."))}xu.isMDXComponent=!0;const Tu={toc:[]};function Cu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Cu.isMDXComponent=!0;const vu={toc:[]};function Lu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Lu.isMDXComponent=!0;const bu={toc:[]};function Zu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Zu.isMDXComponent=!0;const Nu={toc:[]};function Eu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Thread management."))}Eu.isMDXComponent=!0;const Au={toc:[]};function Su(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,c.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}Su.isMDXComponent=!0;const zu={toc:[]};function Ru(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A class representing an individual thread."))}Ru.isMDXComponent=!0;const Iu={toc:[]};function Wu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator wrapped by this thread."))}Wu.isMDXComponent=!0;const Pu={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The generator wrapped by this thread."))}Gu.isMDXComponent=!0;const Fu={toc:[]};function Uu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Used by ",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,c.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}Uu.isMDXComponent=!0;const ju={toc:[]};function Bu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The current time of this thread."))}Bu.isMDXComponent=!0;const Vu={toc:[]};function Ou(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The next value to be passed to the wrapped generator."))}Ou.isMDXComponent=!0;const qu={toc:[]};function Hu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}Hu.isMDXComponent=!0;const $u={toc:[]};function Yu(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Progress the wrapped generator once."))}Yu.isMDXComponent=!0;const Ju={toc:[]};function Ku(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ju,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the thread for the next update cycle."))}Ku.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qu,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A generator function or a normal function that returns a generator."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,c.kt)("p",null,"Progress to the next frame:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,c.kt)("p",null,"Run another generator synchronously:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,c.kt)("p",null,"Run another generator concurrently:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,c.kt)("p",null,"Await a Promise:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}pm.isMDXComponent=!0;const rm={toc:[]};function cm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Cancel all listed tasks."),(0,c.kt)("p",null,"Example:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}cm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to cancel."))}am.isMDXComponent=!0;const im={toc:[]};function lm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},im,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A possible ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the given value is a ",(0,c.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,c.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}hm.isMDXComponent=!0;const ym={toc:[]};function km(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ym,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A possible thread ",(0,c.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,c.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}km.isMDXComponent=!0;const fm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}wm.isMDXComponent=!0;const Mm={toc:[]};function Dm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}Dm.isMDXComponent=!0;const _m={toc:[]};function Xm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_m,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to join."))}Xm.isMDXComponent=!0;const gm={toc:[]};function xm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}xm.isMDXComponent=!0;const Tm={toc:[]};function Cm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Pause the current generator until listed tasks are finished."))}Cm.isMDXComponent=!0;const vm={toc:[]};function Lm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}Lm.isMDXComponent=!0;const bm={toc:[]};function Zm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A list of tasks to join."))}Zm.isMDXComponent=!0;const Nm={toc:[]};function Em(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"From the perspective of the external generator, ",(0,c.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,c.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}Em.isMDXComponent=!0;const Am={toc:[]};function Sm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}Sm.isMDXComponent=!0;const zm={toc:[]};function Rm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a context in which generators can be run concurrently."))}Rm.isMDXComponent=!0;const Im={toc:[]};function Wm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Im,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A function that returns the generator to run."))}Wm.isMDXComponent=!0;const Pm={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}Gm.isMDXComponent=!0;const Fm={toc:[]};function Um(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Transitions between scenes."))}Um.isMDXComponent=!0;const jm={toc:[]};function Bm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that slides the scene in a given direction."))}Bm.isMDXComponent=!0;const Vm={toc:[]};function Om(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The direction in which to slide."))}Om.isMDXComponent=!0;const qm={toc:[]};function Hm(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}Hm.isMDXComponent=!0;const $m={toc:[]};function Ym(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Ym.isMDXComponent=!0;const Jm={toc:[]};function Km(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to use before the current scene is rendered."))}Km.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qm,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The callback to use before the previous scene is rendered."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that zooms in on a given area of the scene."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The area on which to zoom in."))}pd.isMDXComponent=!0;const rd={toc:[]};function cd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}cd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Perform a transition that zooms out from a given area of the scene."))}ad.isMDXComponent=!0;const id={toc:[]};function ld(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},id,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The area from which to zoom out."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the transition."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolation and timing of tweens."))}hd.isMDXComponent=!0;const yd={toc:[]};function kd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Any old key that is missing in ",(0,c.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,c.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,c.kt)("ol",null,(0,c.kt)("li",{parentName:"ol"})))}kd.isMDXComponent=!0;const fd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A value matching the structure of from and to."))}wd.isMDXComponent=!0;const Md={toc:[]};function Dd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Md,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Dd.isMDXComponent=!0;const _d={toc:[]};function Xd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 0."))}Xd.isMDXComponent=!0;const gd={toc:[]};function xd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 1."))}xd.isMDXComponent=!0;const Td={toc:[]};function Cd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Td,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Cd.isMDXComponent=!0;const vd={toc:[]};function Ld(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A value matching the structure of from and to."))}Ld.isMDXComponent=!0;const bd={toc:[]};function Zd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Zd.isMDXComponent=!0;const Nd={toc:[]};function Ed(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 0."))}Ed.isMDXComponent=!0;const Ad={toc:[]};function Sd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The input to favor when value is 1."))}Sd.isMDXComponent=!0;const zd={toc:[]};function Rd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Rd.isMDXComponent=!0;const Id={toc:[]};function Wd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Id,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Complex types used in animations."))}Wd.isMDXComponent=!0;const Pd={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A specialized 2x3 Matrix representing a 2D transformation."),(0,c.kt)("p",null,"A Matrix2D contains six elements defined as\n","[a, b,\nc, d,\ntx, ty]"),(0,c.kt)("p",null,"This is a shortcut for a 3x3 matrix of the form\n","[a, b, 0,\nc, d, 0\ntx, ty, 1]"),(0,c.kt)("p",null,'Note that because a Matrix2D ignores the z-values of each component vectors,\nit does not satisfy all properties of a "real" 3x3 matrix.'),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},"A Matrix2D has no transpose"),(0,c.kt)("li",{parentName:"ul"},"A(B + C) = AB + AC does not hold for a Matrix2D"),(0,c.kt)("li",{parentName:"ul"},"(rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D"),(0,c.kt)("li",{parentName:"ul"},"r(AB) = (rA)B = A(rB) does not hold for a Matrix2D")))}Gd.isMDXComponent=!0;const Fd={toc:[]};function Ud(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the determinant of the matrix."))}Ud.isMDXComponent=!0;const jd={toc:[]};function Bd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the matrix is not invertible, i.e. its determinant is ",(0,c.kt)("inlineCode",{parentName:"p"},"0"),", this will\nreturn ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", instead."))}Bd.isMDXComponent=!0;const Vd={toc:[]};function Od(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst inverse = matrix.inverse;\n// => Matrix2D(\n//      [-2, 1],\n//      [1.5, -0.5],\n//      [1, -2],\n//   )\n")))}Od.isMDXComponent=!0;const qd={toc:[]};function Hd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the inverse of the matrix."))}Hd.isMDXComponent=!0;const $d={toc:[]};function Yd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Yd.isMDXComponent=!0;const Jd={toc:[]};function Kd(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.add(b);\n// => Matrix2D(\n//      [8, 10],\n//      [12, 14],\n//      [16, 18],\n//    )\n")))}Kd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qd,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the provided matrix to this matrix."))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The matrix to add"))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst x = matrix.column(0);\n// Vector2(1, 0)\n\nconst y = matrix.column(1);\n// Vector2(0, 0)\n\nconst z = matrix.column(1);\n// Vector2(1, 0)\n")))}ph.isMDXComponent=!0;const rh={toc:[]};function ch(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the nth component vector of the matrix. Only defined for 0, 1, and 2."))}ch.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index of the component vector to retrieve."))}ah.isMDXComponent=!0;const ih={toc:[]};function lh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ih,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [0, 1],\n  [1, 1],\n);\nconst b = new Matrix2D(\n  [2, 1],\n  [1, 1],\n  [1, 1],\n);\n\nconst result = a.mul(b);\n// => Matrix2D(\n//     [2, 5],\n//     [1, 3],\n//     [2, 4],\n//   )\n")))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the matrix product of this matrix with the provided matrix."))}hh.isMDXComponent=!0;const yh={toc:[]};function kh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The matrix to multiply with"))}kh.isMDXComponent=!0;const fh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.mulScalar(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [10, 12],\n//    )\n")))}wh.isMDXComponent=!0;const Mh={toc:[]};function Dh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Multiply each value of the matrix by a scalar."),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"})))}Dh.isMDXComponent=!0;const _h={toc:[]};function Xh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_h,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value by which to scale each term"))}Xh.isMDXComponent=!0;const gh={toc:[]};function xh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}xh.isMDXComponent=!0;const Th={toc:[]};function Ch(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Th,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result = a.rotate(90);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n\n// Provide the angle in radians\nconst result = a.rotate(Math.PI * 0.5, true);\n// => Matrix2D(\n//     [3, 4],\n//     [-1, -2],\n//     [5, 6],\n//   )\n")))}Ch.isMDXComponent=!0;const vh={toc:[]};function Lh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rotate the matrix by the provided angle. By default, the angle is\nprovided in degrees."))}Lh.isMDXComponent=!0;const bh={toc:[]};function Zh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The angle by which to rotate the matrix"))}Zh.isMDXComponent=!0;const Nh={toc:[]};function Eh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 0],\n  [0, 0],\n  [1, 0],\n);\n\nconst firstRow = matrix.column(0);\n// [1, 0, 1]\n\nconst secondRow = matrix.column(1);\n// [0, 0, 0]\n")))}Eh.isMDXComponent=!0;const Ah={toc:[]};function Sh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the nth row of the matrix. Only defined for 0 and 1."))}Sh.isMDXComponent=!0;const zh={toc:[]};function Rh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index of the row to retrieve."))}Rh.isMDXComponent=!0;const Ih={toc:[]};function Wh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ih,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If ",(0,c.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a vector, the x and y component vectors of the\nmatrix will be scaled by the x and y parts of the vector, respectively."),(0,c.kt)("p",null,"If ",(0,c.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, the x and y component vectors will be\nscaled uniformly by this factor."),(0,c.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Wh.isMDXComponent=!0;const Ph={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ph,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.scale([2, 3]);\n// => new Matrix2D(\n//      [2, 4],\n//      [9, 12],\n//      [5, 6],\n//    )\n\nconst result2 = matrix.scale(2);\n// => new Matrix2D(\n//      [2, 4],\n//      [6, 8],\n//      [5, 6],\n//    )\n")))}Gh.isMDXComponent=!0;const Fh={toc:[]};function Uh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Scale the x and y component vectors of the matrix."))}Uh.isMDXComponent=!0;const jh={toc:[]};function Bh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The factor by which to scale the matrix"))}Bh.isMDXComponent=!0;const Vh={toc:[]};function Oh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}Oh.isMDXComponent=!0;const qh={toc:[]};function Hh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\nconst a = new Matrix2D(\n  [7, 8],\n  [9, 10],\n  [11, 12],\n);\n\nconst result = a.sub(b);\n// => Matrix2D(\n//      [-6, -6],\n//      [-6, -6],\n//      [-6, -6],\n//    )\n")))}Hh.isMDXComponent=!0;const $h={toc:[]};function Yh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Subtract the provided matrix from this matrix."))}Yh.isMDXComponent=!0;const Jh={toc:[]};function Kh(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The matrix to subract"))}Kh.isMDXComponent=!0;const Qh={toc:[]};function ty(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qh,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If ",(0,c.kt)("inlineCode",{parentName:"p"},"vec")," is provided as a scalar, matrix will be translated uniformly\nby this factor."),(0,c.kt)("p",null,"This method returns a new matrix representing the result of the\ncomputation. It will not modify the source matrix."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const matrix = new Matrix2D(\n  [1, 2],\n  [3, 4],\n  [5, 6],\n);\n\nconst result1 = matrix.translate([2, 3]);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [16, 22],\n//    )\n\nconst result2 = matrix.translate(2);\n// => new Matrix2D(\n//      [1, 2],\n//      [3, 4],\n//      [13, 18],\n//    )\n")))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Translate the matrix by the dimensions of the provided vector."))}py.isMDXComponent=!0;const ry={toc:[]};function cy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ry,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The vector by which to translate the matrix"))}cy.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a two-dimensional vector."))}ay.isMDXComponent=!0;const iy={toc:[]};function ly(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The unclipped RGB components."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}hy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}ky.isMDXComponent=!0;const fy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}wy.isMDXComponent=!0;const My={toc:[]};function Dy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},My,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}Dy.isMDXComponent=!0;const _y={toc:[]};function Xy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_y,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}Xy.isMDXComponent=!0;const gy={toc:[]};function xy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}xy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ty,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}Cy.isMDXComponent=!0;const vy={toc:[]};function Ly(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Alias of ",(0,c.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Ly.isMDXComponent=!0;const by={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},by,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Zy.isMDXComponent=!0;const Ny={toc:[]};function Ey(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Ey.isMDXComponent=!0;const Ay={toc:[]};function Sy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ay,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}Sy.isMDXComponent=!0;const zy={toc:[]};function Ry(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,c.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,c.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Ry.isMDXComponent=!0;const Iy={toc:[]};function Wy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Wy.isMDXComponent=!0;const Py={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,c.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,c.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,c.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Gy.isMDXComponent=!0;const Fy={toc:[]};function Uy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}Uy.isMDXComponent=!0;const jy={toc:[]};function By(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("strong",{parentName:"p"},"L"),", ",(0,c.kt)("strong",{parentName:"p"},"a"),", and ",(0,c.kt)("strong",{parentName:"p"},"b")," components."))}By.isMDXComponent=!0;const Vy={toc:[]};function Oy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}Oy.isMDXComponent=!0;const qy={toc:[]};function Hy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the ",(0,c.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,c.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,c.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}Hy.isMDXComponent=!0;const $y={toc:[]};function Yy(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$y,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}Yy.isMDXComponent=!0;const Jy={toc:[]};function Ky(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}Ky.isMDXComponent=!0;const Qy={toc:[]};function tk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qy,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get and set the color opacity."))}pk.isMDXComponent=!0;const rk={toc:[]};function ck(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,c.kt)("code",null,"'rgb'")))}ck.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Similar to saturate, but the opposite direction."))}ak.isMDXComponent=!0;const ik={toc:[]};function lk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"set"))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns a single channel value.\nAlso"))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}hk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color as hexadecimal string."))}kk.isMDXComponent=!0;const fk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,c.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,c.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}wk.isMDXComponent=!0;const Mk={toc:[]};function Dk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,c.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}Dk.isMDXComponent=!0;const _k={toc:[]};function Xk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_k,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}Xk.isMDXComponent=!0;const gk={toc:[]};function xk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}xk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}Ck.isMDXComponent=!0;const vk={toc:[]};function Lk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Lk.isMDXComponent=!0;const bk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Zk.isMDXComponent=!0;const Nk={toc:[]};function Ek(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}Ek.isMDXComponent=!0;const Ak={toc:[]};function Sk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ak,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}Sk.isMDXComponent=!0;const zk={toc:[]};function Rk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Rk.isMDXComponent=!0;const Ik={toc:[]};function Wk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ik,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Wk.isMDXComponent=!0;const Pk={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Gk.isMDXComponent=!0;const Fk={toc:[]};function Uk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Uk.isMDXComponent=!0;const jk={toc:[]};function Bk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The origin to convert."))}Bk.isMDXComponent=!0;const Vk={toc:[]};function Ok(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"General utilities and helper functions."))}Ok.isMDXComponent=!0;const qk={toc:[]};function Hk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,(0,c.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}Hk.isMDXComponent=!0;const $k={toc:[]};function Yk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$k,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Optional override for formatting stack traces"))}Yk.isMDXComponent=!0;const Jk={toc:[]};function Kk(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create .stack property on a target object"))}Kk.isMDXComponent=!0;const Qk={toc:[]};function tf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qk,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is a shortcut for calling ",(0,c.kt)("inlineCode",{parentName:"p"},"useLogger().debug()")," which allows\nyou to more easily log non-string values as well."))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  debug(circle().position());\n});\n")))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Logs a debug message with an arbitrary payload."))}pf.isMDXComponent=!0;const rf={toc:[]};function cf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The payload to log"))}cf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Mark the given function as deprecated."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function to deprecate."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The log message."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The optional log remarks."))}yf.isMDXComponent=!0;const kf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Usually used together with transitions. When a scene is marked as finished,\nthe transition will start but the scene generator will continue running."))}ff.isMDXComponent=!0;const wf={toc:[]};function Mf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Mark the current scene as ready to transition out."))}Mf.isMDXComponent=!0;const Df={toc:[]};function _f(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Df,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}_f.isMDXComponent=!0;const Xf={toc:[]};function gf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an array containing a range of numbers."))}gf.isMDXComponent=!0;const xf={toc:[]};function Tf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The length of the array."))}Tf.isMDXComponent=!0;const Cf={toc:[]};function vf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}vf.isMDXComponent=!0;const Lf={toc:[]};function bf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an array containing a range of numbers."))}bf.isMDXComponent=!0;const Zf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The start of the range."))}Nf.isMDXComponent=!0;const Ef={toc:[]};function Af(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ef,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The end of the range. ",(0,c.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Af.isMDXComponent=!0;const Sf={toc:[]};function zf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}zf.isMDXComponent=!0;const Rf={toc:[]};function If(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function that will be provided the context before render."))}If.isMDXComponent=!0;const Wf={toc:[]};function Pf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}Pf.isMDXComponent=!0;const Gf={toc:[]};function Ff(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The function that will be provided the context after render."))}Ff.isMDXComponent=!0;const Uf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This can be used to better specify when an animation should start\nas well as how long this animation should take"))}jf.isMDXComponent=!0;const Bf={toc:[]};function Vf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"export default makeScene2D(function* (view) {\n  const circle = createRef<Circle>();\n\n  view.add(\n    <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n  );\n\n  yield* circle().scale(2, useDuration('circleGrow'));\n});\n")))}Vf.isMDXComponent=!0;const Of={toc:[]};function qf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Of,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The duration of the event in seconds."))}qf.isMDXComponent=!0;const Hf={toc:[]};function $f(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Register a time event and get its duration in seconds."))}$f.isMDXComponent=!0;const Yf={toc:[]};function Jf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The name of the event."))}Jf.isMDXComponent=!0;const Kf={toc:[]};function Qf(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kf,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current project."))}Qf.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the random number generator for the current scene."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the random number generator for the given seed."))}ow.isMDXComponent=!0;const pw={toc:[]};function rw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The seed for the generator."))}rw.isMDXComponent=!0;const cw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}sw.isMDXComponent=!0;const aw={toc:[]};function iw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current scene."))}iw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a reference to the current thread."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,c.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,c.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}yw.isMDXComponent=!0;const kw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the real time since the start of the animation."))}fw.isMDXComponent=!0;const ww={toc:[]};function Mw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}Mw.isMDXComponent=!0;const Dw={toc:[]};function _w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}_w.isMDXComponent=!0;const Xw={toc:[]};function gw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}gw.isMDXComponent=!0;const xw={toc:[]};function Tw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}Tw.isMDXComponent=!0;const Cw={toc:[]};function vw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}vw.isMDXComponent=!0;const Lw={toc:[]};function bw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}bw.isMDXComponent=!0;const Zw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}Nw.isMDXComponent=!0;const Ew={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ew,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}Aw.isMDXComponent=!0;const Sw={toc:[]};function zw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}zw.isMDXComponent=!0;const Rw={toc:[]};function Iw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}Iw.isMDXComponent=!0;const Ww={toc:[]};function Pw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ww,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}Pw.isMDXComponent=!0;const Gw={toc:[]};function Fw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}Fw.isMDXComponent=!0;const Uw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}jw.isMDXComponent=!0;const Bw={toc:[]};function Vw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}Vw.isMDXComponent=!0;const Ow={toc:[]};function qw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ow,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qw.isMDXComponent=!0;const Hw={toc:[]};function $w(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}$w.isMDXComponent=!0;const Yw={toc:[]};function Jw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}Jw.isMDXComponent=!0;const Kw={toc:[]};function Qw(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kw,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}Qw.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}oM.isMDXComponent=!0;const pM={toc:[]};function rM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}rM.isMDXComponent=!0;const cM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sM.isMDXComponent=!0;const aM={toc:[]};function iM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}iM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yM.isMDXComponent=!0;const kM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}fM.isMDXComponent=!0;const wM={toc:[]};function MM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}MM.isMDXComponent=!0;const DM={toc:[]};function _M(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}_M.isMDXComponent=!0;const XM={toc:[]};function gM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}gM.isMDXComponent=!0;const xM={toc:[]};function TM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}TM.isMDXComponent=!0;const CM={toc:[]};function vM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}vM.isMDXComponent=!0;const LM={toc:[]};function bM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}bM.isMDXComponent=!0;const ZM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}NM.isMDXComponent=!0;const EM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}AM.isMDXComponent=!0;const SM={toc:[]};function zM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}zM.isMDXComponent=!0;const RM={toc:[]};function IM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}IM.isMDXComponent=!0;const WM={toc:[]};function PM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}PM.isMDXComponent=!0;const GM={toc:[]};function FM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}FM.isMDXComponent=!0;const UM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}jM.isMDXComponent=!0;const BM={toc:[]};function VM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}VM.isMDXComponent=!0;const OM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}qM.isMDXComponent=!0;const HM={toc:[]};function $M(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}$M.isMDXComponent=!0;const YM={toc:[]};function JM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}JM.isMDXComponent=!0;const KM={toc:[]};function QM(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KM,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}QM.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}oD.isMDXComponent=!0;const pD={toc:[]};function rD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}rD.isMDXComponent=!0;const cD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}sD.isMDXComponent=!0;const aD={toc:[]};function iD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}iD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}yD.isMDXComponent=!0;const kD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}fD.isMDXComponent=!0;const wD={toc:[]};function MD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}MD.isMDXComponent=!0;const DD={toc:[]};function _D(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}_D.isMDXComponent=!0;const XD={toc:[]};function gD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}gD.isMDXComponent=!0;const xD={toc:[]};function TD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}TD.isMDXComponent=!0;const CD={toc:[]};function vD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}vD.isMDXComponent=!0;const LD={toc:[]};function bD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}bD.isMDXComponent=!0;const ZD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}ND.isMDXComponent=!0;const ED={toc:[]};function AD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ED,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}AD.isMDXComponent=!0;const SD={toc:[]};function zD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}zD.isMDXComponent=!0;const RD={toc:[]};function ID(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}ID.isMDXComponent=!0;const WD={toc:[]};function PD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}PD.isMDXComponent=!0;const GD={toc:[]};function FD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}FD.isMDXComponent=!0;const UD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}jD.isMDXComponent=!0;const BD={toc:[]};function VD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}VD.isMDXComponent=!0;const OD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qD.isMDXComponent=!0;const HD={toc:[]};function $D(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}$D.isMDXComponent=!0;const YD={toc:[]};function JD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}JD.isMDXComponent=!0;const KD={toc:[]};function QD(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KD,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}QD.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}o_.isMDXComponent=!0;const p_={toc:[]};function r_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}r_.isMDXComponent=!0;const c_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}s_.isMDXComponent=!0;const a_={toc:[]};function i_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}i_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}y_.isMDXComponent=!0;const k_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}f_.isMDXComponent=!0;const w_={toc:[]};function M_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}M_.isMDXComponent=!0;const D_={toc:[]};function __(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}__.isMDXComponent=!0;const X_={toc:[]};function g_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}g_.isMDXComponent=!0;const x_={toc:[]};function T_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}T_.isMDXComponent=!0;const C_={toc:[]};function v_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}v_.isMDXComponent=!0;const L_={toc:[]};function b_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}b_.isMDXComponent=!0;const Z_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}N_.isMDXComponent=!0;const E_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}A_.isMDXComponent=!0;const S_={toc:[]};function z_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}z_.isMDXComponent=!0;const R_={toc:[]};function I_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}I_.isMDXComponent=!0;const W_={toc:[]};function P_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}P_.isMDXComponent=!0;const G_={toc:[]};function F_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}F_.isMDXComponent=!0;const U_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}j_.isMDXComponent=!0;const B_={toc:[]};function V_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}V_.isMDXComponent=!0;const O_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}q_.isMDXComponent=!0;const H_={toc:[]};function $_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}$_.isMDXComponent=!0;const Y_={toc:[]};function J_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}J_.isMDXComponent=!0;const K_={toc:[]};function Q_(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K_,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Q_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oX.isMDXComponent=!0;const pX={toc:[]};function rX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}rX.isMDXComponent=!0;const cX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}sX.isMDXComponent=!0;const aX={toc:[]};function iX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}iX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yX.isMDXComponent=!0;const kX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}fX.isMDXComponent=!0;const wX={toc:[]};function MX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}MX.isMDXComponent=!0;const DX={toc:[]};function _X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}_X.isMDXComponent=!0;const XX={toc:[]};function gX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}gX.isMDXComponent=!0;const xX={toc:[]};function TX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}TX.isMDXComponent=!0;const CX={toc:[]};function vX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}vX.isMDXComponent=!0;const LX={toc:[]};function bX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}bX.isMDXComponent=!0;const ZX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}NX.isMDXComponent=!0;const EX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}AX.isMDXComponent=!0;const SX={toc:[]};function zX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}zX.isMDXComponent=!0;const RX={toc:[]};function IX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}IX.isMDXComponent=!0;const WX={toc:[]};function PX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}PX.isMDXComponent=!0;const GX={toc:[]};function FX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}FX.isMDXComponent=!0;const UX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}jX.isMDXComponent=!0;const BX={toc:[]};function VX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}VX.isMDXComponent=!0;const OX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qX.isMDXComponent=!0;const HX={toc:[]};function $X(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}$X.isMDXComponent=!0;const YX={toc:[]};function JX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}JX.isMDXComponent=!0;const KX={toc:[]};function QX(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KX,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}QX.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}og.isMDXComponent=!0;const pg={toc:[]};function rg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}rg.isMDXComponent=!0;const cg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sg.isMDXComponent=!0;const ag={toc:[]};function ig(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}ig.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yg.isMDXComponent=!0;const kg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}fg.isMDXComponent=!0;const wg={toc:[]};function Mg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Mg.isMDXComponent=!0;const Dg={toc:[]};function _g(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}_g.isMDXComponent=!0;const Xg={toc:[]};function gg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}gg.isMDXComponent=!0;const xg={toc:[]};function Tg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}Tg.isMDXComponent=!0;const Cg={toc:[]};function vg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}vg.isMDXComponent=!0;const Lg={toc:[]};function bg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}bg.isMDXComponent=!0;const Zg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Ng.isMDXComponent=!0;const Eg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Ag.isMDXComponent=!0;const Sg={toc:[]};function zg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}zg.isMDXComponent=!0;const Rg={toc:[]};function Ig(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Ig.isMDXComponent=!0;const Wg={toc:[]};function Pg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}Pg.isMDXComponent=!0;const Gg={toc:[]};function Fg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Fg.isMDXComponent=!0;const Ug={toc:[]};function jg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ug,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}jg.isMDXComponent=!0;const Bg={toc:[]};function Vg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Vg.isMDXComponent=!0;const Og={toc:[]};function qg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Og,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}qg.isMDXComponent=!0;const Hg={toc:[]};function $g(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}$g.isMDXComponent=!0;const Yg={toc:[]};function Jg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}Jg.isMDXComponent=!0;const Kg={toc:[]};function Qg(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kg,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Qg.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}ox.isMDXComponent=!0;const px={toc:[]};function rx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}rx.isMDXComponent=!0;const cx={toc:[]};function sx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}sx.isMDXComponent=!0;const ax={toc:[]};function ix(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}ix.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}yx.isMDXComponent=!0;const kx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}fx.isMDXComponent=!0;const wx={toc:[]};function Mx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}Mx.isMDXComponent=!0;const Dx={toc:[]};function _x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}_x.isMDXComponent=!0;const Xx={toc:[]};function gx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}gx.isMDXComponent=!0;const xx={toc:[]};function Tx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}Tx.isMDXComponent=!0;const Cx={toc:[]};function vx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}vx.isMDXComponent=!0;const Lx={toc:[]};function bx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}bx.isMDXComponent=!0;const Zx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Nx.isMDXComponent=!0;const Ex={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ex,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}Ax.isMDXComponent=!0;const Sx={toc:[]};function zx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}zx.isMDXComponent=!0;const Rx={toc:[]};function Ix(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Ix.isMDXComponent=!0;const Wx={toc:[]};function Px(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}Px.isMDXComponent=!0;const Gx={toc:[]};function Fx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}Fx.isMDXComponent=!0;const Ux={toc:[]};function jx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ux,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}jx.isMDXComponent=!0;const Bx={toc:[]};function Vx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Vx.isMDXComponent=!0;const Ox={toc:[]};function qx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ox,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}qx.isMDXComponent=!0;const Hx={toc:[]};function $x(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}$x.isMDXComponent=!0;const Yx={toc:[]};function Jx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Jx.isMDXComponent=!0;const Kx={toc:[]};function Qx(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kx,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}Qx.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}oT.isMDXComponent=!0;const pT={toc:[]};function rT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}rT.isMDXComponent=!0;const cT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}sT.isMDXComponent=!0;const aT={toc:[]};function iT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}iT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}yT.isMDXComponent=!0;const kT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}fT.isMDXComponent=!0;const wT={toc:[]};function MT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}MT.isMDXComponent=!0;const DT={toc:[]};function _T(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}_T.isMDXComponent=!0;const XT={toc:[]};function gT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}gT.isMDXComponent=!0;const xT={toc:[]};function TT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}TT.isMDXComponent=!0;const CT={toc:[]};function vT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}vT.isMDXComponent=!0;const LT={toc:[]};function bT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}bT.isMDXComponent=!0;const ZT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}NT.isMDXComponent=!0;const ET={toc:[]};function AT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ET,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}AT.isMDXComponent=!0;const ST={toc:[]};function zT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ST,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}zT.isMDXComponent=!0;const RT={toc:[]};function IT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}IT.isMDXComponent=!0;const WT={toc:[]};function PT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}PT.isMDXComponent=!0;const GT={toc:[]};function FT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}FT.isMDXComponent=!0;const UT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}jT.isMDXComponent=!0;const BT={toc:[]};function VT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}VT.isMDXComponent=!0;const OT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}qT.isMDXComponent=!0;const HT={toc:[]};function $T(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}$T.isMDXComponent=!0;const YT={toc:[]};function JT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}JT.isMDXComponent=!0;const KT={toc:[]};function QT(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KT,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}QT.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oC.isMDXComponent=!0;const pC={toc:[]};function rC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}rC.isMDXComponent=!0;const cC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}sC.isMDXComponent=!0;const aC={toc:[]};function iC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}iC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}yC.isMDXComponent=!0;const kC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}fC.isMDXComponent=!0;const wC={toc:[]};function MC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}MC.isMDXComponent=!0;const DC={toc:[]};function _C(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}_C.isMDXComponent=!0;const XC={toc:[]};function gC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}gC.isMDXComponent=!0;const xC={toc:[]};function TC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}TC.isMDXComponent=!0;const CC={toc:[]};function vC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}vC.isMDXComponent=!0;const LC={toc:[]};function bC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}bC.isMDXComponent=!0;const ZC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}NC.isMDXComponent=!0;const EC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}AC.isMDXComponent=!0;const SC={toc:[]};function zC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}zC.isMDXComponent=!0;const RC={toc:[]};function IC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}IC.isMDXComponent=!0;const WC={toc:[]};function PC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}PC.isMDXComponent=!0;const GC={toc:[]};function FC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}FC.isMDXComponent=!0;const UC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}jC.isMDXComponent=!0;const BC={toc:[]};function VC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}VC.isMDXComponent=!0;const OC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}qC.isMDXComponent=!0;const HC={toc:[]};function $C(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}$C.isMDXComponent=!0;const YC={toc:[]};function JC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}JC.isMDXComponent=!0;const KC={toc:[]};function QC(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KC,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}QC.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}ov.isMDXComponent=!0;const pv={toc:[]};function rv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}rv.isMDXComponent=!0;const cv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sv.isMDXComponent=!0;const av={toc:[]};function iv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}iv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yv.isMDXComponent=!0;const kv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}fv.isMDXComponent=!0;const wv={toc:[]};function Mv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}Mv.isMDXComponent=!0;const Dv={toc:[]};function _v(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}_v.isMDXComponent=!0;const Xv={toc:[]};function gv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}gv.isMDXComponent=!0;const xv={toc:[]};function Tv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}Tv.isMDXComponent=!0;const Cv={toc:[]};function vv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}vv.isMDXComponent=!0;const Lv={toc:[]};function bv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}bv.isMDXComponent=!0;const Zv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Nv.isMDXComponent=!0;const Ev={toc:[]};function Av(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ev,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Av.isMDXComponent=!0;const Sv={toc:[]};function zv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}zv.isMDXComponent=!0;const Rv={toc:[]};function Iv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Iv.isMDXComponent=!0;const Wv={toc:[]};function Pv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}Pv.isMDXComponent=!0;const Gv={toc:[]};function Fv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Fv.isMDXComponent=!0;const Uv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}jv.isMDXComponent=!0;const Bv={toc:[]};function Vv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Vv.isMDXComponent=!0;const Ov={toc:[]};function qv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ov,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}qv.isMDXComponent=!0;const Hv={toc:[]};function $v(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given position."))}$v.isMDXComponent=!0;const Yv={toc:[]};function Jv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The position in local space at which to sample the color."))}Jv.isMDXComponent=!0;const Kv={toc:[]};function Qv(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kv,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given pixel."))}Qv.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The pixel's position."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}oL.isMDXComponent=!0;const pL={toc:[]};function rL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}rL.isMDXComponent=!0;const cL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}sL.isMDXComponent=!0;const aL={toc:[]};function iL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}iL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}yL.isMDXComponent=!0;const kL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}fL.isMDXComponent=!0;const wL={toc:[]};function ML(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ML.isMDXComponent=!0;const DL={toc:[]};function _L(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}_L.isMDXComponent=!0;const XL={toc:[]};function gL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}gL.isMDXComponent=!0;const xL={toc:[]};function TL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}TL.isMDXComponent=!0;const CL={toc:[]};function vL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}vL.isMDXComponent=!0;const LL={toc:[]};function bL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}bL.isMDXComponent=!0;const ZL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}NL.isMDXComponent=!0;const EL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}AL.isMDXComponent=!0;const SL={toc:[]};function zL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}zL.isMDXComponent=!0;const RL={toc:[]};function IL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}IL.isMDXComponent=!0;const WL={toc:[]};function PL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}PL.isMDXComponent=!0;const GL={toc:[]};function FL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}FL.isMDXComponent=!0;const UL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}jL.isMDXComponent=!0;const BL={toc:[]};function VL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}VL.isMDXComponent=!0;const OL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}qL.isMDXComponent=!0;const HL={toc:[]};function $L(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}$L.isMDXComponent=!0;const YL={toc:[]};function JL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}JL.isMDXComponent=!0;const KL={toc:[]};function QL(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KL,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}QL.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}ob.isMDXComponent=!0;const pb={toc:[]};function rb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}rb.isMDXComponent=!0;const cb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}sb.isMDXComponent=!0;const ab={toc:[]};function ib(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}ib.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}yb.isMDXComponent=!0;const kb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}fb.isMDXComponent=!0;const wb={toc:[]};function Mb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Mb.isMDXComponent=!0;const Db={toc:[]};function _b(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Db,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}_b.isMDXComponent=!0;const Xb={toc:[]};function gb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}gb.isMDXComponent=!0;const xb={toc:[]};function Tb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}Tb.isMDXComponent=!0;const Cb={toc:[]};function vb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}vb.isMDXComponent=!0;const Lb={toc:[]};function bb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}bb.isMDXComponent=!0;const Zb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Nb.isMDXComponent=!0;const Eb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}Ab.isMDXComponent=!0;const Sb={toc:[]};function zb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}zb.isMDXComponent=!0;const Rb={toc:[]};function Ib(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}Ib.isMDXComponent=!0;const Wb={toc:[]};function Pb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Pb.isMDXComponent=!0;const Gb={toc:[]};function Fb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}Fb.isMDXComponent=!0;const Ub={toc:[]};function jb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ub,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}jb.isMDXComponent=!0;const Bb={toc:[]};function Vb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}Vb.isMDXComponent=!0;const Ob={toc:[]};function qb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ob,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qb.isMDXComponent=!0;const Hb={toc:[]};function $b(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}$b.isMDXComponent=!0;const Yb={toc:[]};function Jb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}Jb.isMDXComponent=!0;const Kb={toc:[]};function Qb(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kb,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Qb.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function rZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}rZ.isMDXComponent=!0;const cZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function iZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}iZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}yZ.isMDXComponent=!0;const kZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}fZ.isMDXComponent=!0;const wZ={toc:[]};function MZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}MZ.isMDXComponent=!0;const DZ={toc:[]};function _Z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}_Z.isMDXComponent=!0;const XZ={toc:[]};function gZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}gZ.isMDXComponent=!0;const xZ={toc:[]};function TZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}TZ.isMDXComponent=!0;const CZ={toc:[]};function vZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}vZ.isMDXComponent=!0;const LZ={toc:[]};function bZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}bZ.isMDXComponent=!0;const ZZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}NZ.isMDXComponent=!0;const EZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}AZ.isMDXComponent=!0;const SZ={toc:[]};function zZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}zZ.isMDXComponent=!0;const RZ={toc:[]};function IZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}IZ.isMDXComponent=!0;const WZ={toc:[]};function PZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}PZ.isMDXComponent=!0;const GZ={toc:[]};function FZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}FZ.isMDXComponent=!0;const UZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}jZ.isMDXComponent=!0;const BZ={toc:[]};function VZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}VZ.isMDXComponent=!0;const OZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}qZ.isMDXComponent=!0;const HZ={toc:[]};function $Z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}$Z.isMDXComponent=!0;const YZ={toc:[]};function JZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}JZ.isMDXComponent=!0;const KZ={toc:[]};function QZ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KZ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}QZ.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}oN.isMDXComponent=!0;const pN={toc:[]};function rN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}rN.isMDXComponent=!0;const cN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}sN.isMDXComponent=!0;const aN={toc:[]};function iN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}iN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}yN.isMDXComponent=!0;const kN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}fN.isMDXComponent=!0;const wN={toc:[]};function MN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}MN.isMDXComponent=!0;const DN={toc:[]};function _N(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}_N.isMDXComponent=!0;const XN={toc:[]};function gN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}gN.isMDXComponent=!0;const xN={toc:[]};function TN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}TN.isMDXComponent=!0;const CN={toc:[]};function vN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}vN.isMDXComponent=!0;const LN={toc:[]};function bN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}bN.isMDXComponent=!0;const ZN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}NN.isMDXComponent=!0;const EN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}AN.isMDXComponent=!0;const SN={toc:[]};function zN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}zN.isMDXComponent=!0;const RN={toc:[]};function IN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}IN.isMDXComponent=!0;const WN={toc:[]};function PN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}PN.isMDXComponent=!0;const GN={toc:[]};function FN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}FN.isMDXComponent=!0;const UN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}jN.isMDXComponent=!0;const BN={toc:[]};function VN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}VN.isMDXComponent=!0;const ON={toc:[]};function qN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ON,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}qN.isMDXComponent=!0;const HN={toc:[]};function $N(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}$N.isMDXComponent=!0;const YN={toc:[]};function JN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}JN.isMDXComponent=!0;const KN={toc:[]};function QN(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KN,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}QN.isMDXComponent=!0;const tE={toc:[]};function nE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}nE.isMDXComponent=!0;const eE={toc:[]};function oE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given position."))}oE.isMDXComponent=!0;const pE={toc:[]};function rE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The position in local space at which to sample the color."))}rE.isMDXComponent=!0;const cE={toc:[]};function sE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get color of the image at the given pixel."))}sE.isMDXComponent=!0;const aE={toc:[]};function iE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The pixel's position."))}iE.isMDXComponent=!0;const lE={toc:[]};function uE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}dE.isMDXComponent=!0;const hE={toc:[]};function yE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}yE.isMDXComponent=!0;const kE={toc:[]};function fE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}fE.isMDXComponent=!0;const wE={toc:[]};function ME(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}ME.isMDXComponent=!0;const DE={toc:[]};function _E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}_E.isMDXComponent=!0;const XE={toc:[]};function gE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}gE.isMDXComponent=!0;const xE={toc:[]};function TE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}TE.isMDXComponent=!0;const CE={toc:[]};function vE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}vE.isMDXComponent=!0;const LE={toc:[]};function bE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}bE.isMDXComponent=!0;const ZE={toc:[]};function NE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NE.isMDXComponent=!0;const EE={toc:[]};function AE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}AE.isMDXComponent=!0;const SE={toc:[]};function zE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}zE.isMDXComponent=!0;const RE={toc:[]};function IE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IE.isMDXComponent=!0;const WE={toc:[]};function PE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}PE.isMDXComponent=!0;const GE={toc:[]};function FE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}FE.isMDXComponent=!0;const UE={toc:[]};function jE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}jE.isMDXComponent=!0;const BE={toc:[]};function VE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}VE.isMDXComponent=!0;const OE={toc:[]};function qE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}qE.isMDXComponent=!0;const HE={toc:[]};function $E(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$E.isMDXComponent=!0;const YE={toc:[]};function JE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}JE.isMDXComponent=!0;const KE={toc:[]};function QE(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KE,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}QE.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}oA.isMDXComponent=!0;const pA={toc:[]};function rA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}rA.isMDXComponent=!0;const cA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}sA.isMDXComponent=!0;const aA={toc:[]};function iA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}iA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}yA.isMDXComponent=!0;const kA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}fA.isMDXComponent=!0;const wA={toc:[]};function MA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}MA.isMDXComponent=!0;const DA={toc:[]};function _A(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}_A.isMDXComponent=!0;const XA={toc:[]};function gA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gA.isMDXComponent=!0;const xA={toc:[]};function TA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}TA.isMDXComponent=!0;const CA={toc:[]};function vA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vA.isMDXComponent=!0;const LA={toc:[]};function bA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}bA.isMDXComponent=!0;const ZA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NA.isMDXComponent=!0;const EA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}AA.isMDXComponent=!0;const SA={toc:[]};function zA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zA.isMDXComponent=!0;const RA={toc:[]};function IA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}IA.isMDXComponent=!0;const WA={toc:[]};function PA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}PA.isMDXComponent=!0;const GA={toc:[]};function FA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}FA.isMDXComponent=!0;const UA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}jA.isMDXComponent=!0;const BA={toc:[]};function VA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}VA.isMDXComponent=!0;const OA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}qA.isMDXComponent=!0;const HA={toc:[]};function $A(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$A.isMDXComponent=!0;const YA={toc:[]};function JA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}JA.isMDXComponent=!0;const KA={toc:[]};function QA(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KA,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}QA.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oS.isMDXComponent=!0;const pS={toc:[]};function rS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}rS.isMDXComponent=!0;const cS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sS.isMDXComponent=!0;const aS={toc:[]};function iS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Latex#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}yS.isMDXComponent=!0;const kS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}fS.isMDXComponent=!0;const wS={toc:[]};function MS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}MS.isMDXComponent=!0;const DS={toc:[]};function _S(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_S.isMDXComponent=!0;const XS={toc:[]};function gS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}gS.isMDXComponent=!0;const xS={toc:[]};function TS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}TS.isMDXComponent=!0;const CS={toc:[]};function vS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vS.isMDXComponent=!0;const LS={toc:[]};function bS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}bS.isMDXComponent=!0;const ZS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NS.isMDXComponent=!0;const ES={toc:[]};function AS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ES,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}AS.isMDXComponent=!0;const SS={toc:[]};function zS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}zS.isMDXComponent=!0;const RS={toc:[]};function IS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}IS.isMDXComponent=!0;const WS={toc:[]};function PS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PS.isMDXComponent=!0;const GS={toc:[]};function FS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}FS.isMDXComponent=!0;const US={toc:[]};function jS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},US,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}jS.isMDXComponent=!0;const BS={toc:[]};function VS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}VS.isMDXComponent=!0;const OS={toc:[]};function qS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qS.isMDXComponent=!0;const HS={toc:[]};function $S(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}$S.isMDXComponent=!0;const YS={toc:[]};function JS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}JS.isMDXComponent=!0;const KS={toc:[]};function QS(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KS,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}QS.isMDXComponent=!0;const tz={toc:[]};function nz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nz.isMDXComponent=!0;const ez={toc:[]};function oz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ez,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oz.isMDXComponent=!0;const pz={toc:[]};function rz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}rz.isMDXComponent=!0;const cz={toc:[]};function sz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}sz.isMDXComponent=!0;const az={toc:[]};function iz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},az,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}iz.isMDXComponent=!0;const lz={toc:[]};function uz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}uz.isMDXComponent=!0;const mz={toc:[]};function dz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}dz.isMDXComponent=!0;const hz={toc:[]};function yz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yz.isMDXComponent=!0;const kz={toc:[]};function fz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}fz.isMDXComponent=!0;const wz={toc:[]};function Mz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}Mz.isMDXComponent=!0;const Dz={toc:[]};function _z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}_z.isMDXComponent=!0;const Xz={toc:[]};function gz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gz.isMDXComponent=!0;const xz={toc:[]};function Tz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Tz.isMDXComponent=!0;const Cz={toc:[]};function vz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}vz.isMDXComponent=!0;const Lz={toc:[]};function bz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}bz.isMDXComponent=!0;const Zz={toc:[]};function Nz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Nz.isMDXComponent=!0;const Ez={toc:[]};function Az(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ez,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}Az.isMDXComponent=!0;const Sz={toc:[]};function zz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}zz.isMDXComponent=!0;const Rz={toc:[]};function Iz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}Iz.isMDXComponent=!0;const Wz={toc:[]};function Pz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Pz.isMDXComponent=!0;const Gz={toc:[]};function Fz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}Fz.isMDXComponent=!0;const Uz={toc:[]};function jz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}jz.isMDXComponent=!0;const Bz={toc:[]};function Vz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}Vz.isMDXComponent=!0;const Oz={toc:[]};function qz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}qz.isMDXComponent=!0;const Hz={toc:[]};function $z(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$z.isMDXComponent=!0;const Yz={toc:[]};function Jz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}Jz.isMDXComponent=!0;const Kz={toc:[]};function Qz(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kz,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Qz.isMDXComponent=!0;const tR={toc:[]};function nR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}nR.isMDXComponent=!0;const eR={toc:[]};function oR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}oR.isMDXComponent=!0;const pR={toc:[]};function rR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}rR.isMDXComponent=!0;const cR={toc:[]};function sR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}sR.isMDXComponent=!0;const aR={toc:[]};function iR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}iR.isMDXComponent=!0;const lR={toc:[]};function uR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}uR.isMDXComponent=!0;const mR={toc:[]};function dR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}dR.isMDXComponent=!0;const hR={toc:[]};function yR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}yR.isMDXComponent=!0;const kR={toc:[]};function fR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}fR.isMDXComponent=!0;const wR={toc:[]};function MR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}MR.isMDXComponent=!0;const DR={toc:[]};function _R(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}_R.isMDXComponent=!0;const XR={toc:[]};function gR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}gR.isMDXComponent=!0;const xR={toc:[]};function TR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}TR.isMDXComponent=!0;const CR={toc:[]};function vR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}vR.isMDXComponent=!0;const LR={toc:[]};function bR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}bR.isMDXComponent=!0;const ZR={toc:[]};function NR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NR.isMDXComponent=!0;const ER={toc:[]};function AR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ER,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}AR.isMDXComponent=!0;const SR={toc:[]};function zR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}zR.isMDXComponent=!0;const RR={toc:[]};function IR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IR.isMDXComponent=!0;const WR={toc:[]};function PR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}PR.isMDXComponent=!0;const GR={toc:[]};function FR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}FR.isMDXComponent=!0;const UR={toc:[]};function jR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}jR.isMDXComponent=!0;const BR={toc:[]};function VR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}VR.isMDXComponent=!0;const OR={toc:[]};function qR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}qR.isMDXComponent=!0;const HR={toc:[]};function $R(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$R.isMDXComponent=!0;const YR={toc:[]};function JR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}JR.isMDXComponent=!0;const KR={toc:[]};function QR(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KR,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}QR.isMDXComponent=!0;const tI={toc:[]};function nI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nI.isMDXComponent=!0;const eI={toc:[]};function oI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}oI.isMDXComponent=!0;const pI={toc:[]};function rI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}rI.isMDXComponent=!0;const cI={toc:[]};function sI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}sI.isMDXComponent=!0;const aI={toc:[]};function iI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}iI.isMDXComponent=!0;const lI={toc:[]};function uI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}uI.isMDXComponent=!0;const mI={toc:[]};function dI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dI.isMDXComponent=!0;const hI={toc:[]};function yI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}yI.isMDXComponent=!0;const kI={toc:[]};function fI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}fI.isMDXComponent=!0;const wI={toc:[]};function MI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}MI.isMDXComponent=!0;const DI={toc:[]};function _I(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}_I.isMDXComponent=!0;const XI={toc:[]};function gI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gI.isMDXComponent=!0;const xI={toc:[]};function TI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}TI.isMDXComponent=!0;const CI={toc:[]};function vI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vI.isMDXComponent=!0;const LI={toc:[]};function bI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}bI.isMDXComponent=!0;const ZI={toc:[]};function NI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NI.isMDXComponent=!0;const EI={toc:[]};function AI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}AI.isMDXComponent=!0;const SI={toc:[]};function zI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zI.isMDXComponent=!0;const RI={toc:[]};function II(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}II.isMDXComponent=!0;const WI={toc:[]};function PI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}PI.isMDXComponent=!0;const GI={toc:[]};function FI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}FI.isMDXComponent=!0;const UI={toc:[]};function jI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}jI.isMDXComponent=!0;const BI={toc:[]};function VI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}VI.isMDXComponent=!0;const OI={toc:[]};function qI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}qI.isMDXComponent=!0;const HI={toc:[]};function $I(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$I.isMDXComponent=!0;const YI={toc:[]};function JI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}JI.isMDXComponent=!0;const KI={toc:[]};function QI(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KI,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}QI.isMDXComponent=!0;const tW={toc:[]};function nW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}nW.isMDXComponent=!0;const eW={toc:[]};function oW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oW.isMDXComponent=!0;const pW={toc:[]};function rW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}rW.isMDXComponent=!0;const cW={toc:[]};function sW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sW.isMDXComponent=!0;const aW={toc:[]};function iW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iW.isMDXComponent=!0;const lW={toc:[]};function uW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}uW.isMDXComponent=!0;const mW={toc:[]};function dW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dW.isMDXComponent=!0;const hW={toc:[]};function yW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}yW.isMDXComponent=!0;const kW={toc:[]};function fW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}fW.isMDXComponent=!0;const wW={toc:[]};function MW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}MW.isMDXComponent=!0;const DW={toc:[]};function _W(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_W.isMDXComponent=!0;const XW={toc:[]};function gW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}gW.isMDXComponent=!0;const xW={toc:[]};function TW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}TW.isMDXComponent=!0;const CW={toc:[]};function vW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vW.isMDXComponent=!0;const LW={toc:[]};function bW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}bW.isMDXComponent=!0;const ZW={toc:[]};function NW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NW.isMDXComponent=!0;const EW={toc:[]};function AW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}AW.isMDXComponent=!0;const SW={toc:[]};function zW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}zW.isMDXComponent=!0;const RW={toc:[]};function IW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}IW.isMDXComponent=!0;const WW={toc:[]};function PW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PW.isMDXComponent=!0;const GW={toc:[]};function FW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}FW.isMDXComponent=!0;const UW={toc:[]};function jW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}jW.isMDXComponent=!0;const BW={toc:[]};function VW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}VW.isMDXComponent=!0;const OW={toc:[]};function qW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}qW.isMDXComponent=!0;const HW={toc:[]};function $W(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}$W.isMDXComponent=!0;const YW={toc:[]};function JW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}JW.isMDXComponent=!0;const KW={toc:[]};function QW(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KW,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}QW.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}oP.isMDXComponent=!0;const pP={toc:[]};function rP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}rP.isMDXComponent=!0;const cP={toc:[]};function sP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}sP.isMDXComponent=!0;const aP={toc:[]};function iP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}iP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}dP.isMDXComponent=!0;const hP={toc:[]};function yP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}yP.isMDXComponent=!0;const kP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}fP.isMDXComponent=!0;const wP={toc:[]};function MP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}MP.isMDXComponent=!0;const DP={toc:[]};function _P(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}_P.isMDXComponent=!0;const XP={toc:[]};function gP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gP.isMDXComponent=!0;const xP={toc:[]};function TP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}TP.isMDXComponent=!0;const CP={toc:[]};function vP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}vP.isMDXComponent=!0;const LP={toc:[]};function bP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}bP.isMDXComponent=!0;const ZP={toc:[]};function NP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}NP.isMDXComponent=!0;const EP={toc:[]};function AP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}AP.isMDXComponent=!0;const SP={toc:[]};function zP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}zP.isMDXComponent=!0;const RP={toc:[]};function IP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}IP.isMDXComponent=!0;const WP={toc:[]};function PP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}PP.isMDXComponent=!0;const GP={toc:[]};function FP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}FP.isMDXComponent=!0;const UP={toc:[]};function jP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}jP.isMDXComponent=!0;const BP={toc:[]};function VP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}VP.isMDXComponent=!0;const OP={toc:[]};function qP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}qP.isMDXComponent=!0;const HP={toc:[]};function $P(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$P.isMDXComponent=!0;const YP={toc:[]};function JP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}JP.isMDXComponent=!0;const KP={toc:[]};function QP(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KP,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}QP.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}oG.isMDXComponent=!0;const pG={toc:[]};function rG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}rG.isMDXComponent=!0;const cG={toc:[]};function sG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}sG.isMDXComponent=!0;const aG={toc:[]};function iG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}iG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}dG.isMDXComponent=!0;const hG={toc:[]};function yG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}yG.isMDXComponent=!0;const kG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}fG.isMDXComponent=!0;const wG={toc:[]};function MG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}MG.isMDXComponent=!0;const DG={toc:[]};function _G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}_G.isMDXComponent=!0;const XG={toc:[]};function gG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}gG.isMDXComponent=!0;const xG={toc:[]};function TG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}TG.isMDXComponent=!0;const CG={toc:[]};function vG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}vG.isMDXComponent=!0;const LG={toc:[]};function bG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}bG.isMDXComponent=!0;const ZG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}NG.isMDXComponent=!0;const EG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}AG.isMDXComponent=!0;const SG={toc:[]};function zG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}zG.isMDXComponent=!0;const RG={toc:[]};function IG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}IG.isMDXComponent=!0;const WG={toc:[]};function PG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}PG.isMDXComponent=!0;const GG={toc:[]};function FG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}FG.isMDXComponent=!0;const UG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}jG.isMDXComponent=!0;const BG={toc:[]};function VG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}VG.isMDXComponent=!0;const OG={toc:[]};function qG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}qG.isMDXComponent=!0;const HG={toc:[]};function $G(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}$G.isMDXComponent=!0;const YG={toc:[]};function JG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}JG.isMDXComponent=!0;const KG={toc:[]};function QG(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KG,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}QG.isMDXComponent=!0;const tF={toc:[]};function nF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}nF.isMDXComponent=!0;const eF={toc:[]};function oF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}oF.isMDXComponent=!0;const pF={toc:[]};function rF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}rF.isMDXComponent=!0;const cF={toc:[]};function sF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}sF.isMDXComponent=!0;const aF={toc:[]};function iF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}iF.isMDXComponent=!0;const lF={toc:[]};function uF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}uF.isMDXComponent=!0;const mF={toc:[]};function dF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}dF.isMDXComponent=!0;const hF={toc:[]};function yF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}yF.isMDXComponent=!0;const kF={toc:[]};function fF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}fF.isMDXComponent=!0;const wF={toc:[]};function MF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}MF.isMDXComponent=!0;const DF={toc:[]};function _F(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}_F.isMDXComponent=!0;const XF={toc:[]};function gF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}gF.isMDXComponent=!0;const xF={toc:[]};function TF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}TF.isMDXComponent=!0;const CF={toc:[]};function vF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}vF.isMDXComponent=!0;const LF={toc:[]};function bF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}bF.isMDXComponent=!0;const ZF={toc:[]};function NF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}NF.isMDXComponent=!0;const EF={toc:[]};function AF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}AF.isMDXComponent=!0;const SF={toc:[]};function zF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zF.isMDXComponent=!0;const RF={toc:[]};function IF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}IF.isMDXComponent=!0;const WF={toc:[]};function PF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}PF.isMDXComponent=!0;const GF={toc:[]};function FF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}FF.isMDXComponent=!0;const UF={toc:[]};function jF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}jF.isMDXComponent=!0;const BF={toc:[]};function VF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}VF.isMDXComponent=!0;const OF={toc:[]};function qF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}qF.isMDXComponent=!0;const HF={toc:[]};function $F(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}$F.isMDXComponent=!0;const YF={toc:[]};function JF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}JF.isMDXComponent=!0;const KF={toc:[]};function QF(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KF,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}QF.isMDXComponent=!0;const tU={toc:[]};function nU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}nU.isMDXComponent=!0;const eU={toc:[]};function oU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}oU.isMDXComponent=!0;const pU={toc:[]};function rU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}rU.isMDXComponent=!0;const cU={toc:[]};function sU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}sU.isMDXComponent=!0;const aU={toc:[]};function iU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}iU.isMDXComponent=!0;const lU={toc:[]};function uU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}uU.isMDXComponent=!0;const mU={toc:[]};function dU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}dU.isMDXComponent=!0;const hU={toc:[]};function yU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}yU.isMDXComponent=!0;const kU={toc:[]};function fU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}fU.isMDXComponent=!0;const wU={toc:[]};function MU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}MU.isMDXComponent=!0;const DU={toc:[]};function _U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}_U.isMDXComponent=!0;const XU={toc:[]};function gU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}gU.isMDXComponent=!0;const xU={toc:[]};function TU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}TU.isMDXComponent=!0;const CU={toc:[]};function vU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}vU.isMDXComponent=!0;const LU={toc:[]};function bU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}bU.isMDXComponent=!0;const ZU={toc:[]};function NU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}NU.isMDXComponent=!0;const EU={toc:[]};function AU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}AU.isMDXComponent=!0;const SU={toc:[]};function zU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}zU.isMDXComponent=!0;const RU={toc:[]};function IU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}IU.isMDXComponent=!0;const WU={toc:[]};function PU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}PU.isMDXComponent=!0;const GU={toc:[]};function FU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}FU.isMDXComponent=!0;const UU={toc:[]};function jU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}jU.isMDXComponent=!0;const BU={toc:[]};function VU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}VU.isMDXComponent=!0;const OU={toc:[]};function qU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}qU.isMDXComponent=!0;const HU={toc:[]};function $U(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}$U.isMDXComponent=!0;const YU={toc:[]};function JU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}JU.isMDXComponent=!0;const KU={toc:[]};function QU(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KU,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}QU.isMDXComponent=!0;const tj={toc:[]};function nj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}nj.isMDXComponent=!0;const ej={toc:[]};function oj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ej,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}oj.isMDXComponent=!0;const pj={toc:[]};function rj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}rj.isMDXComponent=!0;const cj={toc:[]};function sj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}sj.isMDXComponent=!0;const aj={toc:[]};function ij(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}ij.isMDXComponent=!0;const lj={toc:[]};function uj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}uj.isMDXComponent=!0;const mj={toc:[]};function dj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dj.isMDXComponent=!0;const hj={toc:[]};function yj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}yj.isMDXComponent=!0;const kj={toc:[]};function fj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}fj.isMDXComponent=!0;const wj={toc:[]};function Mj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mj.isMDXComponent=!0;const Dj={toc:[]};function _j(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}_j.isMDXComponent=!0;const Xj={toc:[]};function gj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}gj.isMDXComponent=!0;const xj={toc:[]};function Tj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}Tj.isMDXComponent=!0;const Cj={toc:[]};function vj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}vj.isMDXComponent=!0;const Lj={toc:[]};function bj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bj.isMDXComponent=!0;const Zj={toc:[]};function Nj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}Nj.isMDXComponent=!0;const Ej={toc:[]};function Aj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ej,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Aj.isMDXComponent=!0;const Sj={toc:[]};function zj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}zj.isMDXComponent=!0;const Rj={toc:[]};function Ij(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}Ij.isMDXComponent=!0;const Wj={toc:[]};function Pj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Pj.isMDXComponent=!0;const Gj={toc:[]};function Fj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}Fj.isMDXComponent=!0;const Uj={toc:[]};function jj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}jj.isMDXComponent=!0;const Bj={toc:[]};function Vj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Vj.isMDXComponent=!0;const Oj={toc:[]};function qj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}qj.isMDXComponent=!0;const Hj={toc:[]};function $j(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}$j.isMDXComponent=!0;const Yj={toc:[]};function Jj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}Jj.isMDXComponent=!0;const Kj={toc:[]};function Qj(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kj,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}Qj.isMDXComponent=!0;const tB={toc:[]};function nB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}nB.isMDXComponent=!0;const eB={toc:[]};function oB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}oB.isMDXComponent=!0;const pB={toc:[]};function rB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}rB.isMDXComponent=!0;const cB={toc:[]};function sB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}sB.isMDXComponent=!0;const aB={toc:[]};function iB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}iB.isMDXComponent=!0;const lB={toc:[]};function uB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}uB.isMDXComponent=!0;const mB={toc:[]};function dB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}dB.isMDXComponent=!0;const hB={toc:[]};function yB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}yB.isMDXComponent=!0;const kB={toc:[]};function fB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}fB.isMDXComponent=!0;const wB={toc:[]};function MB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}MB.isMDXComponent=!0;const DB={toc:[]};function _B(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}_B.isMDXComponent=!0;const XB={toc:[]};function gB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}gB.isMDXComponent=!0;const xB={toc:[]};function TB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}TB.isMDXComponent=!0;const CB={toc:[]};function vB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}vB.isMDXComponent=!0;const LB={toc:[]};function bB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}bB.isMDXComponent=!0;const ZB={toc:[]};function NB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}NB.isMDXComponent=!0;const EB={toc:[]};function AB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}AB.isMDXComponent=!0;const SB={toc:[]};function zB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}zB.isMDXComponent=!0;const RB={toc:[]};function IB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}IB.isMDXComponent=!0;const WB={toc:[]};function PB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}PB.isMDXComponent=!0;const GB={toc:[]};function FB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}FB.isMDXComponent=!0;const UB={toc:[]};function jB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}jB.isMDXComponent=!0;const BB={toc:[]};function VB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}VB.isMDXComponent=!0;const OB={toc:[]};function qB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}qB.isMDXComponent=!0;const HB={toc:[]};function $B(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}$B.isMDXComponent=!0;const YB={toc:[]};function JB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}JB.isMDXComponent=!0;const KB={toc:[]};function QB(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KB,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}QB.isMDXComponent=!0;const tV={toc:[]};function nV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}nV.isMDXComponent=!0;const eV={toc:[]};function oV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}oV.isMDXComponent=!0;const pV={toc:[]};function rV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}rV.isMDXComponent=!0;const cV={toc:[]};function sV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}sV.isMDXComponent=!0;const aV={toc:[]};function iV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}iV.isMDXComponent=!0;const lV={toc:[]};function uV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}uV.isMDXComponent=!0;const mV={toc:[]};function dV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dV.isMDXComponent=!0;const hV={toc:[]};function yV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}yV.isMDXComponent=!0;const kV={toc:[]};function fV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}fV.isMDXComponent=!0;const wV={toc:[]};function MV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}MV.isMDXComponent=!0;const DV={toc:[]};function _V(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}_V.isMDXComponent=!0;const XV={toc:[]};function gV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}gV.isMDXComponent=!0;const xV={toc:[]};function TV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}TV.isMDXComponent=!0;const CV={toc:[]};function vV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}vV.isMDXComponent=!0;const LV={toc:[]};function bV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}bV.isMDXComponent=!0;const ZV={toc:[]};function NV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}NV.isMDXComponent=!0;const EV={toc:[]};function AV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}AV.isMDXComponent=!0;const SV={toc:[]};function zV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zV.isMDXComponent=!0;const RV={toc:[]};function IV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}IV.isMDXComponent=!0;const WV={toc:[]};function PV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}PV.isMDXComponent=!0;const GV={toc:[]};function FV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}FV.isMDXComponent=!0;const UV={toc:[]};function jV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}jV.isMDXComponent=!0;const BV={toc:[]};function VV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}VV.isMDXComponent=!0;const OV={toc:[]};function qV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}qV.isMDXComponent=!0;const HV={toc:[]};function $V(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}$V.isMDXComponent=!0;const YV={toc:[]};function JV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}JV.isMDXComponent=!0;const KV={toc:[]};function QV(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KV,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}QV.isMDXComponent=!0;const tO={toc:[]};function nO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}nO.isMDXComponent=!0;const eO={toc:[]};function oO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oO.isMDXComponent=!0;const pO={toc:[]};function rO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}rO.isMDXComponent=!0;const cO={toc:[]};function sO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}sO.isMDXComponent=!0;const aO={toc:[]};function iO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}iO.isMDXComponent=!0;const lO={toc:[]};function uO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}uO.isMDXComponent=!0;const mO={toc:[]};function dO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dO.isMDXComponent=!0;const hO={toc:[]};function yO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}yO.isMDXComponent=!0;const kO={toc:[]};function fO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}fO.isMDXComponent=!0;const wO={toc:[]};function MO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}MO.isMDXComponent=!0;const DO={toc:[]};function _O(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}_O.isMDXComponent=!0;const XO={toc:[]};function gO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gO.isMDXComponent=!0;const xO={toc:[]};function TO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}TO.isMDXComponent=!0;const CO={toc:[]};function vO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vO.isMDXComponent=!0;const LO={toc:[]};function bO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}bO.isMDXComponent=!0;const ZO={toc:[]};function NO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NO.isMDXComponent=!0;const EO={toc:[]};function AO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}AO.isMDXComponent=!0;const SO={toc:[]};function zO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}zO.isMDXComponent=!0;const RO={toc:[]};function IO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}IO.isMDXComponent=!0;const WO={toc:[]};function PO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}PO.isMDXComponent=!0;const GO={toc:[]};function FO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FO.isMDXComponent=!0;const UO={toc:[]};function jO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}jO.isMDXComponent=!0;const BO={toc:[]};function VO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}VO.isMDXComponent=!0;const OO={toc:[]};function qO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}qO.isMDXComponent=!0;const HO={toc:[]};function $O(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$O.isMDXComponent=!0;const YO={toc:[]};function JO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}JO.isMDXComponent=!0;const KO={toc:[]};function QO(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KO,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}QO.isMDXComponent=!0;const tq={toc:[]};function nq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}nq.isMDXComponent=!0;const eq={toc:[]};function oq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}oq.isMDXComponent=!0;const pq={toc:[]};function rq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}rq.isMDXComponent=!0;const cq={toc:[]};function sq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}sq.isMDXComponent=!0;const aq={toc:[]};function iq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}iq.isMDXComponent=!0;const lq={toc:[]};function uq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}uq.isMDXComponent=!0;const mq={toc:[]};function dq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}dq.isMDXComponent=!0;const hq={toc:[]};function yq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yq.isMDXComponent=!0;const kq={toc:[]};function fq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}fq.isMDXComponent=!0;const wq={toc:[]};function Mq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Mq.isMDXComponent=!0;const Dq={toc:[]};function _q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_q.isMDXComponent=!0;const Xq={toc:[]};function gq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}gq.isMDXComponent=!0;const xq={toc:[]};function Tq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Tq.isMDXComponent=!0;const Cq={toc:[]};function vq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}vq.isMDXComponent=!0;const Lq={toc:[]};function bq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}bq.isMDXComponent=!0;const Zq={toc:[]};function Nq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Zq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Nq.isMDXComponent=!0;const Eq={toc:[]};function Aq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Eq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}Aq.isMDXComponent=!0;const Sq={toc:[]};function zq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Sq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}zq.isMDXComponent=!0;const Rq={toc:[]};function Iq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}Iq.isMDXComponent=!0;const Wq={toc:[]};function Pq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}Pq.isMDXComponent=!0;const Gq={toc:[]};function Fq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}Fq.isMDXComponent=!0;const Uq={toc:[]};function jq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Uq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}jq.isMDXComponent=!0;const Bq={toc:[]};function Vq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}Vq.isMDXComponent=!0;const Oq={toc:[]};function qq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Oq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}qq.isMDXComponent=!0;const Hq={toc:[]};function $q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}$q.isMDXComponent=!0;const Yq={toc:[]};function Jq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Yq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}Jq.isMDXComponent=!0;const Kq={toc:[]};function Qq(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Kq,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Qq.isMDXComponent=!0;const tH={toc:[]};function nH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}nH.isMDXComponent=!0;const eH={toc:[]};function oH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oH.isMDXComponent=!0;const pH={toc:[]};function rH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}rH.isMDXComponent=!0;const cH={toc:[]};function sH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sH.isMDXComponent=!0;const aH={toc:[]};function iH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iH.isMDXComponent=!0;const lH={toc:[]};function uH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}uH.isMDXComponent=!0;const mH={toc:[]};function dH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dH.isMDXComponent=!0;const hH={toc:[]};function yH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}yH.isMDXComponent=!0;const kH={toc:[]};function fH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}fH.isMDXComponent=!0;const wH={toc:[]};function MH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MH.isMDXComponent=!0;const DH={toc:[]};function _H(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_H.isMDXComponent=!0;const XH={toc:[]};function gH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}gH.isMDXComponent=!0;const xH={toc:[]};function TH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}TH.isMDXComponent=!0;const CH={toc:[]};function vH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vH.isMDXComponent=!0;const LH={toc:[]};function bH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}bH.isMDXComponent=!0;const ZH={toc:[]};function NH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}NH.isMDXComponent=!0;const EH={toc:[]};function AH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}AH.isMDXComponent=!0;const SH={toc:[]};function zH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}zH.isMDXComponent=!0;const RH={toc:[]};function IH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}IH.isMDXComponent=!0;const WH={toc:[]};function PH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}PH.isMDXComponent=!0;const GH={toc:[]};function FH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}FH.isMDXComponent=!0;const UH={toc:[]};function jH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}jH.isMDXComponent=!0;const BH={toc:[]};function VH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}VH.isMDXComponent=!0;const OH={toc:[]};function qH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}qH.isMDXComponent=!0;const HH={toc:[]};function $H(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$H.isMDXComponent=!0;const YH={toc:[]};function JH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}JH.isMDXComponent=!0;const KH={toc:[]};function QH(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KH,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}QH.isMDXComponent=!0;const t$={toc:[]};function n$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}n$.isMDXComponent=!0;const e$={toc:[]};function o$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}o$.isMDXComponent=!0;const p$={toc:[]};function r$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}r$.isMDXComponent=!0;const c$={toc:[]};function s$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}s$.isMDXComponent=!0;const a$={toc:[]};function i$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}i$.isMDXComponent=!0;const l$={toc:[]};function u$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}u$.isMDXComponent=!0;const m$={toc:[]};function d$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}d$.isMDXComponent=!0;const h$={toc:[]};function y$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}y$.isMDXComponent=!0;const k$={toc:[]};function f$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}f$.isMDXComponent=!0;const w$={toc:[]};function M$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}M$.isMDXComponent=!0;const D$={toc:[]};function _$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_$.isMDXComponent=!0;const X$={toc:[]};function g$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}g$.isMDXComponent=!0;const x$={toc:[]};function T$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}T$.isMDXComponent=!0;const C$={toc:[]};function v$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}v$.isMDXComponent=!0;const L$={toc:[]};function b$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}b$.isMDXComponent=!0;const Z$={toc:[]};function N$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}N$.isMDXComponent=!0;const E$={toc:[]};function A$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}A$.isMDXComponent=!0;const S$={toc:[]};function z$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}z$.isMDXComponent=!0;const R$={toc:[]};function I$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}I$.isMDXComponent=!0;const W$={toc:[]};function P$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}P$.isMDXComponent=!0;const G$={toc:[]};function F$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}F$.isMDXComponent=!0;const U$={toc:[]};function j$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}j$.isMDXComponent=!0;const B$={toc:[]};function V$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}V$.isMDXComponent=!0;const O$={toc:[]};function q$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}q$.isMDXComponent=!0;const H$={toc:[]};function $$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}$$.isMDXComponent=!0;const Y$={toc:[]};function J$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}J$.isMDXComponent=!0;const K$={toc:[]};function Q$(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K$,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Q$.isMDXComponent=!0;const tY={toc:[]};function nY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}nY.isMDXComponent=!0;const eY={toc:[]};function oY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oY.isMDXComponent=!0;const pY={toc:[]};function rY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}rY.isMDXComponent=!0;const cY={toc:[]};function sY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}sY.isMDXComponent=!0;const aY={toc:[]};function iY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}iY.isMDXComponent=!0;const lY={toc:[]};function uY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}uY.isMDXComponent=!0;const mY={toc:[]};function dY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}dY.isMDXComponent=!0;const hY={toc:[]};function yY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}yY.isMDXComponent=!0;const kY={toc:[]};function fY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}fY.isMDXComponent=!0;const wY={toc:[]};function MY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}MY.isMDXComponent=!0;const DY={toc:[]};function _Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}_Y.isMDXComponent=!0;const XY={toc:[]};function gY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}gY.isMDXComponent=!0;const xY={toc:[]};function TY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}TY.isMDXComponent=!0;const CY={toc:[]};function vY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}vY.isMDXComponent=!0;const LY={toc:[]};function bY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}bY.isMDXComponent=!0;const ZY={toc:[]};function NY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}NY.isMDXComponent=!0;const EY={toc:[]};function AY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}AY.isMDXComponent=!0;const SY={toc:[]};function zY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}zY.isMDXComponent=!0;const RY={toc:[]};function IY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}IY.isMDXComponent=!0;const WY={toc:[]};function PY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}PY.isMDXComponent=!0;const GY={toc:[]};function FY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}FY.isMDXComponent=!0;const UY={toc:[]};function jY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}jY.isMDXComponent=!0;const BY={toc:[]};function VY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}VY.isMDXComponent=!0;const OY={toc:[]};function qY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}qY.isMDXComponent=!0;const HY={toc:[]};function $Y(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$Y.isMDXComponent=!0;const YY={toc:[]};function JY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}JY.isMDXComponent=!0;const KY={toc:[]};function QY(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KY,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}QY.isMDXComponent=!0;const tJ={toc:[]};function nJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}nJ.isMDXComponent=!0;const eJ={toc:[]};function oJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}oJ.isMDXComponent=!0;const pJ={toc:[]};function rJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}rJ.isMDXComponent=!0;const cJ={toc:[]};function sJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}sJ.isMDXComponent=!0;const aJ={toc:[]};function iJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}iJ.isMDXComponent=!0;const lJ={toc:[]};function uJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}uJ.isMDXComponent=!0;const mJ={toc:[]};function dJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}dJ.isMDXComponent=!0;const hJ={toc:[]};function yJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yJ.isMDXComponent=!0;const kJ={toc:[]};function fJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}fJ.isMDXComponent=!0;const wJ={toc:[]};function MJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}MJ.isMDXComponent=!0;const DJ={toc:[]};function _J(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_J.isMDXComponent=!0;const XJ={toc:[]};function gJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}gJ.isMDXComponent=!0;const xJ={toc:[]};function TJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}TJ.isMDXComponent=!0;const CJ={toc:[]};function vJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}vJ.isMDXComponent=!0;const LJ={toc:[]};function bJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}bJ.isMDXComponent=!0;const ZJ={toc:[]};function NJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}NJ.isMDXComponent=!0;const EJ={toc:[]};function AJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}AJ.isMDXComponent=!0;const SJ={toc:[]};function zJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}zJ.isMDXComponent=!0;const RJ={toc:[]};function IJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}IJ.isMDXComponent=!0;const WJ={toc:[]};function PJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}PJ.isMDXComponent=!0;const GJ={toc:[]};function FJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}FJ.isMDXComponent=!0;const UJ={toc:[]};function jJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}jJ.isMDXComponent=!0;const BJ={toc:[]};function VJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}VJ.isMDXComponent=!0;const OJ={toc:[]};function qJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}qJ.isMDXComponent=!0;const HJ={toc:[]};function $J(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}$J.isMDXComponent=!0;const YJ={toc:[]};function JJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}JJ.isMDXComponent=!0;const KJ={toc:[]};function QJ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KJ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}QJ.isMDXComponent=!0;const tK={toc:[]};function nK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}nK.isMDXComponent=!0;const eK={toc:[]};function oK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}oK.isMDXComponent=!0;const pK={toc:[]};function rK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}rK.isMDXComponent=!0;const cK={toc:[]};function sK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}sK.isMDXComponent=!0;const aK={toc:[]};function iK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}iK.isMDXComponent=!0;const lK={toc:[]};function uK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}uK.isMDXComponent=!0;const mK={toc:[]};function dK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dK.isMDXComponent=!0;const hK={toc:[]};function yK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}yK.isMDXComponent=!0;const kK={toc:[]};function fK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}fK.isMDXComponent=!0;const wK={toc:[]};function MK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}MK.isMDXComponent=!0;const DK={toc:[]};function _K(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_K.isMDXComponent=!0;const XK={toc:[]};function gK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}gK.isMDXComponent=!0;const xK={toc:[]};function TK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}TK.isMDXComponent=!0;const CK={toc:[]};function vK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vK.isMDXComponent=!0;const LK={toc:[]};function bK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}bK.isMDXComponent=!0;const ZK={toc:[]};function NK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}NK.isMDXComponent=!0;const EK={toc:[]};function AK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}AK.isMDXComponent=!0;const SK={toc:[]};function zK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}zK.isMDXComponent=!0;const RK={toc:[]};function IK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}IK.isMDXComponent=!0;const WK={toc:[]};function PK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}PK.isMDXComponent=!0;const GK={toc:[]};function FK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}FK.isMDXComponent=!0;const UK={toc:[]};function jK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}jK.isMDXComponent=!0;const BK={toc:[]};function VK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}VK.isMDXComponent=!0;const OK={toc:[]};function qK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}qK.isMDXComponent=!0;const HK={toc:[]};function $K(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$K.isMDXComponent=!0;const YK={toc:[]};function JK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}JK.isMDXComponent=!0;const KK={toc:[]};function QK(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KK,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}QK.isMDXComponent=!0;const tQ={toc:[]};function nQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}nQ.isMDXComponent=!0;const eQ={toc:[]};function oQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}oQ.isMDXComponent=!0;const pQ={toc:[]};function rQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}rQ.isMDXComponent=!0;const cQ={toc:[]};function sQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}sQ.isMDXComponent=!0;const aQ={toc:[]};function iQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}iQ.isMDXComponent=!0;const lQ={toc:[]};function uQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}uQ.isMDXComponent=!0;const mQ={toc:[]};function dQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}dQ.isMDXComponent=!0;const hQ={toc:[]};function yQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}yQ.isMDXComponent=!0;const kQ={toc:[]};function fQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},kQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}fQ.isMDXComponent=!0;const wQ={toc:[]};function MQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}MQ.isMDXComponent=!0;const DQ={toc:[]};function _Q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},DQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_Q.isMDXComponent=!0;const XQ={toc:[]};function gQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},XQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gQ.isMDXComponent=!0;const xQ={toc:[]};function TQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}TQ.isMDXComponent=!0;const CQ={toc:[]};function vQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},CQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vQ.isMDXComponent=!0;const LQ={toc:[]};function bQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},LQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bQ.isMDXComponent=!0;const ZQ={toc:[]};function NQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ZQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}NQ.isMDXComponent=!0;const EQ={toc:[]};function AQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},EQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}AQ.isMDXComponent=!0;const SQ={toc:[]};function zQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},SQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}zQ.isMDXComponent=!0;const RQ={toc:[]};function IQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},RQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}IQ.isMDXComponent=!0;const WQ={toc:[]};function PQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},WQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PQ.isMDXComponent=!0;const GQ={toc:[]};function FQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},GQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}FQ.isMDXComponent=!0;const UQ={toc:[]};function jQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},UQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}jQ.isMDXComponent=!0;const BQ={toc:[]};function VQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},BQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}VQ.isMDXComponent=!0;const OQ={toc:[]};function qQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},OQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qQ.isMDXComponent=!0;const HQ={toc:[]};function $Q(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},HQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}$Q.isMDXComponent=!0;const YQ={toc:[]};function JQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},YQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}JQ.isMDXComponent=!0;const KQ={toc:[]};function QQ(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},KQ,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}QQ.isMDXComponent=!0;const t0={toc:[]};function n0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}n0.isMDXComponent=!0;const e0={toc:[]};function o0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}o0.isMDXComponent=!0;const p0={toc:[]};function r0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}r0.isMDXComponent=!0;const c0={toc:[]};function s0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}s0.isMDXComponent=!0;const a0={toc:[]};function i0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}i0.isMDXComponent=!0;const l0={toc:[]};function u0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}u0.isMDXComponent=!0;const m0={toc:[]};function d0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}d0.isMDXComponent=!0;const h0={toc:[]};function y0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}y0.isMDXComponent=!0;const k0={toc:[]};function f0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}f0.isMDXComponent=!0;const w0={toc:[]};function M0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}M0.isMDXComponent=!0;const D0={toc:[]};function _0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}_0.isMDXComponent=!0;const X0={toc:[]};function g0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}g0.isMDXComponent=!0;const x0={toc:[]};function T0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}T0.isMDXComponent=!0;const C0={toc:[]};function v0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}v0.isMDXComponent=!0;const L0={toc:[]};function b0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}b0.isMDXComponent=!0;const Z0={toc:[]};function N0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}N0.isMDXComponent=!0;const E0={toc:[]};function A0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}A0.isMDXComponent=!0;const S0={toc:[]};function z0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}z0.isMDXComponent=!0;const R0={toc:[]};function I0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}I0.isMDXComponent=!0;const W0={toc:[]};function P0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}P0.isMDXComponent=!0;const G0={toc:[]};function F0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}F0.isMDXComponent=!0;const U0={toc:[]};function j0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}j0.isMDXComponent=!0;const B0={toc:[]};function V0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}V0.isMDXComponent=!0;const O0={toc:[]};function q0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}q0.isMDXComponent=!0;const H0={toc:[]};function $0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$0.isMDXComponent=!0;const Y0={toc:[]};function J0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}J0.isMDXComponent=!0;const K0={toc:[]};function Q0(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K0,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Q0.isMDXComponent=!0;const t3={toc:[]};function n3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}n3.isMDXComponent=!0;const e3={toc:[]};function o3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}o3.isMDXComponent=!0;const p3={toc:[]};function r3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}r3.isMDXComponent=!0;const c3={toc:[]};function s3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}s3.isMDXComponent=!0;const a3={toc:[]};function i3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}i3.isMDXComponent=!0;const l3={toc:[]};function u3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}u3.isMDXComponent=!0;const m3={toc:[]};function d3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}d3.isMDXComponent=!0;const h3={toc:[]};function y3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}y3.isMDXComponent=!0;const k3={toc:[]};function f3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}f3.isMDXComponent=!0;const w3={toc:[]};function M3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}M3.isMDXComponent=!0;const D3={toc:[]};function _3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_3.isMDXComponent=!0;const X3={toc:[]};function g3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}g3.isMDXComponent=!0;const x3={toc:[]};function T3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}T3.isMDXComponent=!0;const C3={toc:[]};function v3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}v3.isMDXComponent=!0;const L3={toc:[]};function b3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}b3.isMDXComponent=!0;const Z3={toc:[]};function N3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}N3.isMDXComponent=!0;const E3={toc:[]};function A3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}A3.isMDXComponent=!0;const S3={toc:[]};function z3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}z3.isMDXComponent=!0;const R3={toc:[]};function I3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}I3.isMDXComponent=!0;const W3={toc:[]};function P3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}P3.isMDXComponent=!0;const G3={toc:[]};function F3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}F3.isMDXComponent=!0;const U3={toc:[]};function j3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}j3.isMDXComponent=!0;const B3={toc:[]};function V3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}V3.isMDXComponent=!0;const O3={toc:[]};function q3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}q3.isMDXComponent=!0;const H3={toc:[]};function $3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}$3.isMDXComponent=!0;const Y3={toc:[]};function J3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}J3.isMDXComponent=!0;const K3={toc:[]};function Q3(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K3,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Q3.isMDXComponent=!0;const t2={toc:[]};function n2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}n2.isMDXComponent=!0;const e2={toc:[]};function o2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}o2.isMDXComponent=!0;const p2={toc:[]};function r2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}r2.isMDXComponent=!0;const c2={toc:[]};function s2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}s2.isMDXComponent=!0;const a2={toc:[]};function i2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}i2.isMDXComponent=!0;const l2={toc:[]};function u2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}u2.isMDXComponent=!0;const m2={toc:[]};function d2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}d2.isMDXComponent=!0;const h2={toc:[]};function y2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}y2.isMDXComponent=!0;const k2={toc:[]};function f2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}f2.isMDXComponent=!0;const w2={toc:[]};function M2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}M2.isMDXComponent=!0;const D2={toc:[]};function _2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_2.isMDXComponent=!0;const X2={toc:[]};function g2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}g2.isMDXComponent=!0;const x2={toc:[]};function T2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}T2.isMDXComponent=!0;const C2={toc:[]};function v2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}v2.isMDXComponent=!0;const L2={toc:[]};function b2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}b2.isMDXComponent=!0;const Z2={toc:[]};function N2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}N2.isMDXComponent=!0;const E2={toc:[]};function A2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}A2.isMDXComponent=!0;const S2={toc:[]};function z2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}z2.isMDXComponent=!0;const R2={toc:[]};function I2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}I2.isMDXComponent=!0;const W2={toc:[]};function P2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}P2.isMDXComponent=!0;const G2={toc:[]};function F2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}F2.isMDXComponent=!0;const U2={toc:[]};function j2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}j2.isMDXComponent=!0;const B2={toc:[]};function V2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}V2.isMDXComponent=!0;const O2={toc:[]};function q2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}q2.isMDXComponent=!0;const H2={toc:[]};function $2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$2.isMDXComponent=!0;const Y2={toc:[]};function J2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}J2.isMDXComponent=!0;const K2={toc:[]};function Q2(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K2,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Q2.isMDXComponent=!0;const t8={toc:[]};function n8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}n8.isMDXComponent=!0;const e8={toc:[]};function o8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}o8.isMDXComponent=!0;const p8={toc:[]};function r8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}r8.isMDXComponent=!0;const c8={toc:[]};function s8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}s8.isMDXComponent=!0;const a8={toc:[]};function i8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}i8.isMDXComponent=!0;const l8={toc:[]};function u8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}u8.isMDXComponent=!0;const m8={toc:[]};function d8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}d8.isMDXComponent=!0;const h8={toc:[]};function y8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}y8.isMDXComponent=!0;const k8={toc:[]};function f8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}f8.isMDXComponent=!0;const w8={toc:[]};function M8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}M8.isMDXComponent=!0;const D8={toc:[]};function _8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_8.isMDXComponent=!0;const X8={toc:[]};function g8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}g8.isMDXComponent=!0;const x8={toc:[]};function T8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}T8.isMDXComponent=!0;const C8={toc:[]};function v8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}v8.isMDXComponent=!0;const L8={toc:[]};function b8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}b8.isMDXComponent=!0;const Z8={toc:[]};function N8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}N8.isMDXComponent=!0;const E8={toc:[]};function A8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}A8.isMDXComponent=!0;const S8={toc:[]};function z8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}z8.isMDXComponent=!0;const R8={toc:[]};function I8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}I8.isMDXComponent=!0;const W8={toc:[]};function P8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}P8.isMDXComponent=!0;const G8={toc:[]};function F8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}F8.isMDXComponent=!0;const U8={toc:[]};function j8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}j8.isMDXComponent=!0;const B8={toc:[]};function V8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}V8.isMDXComponent=!0;const O8={toc:[]};function q8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}q8.isMDXComponent=!0;const H8={toc:[]};function $8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}$8.isMDXComponent=!0;const Y8={toc:[]};function J8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}J8.isMDXComponent=!0;const K8={toc:[]};function Q8(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K8,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Q8.isMDXComponent=!0;const t1={toc:[]};function n1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}n1.isMDXComponent=!0;const e1={toc:[]};function o1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}o1.isMDXComponent=!0;const p1={toc:[]};function r1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}r1.isMDXComponent=!0;const c1={toc:[]};function s1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}s1.isMDXComponent=!0;const a1={toc:[]};function i1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}i1.isMDXComponent=!0;const l1={toc:[]};function u1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}u1.isMDXComponent=!0;const m1={toc:[]};function d1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}d1.isMDXComponent=!0;const h1={toc:[]};function y1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}y1.isMDXComponent=!0;const k1={toc:[]};function f1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}f1.isMDXComponent=!0;const w1={toc:[]};function M1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}M1.isMDXComponent=!0;const D1={toc:[]};function _1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}_1.isMDXComponent=!0;const X1={toc:[]};function g1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}g1.isMDXComponent=!0;const x1={toc:[]};function T1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}T1.isMDXComponent=!0;const C1={toc:[]};function v1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}v1.isMDXComponent=!0;const L1={toc:[]};function b1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}b1.isMDXComponent=!0;const Z1={toc:[]};function N1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}N1.isMDXComponent=!0;const E1={toc:[]};function A1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}A1.isMDXComponent=!0;const S1={toc:[]};function z1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}z1.isMDXComponent=!0;const R1={toc:[]};function I1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}I1.isMDXComponent=!0;const W1={toc:[]};function P1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}P1.isMDXComponent=!0;const G1={toc:[]};function F1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}F1.isMDXComponent=!0;const U1={toc:[]};function j1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}j1.isMDXComponent=!0;const B1={toc:[]};function V1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}V1.isMDXComponent=!0;const O1={toc:[]};function q1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}q1.isMDXComponent=!0;const H1={toc:[]};function $1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$1.isMDXComponent=!0;const Y1={toc:[]};function J1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}J1.isMDXComponent=!0;const K1={toc:[]};function Q1(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K1,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Q1.isMDXComponent=!0;const t4={toc:[]};function n4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}n4.isMDXComponent=!0;const e4={toc:[]};function o4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}o4.isMDXComponent=!0;const p4={toc:[]};function r4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}r4.isMDXComponent=!0;const c4={toc:[]};function s4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}s4.isMDXComponent=!0;const a4={toc:[]};function i4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}i4.isMDXComponent=!0;const l4={toc:[]};function u4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}u4.isMDXComponent=!0;const m4={toc:[]};function d4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}d4.isMDXComponent=!0;const h4={toc:[]};function y4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}y4.isMDXComponent=!0;const k4={toc:[]};function f4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}f4.isMDXComponent=!0;const w4={toc:[]};function M4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}M4.isMDXComponent=!0;const D4={toc:[]};function _4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_4.isMDXComponent=!0;const X4={toc:[]};function g4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}g4.isMDXComponent=!0;const x4={toc:[]};function T4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}T4.isMDXComponent=!0;const C4={toc:[]};function v4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}v4.isMDXComponent=!0;const L4={toc:[]};function b4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}b4.isMDXComponent=!0;const Z4={toc:[]};function N4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}N4.isMDXComponent=!0;const E4={toc:[]};function A4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}A4.isMDXComponent=!0;const S4={toc:[]};function z4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}z4.isMDXComponent=!0;const R4={toc:[]};function I4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}I4.isMDXComponent=!0;const W4={toc:[]};function P4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}P4.isMDXComponent=!0;const G4={toc:[]};function F4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}F4.isMDXComponent=!0;const U4={toc:[]};function j4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}j4.isMDXComponent=!0;const B4={toc:[]};function V4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}V4.isMDXComponent=!0;const O4={toc:[]};function q4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}q4.isMDXComponent=!0;const H4={toc:[]};function $4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}$4.isMDXComponent=!0;const Y4={toc:[]};function J4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}J4.isMDXComponent=!0;const K4={toc:[]};function Q4(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K4,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Q4.isMDXComponent=!0;const t6={toc:[]};function n6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}n6.isMDXComponent=!0;const e6={toc:[]};function o6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}o6.isMDXComponent=!0;const p6={toc:[]};function r6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}r6.isMDXComponent=!0;const c6={toc:[]};function s6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}s6.isMDXComponent=!0;const a6={toc:[]};function i6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}i6.isMDXComponent=!0;const l6={toc:[]};function u6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}u6.isMDXComponent=!0;const m6={toc:[]};function d6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}d6.isMDXComponent=!0;const h6={toc:[]};function y6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}y6.isMDXComponent=!0;const k6={toc:[]};function f6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}f6.isMDXComponent=!0;const w6={toc:[]};function M6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}M6.isMDXComponent=!0;const D6={toc:[]};function _6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_6.isMDXComponent=!0;const X6={toc:[]};function g6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}g6.isMDXComponent=!0;const x6={toc:[]};function T6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}T6.isMDXComponent=!0;const C6={toc:[]};function v6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}v6.isMDXComponent=!0;const L6={toc:[]};function b6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}b6.isMDXComponent=!0;const Z6={toc:[]};function N6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}N6.isMDXComponent=!0;const E6={toc:[]};function A6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}A6.isMDXComponent=!0;const S6={toc:[]};function z6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}z6.isMDXComponent=!0;const R6={toc:[]};function I6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}I6.isMDXComponent=!0;const W6={toc:[]};function P6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}P6.isMDXComponent=!0;const G6={toc:[]};function F6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}F6.isMDXComponent=!0;const U6={toc:[]};function j6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}j6.isMDXComponent=!0;const B6={toc:[]};function V6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}V6.isMDXComponent=!0;const O6={toc:[]};function q6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}q6.isMDXComponent=!0;const H6={toc:[]};function $6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$6.isMDXComponent=!0;const Y6={toc:[]};function J6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}J6.isMDXComponent=!0;const K6={toc:[]};function Q6(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K6,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Q6.isMDXComponent=!0;const t5={toc:[]};function n5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}n5.isMDXComponent=!0;const e5={toc:[]};function o5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}o5.isMDXComponent=!0;const p5={toc:[]};function r5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}r5.isMDXComponent=!0;const c5={toc:[]};function s5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}s5.isMDXComponent=!0;const a5={toc:[]};function i5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}i5.isMDXComponent=!0;const l5={toc:[]};function u5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}u5.isMDXComponent=!0;const m5={toc:[]};function d5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}d5.isMDXComponent=!0;const h5={toc:[]};function y5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}y5.isMDXComponent=!0;const k5={toc:[]};function f5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}f5.isMDXComponent=!0;const w5={toc:[]};function M5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}M5.isMDXComponent=!0;const D5={toc:[]};function _5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_5.isMDXComponent=!0;const X5={toc:[]};function g5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}g5.isMDXComponent=!0;const x5={toc:[]};function T5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}T5.isMDXComponent=!0;const C5={toc:[]};function v5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}v5.isMDXComponent=!0;const L5={toc:[]};function b5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}b5.isMDXComponent=!0;const Z5={toc:[]};function N5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}N5.isMDXComponent=!0;const E5={toc:[]};function A5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}A5.isMDXComponent=!0;const S5={toc:[]};function z5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}z5.isMDXComponent=!0;const R5={toc:[]};function I5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}I5.isMDXComponent=!0;const W5={toc:[]};function P5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}P5.isMDXComponent=!0;const G5={toc:[]};function F5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}F5.isMDXComponent=!0;const U5={toc:[]};function j5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}j5.isMDXComponent=!0;const B5={toc:[]};function V5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}V5.isMDXComponent=!0;const O5={toc:[]};function q5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}q5.isMDXComponent=!0;const H5={toc:[]};function $5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}$5.isMDXComponent=!0;const Y5={toc:[]};function J5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}J5.isMDXComponent=!0;const K5={toc:[]};function Q5(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K5,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Q5.isMDXComponent=!0;const t7={toc:[]};function n7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}n7.isMDXComponent=!0;const e7={toc:[]};function o7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}o7.isMDXComponent=!0;const p7={toc:[]};function r7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}r7.isMDXComponent=!0;const c7={toc:[]};function s7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the position using this signal returns the position in world\nspace. Similarly, setting the position using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,'If the new value is a function, the position of this node will be\ncontinuously updated to always match the position returned by the function.\nThis can be useful to "pin" the node in a specific place or to make it\nfollow another node\'s position.'),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#position"},(0,c.kt)("inlineCode",{parentName:"a"},"position")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}s7.isMDXComponent=!0;const a7={toc:[]};function i7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the position in world space."))}i7.isMDXComponent=!0;const l7={toc:[]};function u7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the rotation using this signal returns the rotation in world\nspace. Similarly, setting the rotation using this signal transforms the\nnew value to local space."),(0,c.kt)("p",null,"If the new value is a function, the rotation of this node will be\ncontinuously updated to always match the rotation returned by the function."))}u7.isMDXComponent=!0;const m7={toc:[]};function d7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the rotation in world space."))}d7.isMDXComponent=!0;const h7={toc:[]};function y7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Retrieving the scale using this signal returns the scale in world space.\nSimilarly, setting the scale using this signal transforms the new value to\nlocal space."),(0,c.kt)("p",null,"If the new value is a function, the scale of this node will be continuously\nupdated to always match the position returned by the function."),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#scale"},(0,c.kt)("inlineCode",{parentName:"a"},"scale")),", this signal is not compound - it doesn't contain\nseparate signals for the ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"y")," components."))}y7.isMDXComponent=!0;const k7={toc:[]};function f7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A helper signal for operating on the scale in world space."))}f7.isMDXComponent=!0;const w7={toc:[]};function M7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"By default, the origin of a node is located at its center. The origin\nserves as the pivot point when rotating and scaling a node, but it doesn't\naffect the placement of its children."),(0,c.kt)("p",null,"The value is relative to the size of this node. A value of ",(0,c.kt)("inlineCode",{parentName:"p"},"1")," means as far\nto the right/bottom as possible. Here are a few examples of offsets:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, -1]")," - top left corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[1, -1]")," - top right corner"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[0, 1]")," - bottom edge"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"[-1, 1]")," - bottom left corner")))}M7.isMDXComponent=!0;const D7={toc:[]};function _7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the offset of this node's origin."))}_7.isMDXComponent=!0;const X7={toc:[]};function g7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node position={[1, 2]} />\n// with individual components:\n<Node x={1} y={2} />\n")),(0,c.kt)("p",null,"Accessing the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst position = node.position();\n// retrieving an individual component:\nconst x = node.position.x();\n")),(0,c.kt)("p",null,"Setting the position:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.position([1, 2]);\nnode.position(() => [1, 2]);\n// with individual components:\nnode.position.x(1);\nnode.position.x(() => 1);\n")))}g7.isMDXComponent=!0;const x7={toc:[]};function T7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the position of this node in local space of its parent."))}T7.isMDXComponent=!0;const C7={toc:[]};function v7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the rotation (in degrees) of this node relative to its parent."))}v7.isMDXComponent=!0;const L7={toc:[]};function b7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node scale={[1, 2]} />\n// with individual components:\n<Node scaleX={1} scaleY={2} />\n")),(0,c.kt)("p",null,"Accessing the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst scale = node.scale();\n// retrieving an individual component:\nconst scaleX = node.scale.x();\n")),(0,c.kt)("p",null,"Setting the scale:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.scale([1, 2]);\nnode.scale(() => [1, 2]);\n// with individual components:\nnode.scale.x(1);\nnode.scale.x(() => 1);\n")))}b7.isMDXComponent=!0;const Z7={toc:[]};function N7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the scale of this node in local space of its parent."))}N7.isMDXComponent=!0;const E7={toc:[]};function A7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A size is a two-dimensional vector, where ",(0,c.kt)("inlineCode",{parentName:"p"},"x")," represents the ",(0,c.kt)("inlineCode",{parentName:"p"},"width"),", and ",(0,c.kt)("inlineCode",{parentName:"p"},"y"),"\nrepresents the ",(0,c.kt)("inlineCode",{parentName:"p"},"height"),"."),(0,c.kt)("p",null,"The value of both x and y is of type ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/partials#Length"},(0,c.kt)("inlineCode",{parentName:"a"},"Length"))," which is\neither:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'")),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"null")," - an automatic length")),(0,c.kt)("p",null,"When retrieving the size, all units are converted to pixels, using the\ncurrent state of the layout. For example, retrieving the width set to\n",(0,c.kt)("inlineCode",{parentName:"p"},"'50%'"),", while the parent has a width of ",(0,c.kt)("inlineCode",{parentName:"p"},"200px")," will result in the number\n",(0,c.kt)("inlineCode",{parentName:"p"},"100")," being returned."),(0,c.kt)("p",null,"When the node is not part of the layout, setting its size using percents\nrefers to the size of the entire scene."))}A7.isMDXComponent=!0;const S7={toc:[]};function z7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Initializing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\n<Node size={['50%', 200]} />\n// with individual components:\n<Node width={'50%'} height={200} />\n")),(0,c.kt)("p",null,"Accessing the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// retrieving the vector:\nconst size = node.size();\n// retrieving an individual component:\nconst width = node.size.x();\n")),(0,c.kt)("p",null,"Setting the size:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"// with a possible vector:\nnode.size(['50%', 200]);\nnode.size(() => ['50%', 200]);\n// with individual components:\nnode.size.x('50%');\nnode.size.x(() => '50%');\n")))}z7.isMDXComponent=!0;const R7={toc:[]};function I7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents the size of this node."))}I7.isMDXComponent=!0;const W7={toc:[]};function P7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The nodes will be appended at the end of the children list."))}P7.isMDXComponent=!0;const G7={toc:[]};function F7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = <Layout />;\nnode.add(<Rect />);\nnode.add(<Circle />);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3ecircle;"}))}F7.isMDXComponent=!0;const U7={toc:[]};function j7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Add the given node(s) as the children of this node."))}j7.isMDXComponent=!0;const B7={toc:[]};function V7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to append."))}V7.isMDXComponent=!0;const O7={toc:[]};function q7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}q7.isMDXComponent=!0;const H7={toc:[]};function $7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}$7.isMDXComponent=!0;const Y7={toc:[]};function J7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}J7.isMDXComponent=!0;const K7={toc:[]};function Q7(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K7,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}Q7.isMDXComponent=!0;const t9={toc:[]};function n9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},t9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Collect all asynchronous resources used by this node."))}n9.isMDXComponent=!0;const e9={toc:[]};function o9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},e9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}o9.isMDXComponent=!0;const p9={toc:[]};function r9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},p9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A matrix mapping composite space to world space."))}r9.isMDXComponent=!0;const c9={toc:[]};function s9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},c9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to control the size using external factors.\nBy default, the returned size is the same as the one declared by the user."))}s9.isMDXComponent=!0;const a9={toc:[]};function i9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},a9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the desired size of this node."))}i9.isMDXComponent=!0;const l9={toc:[]};function u9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},l9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called automatically when a scene is refreshed. It will\nbe called even if the node is not currently attached to the tree."),(0,c.kt)("p",null,"The goal of this method is to clean any external references to allow the\nnode to be garbage collected."))}u9.isMDXComponent=!0;const m9={toc:[]};function d9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},m9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare this node to be disposed of."))}d9.isMDXComponent=!0;const h9={toc:[]};function y9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},h9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}y9.isMDXComponent=!0;const k9={toc:[]};function f9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},k9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw this node onto the canvas."))}f9.isMDXComponent=!0;const w9={toc:[]};function M9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},w9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}M9.isMDXComponent=!0;const D9={toc:[]};function _9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},D9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,c.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}_9.isMDXComponent=!0;const X9={toc:[]};function g9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},X9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Draw an overlay for this node."))}g9.isMDXComponent=!0;const x9={toc:[]};function T9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},x9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}T9.isMDXComponent=!0;const C9={toc:[]};function v9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},C9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A local-to-screen matrix."))}v9.isMDXComponent=!0;const L9={toc:[]};function b9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},L9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}b9.isMDXComponent=!0;const Z9={toc:[]};function N9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Z9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}N9.isMDXComponent=!0;const E9={toc:[]};function A9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},E9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The returned rectangle should be in local space."))}A9.isMDXComponent=!0;const S9={toc:[]};function z9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},S9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}z9.isMDXComponent=!0;const R9={toc:[]};function I9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},R9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Try to find a node intersecting the given position."))}I9.isMDXComponent=!0;const W9={toc:[]};function P9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},W9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The searched position."))}P9.isMDXComponent=!0;const G9={toc:[]};function F9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},G9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-tsx"},"const node = (\n  <Layout>\n    <Rect />\n    <Circle />\n  </Layout>\n);\n\nnode.insert(<Text />, 1);\n")),(0,c.kt)("p",null,"Result:"),(0,c.kt)("mermaid",{value:"graph TD;\n  layout([Layout])\n  circle([Circle])\n  text([Text])\n  rect([Rect])\n    layout--\x3erect;\n    layout--\x3etext;\n    layout--\x3ecircle;"}))}F9.isMDXComponent=!0;const U9={toc:[]};function j9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},U9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Insert the given node(s) at the specified index in the children list."))}j9.isMDXComponent=!0;const B9={toc:[]};function V9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},B9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A node or an array of nodes to insert."))}V9.isMDXComponent=!0;const O9={toc:[]};function q9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},O9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"An index at which to insert the node(s)."))}q9.isMDXComponent=!0;const H9={toc:[]};function $9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},H9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an instance of this node's class."))}$9.isMDXComponent=!0;const Y9={toc:[]};function J9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Y9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to pass to the constructor."))}J9.isMDXComponent=!0;const K9={toc:[]};function Q9(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},K9,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the mode is ",(0,c.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,c.kt)("p",null,"Use ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,c.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Q9.isMDXComponent=!0;const ttt={toc:[]};function ntt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ttt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the resolved layout mode of this node."))}ntt.isMDXComponent=!0;const ett={toc:[]};function ott(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ett,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to local space\nof this node's parent."))}ott.isMDXComponent=!0;const ptt={toc:[]};function rtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ptt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-parent matrix for this node."))}rtt.isMDXComponent=!0;const ctt={toc:[]};function stt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ctt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from local space of this node to world\nspace."))}stt.isMDXComponent=!0;const att={toc:[]};function itt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},att,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the absolute position of a point located 200 pixels to the right\nof the node:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const local = new Vector2(0, 200);\nconst world = local.transformAsPoint(node.localToWorld());\n")))}itt.isMDXComponent=!0;const ltt={toc:[]};function utt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ltt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the local-to-world matrix for this node."))}utt.isMDXComponent=!0;const mtt={toc:[]};function dtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mtt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Children are rendered starting from the beginning of the children list.\nWe can change the rendering order by rearranging said list."),(0,c.kt)("p",null,"A positive ",(0,c.kt)("inlineCode",{parentName:"p"},"by")," arguments move the node up (it will be rendered on top of\nthe elements it has passed). Negative values move it down."))}dtt.isMDXComponent=!0;const htt={toc:[]};function ytt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},htt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Rearrange this node in relation to its siblings."))}ytt.isMDXComponent=!0;const ktt={toc:[]};function ftt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ktt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Number of places by which the node should be moved."))}ftt.isMDXComponent=!0;const wtt={toc:[]};function Mtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wtt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved above the provided node and from then on will be\nrendered on top of it. By default, if the node is already positioned\nhigher than the sibling node, it will not get moved."))}Mtt.isMDXComponent=!0;const Dtt={toc:[]};function _tt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dtt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node above the provided node in the parent's layout."))}_tt.isMDXComponent=!0;const Xtt={toc:[]};function gtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xtt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}gtt.isMDXComponent=!0;const xtt={toc:[]};function Ttt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xtt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly above the\nsibling. When true, will move the node even if it is\nalready positioned above the sibling."))}Ttt.isMDXComponent=!0;const Ctt={toc:[]};function vtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ctt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be moved below the provided node and from then on will be\nrendered below it. By default, if the node is already positioned lower than\nthe sibling node, it will not get moved."))}vtt.isMDXComponent=!0;const Ltt={toc:[]};function btt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ltt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node below the provided node in the parent's layout."))}btt.isMDXComponent=!0;const Ztt={toc:[]};function Ntt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ztt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The sibling node below which to move."))}Ntt.isMDXComponent=!0;const Ett={toc:[]};function Att(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ett,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the node should be positioned directly below\nthe sibling. When true, will move the node even if\nit is already positioned below the sibling."))}Att.isMDXComponent=!0;const Stt={toc:[]};function ztt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Stt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right below it (if any) and\nfrom then on will be rendered under it."))}ztt.isMDXComponent=!0;const Rtt={toc:[]};function Itt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rtt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node down in relation to its siblings."))}Itt.isMDXComponent=!0;const Wtt={toc:[]};function Ptt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wtt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Ptt.isMDXComponent=!0;const Gtt={toc:[]};function Ftt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gtt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new offset."))}Ftt.isMDXComponent=!0;const Utt={toc:[]};function jtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Utt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the node is getting moved to a lower position, it will be placed below\nthe sibling that's currently at the provided index (if any).\nIf the node is getting moved to a higher position, it will be placed above\nthe sibling that's currently at the provided index (if any)."))}jtt.isMDXComponent=!0;const Btt={toc:[]};function Vtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Btt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the provided position relative to its siblings."))}Vtt.isMDXComponent=!0;const Ott={toc:[]};function qtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ott,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The index to move the node to."))}qtt.isMDXComponent=!0;const Htt={toc:[]};function $tt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Htt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the beginning of the children list and from then\non will be rendered below all of its siblings."))}$tt.isMDXComponent=!0;const Ytt={toc:[]};function Jtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ytt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the bottom in relation to its siblings."))}Jtt.isMDXComponent=!0;const Ktt={toc:[]};function Qtt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ktt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will be placed at the end of the children list and from then on\nwill be rendered on top of all of its siblings."))}Qtt.isMDXComponent=!0;const tnt={toc:[]};function nnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node to the top in relation to its siblings."))}nnt.isMDXComponent=!0;const ent={toc:[]};function ont(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ent,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The node will exchange places with the sibling right above it (if any) and\nfrom then on will be rendered on top of it."))}ont.isMDXComponent=!0;const pnt={toc:[]};function rnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Move the node up in relation to its siblings."))}rnt.isMDXComponent=!0;const cnt={toc:[]};function snt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}snt.isMDXComponent=!0;const ant={toc:[]};function int(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ant,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a reactive copy of this node."))}int.isMDXComponent=!0;const lnt={toc:[]};function unt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},lnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}unt.isMDXComponent=!0;const mnt={toc:[]};function dnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},mnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove this node from the tree."))}dnt.isMDXComponent=!0;const hnt={toc:[]};function ynt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},hnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Remove all children of this node."))}ynt.isMDXComponent=!0;const knt={toc:[]};function fnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},knt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Render this node onto the given canvas."))}fnt.isMDXComponent=!0;const wnt={toc:[]};function Mnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},wnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context to draw with."))}Mnt.isMDXComponent=!0;const Dnt={toc:[]};function _nt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Dnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"After performing this operation, the node will stay in the same place\nvisually, but its parent will be changed."))}_nt.isMDXComponent=!0;const Xnt={toc:[]};function gnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Xnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Change the parent of this node while keeping the absolute transform."))}gnt.isMDXComponent=!0;const xnt={toc:[]};function Tnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},xnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The new parent of this node."))}Tnt.isMDXComponent=!0;const Cnt={toc:[]};function vnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Cnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}vnt.isMDXComponent=!0;const Lnt={toc:[]};function bnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Lnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}bnt.isMDXComponent=!0;const Znt={toc:[]};function Nnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Znt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether this node should be cached or not."))}Nnt.isMDXComponent=!0;const Ent={toc:[]};function Ant(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ent,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,c.kt)("p",null,"Whether the node is cached is decided by the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,c.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Ant.isMDXComponent=!0;const Snt={toc:[]};function znt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Snt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}znt.isMDXComponent=!0;const Rnt={toc:[]};function Int(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Rnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The context using which the cache will be drawn."))}Int.isMDXComponent=!0;const Wnt={toc:[]};function Pnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Wnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Unlike ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,c.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Pnt.isMDXComponent=!0;const Gnt={toc:[]};function Fnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Gnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a copy of this node."))}Fnt.isMDXComponent=!0;const Unt={toc:[]};function jnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Unt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Properties to override."))}jnt.isMDXComponent=!0;const Bnt={toc:[]};function Vnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Bnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Vnt.isMDXComponent=!0;const Ont={toc:[]};function qnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ont,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qnt.isMDXComponent=!0;const Hnt={toc:[]};function $nt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Hnt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Apply any new layout changes to this node and its children."))}$nt.isMDXComponent=!0;const Ynt={toc:[]};function Jnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Ynt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode."))}Jnt.isMDXComponent=!0;const Knt={toc:[]};function Qnt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Knt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Calculate the position relative to this node for a point located in the\ntop-left corner of the screen:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const world = new Vector2(0, 0);\nconst local = world.transformAsPoint(node.worldToLocal());\n")))}Qnt.isMDXComponent=!0;const tet={toc:[]};function net(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},tet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-local matrix for this node."))}net.isMDXComponent=!0;const eet={toc:[]};function oet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},eet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This matrix transforms vectors from world space to local space of this\nnode's parent."))}oet.isMDXComponent=!0;const pet={toc:[]};function ret(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},pet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the world-to-parent matrix for this node."))}ret.isMDXComponent=!0;const cet={toc:[]};function set(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},cet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"\nconst signal = createSignal(0);\nsignal.isInitial(); // true\n\nsignal(5);\nsignal.isInitial(); // false\n\nsignal(DEFAULT);\nsignal.isInitial(); // true\n")))}set.isMDXComponent=!0;const aet={toc:[]};function iet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},aet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Check if the signal is currently using its initial value."))}iet.isMDXComponent=!0;const uet={toc:[]};function met(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,c.kt)("p",null,"This method can be used to create copies of signals."))}met.isMDXComponent=!0;const det={toc:[]};function het(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},det,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}het.isMDXComponent=!0;const yet={toc:[]};function ket(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Get the raw value of this signal."))}ket.isMDXComponent=!0;const fet={toc:[]};function wet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}wet.isMDXComponent=!0;const Met={toc:[]};function Det(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Met,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Det.isMDXComponent=!0;const _et={toc:[]};function Xet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_et,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Xet.isMDXComponent=!0;const get={toc:[]};function xet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},get,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}xet.isMDXComponent=!0;const Tet={toc:[]};function Cet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Compute the current value of the signal and immediately set it."))}Cet.isMDXComponent=!0;const vet={toc:[]};function Let(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,c.kt)("p",null,"By default, any property is cloneable."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Let.isMDXComponent=!0;const bet={toc:[]};function Zet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Zet.isMDXComponent=!0;const Net={toc:[]};function Eet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Net,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a cloneable property decorator."))}Eet.isMDXComponent=!0;const Aet={toc:[]};function Set(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Aet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the property should be cloneable."))}Set.isMDXComponent=!0;const zet={toc:[]};function Ret(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}Ret.isMDXComponent=!0;const Iet={toc:[]};function Wet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}Wet.isMDXComponent=!0;const Pet={toc:[]};function Get(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a compound property decorator."))}Get.isMDXComponent=!0;const Fet={toc:[]};function Uet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}Uet.isMDXComponent=!0;const jet={toc:[]};function Bet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,c.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,c.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}Bet.isMDXComponent=!0;const Vet={toc:[]};function Oet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a computed method decorator."))}Oet.isMDXComponent=!0;const qet={toc:[]};function Het(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the initial value of a property."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Het.isMDXComponent=!0;const $et={toc:[]};function Yet(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$et,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Yet.isMDXComponent=!0;const Jet={toc:[]};function Ket(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an initial signal value decorator."))}Ket.isMDXComponent=!0;const Qet={toc:[]};function tot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qet,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The initial value of the property."))}tot.isMDXComponent=!0;const not={toc:[]};function eot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},not,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,c.kt)("p",null,"By default, any property is inspectable."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}eot.isMDXComponent=!0;const oot={toc:[]};function pot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},oot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}pot.isMDXComponent=!0;const rot={toc:[]};function cot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an inspectable property decorator."))}cot.isMDXComponent=!0;const sot={toc:[]};function aot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},sot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Whether the property should be inspectable."))}aot.isMDXComponent=!0;const iot={toc:[]};function lot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},iot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}lot.isMDXComponent=!0;const uot={toc:[]};function mot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},uot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}mot.isMDXComponent=!0;const dot={toc:[]};function hot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal interpolation function decorator."))}hot.isMDXComponent=!0;const yot={toc:[]};function kot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},yot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The interpolation function for the property."))}kot.isMDXComponent=!0;const fot={toc:[]};function wot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,c.kt)("p",null,"If the wrapper class has a method called ",(0,c.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}wot.isMDXComponent=!0;const Mot={toc:[]};function Dot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Dot.isMDXComponent=!0;const _ot={toc:[]};function Xot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_ot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal parser decorator."))}Xot.isMDXComponent=!0;const got={toc:[]};function xot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},got,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The wrapper class for the property."))}xot.isMDXComponent=!0;const Tot={toc:[]};function Cot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This decorator turns the given property into a signal."),(0,c.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}Cot.isMDXComponent=!0;const vot={toc:[]};function Lot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}Lot.isMDXComponent=!0;const bot={toc:[]};function Zot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal decorator."))}Zot.isMDXComponent=!0;const Not={toc:[]};function Eot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Not,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,c.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,c.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,c.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,c.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,c.kt)("p",null,"Must be specified before the ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,c.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}Eot.isMDXComponent=!0;const Aot={toc:[]};function Sot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Aot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}Sot.isMDXComponent=!0;const zot={toc:[]};function Rot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},zot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a signal wrapper decorator."))}Rot.isMDXComponent=!0;const Iot={toc:[]};function Wot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Iot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The wrapper class for the property."))}Wot.isMDXComponent=!0;const Pot={toc:[]};function Got(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Pot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"A unified abstraction for all CSS filters."))}Got.isMDXComponent=!0;const Fot={toc:[]};function Uot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Fot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"When the desired length is set to ",(0,c.kt)("inlineCode",{parentName:"p"},"null")," it represents a default value for\nwhatever property it describes."))}Uot.isMDXComponent=!0;const jot={toc:[]};function Bot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},jot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a desired length used internally by layout Nodes."))}Bot.isMDXComponent=!0;const Vot={toc:[]};function Oot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Vot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value can be either:"),(0,c.kt)("ul",null,(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"number")," - the desired length in pixels"),(0,c.kt)("li",{parentName:"ul"},(0,c.kt)("inlineCode",{parentName:"li"},"${number}%")," - a string with the desired length in percents, for example\n",(0,c.kt)("inlineCode",{parentName:"li"},"'50%'"))))}Oot.isMDXComponent=!0;const qot={toc:[]};function Hot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},qot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a length used by most layout properties."))}Hot.isMDXComponent=!0;const $ot={toc:[]};function Yot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},$ot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Represents a length limit used by layout properties such as ",(0,c.kt)("inlineCode",{parentName:"p"},"max-width"),"."))}Yot.isMDXComponent=!0;const Jot={toc:[]};function Kot(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Jot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,c.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}Kot.isMDXComponent=!0;const Qot={toc:[]};function tpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Qot,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter in pixels."))}tpt.isMDXComponent=!0;const npt={toc:[]};function ept(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},npt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,c.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}ept.isMDXComponent=!0;const opt={toc:[]};function ppt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},opt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}ppt.isMDXComponent=!0;const rpt={toc:[]};function cpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},rpt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,c.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}cpt.isMDXComponent=!0;const spt={toc:[]};function apt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},spt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}apt.isMDXComponent=!0;const ipt={toc:[]};function lpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ipt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,c.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}lpt.isMDXComponent=!0;const upt={toc:[]};function mpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},upt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}mpt.isMDXComponent=!0;const dpt={toc:[]};function hpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},dpt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,c.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}hpt.isMDXComponent=!0;const ypt={toc:[]};function kpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},ypt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter in degrees."))}kpt.isMDXComponent=!0;const fpt={toc:[]};function wpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},fpt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create an ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,c.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}wpt.isMDXComponent=!0;const Mpt={toc:[]};function Dpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Mpt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}Dpt.isMDXComponent=!0;const _pt={toc:[]};function Xpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},_pt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,c.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}Xpt.isMDXComponent=!0;const gpt={toc:[]};function xpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},gpt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}xpt.isMDXComponent=!0;const Tpt={toc:[]};function Cpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},Tpt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Create a ",(0,c.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,c.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}Cpt.isMDXComponent=!0;const vpt={toc:[]};function Lpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},vpt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"The value of the filter."))}Lpt.isMDXComponent=!0;const bpt={toc:[]};function Zpt(t){let{components:n,...e}=t;return(0,c.kt)("wrapper",(0,r.Z)({},bpt,e,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("p",null,"Update the view."),(0,c.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,c.kt)("p",null,"Can modify the state of the view."))}function Npt(t){let{id:n}=t;const e=o[n]??p.Fragment;return p.createElement(e,null)}Zpt.isMDXComponent=!0},9322:(t,n,e)=>{e.d(n,{Z:()=>m});var o=e(2784),p=e(4903),r=e(8698);const c="toggle_S_IX",s="collapsed_wdUB",a="collapse_TjTN",i="inverse_g6vW",l="clearFix_HQ1T";var u=e(6277);function m(t){let{comment:n,full:e=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@remarks"===n}))}),[n]);return o.createElement(o.Fragment,null,o.createElement(p.Z,{id:null==n?void 0:n.summaryId}),o.createElement(p.Z,{id:null==r?void 0:r.contentId}),e&&o.createElement(d,{comment:n}))}function d(t){let{comment:n}=t;const[e,m]=(0,o.useState)(!0),d=(0,o.useMemo)((()=>{var t;return(null==n||null==(t=n.blockTags)?void 0:t.filter((t=>{let{tag:n}=t;return"@example"===n})))??[]}),[n]),h=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@deprecated"===n}))}),[n]),y=(0,o.useMemo)((()=>{var t;return null==n||null==(t=n.blockTags)?void 0:t.find((t=>{let{tag:n}=t;return"@see"===n}))}),[n]);return o.createElement(o.Fragment,null,d.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,o.createElement("a",{className:(0,u.Z)(c,e&&s),onClick:t=>{t.preventDefault(),m(!e)},href:"#"},"Examples")),o.createElement(r.z,{lazy:!0,as:"div",collapsed:e},o.createElement("div",{className:a},d.map((t=>o.createElement(p.Z,{key:t.contentId,id:t.contentId})))),o.createElement("div",{className:l})),o.createElement("div",{className:(0,u.Z)(l,i)})),h&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(p.Z,{id:h.contentId})),y&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(p.Z,{id:y.contentId})))}},1930:(t,n,e)=>{e.d(n,{Z:()=>Ut});var o=e(2784),p=e(7390),r=e(6835),c=e(68),s=e(6277),a=e(8569);const i={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var l=e(7896);function u(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({width:n,height:e,"aria-hidden":"true",viewBox:"0 0 24 24"},p),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:n,highlight:e,onClick:p,link:l}=t;const m=(0,r.F)(),d=(0,c.s2)();return o.createElement("div",{className:(0,s.Z)(a.Z.codeBlockContent,i.codeBlock,e&&i.highlight,p&&i.pointer)},o.createElement("pre",{onClick:p,onKeyDown:t=>{"Enter"===t.key&&(null==p||p())},tabIndex:0,ref:m.codeBlockRef,className:(0,s.Z)(a.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:a.Z.codeBlockLines,style:d},n)),l&&o.createElement("div",{className:a.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(l,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=e(9318);function h(t){let{children:n}=t;return o.createElement(d.Z,{as:"div",className:(0,s.Z)(i.codeBlockContainer,"language-typescript")},n)}var y=e(9817);function k(t){let{children:n,type:e,to:p,id:r,tooltip:s}=t;const a=(0,c.Ld)(e);return p?o.createElement(y.Z,(0,l.Z)({id:r,to:p,"data-tooltip":s},a),n):o.createElement("span",(0,l.Z)({id:r},a),n)}let f,w;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(w||(w={}));const M={[f.None]:i.none,[f.Angle]:i.angle,[f.Curly]:i.curly,[f.Square]:i.square,[f.Parentheses]:i.parentheses};function D(t){let{children:n,type:e,separator:p=w.Comma}=t;return o.createElement("span",{className:(0,s.Z)(i.list,M[e??f.None])},o.createElement("span",{className:(0,s.Z)(i.elements,p!==w.Comma&&i.left)},(Array.isArray(n)?n:[n]).flatMap(((t,n)=>o.createElement("span",{"data-separator":p,key:n,className:i.element},t)))))}var _=e(8617);function X(t){var n;let{type:e}=t;const p=(0,_.RU)(e.project),r=null==p?void 0:p[e.id],c=e.externalUrl??(0,_.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(k,{to:c,type:c?"class-name":"constant",tooltip:!0},e.name),!(null==(n=e.typeArguments)||!n.length)&&o.createElement(D,{type:f.Angle},e.typeArguments.map(((t,n)=>o.createElement(P,{key:n,type:t})))))}function g(t){let{type:n}=t;return o.createElement(k,{type:"keyword"},n.name)}function x(t){let{type:n}=t;return n.elements?o.createElement(D,{type:f.Square},n.elements.map(((t,n)=>o.createElement(P,{key:n,type:t})))):o.createElement(o.Fragment,null,"[]")}function T(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.elementType}),"[]")}function C(t){let{type:n}=t;return o.createElement(D,{type:f.Parentheses,separator:w.Pipe},n.types.map(((t,n)=>o.createElement(P,{key:n,type:t}))))}function v(t){let{type:n}=t;const[e,p]=(0,o.useMemo)((()=>{if(null===n.value)return["null","keyword"];switch(typeof n.value){case"object":return[(n.value.negative?"-":"")+n.value.value,"number"];case"boolean":return[n.value,"keyword"];case"number":return[n.value,"number"];case"string":return[`'${n.value}'`,"string"];default:return[n.value,"constant"]}}),[n.value]);return o.createElement(k,{type:p},e)}function L(t){let{type:n}=t;return n.asserts?o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"asserts "),o.createElement(k,null,n.name," ")):o.createElement(o.Fragment,null,o.createElement(k,null,n.name," "),o.createElement(k,{type:"keyword"},"is "),o.createElement(P,{type:n.targetType}))}function b(t){let{type:n}=t;const e=(0,_.in)();return o.createElement(Y,{reflection:e(n.declaration)})}function Z(t){let{type:n}=t;return o.createElement(D,{type:f.Parentheses,separator:w.Ampersand},n.types.map(((t,n)=>o.createElement(P,{key:n,type:t}))))}function N(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"string"},"`",n.head),n.tail.map(((t,n)=>{let[e,p]=t;return o.createElement(o.Fragment,null,"${",o.createElement(P,{key:n,type:e}),"}",o.createElement(k,{type:"string"},p))})),o.createElement(k,{type:"string"},"`"))}function E(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"typeof "),o.createElement(P,{type:n.queryType}))}function A(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.checkType}),o.createElement(k,{type:"keyword"}," extends "),o.createElement(P,{type:n.extendsType})," ? ",o.createElement(P,{type:n.trueType})," : ",o.createElement(P,{type:n.falseType}))}function S(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"infer "),o.createElement(k,{type:"constant"},n.name))}function z(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(P,{type:n.objectType}),"[",o.createElement(P,{type:n.indexType}),"]")}function R(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},n.operator," "),o.createElement(P,{type:n.target}))}function I(t){let{type:n}=t;return o.createElement(o.Fragment,null,o.createElement(D,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(k,{type:"class"},n.parameter),o.createElement(k,{type:"keyword"}," in "),o.createElement(P,{type:n.parameterType}),"]: ",o.createElement(P,{type:n.templateType}))))}function W(t){let{type:n}=t;return o.createElement(o.Fragment,null,n.name,": ",o.createElement(P,{type:n.element}))}function P(t){const n=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return R;case"conditional":return A;case"reflection":return b;case"query":return E;case"named-tuple-member":return W;case"union":return C;case"intrinsic":return g;case"literal":return v;case"reference":return X;case"predicate":return L;case"tuple":return x;case"array":return T;case"intersection":return Z;case"inferred":return S;case"mapped":return I;case"template-literal":return N;case"indexedAccess":return z}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(n,t)}function G(t){let{flags:n,explicitAccessModifier:e}=t;const p=[];return null!=n&&n.isAbstract&&p.push("abstract"),null!=n&&n.isStatic&&p.push("static"),null!=n&&n.isConst&&p.push("const"),null!=n&&n.isReadonly&&p.push("readonly"),null!=n&&n.isPrivate&&p.push("private"),null!=n&&n.isProtected&&p.push("protected"),(null==n||!n.isPublic)&&(!e||null!=n&&n.isProtected||null!=n&&n.isPrivate)||p.push("public"),o.createElement(o.Fragment,null,p.map((t=>o.createElement(k,{key:t,type:"keyword"},t," "))))}function F(t){let{reflection:n}=t;const e="__namedParameters"===n.name?"{...}":n.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.flags.isRest&&"...",o.createElement(k,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"plain"},e),n.flags.isOptional&&"?",": ",n.type&&o.createElement(P,{type:n.type}),n.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(k,{type:"plain"},n.defaultValue)))}function U(t){let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),n.varianceModifier&&o.createElement(k,{type:"keyword"},n.varianceModifier," "),o.createElement(k,{id:n.anchor,to:n.anchor?`#${n.anchor}`:void 0,type:"class-name"},n.name),n.type&&o.createElement(o.Fragment,null," extends ",o.createElement(P,{type:n.type})),n.default&&o.createElement(o.Fragment,null," = ",o.createElement(P,{type:n.default})))}function j(t){var n,e;let{reflection:r,flags:c}=t;const s=(0,_.in)(),a="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(G,{flags:c??r.flags,explicitAccessModifier:!a}),r.kind===p.W.GetSignature&&o.createElement(k,{type:"keyword"},"get "),r.kind===p.W.SetSignature&&o.createElement(k,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(k,{to:r.overwrites.externalUrl??(0,_.Gr)(s(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===p.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(k,{to:"#",type:"keyword"},"new")," ",o.createElement(k,{type:"plain"},r.type.name)):a?"":o.createElement(k,{type:"function"},r.name),!(null==(n=r.typeParameter)||!n.length)&&o.createElement(D,{type:f.Angle},r.typeParameter.map((t=>o.createElement(U,{key:t.id,reflection:s(t)})))),null!=(e=r.parameters)&&e.length?o.createElement(D,{type:f.Parentheses},r.parameters.map((t=>o.createElement(F,{key:t,reflection:s(t)})))):"()",r.type&&o.createElement(o.Fragment,null,a?" => ":": ",o.createElement(P,{type:r.type})))}function B(t){let{reflection:n}=t;return o.createElement(F,{reflection:n})}const V={[p.W.Namespace]:"namespace",[p.W.Enum]:"enum",[p.W.Class]:"class",[p.W.Interface]:"interface"};function O(t){var n,e,p;let{reflection:r}=t;const c=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:r.flags}),o.createElement(k,{type:"keyword"},V[r.kind]," "),o.createElement(k,{type:"class-name"},r.name),!(null==(n=r.typeParameters)||!n.length)&&o.createElement(D,{type:f.Angle},r.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:c(t)}))))," ",!(null==(e=r.extendedTypes)||!e.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"extends "),o.createElement(D,null,r.extendedTypes.map(((t,n)=>o.createElement(P,{key:n,type:t}))))),!(null==(p=r.implementedTypes)||!p.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"implements "),o.createElement(D,null,r.implementedTypes.map(((t,n)=>o.createElement(P,{key:n,type:t}))))))}function q(t){let{reflection:n}=t;const e=(0,_.in)();return o.createElement(o.Fragment,null,o.createElement(G,{flags:n.flags}),o.createElement(k,{type:"keyword"},"type "),o.createElement(k,{type:"class-name"},n.name),n.typeParameters&&o.createElement(D,{type:f.Angle},n.typeParameters.map((t=>o.createElement(U,{key:t.id,reflection:e(t)}))))," = ",o.createElement(P,{type:n.type}))}function H(t){let{reflection:n}=t;const e=(0,_.in)();return n.signatures?o.createElement(j,{reflection:n.signatures[0]}):n.children?o.createElement(D,{type:f.Curly},n.children.map((t=>o.createElement(Y,{key:t.id,reflection:e(t)})))):o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"unknown"))}function $(t){var n;let{reflection:e}=t;const p=(null==(n=e.signatures)?void 0:n[0])??e.getSignature??e.setSignature??e.indexSignature;return o.createElement(j,{reflection:p})}function Y(t){let{reflection:n}=t;const e=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:case p.W.Module:case p.W.EnumMember:case p.W.Variable:case p.W.Function:break;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return O;case p.W.Constructor:return j;case p.W.Property:return B;case p.W.Method:return $;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:break;case p.W.TypeLiteral:return H;case p.W.TypeParameter:return U;case p.W.Accessor:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return q;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.id]);return o.createElement(e,{reflection:n})}function J(t){let{children:n}=t;const e=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!e.current)return;const t=e.current.closest("pre");if(t.scrollWidth>t.clientWidth){const n=Array.from(e.current.querySelectorAll(`.${i.elements}`)).sort(((t,n)=>function(t,n){return t>n?1:t<n?-1:0}(n.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&n.length>0;)n.shift().classList.add(i.wrap)}})),o.createElement(o.Fragment,null,n&&o.createElement("span",{ref:e,className:(0,s.Z)(i.line,"token-line")},n),o.createElement("br",null))}var K=e(9322),Q=e(4903);function tt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(U,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{parameters:n}=t;const e=(0,_.in)(),p=(0,o.useMemo)((()=>null==n?void 0:n.map(e)),[n]);return null!=p&&p.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,p.map((t=>{var n;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(F,{reflection:t})),o.createElement(Q.Z,{id:null==(n=t.comment)?void 0:n.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{signatures:n,flags:e,source:p}=t;const r=(0,_.in)(),c=(0,o.useMemo)((()=>n.map(r)),[n]),[s,a]=(0,o.useState)(c[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,c.map((t=>o.createElement(m,{link:null==p?void 0:p.url,key:t.id,highlight:n.length>1&&t.id===s.id,onClick:n.length>1?()=>a(t):void 0},o.createElement(J,null,o.createElement(j,{reflection:t,flags:e})))))),o.createElement(K.Z,{comment:s.comment}),o.createElement(tt,{parameters:s.typeParameter}),o.createElement(nt,{parameters:s.parameters}))}var ot=e(7708);function pt(t){let{width:n=24,height:e=24,...p}=t;return o.createElement("svg",(0,l.Z)({viewBox:"0 0 24 24",width:n,height:e,"aria-hidden":!0},p),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",ct="filters_z1iC",st="icon_ROIU";function at(){const t=(0,o.useRef)(null),[n,e]=(0,o.useState)(!1),[p,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const n=n=>{t.current&&!t.current.contains(n.target)&&e(!1)};return document.addEventListener("mousedown",n),document.addEventListener("touchstart",n),()=>{document.removeEventListener("mousedown",n),document.removeEventListener("touchstart",n)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,s.Z)("dropdown dropdown--right margin-bottom--md",n&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),e(!n)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),e(!n))}},"Filters",o.createElement(pt,{className:st})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,s.Z)("dropdown__link",p.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:p.private,onChange:t=>{r({...p,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&e(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,s.Z)("dropdown__link",p.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:p.inherited,onChange:t=>{r({...p,inherited:t.target.checked})}}),"Inherited members")))))}function it(t){let{children:n,kind:e}=t;return e===p.W.Class||e===p.W.Interface?o.createElement("div",{className:(0,s.Z)("row",rt)},o.createElement("div",{className:(0,s.Z)("col",ct)},o.createElement(at,null)),o.createElement("div",{className:"col"},n)):o.createElement(o.Fragment,null,n)}var lt=e(3181),ut=e(3851),mt=e(4126),dt=e(2424),ht=e(2244),yt=e(4155);function kt(t){return function(t){return o.Children.map(t,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(t).map((t=>{let{props:{value:n,label:e,attributes:o,default:p}}=t;return{value:n,label:e,attributes:o,default:p}}))}function ft(t){const{values:n,children:e}=t;return(0,o.useMemo)((()=>{const t=n??kt(e);return function(t){const n=(0,ht.l)(t,((t,n)=>t.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(t),t}),[n,e])}function wt(t){let{value:n,tabValues:e}=t;return e.some((t=>t.value===n))}function Mt(t){let{queryString:n=!1,groupId:e}=t;const p=(0,lt.k6)(),r=function(t){let{queryString:n=!1,groupId:e}=t;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,dt._X)(r),(0,o.useCallback)((t=>{if(!r)return;const n=new URLSearchParams(p.location.search);n.set(r,t),p.replace({...p.location,search:n.toString()})}),[r,p])]}function Dt(t){const{defaultValue:n,queryString:e=!1,groupId:p}=t,r=ft(t),[c,s]=(0,o.useState)((()=>function(t){let{defaultValue:n,tabValues:e}=t;if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!wt({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const o=e.find((t=>t.default))??e[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:r}))),[a,i]=Mt({queryString:e,groupId:p}),[l,u]=function(t){let{groupId:n}=t;const e=function(t){return t?`docusaurus.tab.${t}`:null}(n),[p,r]=(0,yt.Nk)(e);return[p,(0,o.useCallback)((t=>{e&&r.set(t)}),[e,r])]}({groupId:p}),m=(()=>{const t=a??l;return wt({value:t,tabValues:r})?t:null})();(0,o.useLayoutEffect)((()=>{m&&s(m)}),[m]);return{selectedValue:c,selectValue:(0,o.useCallback)((t=>{if(!wt({value:t,tabValues:r}))throw new Error(`Can't select invalid tab value=${t}`);s(t),i(t),u(t)}),[i,u,r]),tabValues:r}}var _t=e(9741);const Xt="tabList_M0Dn",gt="tabItem_ysIP";function xt(t){let{className:n,block:e,selectedValue:p,selectValue:r,tabValues:c}=t;const a=[],{blockElementScrollPositionUntilNextRender:i}=(0,mt.o5)(),u=t=>{const n=t.currentTarget,e=a.indexOf(n),o=c[e].value;o!==p&&(i(n),r(o))},m=t=>{var n;let e=null;switch(t.key){case"Enter":u(t);break;case"ArrowRight":{const n=a.indexOf(t.currentTarget)+1;e=a[n]??a[0];break}case"ArrowLeft":{const n=a.indexOf(t.currentTarget)-1;e=a[n]??a[a.length-1];break}}null==(n=e)||n.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":e},n)},c.map((t=>{let{value:n,label:e,attributes:r}=t;return o.createElement("li",(0,l.Z)({role:"tab",tabIndex:p===n?0:-1,"aria-selected":p===n,key:n,ref:t=>a.push(t),onKeyDown:m,onClick:u},r,{className:(0,s.Z)("tabs__item",gt,null==r?void 0:r.className,{"tabs__item--active":p===n})}),e??n)})))}function Tt(t){let{lazy:n,children:e,selectedValue:p}=t;if(e=Array.isArray(e)?e:[e],n){const t=e.find((t=>t.props.value===p));return t?(0,o.cloneElement)(t,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},e.map(((t,n)=>(0,o.cloneElement)(t,{key:n,hidden:t.props.value!==p}))))}function Ct(t){const n=Dt(t);return o.createElement("div",{className:(0,s.Z)("tabs-container",Xt)},o.createElement(xt,(0,l.Z)({},t,n)),o.createElement(Tt,(0,l.Z)({},t,n)))}function vt(t){const n=(0,_t.Z)();return o.createElement(Ct,(0,l.Z)({key:String(n)},t))}const Lt="tabItem_OMyP";function bt(t){let{children:n,hidden:e,className:p}=t;return o.createElement("div",{role:"tabpanel",className:(0,s.Z)(Lt,p),hidden:e},n)}function Zt(t){let{group:n}=t;return"Constructors"===n.title&&0===n.external.length&&1===n.nested.length?o.createElement(Ut,{reflection:n.nested[0]}):o.createElement(o.Fragment,null,n.external.length>0&&o.createElement("ul",null,n.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t})))))),n.nested.length>0&&n.nested.map(((t,n)=>o.createElement(o.Fragment,{key:t.id},n>0&&o.createElement("hr",null),o.createElement(Ut,{reflection:t})))))}function Nt(t){let{group:n,project:e}=t;const p=(0,lt.TH)(),r=(0,_.RU)(e),c=p.hash.split("-")[0].slice(1),[s]=(0,ot.mN)(),a=(0,o.useMemo)((()=>(n.categories??[n]).map((t=>function(t,n,e){const o=[],p=[],r=[];for(const c of t.children){const t=n[c];t&&(0,ot.It)(e,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):p.push(t))}if(o.length>0||p.length>0)return{title:t.title,external:o,nested:p,anchors:r}}(t,r,s))).filter((t=>!!t))),[n,r,s]);return(0,o.useEffect)((()=>{if(1===a.length)return;const t=p.hash.split("-")[0].slice(1);for(const n of a)if(n.anchors.includes(t))return}),[p.hash,a]),0===a.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h2",id:n.title},n.title),a.length>1?o.createElement(vt,{groupId:n.title},a.map((t=>o.createElement(bt,{default:t.anchors.includes(c),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(Zt,{group:t}))))):o.createElement(Zt,{group:a[0]}))}function Et(t){var n,e,p,r,c;let{reflection:s}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(n=s.sources)||null==(e=n[0])?void 0:e.url},o.createElement(J,null,o.createElement(Y,{reflection:s})))),o.createElement(it,{kind:s.kind},o.createElement(K.Z,{comment:s.comment})),o.createElement(tt,{parameters:s.typeParameters}),(null==(p=s.implementedBy)?void 0:p.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,s.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),(null==(r=s.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,s.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(X,{type:t}))))))),s.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:s.signatures})),null==(c=s.groups)?void 0:c.map((t=>o.createElement(Nt,{group:t,key:t.title,project:s.project}))))}function At(t){var n;let{reflection:e,headless:p}=t;const r=[...e.signatures??[],e.setSignature,e.getSignature,e.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!p&&(e.hasOwnPage?o.createElement("h1",null,e.name):o.createElement(ut.Z,{as:"h3",id:e.anchor},o.createElement("code",null,e.name))),o.createElement(et,{signatures:r,flags:e.flags,source:null==(n=e.sources)?void 0:n[0]}),e.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:e.inheritedFrom}))),e.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(X,{type:e.overwrites}))))}function St(t){var n,e;let{reflection:p,headless:r}=t;return o.createElement(o.Fragment,null,!r&&(p.hasOwnPage?o.createElement("h1",null,p.name):o.createElement(ut.Z,{as:"h3",id:p.anchor},o.createElement("code",null,p.name))),o.createElement(h,null,o.createElement(m,{link:null==(n=p.sources)||null==(e=n[0])?void 0:e.url},o.createElement(J,null,o.createElement(B,{reflection:p})))),o.createElement(K.Z,{comment:p.comment}),p.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(X,{type:p.inheritedFrom}))))}function zt(t){var n,e,p;let{reflection:r}=t;const c=(0,_.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(ut.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(n=r.sources)||null==(e=n[0])?void 0:e.url},o.createElement(J,null,o.createElement(Y,{reflection:r})))),o.createElement(K.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(et,{signatures:r.signatures})),null==(p=r.groups)?void 0:p.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>c[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(Ut,{key:t.id,reflection:t})))))))}var Rt=e(8128);function It(t){var n;let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(Rt.Z,{language:"ts"},"import ","{...}",' from "',e.importPath,'";'),o.createElement(it,{kind:e.kind},o.createElement(K.Z,{comment:e.comment})),null==(n=e.groups)?void 0:n.map((t=>o.createElement(Nt,{group:t,key:t.title,project:e.project}))))}const Wt="cardContainer_ybwo",Pt="cardTitle_Ehd1",Gt="cardDescription_b6wr";function Ft(t){let{reflection:n}=t;const e=(0,_.RU)(n.project),p=n.groups[0].children.map((t=>e[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,s.Z)("row")},p.map((t=>{var n;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(y.Z,{href:t.href,className:(0,s.Z)("card padding--lg",Wt)},o.createElement("h2",{className:(0,s.Z)("text--truncate",Pt)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,s.Z)("text--truncate",Gt)},(null==(n=t.comment)?void 0:n.summaryText)??"\xa0")))}))))}function Ut(t){let{reflection:n,headless:e=!1}=t;const r=(0,o.useMemo)((()=>{switch(n.kind){case p.W.Project:return Ft;case p.W.Module:return It;case p.W.Namespace:case p.W.Enum:case p.W.Class:case p.W.Interface:return Et;case p.W.Function:case p.W.Accessor:case p.W.Constructor:case p.W.Method:return At;case p.W.Variable:case p.W.Property:case p.W.EnumMember:return St;case p.W.CallSignature:case p.W.IndexSignature:case p.W.ConstructorSignature:case p.W.Parameter:case p.W.TypeLiteral:case p.W.TypeParameter:case p.W.GetSignature:case p.W.SetSignature:case p.W.ObjectLiteral:break;case p.W.TypeAlias:return zt;case p.W.Reference:}throw new Error(`Missing component for reflection: ${n.kindString}`)}),[n.kind]);return o.createElement(r,{reflection:n,headless:e})}},7390:(t,n,e)=>{let o;e.d(n,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,n,e)=>{e.d(n,{Gr:()=>i,RU:()=>c,gs:()=>r,in:()=>s,rG:()=>a});var o=e(2784);const p=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:n,lookup:e,urlLookup:r}=t;return o.createElement(p.Provider,{value:{lookup:e,urlLookup:r}},n)}function c(t){const{lookup:n}=(0,o.useContext)(p);return n[t]}function s(){const{lookup:t}=(0,o.useContext)(p);return n=>{if("number"==typeof(null==n?void 0:n.project))return t[n.project][n.id]}}function a(){const{urlLookup:t,lookup:n}=(0,o.useContext)(p);return e=>{var o;const p=t[e];return p?(null==(o=n[p.projectId])?void 0:o[p.id])??null:null}}function i(t){if(t)return t.href}},68:(t,n,e)=>{e.d(n,{Ld:()=>s,Y0:()=>c,s2:()=>a});var o=e(2784),p=e(822);const r=o.createContext(null);function c(t){let{children:n}=t;const e=(0,p.p)(),c=(0,o.useMemo)((()=>function(t,n){const{plain:e}=t,o=Object.create(null),p=t.styles.reduce(((t,e)=>{const{languages:o,style:p}=e;return o&&!o.includes(n)||e.types.forEach((n=>{t[n]={...t[n],...p}})),t}),o);return p.root=e,p.plain={...e,backgroundColor:null},p}(e,"typescript")),[e]);return o.createElement(r.Provider,{value:c},n)}function s(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return{className:`token ${t}`,style:n[t]??n.plain}}function a(t){void 0===t&&(t="plain");const n=(0,o.useContext)(r);return n[t]??n.plain}},7708:(t,n,e)=>{e.d(n,{It:()=>m,Wy:()=>l,mN:()=>u});var o=e(2784),p=e(1263),r=e(9741);const c="api-filters",s=p.Z.canUseDOM?localStorage.getItem(c):null,a=s?JSON.parse(s):{inherited:!0,private:!1},i=o.createContext([a,()=>{}]);function l(t){let{children:n}=t;const[e,p]=(0,o.useState)(a),s=(0,r.Z)();return o.createElement(i.Provider,{value:[e,t=>{s&&localStorage.setItem(c,JSON.stringify(t)),p(t)}]},n)}function u(){return(0,o.useContext)(i)}function m(t,n){var e,o;const p=(null==(e=n.flags)?void 0:e.isPrivate)||(null==(o=n.flags)?void 0:o.isProtected);if(!t.private&&p)return!1;const r=!!n.inheritedFrom;return!(!t.inherited&&r)}},6412:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>m,frontMatter:()=>c,metadata:()=>a,toc:()=>l});var o=e(7896),p=(e(2784),e(876)),r=(e(8128),e(2072));const c={sidebar_position:3,slug:"/hierarchy"},s="Scene hierarchy",a={unversionedId:"getting-started/hierarchy",id:"getting-started/hierarchy",title:"Scene hierarchy",description:"Scenes are collections of nodes displayed in your animation. They're organized",source:"@site/docs/getting-started/hierarchy.mdx",sourceDirName:"getting-started",slug:"/hierarchy",permalink:"/docs/hierarchy",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/packages/docs/docs/getting-started/hierarchy.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/hierarchy"},sidebar:"docs",previous:{title:"Animation flow",permalink:"/docs/flow"},next:{title:"Positioning",permalink:"/docs/positioning"}},i={},l=[{value:"<code>Node.add</code>",id:"nodeadd",level:2},{value:"<code>Node.insert</code>",id:"nodeinsert",level:2},{value:"<code>Node.remove</code>",id:"noderemove",level:2},{value:"<code>Node.reparent</code>",id:"nodereparent",level:2},{value:"<code>Node.moveUp</code>",id:"nodemoveup",level:2},{value:"<code>Node.moveDown</code>",id:"nodemovedown",level:2},{value:"<code>Node.moveToTop</code>",id:"nodemovetotop",level:2},{value:"<code>Node.moveToBottom</code>",id:"nodemovetobottom",level:2},{value:"<code>Node.moveTo</code>",id:"nodemoveto",level:2},{value:"<code>Node.moveAbove</code>",id:"nodemoveabove",level:2},{value:"<code>Node.moveBelow</code>",id:"nodemovebelow",level:2},{value:"<code>Node.removeChildren</code>",id:"noderemovechildren",level:2}],u={toc:l};function m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",{id:"scene-hierarchy"},"Scene hierarchy"),(0,p.kt)("p",null,"Scenes are collections of nodes displayed in your animation. They're organized\nin a tree hierarchy, with the scene view at its root. This concept is similar to\nthe Document Object Model used to represent HTML and XML documents."),(0,p.kt)("p",null,"Here's an example of a simple scene hierarchy together with its object\nrepresentation:"),(0,p.kt)("div",{className:"row margin-bottom--md"},(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"view.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Text>Hi</Text>\n    </Layout>\n  </>,\n);\n"))),(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("mermaid",{value:"graph TD;\n  view[Scene View]\n  circle([Circle])\n  layout([Layout])\n  rect([Rect])\n  text([text 'Hi'])\n    view--\x3ecircle;\n    view--\x3elayout;\n    layout--\x3erect;\n    layout--\x3etext;"}))),(0,p.kt)("p",null,"Each node is an instance of a class extending the base ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,p.kt)("inlineCode",{parentName:"a"},"Node"))," class. To\nmake the code more readable, Motion Canvas uses a custom\n",(0,p.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/introducing-jsx.html"},"JSX")," runtime. This way, instead\nof instantiating the nodes ourselves, we can write an XML-like markup. Note that\nMotion Canvas does ",(0,p.kt)("strong",{parentName:"p"},"not")," use React itself, only JSX. There's no virtual DOM or\nreconciliation and the JSX tags are mapped directly to Node instances. These two\ncode snippets are equivalent:"),(0,p.kt)("div",{className:"row"},(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// JSX\nview.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Text>Hi</Text>\n    </Layout>\n  </>,\n);\n"))),(0,p.kt)("div",{className:"col col--6"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-tsx"},"// No JSX\nview.add([\n  new Circle({}),\n  new Layout({\n    children: [\n      // highlight-start\n      new Rect({}),\n      new Text({text: 'Hi'}),\n    ],\n  }),\n]);\n")))),(0,p.kt)("p",null,"Just like with DOM, it's possible to add, remove, and rearrange nodes at any\ntime. The ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,p.kt)("inlineCode",{parentName:"a"},"Node"))," class contains the\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,p.kt)("inlineCode",{parentName:"a"},"children"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#parent"},(0,p.kt)("inlineCode",{parentName:"a"},"parent"))," properties that can be used to\ntraverse the tree. But in order to modify it, it's recommended to use the\nfollowing helper methods:"),(0,p.kt)("h2",{id:"nodeadd"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.add")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#add",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodeinsert"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.insert")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#insert",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"noderemove"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.remove")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#remove",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodereparent"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.reparent")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#reparent",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveup"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveUp")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveUp",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovedown"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveDown")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveDown",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovetotop"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveToTop")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveToTop",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovetobottom"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveToBottom")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveToBottom",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveto"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveTo")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveTo",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemoveabove"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveAbove")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveAbove",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"nodemovebelow"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.moveBelow")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#moveBelow",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null),(0,p.kt)("h2",{id:"noderemovechildren"},(0,p.kt)("inlineCode",{parentName:"h2"},"Node.removeChildren")),(0,p.kt)(r.Z,{url:"/api/2d/components/Node#removeChildren",mdxType:"ApiSnippet"}),(0,p.kt)("hr",null))}m.isMDXComponent=!0}}]);
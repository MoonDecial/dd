"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[1276],{2072:(t,e,n)=>{n.d(e,{Z:()=>a});var o=n(2784),c=n(8617),r=n(1836),p=n(9817);function a(t){let{url:e}=t;const n=(0,c.rG)()(e);return o.createElement(o.Fragment,null,o.createElement(r.Z,{reflection:n,headless:!0}),o.createElement(p.Z,{to:n.href},o.createElement("small",null,"Got to the API documentation")))}},4791:(t,e,n)=>{n.d(e,{Z:()=>_P});var o={};n.r(o),n.d(o,{content_0_0:()=>s,content_0_10:()=>D,content_0_100:()=>te,content_0_102:()=>ne,content_0_104:()=>ce,content_0_106:()=>pe,content_0_108:()=>se,content_0_110:()=>ie,content_0_112:()=>me,content_0_114:()=>he,content_0_116:()=>ke,content_0_118:()=>De,content_0_12:()=>_,content_0_120:()=>_e,content_0_122:()=>we,content_0_124:()=>Ce,content_0_126:()=>xe,content_0_128:()=>Le,content_0_130:()=>be,content_0_132:()=>Ee,content_0_134:()=>Ae,content_0_136:()=>We,content_0_138:()=>Ge,content_0_14:()=>w,content_0_140:()=>Re,content_0_142:()=>je,content_0_144:()=>qe,content_0_146:()=>Ve,content_0_148:()=>He,content_0_150:()=>Je,content_0_152:()=>Ye,content_0_154:()=>tn,content_0_156:()=>nn,content_0_158:()=>cn,content_0_16:()=>C,content_0_160:()=>pn,content_0_162:()=>sn,content_0_164:()=>un,content_0_166:()=>dn,content_0_168:()=>yn,content_0_170:()=>fn,content_0_172:()=>Mn,content_0_174:()=>Xn,content_0_176:()=>Tn,content_0_178:()=>gn,content_0_18:()=>x,content_0_180:()=>Zn,content_0_182:()=>vn,content_0_184:()=>Nn,content_0_186:()=>Sn,content_0_188:()=>Pn,content_0_190:()=>Fn,content_0_192:()=>In,content_0_194:()=>Un,content_0_196:()=>zn,content_0_198:()=>Bn,content_0_2:()=>i,content_0_20:()=>L,content_0_200:()=>On,content_0_202:()=>$n,content_0_204:()=>Kn,content_0_206:()=>Qn,content_0_208:()=>eo,content_0_210:()=>oo,content_0_212:()=>ro,content_0_214:()=>ao,content_0_216:()=>lo,content_0_218:()=>uo,content_0_22:()=>b,content_0_220:()=>ho,content_0_222:()=>ko,content_0_224:()=>Do,content_0_226:()=>_o,content_0_228:()=>wo,content_0_230:()=>Co,content_0_232:()=>xo,content_0_234:()=>Lo,content_0_236:()=>bo,content_0_238:()=>Eo,content_0_24:()=>E,content_0_240:()=>Ao,content_0_242:()=>Wo,content_0_244:()=>Go,content_0_246:()=>Ro,content_0_248:()=>jo,content_0_250:()=>qo,content_0_252:()=>Vo,content_0_254:()=>Ho,content_0_256:()=>Jo,content_0_258:()=>Yo,content_0_26:()=>A,content_0_260:()=>tc,content_0_262:()=>nc,content_0_264:()=>cc,content_0_266:()=>pc,content_0_268:()=>sc,content_0_270:()=>ic,content_0_272:()=>mc,content_0_274:()=>hc,content_0_276:()=>kc,content_0_278:()=>Dc,content_0_28:()=>W,content_0_280:()=>_c,content_0_282:()=>wc,content_0_284:()=>Cc,content_0_286:()=>xc,content_0_288:()=>Lc,content_0_290:()=>bc,content_0_292:()=>Ec,content_0_294:()=>Ac,content_0_296:()=>Wc,content_0_298:()=>Gc,content_0_30:()=>G,content_0_300:()=>Rc,content_0_302:()=>jc,content_0_304:()=>qc,content_0_306:()=>Vc,content_0_308:()=>Hc,content_0_310:()=>Jc,content_0_312:()=>Yc,content_0_314:()=>tr,content_0_316:()=>nr,content_0_318:()=>cr,content_0_32:()=>R,content_0_320:()=>pr,content_0_322:()=>sr,content_0_324:()=>ir,content_0_326:()=>mr,content_0_328:()=>hr,content_0_330:()=>kr,content_0_332:()=>Dr,content_0_334:()=>_r,content_0_336:()=>wr,content_0_338:()=>Cr,content_0_34:()=>j,content_0_340:()=>xr,content_0_342:()=>Lr,content_0_344:()=>br,content_0_346:()=>Er,content_0_348:()=>Ar,content_0_350:()=>Wr,content_0_352:()=>Gr,content_0_354:()=>Rr,content_0_356:()=>jr,content_0_358:()=>qr,content_0_36:()=>q,content_0_360:()=>Vr,content_0_362:()=>Hr,content_0_364:()=>Jr,content_0_366:()=>Yr,content_0_368:()=>tp,content_0_370:()=>np,content_0_372:()=>cp,content_0_374:()=>pp,content_0_376:()=>sp,content_0_378:()=>ip,content_0_38:()=>V,content_0_380:()=>mp,content_0_382:()=>hp,content_0_384:()=>kp,content_0_386:()=>Dp,content_0_388:()=>_p,content_0_390:()=>wp,content_0_392:()=>Cp,content_0_394:()=>xp,content_0_396:()=>Lp,content_0_398:()=>bp,content_0_4:()=>m,content_0_40:()=>H,content_0_400:()=>Ep,content_0_402:()=>Ap,content_0_404:()=>Wp,content_0_406:()=>Gp,content_0_408:()=>Rp,content_0_410:()=>jp,content_0_412:()=>qp,content_0_414:()=>Vp,content_0_416:()=>Hp,content_0_418:()=>Jp,content_0_42:()=>J,content_0_420:()=>Yp,content_0_422:()=>ta,content_0_424:()=>na,content_0_426:()=>ca,content_0_428:()=>pa,content_0_430:()=>sa,content_0_432:()=>ia,content_0_434:()=>ma,content_0_436:()=>ha,content_0_438:()=>ka,content_0_44:()=>Y,content_0_440:()=>Da,content_0_442:()=>_a,content_0_444:()=>wa,content_0_446:()=>Ca,content_0_448:()=>xa,content_0_450:()=>La,content_0_452:()=>ba,content_0_454:()=>Ea,content_0_456:()=>Aa,content_0_458:()=>Wa,content_0_46:()=>tt,content_0_460:()=>Ga,content_0_462:()=>Ra,content_0_464:()=>ja,content_0_466:()=>qa,content_0_468:()=>Va,content_0_470:()=>Ha,content_0_472:()=>Ja,content_0_474:()=>Ya,content_0_476:()=>ts,content_0_478:()=>ns,content_0_48:()=>nt,content_0_480:()=>cs,content_0_482:()=>ps,content_0_484:()=>ss,content_0_486:()=>is,content_0_488:()=>ms,content_0_490:()=>hs,content_0_492:()=>ks,content_0_494:()=>Ds,content_0_496:()=>_s,content_0_498:()=>ws,content_0_50:()=>ct,content_0_500:()=>Cs,content_0_502:()=>xs,content_0_504:()=>Ls,content_0_506:()=>bs,content_0_508:()=>Es,content_0_510:()=>As,content_0_512:()=>Ws,content_0_514:()=>Gs,content_0_516:()=>Rs,content_0_518:()=>js,content_0_52:()=>pt,content_0_520:()=>qs,content_0_522:()=>Vs,content_0_524:()=>Hs,content_0_526:()=>Js,content_0_528:()=>Ys,content_0_530:()=>tl,content_0_532:()=>nl,content_0_534:()=>cl,content_0_536:()=>pl,content_0_538:()=>sl,content_0_54:()=>st,content_0_540:()=>il,content_0_542:()=>ml,content_0_544:()=>hl,content_0_546:()=>kl,content_0_548:()=>Dl,content_0_550:()=>_l,content_0_552:()=>wl,content_0_554:()=>Cl,content_0_556:()=>xl,content_0_558:()=>Ll,content_0_56:()=>it,content_0_560:()=>bl,content_0_562:()=>El,content_0_564:()=>Al,content_0_566:()=>Wl,content_0_568:()=>Gl,content_0_570:()=>Rl,content_0_572:()=>jl,content_0_574:()=>ql,content_0_576:()=>Vl,content_0_578:()=>Hl,content_0_58:()=>mt,content_0_580:()=>Jl,content_0_582:()=>Yl,content_0_584:()=>ti,content_0_586:()=>ni,content_0_588:()=>ci,content_0_590:()=>pi,content_0_592:()=>si,content_0_594:()=>ii,content_0_596:()=>mi,content_0_598:()=>hi,content_0_6:()=>h,content_0_60:()=>ht,content_0_600:()=>ki,content_0_602:()=>Di,content_0_604:()=>_i,content_0_606:()=>wi,content_0_608:()=>Ci,content_0_610:()=>xi,content_0_612:()=>Li,content_0_614:()=>bi,content_0_616:()=>Ei,content_0_618:()=>Ai,content_0_62:()=>kt,content_0_620:()=>Wi,content_0_622:()=>Gi,content_0_624:()=>Ri,content_0_626:()=>ji,content_0_628:()=>qi,content_0_630:()=>Vi,content_0_632:()=>Hi,content_0_634:()=>Ji,content_0_636:()=>Yi,content_0_638:()=>tu,content_0_64:()=>Dt,content_0_640:()=>nu,content_0_642:()=>cu,content_0_644:()=>pu,content_0_646:()=>su,content_0_648:()=>iu,content_0_650:()=>mu,content_0_652:()=>hu,content_0_654:()=>ku,content_0_656:()=>Du,content_0_658:()=>_u,content_0_66:()=>_t,content_0_660:()=>wu,content_0_662:()=>Cu,content_0_664:()=>xu,content_0_666:()=>Lu,content_0_668:()=>bu,content_0_670:()=>Eu,content_0_672:()=>Au,content_0_674:()=>Wu,content_0_676:()=>Gu,content_0_678:()=>Ru,content_0_68:()=>wt,content_0_680:()=>ju,content_0_682:()=>qu,content_0_684:()=>Vu,content_0_686:()=>Hu,content_0_688:()=>Ju,content_0_690:()=>Yu,content_0_692:()=>tm,content_0_694:()=>nm,content_0_696:()=>cm,content_0_698:()=>pm,content_0_70:()=>Ct,content_0_700:()=>sm,content_0_702:()=>im,content_0_704:()=>mm,content_0_706:()=>hm,content_0_708:()=>km,content_0_710:()=>Dm,content_0_712:()=>_m,content_0_714:()=>wm,content_0_716:()=>Cm,content_0_718:()=>xm,content_0_72:()=>xt,content_0_720:()=>Lm,content_0_722:()=>bm,content_0_724:()=>Em,content_0_726:()=>Am,content_0_728:()=>Wm,content_0_730:()=>Gm,content_0_732:()=>Rm,content_0_734:()=>jm,content_0_736:()=>qm,content_0_738:()=>Vm,content_0_74:()=>Lt,content_0_740:()=>Hm,content_0_742:()=>Jm,content_0_744:()=>Ym,content_0_746:()=>td,content_0_748:()=>nd,content_0_750:()=>cd,content_0_752:()=>pd,content_0_754:()=>sd,content_0_756:()=>id,content_0_758:()=>md,content_0_76:()=>bt,content_0_760:()=>hd,content_0_762:()=>kd,content_0_764:()=>Dd,content_0_766:()=>_d,content_0_768:()=>wd,content_0_770:()=>Cd,content_0_772:()=>xd,content_0_774:()=>Ld,content_0_776:()=>bd,content_0_778:()=>Ed,content_0_78:()=>Et,content_0_780:()=>Ad,content_0_782:()=>Wd,content_0_784:()=>Gd,content_0_786:()=>Rd,content_0_788:()=>jd,content_0_790:()=>qd,content_0_792:()=>Vd,content_0_794:()=>Hd,content_0_796:()=>Jd,content_0_798:()=>Yd,content_0_8:()=>k,content_0_80:()=>At,content_0_800:()=>th,content_0_802:()=>nh,content_0_804:()=>ch,content_0_806:()=>ph,content_0_808:()=>sh,content_0_810:()=>ih,content_0_812:()=>mh,content_0_814:()=>hh,content_0_816:()=>kh,content_0_818:()=>Dh,content_0_82:()=>Wt,content_0_820:()=>_h,content_0_822:()=>wh,content_0_824:()=>Ch,content_0_826:()=>xh,content_0_828:()=>Lh,content_0_830:()=>bh,content_0_832:()=>Eh,content_0_834:()=>Ah,content_0_836:()=>Wh,content_0_838:()=>Gh,content_0_84:()=>Gt,content_0_840:()=>Rh,content_0_842:()=>jh,content_0_844:()=>qh,content_0_846:()=>Vh,content_0_848:()=>Hh,content_0_850:()=>Jh,content_0_852:()=>Yh,content_0_854:()=>ty,content_0_856:()=>ny,content_0_858:()=>cy,content_0_86:()=>Rt,content_0_860:()=>py,content_0_862:()=>sy,content_0_864:()=>iy,content_0_866:()=>my,content_0_868:()=>hy,content_0_870:()=>ky,content_0_872:()=>Dy,content_0_874:()=>_y,content_0_876:()=>wy,content_0_878:()=>Cy,content_0_88:()=>jt,content_0_880:()=>xy,content_0_882:()=>Ly,content_0_884:()=>by,content_0_886:()=>Ey,content_0_888:()=>Ay,content_0_890:()=>Wy,content_0_892:()=>Gy,content_0_894:()=>Ry,content_0_896:()=>jy,content_0_898:()=>qy,content_0_90:()=>qt,content_0_900:()=>Vy,content_0_902:()=>Hy,content_0_92:()=>Vt,content_0_94:()=>Ht,content_0_96:()=>Jt,content_0_98:()=>Yt,content_2112_0:()=>Jy,content_2112_10:()=>pk,content_2112_100:()=>zf,content_2112_1000:()=>gA,content_2112_1002:()=>ZA,content_2112_1004:()=>vA,content_2112_1006:()=>NA,content_2112_1008:()=>SA,content_2112_1010:()=>PA,content_2112_1012:()=>FA,content_2112_1014:()=>IA,content_2112_1016:()=>UA,content_2112_1018:()=>zA,content_2112_102:()=>Bf,content_2112_1020:()=>BA,content_2112_1022:()=>OA,content_2112_1024:()=>$A,content_2112_1026:()=>KA,content_2112_1028:()=>QA,content_2112_1030:()=>eP,content_2112_1032:()=>oP,content_2112_1034:()=>rP,content_2112_1036:()=>aP,content_2112_1038:()=>lP,content_2112_104:()=>Of,content_2112_1040:()=>uP,content_2112_1042:()=>dP,content_2112_1044:()=>yP,content_2112_1046:()=>fP,content_2112_1048:()=>MP,content_2112_106:()=>$f,content_2112_108:()=>Kf,content_2112_110:()=>Qf,content_2112_112:()=>eD,content_2112_114:()=>oD,content_2112_116:()=>rD,content_2112_118:()=>aD,content_2112_12:()=>sk,content_2112_120:()=>lD,content_2112_122:()=>uD,content_2112_124:()=>dD,content_2112_126:()=>yD,content_2112_128:()=>fD,content_2112_130:()=>MD,content_2112_132:()=>XD,content_2112_134:()=>TD,content_2112_136:()=>gD,content_2112_138:()=>ZD,content_2112_14:()=>ik,content_2112_140:()=>vD,content_2112_142:()=>ND,content_2112_144:()=>SD,content_2112_146:()=>PD,content_2112_148:()=>FD,content_2112_150:()=>ID,content_2112_152:()=>UD,content_2112_154:()=>zD,content_2112_156:()=>BD,content_2112_158:()=>OD,content_2112_16:()=>mk,content_2112_160:()=>$D,content_2112_162:()=>KD,content_2112_164:()=>QD,content_2112_166:()=>eM,content_2112_168:()=>oM,content_2112_170:()=>rM,content_2112_172:()=>aM,content_2112_174:()=>lM,content_2112_176:()=>uM,content_2112_178:()=>dM,content_2112_18:()=>hk,content_2112_180:()=>yM,content_2112_182:()=>fM,content_2112_184:()=>MM,content_2112_186:()=>XM,content_2112_188:()=>TM,content_2112_190:()=>gM,content_2112_192:()=>ZM,content_2112_194:()=>vM,content_2112_196:()=>NM,content_2112_198:()=>SM,content_2112_2:()=>Yy,content_2112_20:()=>kk,content_2112_200:()=>PM,content_2112_202:()=>FM,content_2112_204:()=>IM,content_2112_206:()=>UM,content_2112_208:()=>zM,content_2112_210:()=>BM,content_2112_212:()=>OM,content_2112_214:()=>$M,content_2112_216:()=>KM,content_2112_218:()=>QM,content_2112_22:()=>Dk,content_2112_220:()=>e_,content_2112_222:()=>o_,content_2112_224:()=>r_,content_2112_226:()=>a_,content_2112_228:()=>l_,content_2112_230:()=>u_,content_2112_232:()=>d_,content_2112_234:()=>y_,content_2112_236:()=>f_,content_2112_238:()=>M_,content_2112_24:()=>_k,content_2112_240:()=>X_,content_2112_242:()=>T_,content_2112_244:()=>g_,content_2112_246:()=>Z_,content_2112_248:()=>v_,content_2112_250:()=>N_,content_2112_252:()=>S_,content_2112_254:()=>P_,content_2112_256:()=>F_,content_2112_258:()=>I_,content_2112_26:()=>wk,content_2112_260:()=>U_,content_2112_262:()=>z_,content_2112_264:()=>B_,content_2112_266:()=>O_,content_2112_268:()=>$_,content_2112_270:()=>K_,content_2112_272:()=>Q_,content_2112_274:()=>eX,content_2112_276:()=>oX,content_2112_278:()=>rX,content_2112_28:()=>Ck,content_2112_280:()=>aX,content_2112_282:()=>lX,content_2112_284:()=>uX,content_2112_286:()=>dX,content_2112_288:()=>yX,content_2112_290:()=>fX,content_2112_292:()=>MX,content_2112_294:()=>XX,content_2112_296:()=>TX,content_2112_298:()=>gX,content_2112_30:()=>xk,content_2112_300:()=>ZX,content_2112_302:()=>vX,content_2112_304:()=>NX,content_2112_306:()=>SX,content_2112_308:()=>PX,content_2112_310:()=>FX,content_2112_312:()=>IX,content_2112_314:()=>UX,content_2112_316:()=>zX,content_2112_318:()=>BX,content_2112_32:()=>Lk,content_2112_320:()=>OX,content_2112_322:()=>$X,content_2112_324:()=>KX,content_2112_326:()=>QX,content_2112_328:()=>ew,content_2112_330:()=>ow,content_2112_332:()=>rw,content_2112_334:()=>aw,content_2112_336:()=>lw,content_2112_338:()=>uw,content_2112_34:()=>bk,content_2112_340:()=>dw,content_2112_342:()=>yw,content_2112_344:()=>fw,content_2112_346:()=>Mw,content_2112_348:()=>Xw,content_2112_350:()=>Tw,content_2112_352:()=>gw,content_2112_354:()=>Zw,content_2112_356:()=>vw,content_2112_358:()=>Nw,content_2112_36:()=>Ek,content_2112_360:()=>Sw,content_2112_362:()=>Pw,content_2112_364:()=>Fw,content_2112_366:()=>Iw,content_2112_368:()=>Uw,content_2112_370:()=>zw,content_2112_372:()=>Bw,content_2112_374:()=>Ow,content_2112_376:()=>$w,content_2112_378:()=>Kw,content_2112_38:()=>Ak,content_2112_380:()=>Qw,content_2112_382:()=>eT,content_2112_384:()=>oT,content_2112_386:()=>rT,content_2112_388:()=>aT,content_2112_390:()=>lT,content_2112_392:()=>uT,content_2112_394:()=>dT,content_2112_396:()=>yT,content_2112_398:()=>fT,content_2112_4:()=>tk,content_2112_40:()=>Wk,content_2112_400:()=>MT,content_2112_402:()=>XT,content_2112_404:()=>TT,content_2112_406:()=>gT,content_2112_408:()=>ZT,content_2112_410:()=>vT,content_2112_412:()=>NT,content_2112_414:()=>ST,content_2112_416:()=>PT,content_2112_418:()=>FT,content_2112_42:()=>Gk,content_2112_420:()=>IT,content_2112_422:()=>UT,content_2112_424:()=>zT,content_2112_426:()=>BT,content_2112_428:()=>OT,content_2112_430:()=>$T,content_2112_432:()=>KT,content_2112_434:()=>QT,content_2112_436:()=>eC,content_2112_438:()=>oC,content_2112_44:()=>Rk,content_2112_440:()=>rC,content_2112_442:()=>aC,content_2112_444:()=>lC,content_2112_446:()=>uC,content_2112_448:()=>dC,content_2112_450:()=>yC,content_2112_452:()=>fC,content_2112_454:()=>MC,content_2112_456:()=>XC,content_2112_458:()=>TC,content_2112_46:()=>jk,content_2112_460:()=>gC,content_2112_462:()=>ZC,content_2112_464:()=>vC,content_2112_466:()=>NC,content_2112_468:()=>SC,content_2112_470:()=>PC,content_2112_472:()=>FC,content_2112_474:()=>IC,content_2112_476:()=>UC,content_2112_478:()=>zC,content_2112_48:()=>qk,content_2112_480:()=>BC,content_2112_482:()=>OC,content_2112_484:()=>$C,content_2112_486:()=>KC,content_2112_488:()=>QC,content_2112_490:()=>eg,content_2112_492:()=>og,content_2112_494:()=>rg,content_2112_496:()=>ag,content_2112_498:()=>lg,content_2112_50:()=>Vk,content_2112_500:()=>ug,content_2112_502:()=>dg,content_2112_504:()=>yg,content_2112_506:()=>fg,content_2112_508:()=>Mg,content_2112_510:()=>Xg,content_2112_512:()=>Tg,content_2112_514:()=>gg,content_2112_516:()=>Zg,content_2112_518:()=>vg,content_2112_52:()=>Hk,content_2112_520:()=>Ng,content_2112_522:()=>Sg,content_2112_524:()=>Pg,content_2112_526:()=>Fg,content_2112_528:()=>Ig,content_2112_530:()=>Ug,content_2112_532:()=>zg,content_2112_534:()=>Bg,content_2112_536:()=>Og,content_2112_538:()=>$g,content_2112_54:()=>Jk,content_2112_540:()=>Kg,content_2112_542:()=>Qg,content_2112_544:()=>ex,content_2112_546:()=>ox,content_2112_548:()=>rx,content_2112_550:()=>ax,content_2112_552:()=>lx,content_2112_554:()=>ux,content_2112_556:()=>dx,content_2112_558:()=>yx,content_2112_56:()=>Yk,content_2112_560:()=>fx,content_2112_562:()=>Mx,content_2112_564:()=>Xx,content_2112_566:()=>Tx,content_2112_568:()=>gx,content_2112_570:()=>Zx,content_2112_572:()=>vx,content_2112_574:()=>Nx,content_2112_576:()=>Sx,content_2112_578:()=>Px,content_2112_58:()=>tf,content_2112_580:()=>Fx,content_2112_582:()=>Ix,content_2112_584:()=>Ux,content_2112_586:()=>zx,content_2112_588:()=>Bx,content_2112_590:()=>Ox,content_2112_592:()=>$x,content_2112_594:()=>Kx,content_2112_596:()=>Qx,content_2112_598:()=>eZ,content_2112_6:()=>nk,content_2112_60:()=>nf,content_2112_600:()=>oZ,content_2112_602:()=>rZ,content_2112_604:()=>aZ,content_2112_606:()=>lZ,content_2112_608:()=>uZ,content_2112_610:()=>dZ,content_2112_612:()=>yZ,content_2112_614:()=>fZ,content_2112_616:()=>MZ,content_2112_618:()=>XZ,content_2112_62:()=>cf,content_2112_620:()=>TZ,content_2112_622:()=>gZ,content_2112_624:()=>ZZ,content_2112_626:()=>vZ,content_2112_628:()=>NZ,content_2112_630:()=>SZ,content_2112_632:()=>PZ,content_2112_634:()=>FZ,content_2112_636:()=>IZ,content_2112_638:()=>UZ,content_2112_64:()=>pf,content_2112_640:()=>zZ,content_2112_642:()=>BZ,content_2112_644:()=>OZ,content_2112_646:()=>$Z,content_2112_648:()=>KZ,content_2112_650:()=>QZ,content_2112_652:()=>eL,content_2112_654:()=>oL,content_2112_656:()=>rL,content_2112_658:()=>aL,content_2112_66:()=>sf,content_2112_660:()=>lL,content_2112_662:()=>uL,content_2112_664:()=>dL,content_2112_666:()=>yL,content_2112_668:()=>fL,content_2112_670:()=>ML,content_2112_672:()=>XL,content_2112_674:()=>TL,content_2112_676:()=>gL,content_2112_678:()=>ZL,content_2112_68:()=>uf,content_2112_680:()=>vL,content_2112_682:()=>NL,content_2112_684:()=>SL,content_2112_686:()=>PL,content_2112_688:()=>FL,content_2112_690:()=>IL,content_2112_692:()=>UL,content_2112_694:()=>zL,content_2112_696:()=>BL,content_2112_698:()=>OL,content_2112_70:()=>df,content_2112_700:()=>$L,content_2112_702:()=>KL,content_2112_704:()=>QL,content_2112_706:()=>ev,content_2112_708:()=>ov,content_2112_710:()=>rv,content_2112_712:()=>av,content_2112_714:()=>lv,content_2112_716:()=>uv,content_2112_718:()=>dv,content_2112_72:()=>yf,content_2112_720:()=>yv,content_2112_722:()=>fv,content_2112_724:()=>Mv,content_2112_726:()=>Xv,content_2112_728:()=>Tv,content_2112_730:()=>gv,content_2112_732:()=>Zv,content_2112_734:()=>vv,content_2112_736:()=>Nv,content_2112_738:()=>Sv,content_2112_74:()=>ff,content_2112_740:()=>Pv,content_2112_742:()=>Fv,content_2112_744:()=>Iv,content_2112_746:()=>Uv,content_2112_748:()=>zv,content_2112_750:()=>Bv,content_2112_752:()=>Ov,content_2112_754:()=>$v,content_2112_756:()=>Kv,content_2112_758:()=>Qv,content_2112_76:()=>Mf,content_2112_760:()=>eb,content_2112_762:()=>ob,content_2112_764:()=>rb,content_2112_766:()=>ab,content_2112_768:()=>lb,content_2112_770:()=>ub,content_2112_772:()=>db,content_2112_774:()=>yb,content_2112_776:()=>fb,content_2112_778:()=>Mb,content_2112_78:()=>Xf,content_2112_780:()=>Xb,content_2112_782:()=>Tb,content_2112_784:()=>gb,content_2112_786:()=>Zb,content_2112_788:()=>vb,content_2112_790:()=>Nb,content_2112_792:()=>Sb,content_2112_794:()=>Pb,content_2112_796:()=>Fb,content_2112_798:()=>Ib,content_2112_8:()=>ck,content_2112_80:()=>Tf,content_2112_800:()=>Ub,content_2112_802:()=>zb,content_2112_804:()=>Bb,content_2112_806:()=>Ob,content_2112_808:()=>$b,content_2112_810:()=>Kb,content_2112_812:()=>Qb,content_2112_814:()=>eN,content_2112_816:()=>oN,content_2112_818:()=>rN,content_2112_82:()=>gf,content_2112_820:()=>aN,content_2112_822:()=>lN,content_2112_824:()=>uN,content_2112_826:()=>dN,content_2112_828:()=>yN,content_2112_830:()=>fN,content_2112_832:()=>MN,content_2112_834:()=>XN,content_2112_836:()=>TN,content_2112_838:()=>gN,content_2112_84:()=>Zf,content_2112_840:()=>ZN,content_2112_842:()=>vN,content_2112_844:()=>NN,content_2112_846:()=>SN,content_2112_848:()=>PN,content_2112_850:()=>FN,content_2112_852:()=>IN,content_2112_854:()=>UN,content_2112_856:()=>zN,content_2112_858:()=>BN,content_2112_86:()=>vf,content_2112_860:()=>ON,content_2112_862:()=>$N,content_2112_864:()=>KN,content_2112_866:()=>QN,content_2112_868:()=>eE,content_2112_870:()=>oE,content_2112_872:()=>rE,content_2112_874:()=>aE,content_2112_876:()=>lE,content_2112_878:()=>uE,content_2112_88:()=>Nf,content_2112_880:()=>dE,content_2112_882:()=>yE,content_2112_884:()=>fE,content_2112_886:()=>ME,content_2112_888:()=>XE,content_2112_890:()=>TE,content_2112_892:()=>gE,content_2112_894:()=>ZE,content_2112_896:()=>vE,content_2112_898:()=>NE,content_2112_90:()=>Sf,content_2112_900:()=>SE,content_2112_902:()=>PE,content_2112_904:()=>FE,content_2112_906:()=>IE,content_2112_908:()=>UE,content_2112_910:()=>zE,content_2112_912:()=>BE,content_2112_914:()=>OE,content_2112_916:()=>$E,content_2112_918:()=>KE,content_2112_92:()=>Pf,content_2112_920:()=>QE,content_2112_922:()=>eS,content_2112_924:()=>oS,content_2112_926:()=>rS,content_2112_928:()=>aS,content_2112_930:()=>lS,content_2112_932:()=>uS,content_2112_934:()=>dS,content_2112_936:()=>yS,content_2112_938:()=>fS,content_2112_94:()=>Ff,content_2112_940:()=>MS,content_2112_942:()=>XS,content_2112_944:()=>TS,content_2112_946:()=>gS,content_2112_948:()=>ZS,content_2112_950:()=>vS,content_2112_952:()=>NS,content_2112_954:()=>SS,content_2112_956:()=>PS,content_2112_958:()=>FS,content_2112_96:()=>If,content_2112_960:()=>IS,content_2112_962:()=>US,content_2112_964:()=>zS,content_2112_966:()=>BS,content_2112_968:()=>OS,content_2112_970:()=>$S,content_2112_972:()=>KS,content_2112_974:()=>QS,content_2112_976:()=>eA,content_2112_978:()=>oA,content_2112_98:()=>Uf,content_2112_980:()=>rA,content_2112_982:()=>aA,content_2112_984:()=>lA,content_2112_986:()=>uA,content_2112_988:()=>dA,content_2112_990:()=>yA,content_2112_992:()=>fA,content_2112_994:()=>MA,content_2112_996:()=>XA,content_2112_998:()=>TA});var c=n(2784),r=n(7896),p=n(876);const a={toc:[]};function s(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},a,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Property decorators."))}s.isMDXComponent=!0;const l={toc:[]};function i(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscriptions and triggering of events."))}i.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,p.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}h.isMDXComponent=!0;const y={toc:[]};function k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},y,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches an asynchronous ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}k.isMDXComponent=!0;const f={toc:[]};function D(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}D.isMDXComponent=!0;const M={toc:[]};function _(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},M,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}_.isMDXComponent=!0;const X={toc:[]};function w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},X,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}w.isMDXComponent=!0;const T={toc:[]};function C(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},T,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}C.isMDXComponent=!0;const g={toc:[]};function x(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}x.isMDXComponent=!0;const Z={toc:[]};function L(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}L.isMDXComponent=!0;const v={toc:[]};function b(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},v,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}b.isMDXComponent=!0;const N={toc:[]};function E(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}E.isMDXComponent=!0;const S={toc:[]};function A(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},S,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}A.isMDXComponent=!0;const P={toc:[]};function W(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},P,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}W.isMDXComponent=!0;const F={toc:[]};function G(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},F,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}G.isMDXComponent=!0;const I={toc:[]};function R(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},I,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}R.isMDXComponent=!0;const U={toc:[]};function j(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},U,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}j.isMDXComponent=!0;const z={toc:[]};function q(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}q.isMDXComponent=!0;const B={toc:[]};function V(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},B,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}V.isMDXComponent=!0;const O={toc:[]};function H(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},O,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value argument to subscribers."))}H.isMDXComponent=!0;const $={toc:[]};function J(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A base for dispatching ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,p.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}J.isMDXComponent=!0;const K={toc:[]};function Y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},K,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}Y.isMDXComponent=!0;const Q={toc:[]};function tt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Q,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}tt.isMDXComponent=!0;const et={toc:[]};function nt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},et,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}nt.isMDXComponent=!0;const ot={toc:[]};function ct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}ct.isMDXComponent=!0;const rt={toc:[]};function pt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}pt.isMDXComponent=!0;const at={toc:[]};function st(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},at,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}st.isMDXComponent=!0;const lt={toc:[]};function it(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}it.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,p.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,p.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}ht.isMDXComponent=!0;const yt={toc:[]};function kt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}kt.isMDXComponent=!0;const ft={toc:[]};function Dt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}Dt.isMDXComponent=!0;const Mt={toc:[]};function _t(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}_t.isMDXComponent=!0;const Xt={toc:[]};function wt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Are subscribers being notified?"))}wt.isMDXComponent=!0;const Tt={toc:[]};function Ct(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Notify all current and future subscribers."))}Ct.isMDXComponent=!0;const gt={toc:[]};function xt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stop notifying future subscribers."))}xt.isMDXComponent=!0;const Zt={toc:[]};function Lt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Lt.isMDXComponent=!0;const vt={toc:[]};function bt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}bt.isMDXComponent=!0;const Nt={toc:[]};function Et(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Et.isMDXComponent=!0;const St={toc:[]};function At(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},St,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}At.isMDXComponent=!0;const Pt={toc:[]};function Wt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Wt.isMDXComponent=!0;const Ft={toc:[]};function Gt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ft,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Gt.isMDXComponent=!0;const It={toc:[]};function Rt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},It,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}Rt.isMDXComponent=!0;const Ut={toc:[]};function jt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ut,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}jt.isMDXComponent=!0;const zt={toc:[]};function qt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}qt.isMDXComponent=!0;const Bt={toc:[]};function Vt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Vt.isMDXComponent=!0;const Ot={toc:[]};function Ht(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ot,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Ht.isMDXComponent=!0;const $t={toc:[]};function Jt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$t,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Jt.isMDXComponent=!0;const Kt={toc:[]};function Yt(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}Yt.isMDXComponent=!0;const Qt={toc:[]};function te(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qt,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}te.isMDXComponent=!0;const ee={toc:[]};function ne(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ee,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ne.isMDXComponent=!0;const oe={toc:[]};function ce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}ce.isMDXComponent=!0;const re={toc:[]};function pe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},re,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}pe.isMDXComponent=!0;const ae={toc:[]};function se(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ae,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}se.isMDXComponent=!0;const le={toc:[]};function ie(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},le,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}ie.isMDXComponent=!0;const ue={toc:[]};function me(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}me.isMDXComponent=!0;const de={toc:[]};function he(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},de,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}he.isMDXComponent=!0;const ye={toc:[]};function ke(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ye,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}ke.isMDXComponent=!0;const fe={toc:[]};function De(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}De.isMDXComponent=!0;const Me={toc:[]};function _e(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Me,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}_e.isMDXComponent=!0;const Xe={toc:[]};function we(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}we.isMDXComponent=!0;const Te={toc:[]};function Ce(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Te,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Ce.isMDXComponent=!0;const ge={toc:[]};function xe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ge,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}xe.isMDXComponent=!0;const Ze={toc:[]};function Le(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ze,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Le.isMDXComponent=!0;const ve={toc:[]};function be(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ve,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}be.isMDXComponent=!0;const Ne={toc:[]};function Ee(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ne,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value."))}Ee.isMDXComponent=!0;const Se={toc:[]};function Ae(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Se,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}Ae.isMDXComponent=!0;const Pe={toc:[]};function We(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Setting the value will immediately notify all subscribers."))}We.isMDXComponent=!0;const Fe={toc:[]};function Ge(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set the current value of this dispatcher."))}Ge.isMDXComponent=!0;const Ie={toc:[]};function Re(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ie,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new value."))}Re.isMDXComponent=!0;const Ue={toc:[]};function je(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ue,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}je.isMDXComponent=!0;const ze={toc:[]};function qe(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ze,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}qe.isMDXComponent=!0;const Be={toc:[]};function Ve(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Be,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}Ve.isMDXComponent=!0;const Oe={toc:[]};function He(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}He.isMDXComponent=!0;const $e={toc:[]};function Je(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$e,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Je.isMDXComponent=!0;const Ke={toc:[]};function Ye(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ke,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Ye.isMDXComponent=!0;const Qe={toc:[]};function tn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qe,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}tn.isMDXComponent=!0;const en={toc:[]};function nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},en,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}nn.isMDXComponent=!0;const on={toc:[]};function cn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},on,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}cn.isMDXComponent=!0;const rn={toc:[]};function pn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}pn.isMDXComponent=!0;const an={toc:[]};function sn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},an,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}sn.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ln,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}yn.isMDXComponent=!0;const kn={toc:[]};function fn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}fn.isMDXComponent=!0;const Dn={toc:[]};function Mn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}Mn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_n,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}Xn.isMDXComponent=!0;const wn={toc:[]};function Tn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of times the timer has ticked."))}Tn.isMDXComponent=!0;const Cn={toc:[]};function gn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator responsible for running this timer."))}gn.isMDXComponent=!0;const xn={toc:[]};function Zn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the timer ticks."))}Zn.isMDXComponent=!0;const Ln={toc:[]};function vn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ln,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current iteration index."))}vn.isMDXComponent=!0;const bn={toc:[]};function Nn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}Nn.isMDXComponent=!0;const En={toc:[]};function Sn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},En,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Sn.isMDXComponent=!0;const An={toc:[]};function Pn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},An,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Pn.isMDXComponent=!0;const Wn={toc:[]};function Fn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Fn.isMDXComponent=!0;const Gn={toc:[]};function In(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}In.isMDXComponent=!0;const Rn={toc:[]};function Un(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Un.isMDXComponent=!0;const jn={toc:[]};function zn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.corenerRadius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}zn.isMDXComponent=!0;const qn={toc:[]};function Bn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run tasks one after another."))}Bn.isMDXComponent=!0;const Vn={toc:[]};function On(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}On.isMDXComponent=!0;const Hn={toc:[]};function $n(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}$n.isMDXComponent=!0;const Jn={toc:[]};function Kn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Kn.isMDXComponent=!0;const Yn={toc:[]};function Qn(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yn,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay in seconds"))}Qn.isMDXComponent=!0;const to={toc:[]};function eo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},to,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task or callback to run after the delay."))}eo.isMDXComponent=!0;const no={toc:[]};function oo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},no,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}oo.isMDXComponent=!0;const co={toc:[]};function ro(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},co,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Call the given callback every N seconds."))}ro.isMDXComponent=!0;const po={toc:[]};function ao(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},po,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interval between subsequent calls."))}ao.isMDXComponent=!0;const so={toc:[]};function lo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},so,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to be called."))}lo.isMDXComponent=!0;const io={toc:[]};function uo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},io,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each time iteration waits until the previous one is completed."))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}ho.isMDXComponent=!0;const yo={toc:[]};function ko(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator N times."))}ko.isMDXComponent=!0;const fo={toc:[]};function Do(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of iterations."))}Do.isMDXComponent=!0;const Mo={toc:[]};function _o(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}_o.isMDXComponent=!0;const Xo={toc:[]};function wo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Do nothing."))}wo.isMDXComponent=!0;const To={toc:[]};function Co(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},To,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Co.isMDXComponent=!0;const go={toc:[]};function xo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},go,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}xo.isMDXComponent=!0;const Zo={toc:[]};function Lo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}Lo.isMDXComponent=!0;const vo={toc:[]};function bo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}bo.isMDXComponent=!0;const No={toc:[]};function Eo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},No,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}Eo.isMDXComponent=!0;const So={toc:[]};function Ao(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},So,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional name used when displaying this generator in the UI."))}Ao.isMDXComponent=!0;const Po={toc:[]};function Wo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Po,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}Wo.isMDXComponent=!0;const Fo={toc:[]};function Go(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Go.isMDXComponent=!0;const Io={toc:[]};function Ro(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Io,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Ro.isMDXComponent=!0;const Uo={toc:[]};function jo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Start all tasks one after another with a constant delay between."))}jo.isMDXComponent=!0;const zo={toc:[]};function qo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay between each of the tasks."))}qo.isMDXComponent=!0;const Bo={toc:[]};function Vo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to be run in a sequence."))}Vo.isMDXComponent=!0;const Oo={toc:[]};function Ho(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Ho.isMDXComponent=!0;const $o={toc:[]};function Jo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$o,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the given amount of time."))}Jo.isMDXComponent=!0;const Ko={toc:[]};function Yo(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ko,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The relative time in seconds."))}Yo.isMDXComponent=!0;const Qo={toc:[]};function tc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qo,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}tc.isMDXComponent=!0;const ec={toc:[]};function nc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ec,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}nc.isMDXComponent=!0;const oc={toc:[]};function cc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}cc.isMDXComponent=!0;const rc={toc:[]};function pc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the given time event."))}pc.isMDXComponent=!0;const ac={toc:[]};function sc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ac,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the time event."))}sc.isMDXComponent=!0;const lc={toc:[]};function ic(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}ic.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Main Motion Canvas classes."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when a new message is logged."))}hc.isMDXComponent=!0;const yc={toc:[]};function kc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the meta file of a given entity."))}kc.isMDXComponent=!0;const fc={toc:[]};function Dc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when metadata changes."))}Dc.isMDXComponent=!0;const Mc={toc:[]};function _c(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Load new metadata from a file."))}_c.isMDXComponent=!0;const Xc={toc:[]};function wc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New metadata."))}wc.isMDXComponent=!0;const Tc={toc:[]};function Cc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any possible errors will be logged to the console."))}Cc.isMDXComponent=!0;const gc={toc:[]};function xc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set data without waiting for confirmation."))}xc.isMDXComponent=!0;const Zc={toc:[]};function Lc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New data."))}Lc.isMDXComponent=!0;const vc={toc:[]};function bc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the data stored in the meta file."))}bc.isMDXComponent=!0;const Nc={toc:[]};function Ec(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,p.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}Ec.isMDXComponent=!0;const Sc={toc:[]};function Ac(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sc,n,{components:e,mdxType:"MDXLayout"}))}Ac.isMDXComponent=!0;const Pc={toc:[]};function Wc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The project configuration."))}Wc.isMDXComponent=!0;const Fc={toc:[]};function Gc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the current scene changes."))}Gc.isMDXComponent=!0;const Ic={toc:[]};function Rc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ic,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Rc.isMDXComponent=!0;const Uc={toc:[]};function jc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after the scenes were recalculated."))}jc.isMDXComponent=!0;const zc={toc:[]};function qc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}qc.isMDXComponent=!0;const Bc={toc:[]};function Vc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Multi-media management."))}Vc.isMDXComponent=!0;const Oc={toc:[]};function Hc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Hc.isMDXComponent=!0;const $c={toc:[]};function Jc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$c,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause/resume the audio."))}Jc.isMDXComponent=!0;const Kc={toc:[]};function Yc(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the audio should be paused or resumed."))}Yc.isMDXComponent=!0;const Qc={toc:[]};function tr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qc,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The absolute biggest value from the peaks array."))}tr.isMDXComponent=!0;const er={toc:[]};function nr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},er,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of samples taken."))}nr.isMDXComponent=!0;const or={toc:[]};function cr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},or,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}cr.isMDXComponent=!0;const rr={toc:[]};function pr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Samples per seconds."))}pr.isMDXComponent=!0;const ar={toc:[]};function sr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ar,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Playback control."))}sr.isMDXComponent=!0;const lr={toc:[]};function ir(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Abstract scene representations and related utilities."))}ir.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ur,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Signifies the various stages of a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs after a render ends."))}hr.isMDXComponent=!0;const yr={toc:[]};function kr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}kr.isMDXComponent=!0;const fr={toc:[]};function Dr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,p.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}Dr.isMDXComponent=!0;const Mr={toc:[]};function _r(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,p.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}_r.isMDXComponent=!0;const Xr={toc:[]};function wr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes the state of a scene."))}wr.isMDXComponent=!0;const Tr={toc:[]};function Cr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}Cr.isMDXComponent=!0;const gr={toc:[]};function xr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished transitioning in."))}xr.isMDXComponent=!0;const Zr={toc:[]};function Lr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}Lr.isMDXComponent=!0;const vr={toc:[]};function br(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene is ready to transition out."))}br.isMDXComponent=!0;const Nr={toc:[]};function Er(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoking ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}Er.isMDXComponent=!0;const Sr={toc:[]};function Ar(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished."))}Ar.isMDXComponent=!0;const Pr={toc:[]};function Wr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has just been created/reset."))}Wr.isMDXComponent=!0;const Fr={toc:[]};function Gr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The default implementation of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,p.kt)("p",null,"Uses generators to control the animation."))}Gr.isMDXComponent=!0;const Ir={toc:[]};function Rr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ir,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Rr.isMDXComponent=!0;const Ur={toc:[]};function jr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ur,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}jr.isMDXComponent=!0;const zr={toc:[]};function qr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}qr.isMDXComponent=!0;const Br={toc:[]};function Vr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Br,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Vr.isMDXComponent=!0;const Or={toc:[]};function Hr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Or,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}Hr.isMDXComponent=!0;const $r={toc:[]};function Jr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$r,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Jr.isMDXComponent=!0;const Kr={toc:[]};function Yr(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Yr.isMDXComponent=!0;const Qr={toc:[]};function tp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qr,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}tp.isMDXComponent=!0;const ep={toc:[]};function np(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ep,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}np.isMDXComponent=!0;const op={toc:[]};function cp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},op,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}cp.isMDXComponent=!0;const rp={toc:[]};function pp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}pp.isMDXComponent=!0;const ap={toc:[]};function sp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ap,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}sp.isMDXComponent=!0;const lp={toc:[]};function ip(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ip.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},up,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}hp.isMDXComponent=!0;const yp={toc:[]};function kp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}kp.isMDXComponent=!0;const fp={toc:[]};function Dp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}Dp.isMDXComponent=!0;const Mp={toc:[]};function _p(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}_p.isMDXComponent=!0;const Xp={toc:[]};function wp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}wp.isMDXComponent=!0;const Tp={toc:[]};function Cp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}Cp.isMDXComponent=!0;const gp={toc:[]};function xp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}xp.isMDXComponent=!0;const Zp={toc:[]};function Lp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}Lp.isMDXComponent=!0;const vp={toc:[]};function bp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}bp.isMDXComponent=!0;const Np={toc:[]};function Ep(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Np,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Ep.isMDXComponent=!0;const Sp={toc:[]};function Ap(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}Ap.isMDXComponent=!0;const Pp={toc:[]};function Wp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Wp.isMDXComponent=!0;const Fp={toc:[]};function Gp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Gp.isMDXComponent=!0;const Ip={toc:[]};function Rp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ip,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Rp.isMDXComponent=!0;const Up={toc:[]};function jp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Up,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}jp.isMDXComponent=!0;const zp={toc:[]};function qp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}qp.isMDXComponent=!0;const Bp={toc:[]};function Vp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Lifecycle events for ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Vp.isMDXComponent=!0;const Op={toc:[]};function Hp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Op,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A random number generator based on\n",(0,p.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,p.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Hp.isMDXComponent=!0;const $p={toc:[]};function Jp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$p,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random floats in the given range."))}Jp.isMDXComponent=!0;const Kp={toc:[]};function Yp(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."))}Yp.isMDXComponent=!0;const Qp={toc:[]};function ta(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qp,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ta.isMDXComponent=!0;const ea={toc:[]};function na(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ea,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}na.isMDXComponent=!0;const oa={toc:[]};function ca(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random integers in the given range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"}),(0,p.kt)("li",{parentName:"ul"})))}ca.isMDXComponent=!0;const ra={toc:[]};function pa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ra,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}pa.isMDXComponent=!0;const aa={toc:[]};function sa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},aa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}sa.isMDXComponent=!0;const la={toc:[]};function ia(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},la,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}ia.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ua,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random float in the given range."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},da,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ha.isMDXComponent=!0;const ya={toc:[]};function ka(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ya,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}ka.isMDXComponent=!0;const fa={toc:[]};function Da(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random integer in the given range."))}Da.isMDXComponent=!0;const Ma={toc:[]};function _a(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ma,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}_a.isMDXComponent=!0;const Xa={toc:[]};function wa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}wa.isMDXComponent=!0;const Ta={toc:[]};function Ca(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ta,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a new independent generator."))}Ca.isMDXComponent=!0;const ga={toc:[]};function xa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ga,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Manages time events for a given scene."))}xa.isMDXComponent=!0;const Za={toc:[]};function La(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Za,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when time events change."))}La.isMDXComponent=!0;const va={toc:[]};function ba(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},va,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the time offset of the given event."))}ba.isMDXComponent=!0;const Na={toc:[]};function Ea(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Na,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the event."))}Ea.isMDXComponent=!0;const Sa={toc:[]};function Aa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The time offset in seconds."))}Aa.isMDXComponent=!0;const Pa={toc:[]};function Wa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}Wa.isMDXComponent=!0;const Fa={toc:[]};function Ga(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes cached information about the timing of a scene."))}Ga.isMDXComponent=!0;const Ia={toc:[]};function Ra(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ia,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a complete scene together with the meta file."))}Ra.isMDXComponent=!0;const Ua={toc:[]};function ja(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ua,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}ja.isMDXComponent=!0;const za={toc:[]};function qa(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},za,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}qa.isMDXComponent=!0;const Ba={toc:[]};function Va(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ba,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Va.isMDXComponent=!0;const Oa={toc:[]};function Ha(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Ha.isMDXComponent=!0;const $a={toc:[]};function Ja(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$a,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Ja.isMDXComponent=!0;const Ka={toc:[]};function Ya(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ka,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Ya.isMDXComponent=!0;const Qa={toc:[]};function ts(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qa,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for the inspected element."))}ts.isMDXComponent=!0;const es={toc:[]};function ns(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},es,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element for which to draw an overlay."))}ns.isMDXComponent=!0;const os={toc:[]};function cs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},os,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}cs.isMDXComponent=!0;const rs={toc:[]};function ps(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ps.isMDXComponent=!0;const as={toc:[]};function ss(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},as,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}ss.isMDXComponent=!0;const ls={toc:[]};function is(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ls,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the attributes of the inspected element."))}is.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},us,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to inspect."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ds,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a possible element to inspect at a given position."))}hs.isMDXComponent=!0;const ys={toc:[]};function ks(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ys,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x coordinate."))}ks.isMDXComponent=!0;const fs={toc:[]};function Ds(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y coordinate."))}Ds.isMDXComponent=!0;const Ms={toc:[]};function _s(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ms,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}_s.isMDXComponent=!0;const Xs={toc:[]};function ws(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the inspected element is still valid."))}ws.isMDXComponent=!0;const Ts={toc:[]};function Cs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ts,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to validate."))}Cs.isMDXComponent=!0;const gs={toc:[]};function xs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event stored in a meta file."))}xs.isMDXComponent=!0;const Zs={toc:[]};function Ls(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}Ls.isMDXComponent=!0;const vs={toc:[]};function bs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main interface for scenes."))}bs.isMDXComponent=!0;const Ns={toc:[]};function Es(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ns,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Es.isMDXComponent=!0;const Ss={toc:[]};function As(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ss,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}As.isMDXComponent=!0;const Ps={toc:[]};function Ws(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ps,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Ws.isMDXComponent=!0;const Fs={toc:[]};function Gs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene's ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Gs.isMDXComponent=!0;const Is={toc:[]};function Rs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Is,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Rs.isMDXComponent=!0;const Us={toc:[]};function js(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Us,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}js.isMDXComponent=!0;const zs={toc:[]};function qs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}qs.isMDXComponent=!0;const Bs={toc:[]};function Vs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Vs.isMDXComponent=!0;const Os={toc:[]};function Hs(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Os,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Hs.isMDXComponent=!0;const $s={toc:[]};function Js(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$s,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Js.isMDXComponent=!0;const Ks={toc:[]};function Ys(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ks,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Ys.isMDXComponent=!0;const Qs={toc:[]};function tl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qs,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}tl.isMDXComponent=!0;const el={toc:[]};function nl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},el,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}nl.isMDXComponent=!0;const ol={toc:[]};function cl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ol,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}cl.isMDXComponent=!0;const rl={toc:[]};function pl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}pl.isMDXComponent=!0;const al={toc:[]};function sl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},al,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}sl.isMDXComponent=!0;const ll={toc:[]};function il(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ll,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}il.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ul,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}hl.isMDXComponent=!0;const yl={toc:[]};function kl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}kl.isMDXComponent=!0;const fl={toc:[]};function Dl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Dl.isMDXComponent=!0;const Ml={toc:[]};function _l(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ml,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}_l.isMDXComponent=!0;const Xl={toc:[]};function wl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}wl.isMDXComponent=!0;const Tl={toc:[]};function Cl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}Cl.isMDXComponent=!0;const gl={toc:[]};function xl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}xl.isMDXComponent=!0;const Zl={toc:[]};function Ll(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Ll.isMDXComponent=!0;const vl={toc:[]};function bl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}bl.isMDXComponent=!0;const Nl={toc:[]};function El(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}El.isMDXComponent=!0;const Sl={toc:[]};function Al(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Al.isMDXComponent=!0;const Pl={toc:[]};function Wl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Wl.isMDXComponent=!0;const Fl={toc:[]};function Gl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each class implementing the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Gl.isMDXComponent=!0;const Il={toc:[]};function Rl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Il,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constructor used when creating new scenes."))}Rl.isMDXComponent=!0;const Ul={toc:[]};function jl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ul,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,p.kt)("inlineCode",{parentName:"a"},"config")),"."))}jl.isMDXComponent=!0;const zl={toc:[]};function ql(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a scene exposed by scene files."))}ql.isMDXComponent=!0;const Bl={toc:[]};function Vl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Vl.isMDXComponent=!0;const Ol={toc:[]};function Hl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ol,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}Hl.isMDXComponent=!0;const $l={toc:[]};function Jl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$l,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Jl.isMDXComponent=!0;const Kl={toc:[]};function Yl(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kl,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Yl.isMDXComponent=!0;const Ql={toc:[]};function ti(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ql,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}ti.isMDXComponent=!0;const ei={toc:[]};function ni(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ei,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}ni.isMDXComponent=!0;const oi={toc:[]};function ci(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}ci.isMDXComponent=!0;const ri={toc:[]};function pi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ri,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}pi.isMDXComponent=!0;const ai={toc:[]};function si(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ai,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event at runtime."))}si.isMDXComponent=!0;const li={toc:[]};function ii(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},li,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"In other words, the moment at which ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,p.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}ii.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ui,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},di,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the event."))}hi.isMDXComponent=!0;const yi={toc:[]};function ki(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Duration of the event in seconds."))}ki.isMDXComponent=!0;const fi={toc:[]};function Di(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stack trace at the moment of registration."))}Di.isMDXComponent=!0;const Mi={toc:[]};function _i(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}_i.isMDXComponent=!0;const Xi={toc:[]};function wi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents attributes of an inspected element."))}wi.isMDXComponent=!0;const Ti={toc:[]};function Ci(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ti,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}Ci.isMDXComponent=!0;const gi={toc:[]};function xi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents an element to inspect."))}xi.isMDXComponent=!0;const Zi={toc:[]};function Li(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}Li.isMDXComponent=!0;const vi={toc:[]};function bi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}bi.isMDXComponent=!0;const Ni={toc:[]};function Ei(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ni,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Ei.isMDXComponent=!0;const Si={toc:[]};function Ai(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Si,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Ai.isMDXComponent=!0;const Pi={toc:[]};function Wi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Wi.isMDXComponent=!0;const Fi={toc:[]};function Gi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Gi.isMDXComponent=!0;const Ii={toc:[]};function Ri(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ii,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Ri.isMDXComponent=!0;const Ui={toc:[]};function ji(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ui,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}ji.isMDXComponent=!0;const zi={toc:[]};function qi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}qi.isMDXComponent=!0;const Bi={toc:[]};function Vi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Vi.isMDXComponent=!0;const Oi={toc:[]};function Hi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Hi.isMDXComponent=!0;const $i={toc:[]};function Ji(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$i,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Ji.isMDXComponent=!0;const Ki={toc:[]};function Yi(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ki,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Yi.isMDXComponent=!0;const Qi={toc:[]};function tu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qi,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}tu.isMDXComponent=!0;const eu={toc:[]};function nu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}nu.isMDXComponent=!0;const ou={toc:[]};function cu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ou,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}cu.isMDXComponent=!0;const ru={toc:[]};function pu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ru,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}pu.isMDXComponent=!0;const au={toc:[]};function su(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},au,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}su.isMDXComponent=!0;const lu={toc:[]};function iu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}iu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},du,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread management."))}hu.isMDXComponent=!0;const yu={toc:[]};function ku(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,p.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}ku.isMDXComponent=!0;const fu={toc:[]};function Du(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A class representing an individual thread."))}Du.isMDXComponent=!0;const Mu={toc:[]};function _u(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}_u.isMDXComponent=!0;const Xu={toc:[]};function wu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}wu.isMDXComponent=!0;const Tu={toc:[]};function Cu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Used by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}Cu.isMDXComponent=!0;const gu={toc:[]};function xu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current time of this thread."))}xu.isMDXComponent=!0;const Zu={toc:[]};function Lu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The next value to be passed to the wrapped generator."))}Lu.isMDXComponent=!0;const vu={toc:[]};function bu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}bu.isMDXComponent=!0;const Nu={toc:[]};function Eu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress the wrapped generator once."))}Eu.isMDXComponent=!0;const Su={toc:[]};function Au(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Su,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the thread for the next update cycle."))}Au.isMDXComponent=!0;const Pu={toc:[]};function Wu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a normal function that returns a generator."))}Wu.isMDXComponent=!0;const Fu={toc:[]};function Gu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,p.kt)("p",null,"Progress to the next frame:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,p.kt)("p",null,"Run another generator synchronously:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,p.kt)("p",null,"Run another generator concurrently:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,p.kt)("p",null,"Await a Promise:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Gu.isMDXComponent=!0;const Iu={toc:[]};function Ru(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Ru.isMDXComponent=!0;const Uu={toc:[]};function ju(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Cancel all listed tasks."),(0,p.kt)("p",null,"Example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}ju.isMDXComponent=!0;const zu={toc:[]};function qu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to cancel."))}qu.isMDXComponent=!0;const Bu={toc:[]};function Vu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Vu.isMDXComponent=!0;const Ou={toc:[]};function Hu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ou,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Hu.isMDXComponent=!0;const $u={toc:[]};function Ju(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$u,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Ju.isMDXComponent=!0;const Ku={toc:[]};function Yu(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ku,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible thread ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Yu.isMDXComponent=!0;const Qu={toc:[]};function tm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qu,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}tm.isMDXComponent=!0;const em={toc:[]};function nm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},em,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}nm.isMDXComponent=!0;const om={toc:[]};function cm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},om,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}cm.isMDXComponent=!0;const rm={toc:[]};function pm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}pm.isMDXComponent=!0;const am={toc:[]};function sm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},am,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until listed tasks are finished."))}sm.isMDXComponent=!0;const lm={toc:[]};function im(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}im.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},um,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"From the perspective of the external generator, ",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}hm.isMDXComponent=!0;const ym={toc:[]};function km(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ym,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}km.isMDXComponent=!0;const fm={toc:[]};function Dm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a context in which generators can be run concurrently."))}Dm.isMDXComponent=!0;const Mm={toc:[]};function _m(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the generator to run."))}_m.isMDXComponent=!0;const Xm={toc:[]};function wm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}wm.isMDXComponent=!0;const Tm={toc:[]};function Cm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transitions between scenes."))}Cm.isMDXComponent=!0;const gm={toc:[]};function xm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}xm.isMDXComponent=!0;const Zm={toc:[]};function Lm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the current scene is rendered."))}Lm.isMDXComponent=!0;const vm={toc:[]};function bm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the previous scene is rendered."))}bm.isMDXComponent=!0;const Nm={toc:[]};function Em(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolation and timing of tweens."))}Em.isMDXComponent=!0;const Sm={toc:[]};function Am(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any old key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"})))}Am.isMDXComponent=!0;const Pm={toc:[]};function Wm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Wm.isMDXComponent=!0;const Fm={toc:[]};function Gm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Gm.isMDXComponent=!0;const Im={toc:[]};function Rm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Im,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Rm.isMDXComponent=!0;const Um={toc:[]};function jm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Um,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}jm.isMDXComponent=!0;const zm={toc:[]};function qm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}qm.isMDXComponent=!0;const Bm={toc:[]};function Vm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Vm.isMDXComponent=!0;const Om={toc:[]};function Hm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Om,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Hm.isMDXComponent=!0;const $m={toc:[]};function Jm(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$m,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Jm.isMDXComponent=!0;const Km={toc:[]};function Ym(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Km,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Ym.isMDXComponent=!0;const Qm={toc:[]};function td(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qm,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}td.isMDXComponent=!0;const ed={toc:[]};function nd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ed,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Complex types used in animations."))}nd.isMDXComponent=!0;const od={toc:[]};function cd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},od,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a two-dimensional vector."))}cd.isMDXComponent=!0;const rd={toc:[]};function pd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}pd.isMDXComponent=!0;const ad={toc:[]};function sd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ad,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The unclipped RGB components."))}sd.isMDXComponent=!0;const ld={toc:[]};function id(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ld,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}id.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ud,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}hd.isMDXComponent=!0;const yd={toc:[]};function kd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}kd.isMDXComponent=!0;const fd={toc:[]};function Dd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}Dd.isMDXComponent=!0;const Md={toc:[]};function _d(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Md,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}_d.isMDXComponent=!0;const Xd={toc:[]};function wd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}wd.isMDXComponent=!0;const Td={toc:[]};function Cd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Td,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Alias of ",(0,p.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}Cd.isMDXComponent=!0;const gd={toc:[]};function xd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}xd.isMDXComponent=!0;const Zd={toc:[]};function Ld(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Ld.isMDXComponent=!0;const vd={toc:[]};function bd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}bd.isMDXComponent=!0;const Nd={toc:[]};function Ed(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}Ed.isMDXComponent=!0;const Sd={toc:[]};function Ad(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Ad.isMDXComponent=!0;const Pd={toc:[]};function Wd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Wd.isMDXComponent=!0;const Fd={toc:[]};function Gd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}Gd.isMDXComponent=!0;const Id={toc:[]};function Rd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Id,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"L"),", ",(0,p.kt)("strong",{parentName:"p"},"a"),", and ",(0,p.kt)("strong",{parentName:"p"},"b")," components."))}Rd.isMDXComponent=!0;const Ud={toc:[]};function jd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ud,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}jd.isMDXComponent=!0;const zd={toc:[]};function qd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,p.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,p.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}qd.isMDXComponent=!0;const Bd={toc:[]};function Vd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}Vd.isMDXComponent=!0;const Od={toc:[]};function Hd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Od,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}Hd.isMDXComponent=!0;const $d={toc:[]};function Jd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$d,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Jd.isMDXComponent=!0;const Kd={toc:[]};function Yd(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}Yd.isMDXComponent=!0;const Qd={toc:[]};function th(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qd,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get and set the color opacity."))}th.isMDXComponent=!0;const eh={toc:[]};function nh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},eh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,p.kt)("code",null,"'rgb'")))}nh.isMDXComponent=!0;const oh={toc:[]};function ch(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Similar to saturate, but the opposite direction."))}ch.isMDXComponent=!0;const rh={toc:[]};function ph(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"set"))}ph.isMDXComponent=!0;const ah={toc:[]};function sh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ah,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a single channel value.\nAlso"))}sh.isMDXComponent=!0;const lh={toc:[]};function ih(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}ih.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color as hexadecimal string."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}hh.isMDXComponent=!0;const yh={toc:[]};function kh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,p.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}kh.isMDXComponent=!0;const fh={toc:[]};function Dh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}Dh.isMDXComponent=!0;const Mh={toc:[]};function _h(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}_h.isMDXComponent=!0;const Xh={toc:[]};function wh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}wh.isMDXComponent=!0;const Th={toc:[]};function Ch(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Th,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}Ch.isMDXComponent=!0;const gh={toc:[]};function xh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}xh.isMDXComponent=!0;const Zh={toc:[]};function Lh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}Lh.isMDXComponent=!0;const vh={toc:[]};function bh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}bh.isMDXComponent=!0;const Nh={toc:[]};function Eh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}Eh.isMDXComponent=!0;const Sh={toc:[]};function Ah(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Ah.isMDXComponent=!0;const Ph={toc:[]};function Wh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ph,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Wh.isMDXComponent=!0;const Fh={toc:[]};function Gh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Gh.isMDXComponent=!0;const Ih={toc:[]};function Rh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ih,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The origin to convert."))}Rh.isMDXComponent=!0;const Uh={toc:[]};function jh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"General utilities and helper functions."))}jh.isMDXComponent=!0;const zh={toc:[]};function qh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}qh.isMDXComponent=!0;const Bh={toc:[]};function Vh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Optional override for formatting stack traces"))}Vh.isMDXComponent=!0;const Oh={toc:[]};function Hh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create .stack property on a target object"))}Hh.isMDXComponent=!0;const $h={toc:[]};function Jh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$h,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the reference instead."))}Jh.isMDXComponent=!0;const Kh={toc:[]};function Yh(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kh,n,{components:e,mdxType:"MDXLayout"}))}Yh.isMDXComponent=!0;const Qh={toc:[]};function ty(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qh,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mark the given function as deprecated."))}ty.isMDXComponent=!0;const ey={toc:[]};function ny(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ey,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function to deprecate."))}ny.isMDXComponent=!0;const oy={toc:[]};function cy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},oy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The log message."))}cy.isMDXComponent=!0;const ry={toc:[]};function py(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ry,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The optional log remarks."))}py.isMDXComponent=!0;const ay={toc:[]};function sy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ay,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}sy.isMDXComponent=!0;const ly={toc:[]};function iy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ly,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}iy.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The length of the array."))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}hy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}ky.isMDXComponent=!0;const fy={toc:[]};function Dy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}Dy.isMDXComponent=!0;const My={toc:[]};function _y(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},My,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}_y.isMDXComponent=!0;const Xy={toc:[]};function wy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}wy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ty,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context before render."))}Cy.isMDXComponent=!0;const gy={toc:[]};function xy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}xy.isMDXComponent=!0;const Zy={toc:[]};function Ly(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context after render."))}Ly.isMDXComponent=!0;const vy={toc:[]};function by(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current project."))}by.isMDXComponent=!0;const Ny={toc:[]};function Ey(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ny,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the current scene."))}Ey.isMDXComponent=!0;const Sy={toc:[]};function Ay(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the given seed."))}Ay.isMDXComponent=!0;const Py={toc:[]};function Wy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Py,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The seed for the generator."))}Wy.isMDXComponent=!0;const Fy={toc:[]};function Gy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}Gy.isMDXComponent=!0;const Iy={toc:[]};function Ry(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Iy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current scene."))}Ry.isMDXComponent=!0;const Uy={toc:[]};function jy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current thread."))}jy.isMDXComponent=!0;const zy={toc:[]};function qy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}qy.isMDXComponent=!0;const By={toc:[]};function Vy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},By,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}Vy.isMDXComponent=!0;const Oy={toc:[]};function Hy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Oy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the real time since the start of the animation."))}Hy.isMDXComponent=!0;const $y={toc:[]};function Jy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$y,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Jy.isMDXComponent=!0;const Ky={toc:[]};function Yy(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ky,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Yy.isMDXComponent=!0;const Qy={toc:[]};function tk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qy,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}tk.isMDXComponent=!0;const ek={toc:[]};function nk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ek,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}nk.isMDXComponent=!0;const ok={toc:[]};function ck(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ok,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}ck.isMDXComponent=!0;const rk={toc:[]};function pk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pk.isMDXComponent=!0;const ak={toc:[]};function sk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ak,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}sk.isMDXComponent=!0;const lk={toc:[]};function ik(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ik.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},uk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},dk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}hk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},yk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}kk.isMDXComponent=!0;const fk={toc:[]};function Dk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},fk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Dk.isMDXComponent=!0;const Mk={toc:[]};function _k(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Mk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}_k.isMDXComponent=!0;const Xk={toc:[]};function wk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Xk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}wk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Tk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Ck.isMDXComponent=!0;const gk={toc:[]};function xk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},gk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}xk.isMDXComponent=!0;const Zk={toc:[]};function Lk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Zk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Lk.isMDXComponent=!0;const vk={toc:[]};function bk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},vk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}bk.isMDXComponent=!0;const Nk={toc:[]};function Ek(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Nk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Ek.isMDXComponent=!0;const Sk={toc:[]};function Ak(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Sk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Ak.isMDXComponent=!0;const Pk={toc:[]};function Wk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Pk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Wk.isMDXComponent=!0;const Fk={toc:[]};function Gk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Fk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Gk.isMDXComponent=!0;const Ik={toc:[]};function Rk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ik,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Rk.isMDXComponent=!0;const Uk={toc:[]};function jk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Uk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}jk.isMDXComponent=!0;const zk={toc:[]};function qk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},zk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}qk.isMDXComponent=!0;const Bk={toc:[]};function Vk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Bk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Vk.isMDXComponent=!0;const Ok={toc:[]};function Hk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ok,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Hk.isMDXComponent=!0;const $k={toc:[]};function Jk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},$k,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Jk.isMDXComponent=!0;const Kk={toc:[]};function Yk(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Kk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Yk.isMDXComponent=!0;const Qk={toc:[]};function tf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Qk,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}tf.isMDXComponent=!0;const ef={toc:[]};function nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ef,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nf.isMDXComponent=!0;const of={toc:[]};function cf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},of,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}cf.isMDXComponent=!0;const rf={toc:[]};function pf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},rf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}pf.isMDXComponent=!0;const af={toc:[]};function sf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},af,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}sf.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},lf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}yf.isMDXComponent=!0;const kf={toc:[]};function ff(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ff.isMDXComponent=!0;const Df={toc:[]};function Mf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Df,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Mf.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_f,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Xf.isMDXComponent=!0;const wf={toc:[]};function Tf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Tf.isMDXComponent=!0;const Cf={toc:[]};function gf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}gf.isMDXComponent=!0;const xf={toc:[]};function Zf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Zf.isMDXComponent=!0;const Lf={toc:[]};function vf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}vf.isMDXComponent=!0;const bf={toc:[]};function Nf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Nf.isMDXComponent=!0;const Ef={toc:[]};function Sf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ef,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Sf.isMDXComponent=!0;const Af={toc:[]};function Pf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Af,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Pf.isMDXComponent=!0;const Wf={toc:[]};function Ff(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Ff.isMDXComponent=!0;const Gf={toc:[]};function If(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}If.isMDXComponent=!0;const Rf={toc:[]};function Uf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Uf.isMDXComponent=!0;const jf={toc:[]};function zf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}zf.isMDXComponent=!0;const qf={toc:[]};function Bf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Bf.isMDXComponent=!0;const Vf={toc:[]};function Of(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Of.isMDXComponent=!0;const Hf={toc:[]};function $f(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}$f.isMDXComponent=!0;const Jf={toc:[]};function Kf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Kf.isMDXComponent=!0;const Yf={toc:[]};function Qf(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yf,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Qf.isMDXComponent=!0;const tD={toc:[]};function eD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}eD.isMDXComponent=!0;const nD={toc:[]};function oD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}oD.isMDXComponent=!0;const cD={toc:[]};function rD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}rD.isMDXComponent=!0;const pD={toc:[]};function aD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}aD.isMDXComponent=!0;const sD={toc:[]};function lD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}lD.isMDXComponent=!0;const iD={toc:[]};function uD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}yD.isMDXComponent=!0;const kD={toc:[]};function fD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}fD.isMDXComponent=!0;const DD={toc:[]};function MD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}MD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_D,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}XD.isMDXComponent=!0;const wD={toc:[]};function TD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}TD.isMDXComponent=!0;const CD={toc:[]};function gD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}gD.isMDXComponent=!0;const xD={toc:[]};function ZD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ZD.isMDXComponent=!0;const LD={toc:[]};function vD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}vD.isMDXComponent=!0;const bD={toc:[]};function ND(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ND.isMDXComponent=!0;const ED={toc:[]};function SD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ED,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}SD.isMDXComponent=!0;const AD={toc:[]};function PD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}PD.isMDXComponent=!0;const WD={toc:[]};function FD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}FD.isMDXComponent=!0;const GD={toc:[]};function ID(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ID.isMDXComponent=!0;const RD={toc:[]};function UD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}UD.isMDXComponent=!0;const jD={toc:[]};function zD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}zD.isMDXComponent=!0;const qD={toc:[]};function BD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}BD.isMDXComponent=!0;const VD={toc:[]};function OD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}OD.isMDXComponent=!0;const HD={toc:[]};function $D(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}$D.isMDXComponent=!0;const JD={toc:[]};function KD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}KD.isMDXComponent=!0;const YD={toc:[]};function QD(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YD,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}QD.isMDXComponent=!0;const tM={toc:[]};function eM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}eM.isMDXComponent=!0;const nM={toc:[]};function oM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}oM.isMDXComponent=!0;const cM={toc:[]};function rM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}rM.isMDXComponent=!0;const pM={toc:[]};function aM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}aM.isMDXComponent=!0;const sM={toc:[]};function lM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}lM.isMDXComponent=!0;const iM={toc:[]};function uM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}yM.isMDXComponent=!0;const kM={toc:[]};function fM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}fM.isMDXComponent=!0;const DM={toc:[]};function MM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}MM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_M,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}XM.isMDXComponent=!0;const wM={toc:[]};function TM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}TM.isMDXComponent=!0;const CM={toc:[]};function gM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}gM.isMDXComponent=!0;const xM={toc:[]};function ZM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}ZM.isMDXComponent=!0;const LM={toc:[]};function vM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}vM.isMDXComponent=!0;const bM={toc:[]};function NM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}NM.isMDXComponent=!0;const EM={toc:[]};function SM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}SM.isMDXComponent=!0;const AM={toc:[]};function PM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}PM.isMDXComponent=!0;const WM={toc:[]};function FM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}FM.isMDXComponent=!0;const GM={toc:[]};function IM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}IM.isMDXComponent=!0;const RM={toc:[]};function UM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}UM.isMDXComponent=!0;const jM={toc:[]};function zM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}zM.isMDXComponent=!0;const qM={toc:[]};function BM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}BM.isMDXComponent=!0;const VM={toc:[]};function OM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}OM.isMDXComponent=!0;const HM={toc:[]};function $M(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}$M.isMDXComponent=!0;const JM={toc:[]};function KM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}KM.isMDXComponent=!0;const YM={toc:[]};function QM(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YM,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}QM.isMDXComponent=!0;const t_={toc:[]};function e_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},t_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}e_.isMDXComponent=!0;const n_={toc:[]};function o_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},n_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}o_.isMDXComponent=!0;const c_={toc:[]};function r_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},c_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}r_.isMDXComponent=!0;const p_={toc:[]};function a_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},p_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}a_.isMDXComponent=!0;const s_={toc:[]};function l_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},s_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}l_.isMDXComponent=!0;const i_={toc:[]};function u_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},i_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},m_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},h_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}y_.isMDXComponent=!0;const k_={toc:[]};function f_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},k_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}f_.isMDXComponent=!0;const D_={toc:[]};function M_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},D_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}M_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},__,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}X_.isMDXComponent=!0;const w_={toc:[]};function T_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},w_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}T_.isMDXComponent=!0;const C_={toc:[]};function g_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},C_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}g_.isMDXComponent=!0;const x_={toc:[]};function Z_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},x_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Z_.isMDXComponent=!0;const L_={toc:[]};function v_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},L_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}v_.isMDXComponent=!0;const b_={toc:[]};function N_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},b_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}N_.isMDXComponent=!0;const E_={toc:[]};function S_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},E_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}S_.isMDXComponent=!0;const A_={toc:[]};function P_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},A_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}P_.isMDXComponent=!0;const W_={toc:[]};function F_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},W_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}F_.isMDXComponent=!0;const G_={toc:[]};function I_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},G_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}I_.isMDXComponent=!0;const R_={toc:[]};function U_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},R_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}U_.isMDXComponent=!0;const j_={toc:[]};function z_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},j_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}z_.isMDXComponent=!0;const q_={toc:[]};function B_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},q_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}B_.isMDXComponent=!0;const V_={toc:[]};function O_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},V_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}O_.isMDXComponent=!0;const H_={toc:[]};function $_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},H_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}$_.isMDXComponent=!0;const J_={toc:[]};function K_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},J_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}K_.isMDXComponent=!0;const Y_={toc:[]};function Q_(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Y_,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Q_.isMDXComponent=!0;const tX={toc:[]};function eX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}eX.isMDXComponent=!0;const nX={toc:[]};function oX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}oX.isMDXComponent=!0;const cX={toc:[]};function rX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}rX.isMDXComponent=!0;const pX={toc:[]};function aX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}aX.isMDXComponent=!0;const sX={toc:[]};function lX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}lX.isMDXComponent=!0;const iX={toc:[]};function uX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}yX.isMDXComponent=!0;const kX={toc:[]};function fX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}fX.isMDXComponent=!0;const DX={toc:[]};function MX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}MX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_X,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}XX.isMDXComponent=!0;const wX={toc:[]};function TX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}TX.isMDXComponent=!0;const CX={toc:[]};function gX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}gX.isMDXComponent=!0;const xX={toc:[]};function ZX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}ZX.isMDXComponent=!0;const LX={toc:[]};function vX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}vX.isMDXComponent=!0;const bX={toc:[]};function NX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}NX.isMDXComponent=!0;const EX={toc:[]};function SX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}SX.isMDXComponent=!0;const AX={toc:[]};function PX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}PX.isMDXComponent=!0;const WX={toc:[]};function FX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}FX.isMDXComponent=!0;const GX={toc:[]};function IX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}IX.isMDXComponent=!0;const RX={toc:[]};function UX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}UX.isMDXComponent=!0;const jX={toc:[]};function zX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}zX.isMDXComponent=!0;const qX={toc:[]};function BX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}BX.isMDXComponent=!0;const VX={toc:[]};function OX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}OX.isMDXComponent=!0;const HX={toc:[]};function $X(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}$X.isMDXComponent=!0;const JX={toc:[]};function KX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}KX.isMDXComponent=!0;const YX={toc:[]};function QX(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YX,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}QX.isMDXComponent=!0;const tw={toc:[]};function ew(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ew.isMDXComponent=!0;const nw={toc:[]};function ow(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}ow.isMDXComponent=!0;const cw={toc:[]};function rw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}rw.isMDXComponent=!0;const pw={toc:[]};function aw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}aw.isMDXComponent=!0;const sw={toc:[]};function lw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}lw.isMDXComponent=!0;const iw={toc:[]};function uw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}yw.isMDXComponent=!0;const kw={toc:[]};function fw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}fw.isMDXComponent=!0;const Dw={toc:[]};function Mw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Mw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_w,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Xw.isMDXComponent=!0;const ww={toc:[]};function Tw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ww,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Tw.isMDXComponent=!0;const Cw={toc:[]};function gw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}gw.isMDXComponent=!0;const xw={toc:[]};function Zw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Zw.isMDXComponent=!0;const Lw={toc:[]};function vw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}vw.isMDXComponent=!0;const bw={toc:[]};function Nw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Nw.isMDXComponent=!0;const Ew={toc:[]};function Sw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ew,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Sw.isMDXComponent=!0;const Aw={toc:[]};function Pw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Aw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Pw.isMDXComponent=!0;const Ww={toc:[]};function Fw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ww,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Fw.isMDXComponent=!0;const Gw={toc:[]};function Iw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Iw.isMDXComponent=!0;const Rw={toc:[]};function Uw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Uw.isMDXComponent=!0;const jw={toc:[]};function zw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}zw.isMDXComponent=!0;const qw={toc:[]};function Bw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Bw.isMDXComponent=!0;const Vw={toc:[]};function Ow(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Ow.isMDXComponent=!0;const Hw={toc:[]};function $w(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}$w.isMDXComponent=!0;const Jw={toc:[]};function Kw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Kw.isMDXComponent=!0;const Yw={toc:[]};function Qw(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yw,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Qw.isMDXComponent=!0;const tT={toc:[]};function eT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}eT.isMDXComponent=!0;const nT={toc:[]};function oT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}oT.isMDXComponent=!0;const cT={toc:[]};function rT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}rT.isMDXComponent=!0;const pT={toc:[]};function aT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}aT.isMDXComponent=!0;const sT={toc:[]};function lT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}lT.isMDXComponent=!0;const iT={toc:[]};function uT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}yT.isMDXComponent=!0;const kT={toc:[]};function fT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}fT.isMDXComponent=!0;const DT={toc:[]};function MT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}MT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_T,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}XT.isMDXComponent=!0;const wT={toc:[]};function TT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}TT.isMDXComponent=!0;const CT={toc:[]};function gT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}gT.isMDXComponent=!0;const xT={toc:[]};function ZT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ZT.isMDXComponent=!0;const LT={toc:[]};function vT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}vT.isMDXComponent=!0;const bT={toc:[]};function NT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}NT.isMDXComponent=!0;const ET={toc:[]};function ST(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ET,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}ST.isMDXComponent=!0;const AT={toc:[]};function PT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}PT.isMDXComponent=!0;const WT={toc:[]};function FT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}FT.isMDXComponent=!0;const GT={toc:[]};function IT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}IT.isMDXComponent=!0;const RT={toc:[]};function UT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}UT.isMDXComponent=!0;const jT={toc:[]};function zT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}zT.isMDXComponent=!0;const qT={toc:[]};function BT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}BT.isMDXComponent=!0;const VT={toc:[]};function OT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}OT.isMDXComponent=!0;const HT={toc:[]};function $T(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}$T.isMDXComponent=!0;const JT={toc:[]};function KT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}KT.isMDXComponent=!0;const YT={toc:[]};function QT(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YT,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}QT.isMDXComponent=!0;const tC={toc:[]};function eC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}eC.isMDXComponent=!0;const nC={toc:[]};function oC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}oC.isMDXComponent=!0;const cC={toc:[]};function rC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}rC.isMDXComponent=!0;const pC={toc:[]};function aC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}aC.isMDXComponent=!0;const sC={toc:[]};function lC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}lC.isMDXComponent=!0;const iC={toc:[]};function uC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}yC.isMDXComponent=!0;const kC={toc:[]};function fC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}fC.isMDXComponent=!0;const DC={toc:[]};function MC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}MC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_C,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}XC.isMDXComponent=!0;const wC={toc:[]};function TC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}TC.isMDXComponent=!0;const CC={toc:[]};function gC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}gC.isMDXComponent=!0;const xC={toc:[]};function ZC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}ZC.isMDXComponent=!0;const LC={toc:[]};function vC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}vC.isMDXComponent=!0;const bC={toc:[]};function NC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}NC.isMDXComponent=!0;const EC={toc:[]};function SC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}SC.isMDXComponent=!0;const AC={toc:[]};function PC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}PC.isMDXComponent=!0;const WC={toc:[]};function FC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}FC.isMDXComponent=!0;const GC={toc:[]};function IC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}IC.isMDXComponent=!0;const RC={toc:[]};function UC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}UC.isMDXComponent=!0;const jC={toc:[]};function zC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}zC.isMDXComponent=!0;const qC={toc:[]};function BC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}BC.isMDXComponent=!0;const VC={toc:[]};function OC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}OC.isMDXComponent=!0;const HC={toc:[]};function $C(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}$C.isMDXComponent=!0;const JC={toc:[]};function KC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}KC.isMDXComponent=!0;const YC={toc:[]};function QC(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YC,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}QC.isMDXComponent=!0;const tg={toc:[]};function eg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}eg.isMDXComponent=!0;const ng={toc:[]};function og(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ng,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}og.isMDXComponent=!0;const cg={toc:[]};function rg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}rg.isMDXComponent=!0;const pg={toc:[]};function ag(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ag.isMDXComponent=!0;const sg={toc:[]};function lg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}lg.isMDXComponent=!0;const ig={toc:[]};function ug(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ig,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}yg.isMDXComponent=!0;const kg={toc:[]};function fg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}fg.isMDXComponent=!0;const Dg={toc:[]};function Mg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Mg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_g,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Xg.isMDXComponent=!0;const wg={toc:[]};function Tg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Tg.isMDXComponent=!0;const Cg={toc:[]};function gg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}gg.isMDXComponent=!0;const xg={toc:[]};function Zg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}Zg.isMDXComponent=!0;const Lg={toc:[]};function vg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}vg.isMDXComponent=!0;const bg={toc:[]};function Ng(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ng.isMDXComponent=!0;const Eg={toc:[]};function Sg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Sg.isMDXComponent=!0;const Ag={toc:[]};function Pg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ag,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Pg.isMDXComponent=!0;const Wg={toc:[]};function Fg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Fg.isMDXComponent=!0;const Gg={toc:[]};function Ig(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Ig.isMDXComponent=!0;const Rg={toc:[]};function Ug(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Ug.isMDXComponent=!0;const jg={toc:[]};function zg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}zg.isMDXComponent=!0;const qg={toc:[]};function Bg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Bg.isMDXComponent=!0;const Vg={toc:[]};function Og(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Og.isMDXComponent=!0;const Hg={toc:[]};function $g(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}$g.isMDXComponent=!0;const Jg={toc:[]};function Kg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Kg.isMDXComponent=!0;const Yg={toc:[]};function Qg(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yg,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Qg.isMDXComponent=!0;const tx={toc:[]};function ex(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}ex.isMDXComponent=!0;const nx={toc:[]};function ox(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ox.isMDXComponent=!0;const cx={toc:[]};function rx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}rx.isMDXComponent=!0;const px={toc:[]};function ax(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},px,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ax.isMDXComponent=!0;const sx={toc:[]};function lx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}lx.isMDXComponent=!0;const ix={toc:[]};function ux(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ix,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}yx.isMDXComponent=!0;const kx={toc:[]};function fx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}fx.isMDXComponent=!0;const Dx={toc:[]};function Mx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Mx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_x,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Xx.isMDXComponent=!0;const wx={toc:[]};function Tx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Tx.isMDXComponent=!0;const Cx={toc:[]};function gx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}gx.isMDXComponent=!0;const xx={toc:[]};function Zx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Zx.isMDXComponent=!0;const Lx={toc:[]};function vx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}vx.isMDXComponent=!0;const bx={toc:[]};function Nx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Nx.isMDXComponent=!0;const Ex={toc:[]};function Sx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ex,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Sx.isMDXComponent=!0;const Ax={toc:[]};function Px(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ax,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Px.isMDXComponent=!0;const Wx={toc:[]};function Fx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Fx.isMDXComponent=!0;const Gx={toc:[]};function Ix(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Ix.isMDXComponent=!0;const Rx={toc:[]};function Ux(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Ux.isMDXComponent=!0;const jx={toc:[]};function zx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}zx.isMDXComponent=!0;const qx={toc:[]};function Bx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Bx.isMDXComponent=!0;const Vx={toc:[]};function Ox(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Ox.isMDXComponent=!0;const Hx={toc:[]};function $x(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}$x.isMDXComponent=!0;const Jx={toc:[]};function Kx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Kx.isMDXComponent=!0;const Yx={toc:[]};function Qx(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yx,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Qx.isMDXComponent=!0;const tZ={toc:[]};function eZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}eZ.isMDXComponent=!0;const nZ={toc:[]};function oZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}oZ.isMDXComponent=!0;const cZ={toc:[]};function rZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}rZ.isMDXComponent=!0;const pZ={toc:[]};function aZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}aZ.isMDXComponent=!0;const sZ={toc:[]};function lZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}lZ.isMDXComponent=!0;const iZ={toc:[]};function uZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}yZ.isMDXComponent=!0;const kZ={toc:[]};function fZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}fZ.isMDXComponent=!0;const DZ={toc:[]};function MZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}MZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_Z,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}XZ.isMDXComponent=!0;const wZ={toc:[]};function TZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}TZ.isMDXComponent=!0;const CZ={toc:[]};function gZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}gZ.isMDXComponent=!0;const xZ={toc:[]};function ZZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}ZZ.isMDXComponent=!0;const LZ={toc:[]};function vZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}vZ.isMDXComponent=!0;const bZ={toc:[]};function NZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}NZ.isMDXComponent=!0;const EZ={toc:[]};function SZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}SZ.isMDXComponent=!0;const AZ={toc:[]};function PZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}PZ.isMDXComponent=!0;const WZ={toc:[]};function FZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}FZ.isMDXComponent=!0;const GZ={toc:[]};function IZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}IZ.isMDXComponent=!0;const RZ={toc:[]};function UZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}UZ.isMDXComponent=!0;const jZ={toc:[]};function zZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}zZ.isMDXComponent=!0;const qZ={toc:[]};function BZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}BZ.isMDXComponent=!0;const VZ={toc:[]};function OZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}OZ.isMDXComponent=!0;const HZ={toc:[]};function $Z(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}$Z.isMDXComponent=!0;const JZ={toc:[]};function KZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}KZ.isMDXComponent=!0;const YZ={toc:[]};function QZ(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YZ,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}QZ.isMDXComponent=!0;const tL={toc:[]};function eL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}eL.isMDXComponent=!0;const nL={toc:[]};function oL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}oL.isMDXComponent=!0;const cL={toc:[]};function rL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}rL.isMDXComponent=!0;const pL={toc:[]};function aL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}aL.isMDXComponent=!0;const sL={toc:[]};function lL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}lL.isMDXComponent=!0;const iL={toc:[]};function uL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}yL.isMDXComponent=!0;const kL={toc:[]};function fL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}fL.isMDXComponent=!0;const DL={toc:[]};function ML(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}ML.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_L,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}XL.isMDXComponent=!0;const wL={toc:[]};function TL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}TL.isMDXComponent=!0;const CL={toc:[]};function gL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}gL.isMDXComponent=!0;const xL={toc:[]};function ZL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ZL.isMDXComponent=!0;const LL={toc:[]};function vL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}vL.isMDXComponent=!0;const bL={toc:[]};function NL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}NL.isMDXComponent=!0;const EL={toc:[]};function SL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}SL.isMDXComponent=!0;const AL={toc:[]};function PL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}PL.isMDXComponent=!0;const WL={toc:[]};function FL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}FL.isMDXComponent=!0;const GL={toc:[]};function IL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}IL.isMDXComponent=!0;const RL={toc:[]};function UL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}UL.isMDXComponent=!0;const jL={toc:[]};function zL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}zL.isMDXComponent=!0;const qL={toc:[]};function BL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}BL.isMDXComponent=!0;const VL={toc:[]};function OL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}OL.isMDXComponent=!0;const HL={toc:[]};function $L(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}$L.isMDXComponent=!0;const JL={toc:[]};function KL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}KL.isMDXComponent=!0;const YL={toc:[]};function QL(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YL,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}QL.isMDXComponent=!0;const tv={toc:[]};function ev(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}ev.isMDXComponent=!0;const nv={toc:[]};function ov(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}ov.isMDXComponent=!0;const cv={toc:[]};function rv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}rv.isMDXComponent=!0;const pv={toc:[]};function av(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}av.isMDXComponent=!0;const sv={toc:[]};function lv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}lv.isMDXComponent=!0;const iv={toc:[]};function uv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}yv.isMDXComponent=!0;const kv={toc:[]};function fv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}fv.isMDXComponent=!0;const Dv={toc:[]};function Mv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Dv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Mv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_v,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Xv.isMDXComponent=!0;const wv={toc:[]};function Tv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Tv.isMDXComponent=!0;const Cv={toc:[]};function gv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}gv.isMDXComponent=!0;const xv={toc:[]};function Zv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Zv.isMDXComponent=!0;const Lv={toc:[]};function vv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}vv.isMDXComponent=!0;const bv={toc:[]};function Nv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Nv.isMDXComponent=!0;const Ev={toc:[]};function Sv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ev,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Sv.isMDXComponent=!0;const Av={toc:[]};function Pv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Av,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Pv.isMDXComponent=!0;const Wv={toc:[]};function Fv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Fv.isMDXComponent=!0;const Gv={toc:[]};function Iv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Iv.isMDXComponent=!0;const Rv={toc:[]};function Uv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Uv.isMDXComponent=!0;const jv={toc:[]};function zv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}zv.isMDXComponent=!0;const qv={toc:[]};function Bv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Bv.isMDXComponent=!0;const Vv={toc:[]};function Ov(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Ov.isMDXComponent=!0;const Hv={toc:[]};function $v(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}$v.isMDXComponent=!0;const Jv={toc:[]};function Kv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Kv.isMDXComponent=!0;const Yv={toc:[]};function Qv(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yv,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Qv.isMDXComponent=!0;const tb={toc:[]};function eb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}eb.isMDXComponent=!0;const nb={toc:[]};function ob(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}ob.isMDXComponent=!0;const cb={toc:[]};function rb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}rb.isMDXComponent=!0;const pb={toc:[]};function ab(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}ab.isMDXComponent=!0;const sb={toc:[]};function lb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}lb.isMDXComponent=!0;const ib={toc:[]};function ub(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ib,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}yb.isMDXComponent=!0;const kb={toc:[]};function fb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}fb.isMDXComponent=!0;const Db={toc:[]};function Mb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Db,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Mb.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_b,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Xb.isMDXComponent=!0;const wb={toc:[]};function Tb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Tb.isMDXComponent=!0;const Cb={toc:[]};function gb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Cb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}gb.isMDXComponent=!0;const xb={toc:[]};function Zb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Zb.isMDXComponent=!0;const Lb={toc:[]};function vb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Lb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}vb.isMDXComponent=!0;const bb={toc:[]};function Nb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Nb.isMDXComponent=!0;const Eb={toc:[]};function Sb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Eb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Sb.isMDXComponent=!0;const Ab={toc:[]};function Pb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Ab,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Pb.isMDXComponent=!0;const Wb={toc:[]};function Fb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Wb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Fb.isMDXComponent=!0;const Gb={toc:[]};function Ib(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Gb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Ib.isMDXComponent=!0;const Rb={toc:[]};function Ub(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Rb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Ub.isMDXComponent=!0;const jb={toc:[]};function zb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}zb.isMDXComponent=!0;const qb={toc:[]};function Bb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Bb.isMDXComponent=!0;const Vb={toc:[]};function Ob(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Vb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Ob.isMDXComponent=!0;const Hb={toc:[]};function $b(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Hb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$b.isMDXComponent=!0;const Jb={toc:[]};function Kb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Jb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Kb.isMDXComponent=!0;const Yb={toc:[]};function Qb(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},Yb,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Qb.isMDXComponent=!0;const tN={toc:[]};function eN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}eN.isMDXComponent=!0;const nN={toc:[]};function oN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oN.isMDXComponent=!0;const cN={toc:[]};function rN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}rN.isMDXComponent=!0;const pN={toc:[]};function aN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}aN.isMDXComponent=!0;const sN={toc:[]};function lN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}lN.isMDXComponent=!0;const iN={toc:[]};function uN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}yN.isMDXComponent=!0;const kN={toc:[]};function fN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}fN.isMDXComponent=!0;const DN={toc:[]};function MN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}MN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_N,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}XN.isMDXComponent=!0;const wN={toc:[]};function TN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}TN.isMDXComponent=!0;const CN={toc:[]};function gN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}gN.isMDXComponent=!0;const xN={toc:[]};function ZN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}ZN.isMDXComponent=!0;const LN={toc:[]};function vN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}vN.isMDXComponent=!0;const bN={toc:[]};function NN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}NN.isMDXComponent=!0;const EN={toc:[]};function SN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}SN.isMDXComponent=!0;const AN={toc:[]};function PN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}PN.isMDXComponent=!0;const WN={toc:[]};function FN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}FN.isMDXComponent=!0;const GN={toc:[]};function IN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}IN.isMDXComponent=!0;const RN={toc:[]};function UN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}UN.isMDXComponent=!0;const jN={toc:[]};function zN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}zN.isMDXComponent=!0;const qN={toc:[]};function BN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}BN.isMDXComponent=!0;const VN={toc:[]};function ON(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ON.isMDXComponent=!0;const HN={toc:[]};function $N(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}$N.isMDXComponent=!0;const JN={toc:[]};function KN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}KN.isMDXComponent=!0;const YN={toc:[]};function QN(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YN,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}QN.isMDXComponent=!0;const tE={toc:[]};function eE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}eE.isMDXComponent=!0;const nE={toc:[]};function oE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}oE.isMDXComponent=!0;const cE={toc:[]};function rE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}rE.isMDXComponent=!0;const pE={toc:[]};function aE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}aE.isMDXComponent=!0;const sE={toc:[]};function lE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}lE.isMDXComponent=!0;const iE={toc:[]};function uE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}uE.isMDXComponent=!0;const mE={toc:[]};function dE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}dE.isMDXComponent=!0;const hE={toc:[]};function yE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}yE.isMDXComponent=!0;const kE={toc:[]};function fE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}fE.isMDXComponent=!0;const DE={toc:[]};function ME(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}ME.isMDXComponent=!0;const _E={toc:[]};function XE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_E,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}XE.isMDXComponent=!0;const wE={toc:[]};function TE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}TE.isMDXComponent=!0;const CE={toc:[]};function gE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}gE.isMDXComponent=!0;const xE={toc:[]};function ZE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}ZE.isMDXComponent=!0;const LE={toc:[]};function vE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}vE.isMDXComponent=!0;const bE={toc:[]};function NE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}NE.isMDXComponent=!0;const EE={toc:[]};function SE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}SE.isMDXComponent=!0;const AE={toc:[]};function PE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}PE.isMDXComponent=!0;const WE={toc:[]};function FE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}FE.isMDXComponent=!0;const GE={toc:[]};function IE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}IE.isMDXComponent=!0;const RE={toc:[]};function UE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}UE.isMDXComponent=!0;const jE={toc:[]};function zE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}zE.isMDXComponent=!0;const qE={toc:[]};function BE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}BE.isMDXComponent=!0;const VE={toc:[]};function OE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}OE.isMDXComponent=!0;const HE={toc:[]};function $E(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}$E.isMDXComponent=!0;const JE={toc:[]};function KE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}KE.isMDXComponent=!0;const YE={toc:[]};function QE(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YE,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}QE.isMDXComponent=!0;const tS={toc:[]};function eS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}eS.isMDXComponent=!0;const nS={toc:[]};function oS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}oS.isMDXComponent=!0;const cS={toc:[]};function rS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}rS.isMDXComponent=!0;const pS={toc:[]};function aS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}aS.isMDXComponent=!0;const sS={toc:[]};function lS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}lS.isMDXComponent=!0;const iS={toc:[]};function uS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}yS.isMDXComponent=!0;const kS={toc:[]};function fS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}fS.isMDXComponent=!0;const DS={toc:[]};function MS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}MS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_S,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}XS.isMDXComponent=!0;const wS={toc:[]};function TS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}TS.isMDXComponent=!0;const CS={toc:[]};function gS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}gS.isMDXComponent=!0;const xS={toc:[]};function ZS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,p.kt)("p",null,"By default, any property is cloneable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}ZS.isMDXComponent=!0;const LS={toc:[]};function vS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}vS.isMDXComponent=!0;const bS={toc:[]};function NS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a cloneable property decorator."))}NS.isMDXComponent=!0;const ES={toc:[]};function SS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},ES,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be cloneable."))}SS.isMDXComponent=!0;const AS={toc:[]};function PS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}PS.isMDXComponent=!0;const WS={toc:[]};function FS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}FS.isMDXComponent=!0;const GS={toc:[]};function IS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a compound property decorator."))}IS.isMDXComponent=!0;const RS={toc:[]};function US(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}US.isMDXComponent=!0;const jS={toc:[]};function zS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,p.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,p.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}zS.isMDXComponent=!0;const qS={toc:[]};function BS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a computed method decorator."))}BS.isMDXComponent=!0;const VS={toc:[]};function OS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the initial value of a property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}OS.isMDXComponent=!0;const HS={toc:[]};function $S(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}$S.isMDXComponent=!0;const JS={toc:[]};function KS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an initial signal value decorator."))}KS.isMDXComponent=!0;const YS={toc:[]};function QS(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YS,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the property."))}QS.isMDXComponent=!0;const tA={toc:[]};function eA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,p.kt)("p",null,"By default, any property is inspectable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}eA.isMDXComponent=!0;const nA={toc:[]};function oA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}oA.isMDXComponent=!0;const cA={toc:[]};function rA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an inspectable property decorator."))}rA.isMDXComponent=!0;const pA={toc:[]};function aA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be inspectable."))}aA.isMDXComponent=!0;const sA={toc:[]};function lA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}lA.isMDXComponent=!0;const iA={toc:[]};function uA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal interpolation function decorator."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function for the property."))}yA.isMDXComponent=!0;const kA={toc:[]};function fA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,p.kt)("p",null,"If the wrapper class has a method called ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}fA.isMDXComponent=!0;const DA={toc:[]};function MA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}MA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},_A,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal parser decorator."))}XA.isMDXComponent=!0;const wA={toc:[]};function TA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},wA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}TA.isMDXComponent=!0;const CA={toc:[]};function gA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},CA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given property into a signal."),(0,p.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}gA.isMDXComponent=!0;const xA={toc:[]};function ZA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},xA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}ZA.isMDXComponent=!0;const LA={toc:[]};function vA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},LA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal decorator."))}vA.isMDXComponent=!0;const bA={toc:[]};function NA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},bA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,p.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,p.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,p.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}NA.isMDXComponent=!0;const EA={toc:[]};function SA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},EA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}SA.isMDXComponent=!0;const AA={toc:[]};function PA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},AA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal wrapper decorator."))}PA.isMDXComponent=!0;const WA={toc:[]};function FA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},WA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}FA.isMDXComponent=!0;const GA={toc:[]};function IA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},GA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A unified abstraction for all CSS filters."))}IA.isMDXComponent=!0;const RA={toc:[]};function UA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},RA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,p.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}UA.isMDXComponent=!0;const jA={toc:[]};function zA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},jA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in pixels."))}zA.isMDXComponent=!0;const qA={toc:[]};function BA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},qA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,p.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}BA.isMDXComponent=!0;const VA={toc:[]};function OA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},VA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}OA.isMDXComponent=!0;const HA={toc:[]};function $A(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},HA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,p.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}$A.isMDXComponent=!0;const JA={toc:[]};function KA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},JA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}KA.isMDXComponent=!0;const YA={toc:[]};function QA(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},YA,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,p.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}QA.isMDXComponent=!0;const tP={toc:[]};function eP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},tP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}eP.isMDXComponent=!0;const nP={toc:[]};function oP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},nP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,p.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}oP.isMDXComponent=!0;const cP={toc:[]};function rP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},cP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in degrees."))}rP.isMDXComponent=!0;const pP={toc:[]};function aP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},pP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,p.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}aP.isMDXComponent=!0;const sP={toc:[]};function lP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},sP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}lP.isMDXComponent=!0;const iP={toc:[]};function uP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},iP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,p.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},mP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}dP.isMDXComponent=!0;const hP={toc:[]};function yP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},hP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,p.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}yP.isMDXComponent=!0;const kP={toc:[]};function fP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},kP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}fP.isMDXComponent=!0;const DP={toc:[]};function MP(t){let{components:e,...n}=t;return(0,p.kt)("wrapper",(0,r.Z)({},DP,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}function _P(t){let{id:e}=t;const n=o[e]??c.Fragment;return c.createElement(n,null)}MP.isMDXComponent=!0},8943:(t,e,n)=>{n.d(e,{Z:()=>r});var o=n(2784),c=n(4791);function r(t){let{comment:e,full:n=!0}=t;const r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@remarks"===e}))}),[e]);return o.createElement(o.Fragment,null,o.createElement(c.Z,{id:null==e?void 0:e.summaryId}),o.createElement(c.Z,{id:null==r?void 0:r.contentId}),n&&o.createElement(p,{comment:e}))}function p(t){let{comment:e}=t;const n=(0,o.useMemo)((()=>{var t;return(null==e||null==(t=e.blockTags)?void 0:t.filter((t=>{let{tag:e}=t;return"@example"===e})))??[]}),[e]),r=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@deprecated"===e}))}),[e]),p=(0,o.useMemo)((()=>{var t;return null==e||null==(t=e.blockTags)?void 0:t.find((t=>{let{tag:e}=t;return"@see"===e}))}),[e]);return o.createElement(o.Fragment,null,n.length>0&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Examples"),n.map((t=>o.createElement(c.Z,{key:t.contentId,id:t.contentId})))),r&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Deprecated"),o.createElement(c.Z,{id:r.contentId})),p&&o.createElement(o.Fragment,null,o.createElement("h4",null,"See also"),o.createElement(c.Z,{id:p.contentId})))}},1836:(t,e,n)=>{n.d(e,{Z:()=>At});var o=n(2784),c=n(7390),r=n(6835),p=n(68),a=n(6277),s=n(8569);const l={list:"list__hZI",elements:"elements_bdzb",wrap:"wrap_iQ7y",element:"element_nvvE",left:"left_HhPc",angle:"angle_VN_b",curly:"curly_EVXr",square:"square_psNU",parentheses:"parentheses_lWmE",codeBlockContainer:"codeBlockContainer_tfjS",blockSeparator:"blockSeparator_qZiC",codeBlock:"codeBlock_LRvA",highlight:"highlight_l8HV",pointer:"pointer_oZMZ"};var i=n(7896);function u(t){let{width:e=24,height:n=24,...c}=t;return o.createElement("svg",(0,i.Z)({width:e,height:n,"aria-hidden":"true",viewBox:"0 0 24 24"},c),o.createElement("path",{d:"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z",fill:"currentColor"}))}function m(t){let{children:e,highlight:n,onClick:c,link:i}=t;const m=(0,r.F)(),d=(0,p.s2)();return o.createElement("div",{className:(0,a.Z)(s.Z.codeBlockContent,l.codeBlock,n&&l.highlight,c&&l.pointer)},o.createElement("pre",{onClick:c,onKeyDown:t=>{"Enter"===t.key&&(null==c||c())},tabIndex:0,ref:m.codeBlockRef,className:(0,a.Z)(s.Z.codeBlock,"thin-scrollbar")},o.createElement("code",{className:s.Z.codeBlockLines,style:d},e)),i&&o.createElement("div",{className:s.Z.buttonGroup},o.createElement("button",{title:"Go to source",className:"clean-btn",onClick:t=>{t.preventDefault(),window.open(i,"_blank")}},o.createElement(u,{width:18,height:18}))))}var d=n(9318);function h(t){let{children:e}=t;return o.createElement(d.Z,{as:"div",className:(0,a.Z)(l.codeBlockContainer,"language-typescript")},e)}var y=n(9817);function k(t){let{children:e,type:n,to:c,id:r,tooltip:a}=t;const s=(0,p.Ld)(n);return c?o.createElement(y.Z,(0,i.Z)({id:r,to:c,"data-tooltip":a},s),e):o.createElement("span",(0,i.Z)({id:r},s),e)}let f,D;!function(t){t[t.None=0]="None",t[t.Angle=1]="Angle",t[t.Curly=2]="Curly",t[t.Square=3]="Square",t[t.Parentheses=4]="Parentheses"}(f||(f={})),function(t){t.Comma=", ",t.Pipe=" | ",t.Ampersand=" & "}(D||(D={}));const M={[f.None]:l.none,[f.Angle]:l.angle,[f.Curly]:l.curly,[f.Square]:l.square,[f.Parentheses]:l.parentheses};function _(t){let{children:e,type:n,separator:c=D.Comma}=t;return o.createElement("span",{className:(0,a.Z)(l.list,M[n??f.None])},o.createElement("span",{className:(0,a.Z)(l.elements,c!==D.Comma&&l.left)},(Array.isArray(e)?e:[e]).flatMap(((t,e)=>o.createElement("span",{"data-separator":c,key:e,className:l.element},t)))))}var X=n(8617);function w(t){var e;let{type:n}=t;const c=(0,X.RU)(n.project),r=null==c?void 0:c[n.id],p=n.externalUrl??(0,X.Gr)(r);return o.createElement(o.Fragment,null,o.createElement(k,{to:p,type:p?"class-name":"constant",tooltip:!0},n.name),!(null==(e=n.typeArguments)||!e.length)&&o.createElement(_,{type:f.Angle},n.typeArguments.map(((t,e)=>o.createElement(I,{key:e,type:t})))))}function T(t){let{type:e}=t;return o.createElement(k,{type:"keyword"},e.name)}function C(t){let{type:e}=t;return e.elements?o.createElement(_,{type:f.Square},e.elements.map(((t,e)=>o.createElement(I,{key:e,type:t})))):o.createElement(o.Fragment,null,"[]")}function g(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(I,{type:e.elementType}),"[]")}function x(t){let{type:e}=t;return o.createElement(_,{type:f.Parentheses,separator:D.Pipe},e.types.map(((t,e)=>o.createElement(I,{key:e,type:t}))))}function Z(t){let{type:e}=t;const[n,c]=(0,o.useMemo)((()=>{if(null===e.value)return["null","keyword"];switch(typeof e.value){case"object":return[(e.value.negative?"-":"")+e.value.value,"number"];case"boolean":return[e.value,"keyword"];case"number":return[e.value,"number"];case"string":return[`'${e.value}'`,"string"];default:return[e.value,"constant"]}}),[e.value]);return o.createElement(k,{type:c},n)}function L(t){let{type:e}=t;return e.asserts?o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"asserts "),o.createElement(k,null,e.name," ")):o.createElement(o.Fragment,null,o.createElement(k,null,e.name," "),o.createElement(k,{type:"keyword"},"is "),o.createElement(I,{type:e.targetType}))}function v(t){let{type:e}=t;const n=(0,X.in)();return o.createElement(J,{reflection:n(e.declaration)})}function b(t){let{type:e}=t;return o.createElement(_,{type:f.Parentheses,separator:D.Ampersand},e.types.map(((t,e)=>o.createElement(I,{key:e,type:t}))))}function N(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"string"},"`",e.head),e.tail.map(((t,e)=>{let[n,c]=t;return o.createElement(o.Fragment,null,"${",o.createElement(I,{key:e,type:n}),"}",o.createElement(k,{type:"string"},c))})),o.createElement(k,{type:"string"},"`"))}function E(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"typeof "),o.createElement(I,{type:e.queryType}))}function S(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(I,{type:e.checkType}),o.createElement(k,{type:"keyword"}," extends "),o.createElement(I,{type:e.extendsType})," ? ",o.createElement(I,{type:e.trueType})," : ",o.createElement(I,{type:e.falseType}))}function A(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"infer "),o.createElement(k,{type:"constant"},e.name))}function P(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(I,{type:e.objectType}),"[",o.createElement(I,{type:e.indexType}),"]")}function W(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},e.operator," "),o.createElement(I,{type:e.target}))}function F(t){let{type:e}=t;return o.createElement(o.Fragment,null,o.createElement(_,{type:f.Curly},o.createElement(o.Fragment,null,"[",o.createElement(k,{type:"class"},e.parameter),o.createElement(k,{type:"keyword"}," in "),o.createElement(I,{type:e.parameterType}),"]: ",o.createElement(I,{type:e.templateType}))))}function G(t){let{type:e}=t;return o.createElement(o.Fragment,null,e.name,": ",o.createElement(I,{type:e.element}))}function I(t){const e=(0,o.useMemo)((()=>{switch(t.type.type){case"rest":case"optional":case"unknown":break;case"typeOperator":return W;case"conditional":return S;case"reflection":return v;case"query":return E;case"named-tuple-member":return G;case"union":return x;case"intrinsic":return T;case"literal":return Z;case"reference":return w;case"predicate":return L;case"tuple":return C;case"array":return g;case"intersection":return b;case"inferred":return A;case"mapped":return F;case"template-literal":return N;case"indexedAccess":return P}throw new Error(`Missing component for type: ${t.type.type}`)}),[t.type]);return o.createElement(e,t)}function R(t){let{flags:e,explicitAccessModifier:n}=t;const c=[];return null!=e&&e.isAbstract&&c.push("abstract"),null!=e&&e.isStatic&&c.push("static"),null!=e&&e.isConst&&c.push("const"),null!=e&&e.isReadonly&&c.push("readonly"),null!=e&&e.isPrivate&&c.push("private"),null!=e&&e.isProtected&&c.push("protected"),(null==e||!e.isPublic)&&(!n||null!=e&&e.isProtected||null!=e&&e.isPrivate)||c.push("public"),o.createElement(o.Fragment,null,c.map((t=>o.createElement(k,{key:t,type:"keyword"},t," "))))}function U(t){let{reflection:e}=t;const n="__namedParameters"===e.name?"{...}":e.name;return o.createElement(o.Fragment,null,o.createElement(R,{flags:e.flags}),e.flags.isRest&&"...",o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"plain"},n),e.flags.isOptional&&"?",": ",e.type&&o.createElement(I,{type:e.type}),e.defaultValue&&o.createElement(o.Fragment,null," = ",o.createElement(k,{type:"plain"},e.defaultValue)))}function j(t){let{reflection:e}=t;return o.createElement(o.Fragment,null,o.createElement(R,{flags:e.flags}),e.varianceModifier&&o.createElement(k,{type:"keyword"},e.varianceModifier," "),o.createElement(k,{id:e.anchor,to:e.anchor?`#${e.anchor}`:void 0,type:"class-name"},e.name),e.type&&o.createElement(o.Fragment,null," extends ",o.createElement(I,{type:e.type})),e.default&&o.createElement(o.Fragment,null," = ",o.createElement(I,{type:e.default})))}function z(t){var e,n;let{reflection:r,flags:p}=t;const a=(0,X.in)(),s="__type"===r.name;return o.createElement(o.Fragment,null,o.createElement(R,{flags:p??r.flags,explicitAccessModifier:!s}),r.kind===c.W.GetSignature&&o.createElement(k,{type:"keyword"},"get "),r.kind===c.W.SetSignature&&o.createElement(k,{type:"keyword"},"set "),r.overwrites&&o.createElement(o.Fragment,null,o.createElement(k,{to:r.overwrites.externalUrl??(0,X.Gr)(a(r.overwrites.id)),type:"keyword"},"override")," "),r.kind===c.W.ConstructorSignature?o.createElement(o.Fragment,null,o.createElement(k,{to:"#",type:"keyword"},"new")," ",o.createElement(k,{type:"plain"},r.type.name)):s?"":o.createElement(k,{type:"function"},r.name),!(null==(e=r.typeParameter)||!e.length)&&o.createElement(_,{type:f.Angle},r.typeParameter.map((t=>o.createElement(j,{key:t.id,reflection:a(t)})))),null!=(n=r.parameters)&&n.length?o.createElement(_,{type:f.Parentheses},r.parameters.map((t=>o.createElement(U,{key:t,reflection:a(t)})))):"()",r.type&&o.createElement(o.Fragment,null,s?" => ":": ",o.createElement(I,{type:r.type})))}function q(t){let{reflection:e}=t;return o.createElement(U,{reflection:e})}const B={[c.W.Namespace]:"namespace",[c.W.Enum]:"enum",[c.W.Class]:"class",[c.W.Interface]:"interface"};function V(t){var e,n,c;let{reflection:r}=t;const p=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(R,{flags:r.flags}),o.createElement(k,{type:"keyword"},B[r.kind]," "),o.createElement(k,{type:"class-name"},r.name),!(null==(e=r.typeParameters)||!e.length)&&o.createElement(_,{type:f.Angle},r.typeParameters.map((t=>o.createElement(j,{key:t.id,reflection:p(t)}))))," ",!(null==(n=r.extendedTypes)||!n.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"extends "),o.createElement(_,null,r.extendedTypes.map(((t,e)=>o.createElement(I,{key:e,type:t}))))),!(null==(c=r.implementedTypes)||!c.length)&&o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"implements "),o.createElement(_,null,r.implementedTypes.map(((t,e)=>o.createElement(I,{key:e,type:t}))))))}function O(t){let{reflection:e}=t;const n=(0,X.in)();return o.createElement(o.Fragment,null,o.createElement(R,{flags:e.flags}),o.createElement(k,{type:"keyword"},"type "),o.createElement(k,{type:"class-name"},e.name),e.typeParameters&&o.createElement(_,{type:f.Angle},e.typeParameters.map((t=>o.createElement(j,{key:t.id,reflection:n(t)}))))," = ",o.createElement(I,{type:e.type}))}function H(t){let{reflection:e}=t;const n=(0,X.in)();return e.signatures?o.createElement(z,{reflection:e.signatures[0]}):e.children?o.createElement(_,{type:f.Curly},e.children.map((t=>o.createElement(J,{key:t.id,reflection:n(t)})))):o.createElement(o.Fragment,null,o.createElement(k,{type:"keyword"},"unknown"))}function $(t){var e;let{reflection:n}=t;const c=(null==(e=n.signatures)?void 0:e[0])??n.getSignature??n.setSignature??n.indexSignature;return o.createElement(z,{reflection:c})}function J(t){let{reflection:e}=t;const n=(0,o.useMemo)((()=>{switch(e.kind){case c.W.Project:case c.W.Module:case c.W.EnumMember:case c.W.Variable:case c.W.Function:break;case c.W.Namespace:case c.W.Enum:case c.W.Class:case c.W.Interface:return V;case c.W.Constructor:return z;case c.W.Property:return q;case c.W.Method:return $;case c.W.CallSignature:case c.W.IndexSignature:case c.W.ConstructorSignature:case c.W.Parameter:break;case c.W.TypeLiteral:return H;case c.W.TypeParameter:return j;case c.W.Accessor:case c.W.GetSignature:case c.W.SetSignature:case c.W.ObjectLiteral:break;case c.W.TypeAlias:return O;case c.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.id]);return o.createElement(n,{reflection:e})}function K(t){let{children:e}=t;const n=(0,o.useRef)();return(0,o.useLayoutEffect)((()=>{if(!n.current)return;const t=n.current.closest("pre");if(t.scrollWidth>t.clientWidth){const e=Array.from(n.current.querySelectorAll(`.${l.elements}`)).sort(((t,e)=>function(t,e){return t>e?1:t<e?-1:0}(e.innerText.length,t.innerText.length)));for(;t.scrollWidth>t.clientWidth&&e.length>0;)e.shift().classList.add(l.wrap)}})),o.createElement(o.Fragment,null,e&&o.createElement("span",{ref:n,className:(0,a.Z)(l.line,"token-line")},e),o.createElement("br",null))}var Y=n(8943),Q=n(4791);function tt(t){let{parameters:e}=t;const n=(0,X.in)(),c=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=c&&c.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Type Parameters"),o.createElement("ul",null,c.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(j,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function et(t){let{parameters:e}=t;const n=(0,X.in)(),c=(0,o.useMemo)((()=>null==e?void 0:e.map(n)),[e]);return null!=c&&c.length?o.createElement(o.Fragment,null,o.createElement("h4",null,"Parameters"),o.createElement("ul",null,c.map((t=>{var e;return o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(U,{reflection:t})),o.createElement(Q.Z,{id:null==(e=t.comment)?void 0:e.summaryId}))})))):o.createElement(o.Fragment,null)}function nt(t){let{signatures:e,flags:n,source:c}=t;const r=(0,X.in)(),p=(0,o.useMemo)((()=>e.map(r)),[e]),[a,s]=(0,o.useState)(p[0]);return o.createElement(o.Fragment,null,o.createElement(h,null,p.map((t=>o.createElement(m,{link:null==c?void 0:c.url,key:t.id,highlight:e.length>1&&t.id===a.id,onClick:e.length>1?()=>s(t):void 0},o.createElement(K,null,o.createElement(z,{reflection:t,flags:n})))))),o.createElement(Y.Z,{comment:a.comment}),o.createElement(tt,{parameters:a.typeParameter}),o.createElement(et,{parameters:a.parameters}))}var ot=n(7708);function ct(t){let{width:e=24,height:n=24,...c}=t;return o.createElement("svg",(0,i.Z)({viewBox:"0 0 24 24",width:e,height:n,"aria-hidden":!0},c),o.createElement("path",{d:"M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z",fill:"currentColor"}))}const rt="header_nSmr",pt="filters_z1iC",at="icon_ROIU";function st(){const t=(0,o.useRef)(null),[e,n]=(0,o.useState)(!1),[c,r]=(0,ot.mN)();return(0,o.useEffect)((()=>{const e=e=>{t.current&&!t.current.contains(e.target)&&n(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e)}}),[t]),o.createElement(o.Fragment,null,o.createElement("div",{ref:t,className:(0,a.Z)("dropdown dropdown--right margin-bottom--md",e&&"dropdown--show")},o.createElement("a",{href:"#","aria-haspopup":"true","aria-expanded":!1,role:"button",onClick:t=>{t.preventDefault(),n(!e)},onKeyDown:t=>{"Enter"===t.key&&(t.preventDefault(),n(!e))}},"Filters",o.createElement(ct,{className:at})),o.createElement("ul",{className:"dropdown__menu"},o.createElement("li",null,o.createElement("label",{htmlFor:"private",className:(0,a.Z)("dropdown__link",c.private&&"dropdown__link--active")},o.createElement("input",{id:"private",type:"checkbox",className:"margin-right--md",checked:c.private,onChange:t=>{r({...c,private:t.target.checked})}}),"Protected members")),o.createElement("li",{onKeyDown:t=>{"Tab"===t.key&&n(!1)}},o.createElement("label",{htmlFor:"inherited",className:(0,a.Z)("dropdown__link",c.inherited&&"dropdown__link--active")},o.createElement("input",{id:"inherited",type:"checkbox",className:"margin-right--md",checked:c.inherited,onChange:t=>{r({...c,inherited:t.target.checked})}}),"Inherited members")))))}function lt(t){let{children:e,kind:n}=t;return n===c.W.Class||n===c.W.Interface?o.createElement("div",{className:(0,a.Z)("row",rt)},o.createElement("div",{className:(0,a.Z)("col",pt)},o.createElement(st,null)),o.createElement("div",{className:"col"},e)):o.createElement(o.Fragment,null,e)}var it=n(3181),ut=n(8963),mt=n(3851),dt=n(9741),ht=n(2244),yt=n(4126);const kt="tabList_M0Dn",ft="tabItem_ysIP";function Dt(t){var e;const{lazy:n,block:c,defaultValue:r,values:p,groupId:s,className:l}=t,u=o.Children.map(t.children,(t=>{if((0,o.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),m=p??u.map((t=>{let{props:{value:e,label:n,attributes:o}}=t;return{value:e,label:n,attributes:o}})),d=(0,ht.l)(m,((t,e)=>t.value===e.value));if(d.length>0)throw new Error(`Docusaurus error: Duplicate values "${d.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const h=null===r?r:r??(null==(e=u.find((t=>t.props.default)))?void 0:e.props.value)??u[0].props.value;if(null!==h&&!m.some((t=>t.value===h)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${h}" but none of its children has the corresponding value. Available values are: ${m.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:k}=(0,ut.U)(),[f,D]=(0,o.useState)(h),M=[],{blockElementScrollPositionUntilNextRender:_}=(0,yt.o5)();if(null!=s){const t=y[s];null!=t&&t!==f&&m.some((e=>e.value===t))&&D(t)}const X=t=>{const e=t.currentTarget,n=M.indexOf(e),o=m[n].value;o!==f&&(_(e),D(o),null!=s&&k(s,String(o)))},w=t=>{var e;let n=null;switch(t.key){case"Enter":X(t);break;case"ArrowRight":{const e=M.indexOf(t.currentTarget)+1;n=M[e]??M[0];break}case"ArrowLeft":{const e=M.indexOf(t.currentTarget)-1;n=M[e]??M[M.length-1];break}}null==(e=n)||e.focus()};return o.createElement("div",{className:(0,a.Z)("tabs-container",kt)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":c},l)},m.map((t=>{let{value:e,label:n,attributes:c}=t;return o.createElement("li",(0,i.Z)({role:"tab",tabIndex:f===e?0:-1,"aria-selected":f===e,key:e,ref:t=>M.push(t),onKeyDown:w,onClick:X},c,{className:(0,a.Z)("tabs__item",ft,null==c?void 0:c.className,{"tabs__item--active":f===e})}),n??e)}))),n?(0,o.cloneElement)(u.filter((t=>t.props.value===f))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},u.map(((t,e)=>(0,o.cloneElement)(t,{key:e,hidden:t.props.value!==f})))))}function Mt(t){const e=(0,dt.Z)();return o.createElement(Dt,(0,i.Z)({key:String(e)},t))}const _t="tabItem_OMyP";function Xt(t){let{children:e,hidden:n,className:c}=t;return o.createElement("div",{role:"tabpanel",className:(0,a.Z)(_t,c),hidden:n},e)}function wt(t){let{group:e}=t;return"Constructors"===e.title&&0===e.external.length&&1===e.nested.length?o.createElement(At,{reflection:e.nested[0]}):o.createElement(o.Fragment,null,e.external.length>0&&o.createElement("ul",null,e.external.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t})))))),e.nested.length>0&&e.nested.map(((t,e)=>o.createElement(o.Fragment,{key:t.id},e>0&&o.createElement("hr",null),o.createElement(At,{reflection:t})))))}function Tt(t){let{group:e,project:n}=t;const c=(0,it.TH)(),r=(0,X.RU)(n),{setTabGroupChoices:p}=(0,ut.U)(),a=c.hash.split("-")[0].slice(1),[s]=(0,ot.mN)(),l=(0,o.useMemo)((()=>(e.categories??[e]).map((t=>function(t,e,n){const o=[],c=[],r=[];for(const p of t.children){const t=e[p];t&&(0,ot.It)(n,t)&&(r.push(t.anchor),t.hasOwnPage?o.push(t):c.push(t))}if(o.length>0||c.length>0)return{title:t.title,external:o,nested:c,anchors:r}}(t,r,s))).filter((t=>!!t))),[e,r,s]);return(0,o.useEffect)((()=>{if(1===l.length)return;const t=c.hash.split("-")[0].slice(1);for(const n of l)if(n.anchors.includes(t))return void p(e.title,n.title)}),[c.hash,l]),0===l.length?o.createElement(o.Fragment,null):o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h2",id:e.title},e.title),l.length>1?o.createElement(Mt,{groupId:e.title},l.map((t=>o.createElement(Xt,{default:t.anchors.includes(a),value:t.title,label:t.title,className:"margin-top--lg"},o.createElement(wt,{group:t}))))):o.createElement(wt,{group:l[0]}))}function Ct(t){var e,n,c,r,p;let{reflection:a}=t;return o.createElement(o.Fragment,null,o.createElement(h,null,o.createElement(m,{link:null==(e=a.sources)||null==(n=e[0])?void 0:n.url},o.createElement(K,null,o.createElement(J,{reflection:a})))),o.createElement(lt,{kind:a.kind},o.createElement(Y.Z,{comment:a.comment})),o.createElement(tt,{parameters:a.typeParameters}),(null==(c=a.implementedBy)?void 0:c.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Implemented by"),o.createElement("ul",null,a.implementedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),(null==(r=a.extendedBy)?void 0:r.length)&&o.createElement(o.Fragment,null,o.createElement("h4",null,"Extended by"),o.createElement("ul",null,a.extendedBy.map((t=>o.createElement("li",{key:t.id},o.createElement("code",null,o.createElement(w,{type:t}))))))),a.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:a.signatures})),null==(p=a.groups)?void 0:p.map((t=>o.createElement(Tt,{group:t,key:t.title,project:a.project}))))}function gt(t){var e;let{reflection:n,headless:c}=t;const r=[...n.signatures??[],n.setSignature,n.getSignature,n.indexSignature].filter((t=>!!t));return o.createElement(o.Fragment,null,!c&&(n.hasOwnPage?o.createElement("h1",null,n.name):o.createElement(mt.Z,{as:"h3",id:n.anchor},o.createElement("code",null,n.name))),o.createElement(nt,{signatures:r,flags:n.flags,source:null==(e=n.sources)?void 0:e[0]}),n.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:n.inheritedFrom}))),n.overwrites&&o.createElement("small",null,"Overwrites"," ",o.createElement("code",null,o.createElement(w,{type:n.overwrites}))))}function xt(t){var e,n;let{reflection:c}=t;return o.createElement(o.Fragment,null,c.hasOwnPage?o.createElement("h1",null,c.name):o.createElement(mt.Z,{as:"h3",id:c.anchor},o.createElement("code",null,c.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=c.sources)||null==(n=e[0])?void 0:n.url},o.createElement(K,null,o.createElement(q,{reflection:c})))),o.createElement(Y.Z,{comment:c.comment}),c.inheritedFrom&&o.createElement("small",null,"Inherited from"," ",o.createElement("code",null,o.createElement(w,{type:c.inheritedFrom}))))}function Zt(t){var e,n,c;let{reflection:r}=t;const p=(0,X.RU)(r.project);return o.createElement(o.Fragment,null,o.createElement(mt.Z,{as:"h3",id:r.anchor},o.createElement("code",null,r.name)),o.createElement(h,null,o.createElement(m,{link:null==(e=r.sources)||null==(n=e[0])?void 0:n.url},o.createElement(K,null,o.createElement(J,{reflection:r})))),o.createElement(Y.Z,{comment:r.comment}),o.createElement(tt,{parameters:r.typeParameters}),r.signatures&&o.createElement(o.Fragment,null,o.createElement("h2",null,"Callable"),o.createElement(nt,{signatures:r.signatures})),null==(c=r.groups)?void 0:c.map((t=>o.createElement(o.Fragment,{key:t.title},o.createElement("h2",null,t.title),t.children.map((t=>p[t])).filter((t=>t&&(t.flags.isPublic||!t.flags.isProtected&&!t.flags.isPrivate))).map((t=>o.createElement(At,{key:t.id,reflection:t})))))))}var Lt=n(8128);function vt(t){var e;let{reflection:n}=t;return o.createElement(o.Fragment,null,o.createElement(Lt.Z,{language:"ts"},"import ","{...}",' from "',n.importPath,'";'),o.createElement(lt,{kind:n.kind},o.createElement(Y.Z,{comment:n.comment})),null==(e=n.groups)?void 0:e.map((t=>o.createElement(Tt,{group:t,key:t.title,project:n.project}))))}const bt="cardContainer_ybwo",Nt="cardTitle_Ehd1",Et="cardDescription_b6wr";function St(t){let{reflection:e}=t;const n=(0,X.RU)(e.project),c=e.groups[0].children.map((t=>n[t])).filter((t=>!!t));return o.createElement("article",{className:"margin-top--lg"},o.createElement("section",{className:(0,a.Z)("row")},c.map((t=>{var e;return o.createElement("article",{key:t.id,className:"col col--6 margin-bottom--lg"},o.createElement(y.Z,{href:t.href,className:(0,a.Z)("card padding--lg",bt)},o.createElement("h2",{className:(0,a.Z)("text--truncate",Nt)},o.createElement("code",null,t.name)),o.createElement("div",{className:(0,a.Z)("text--truncate",Et)},(null==(e=t.comment)?void 0:e.summaryText)??"\xa0")))}))))}function At(t){let{reflection:e,headless:n=!1}=t;const r=(0,o.useMemo)((()=>{switch(e.kind){case c.W.Project:return St;case c.W.Module:return vt;case c.W.Namespace:case c.W.Enum:case c.W.Class:case c.W.Interface:return Ct;case c.W.Function:case c.W.Accessor:case c.W.Constructor:case c.W.Method:return gt;case c.W.Variable:case c.W.Property:case c.W.EnumMember:return xt;case c.W.CallSignature:case c.W.IndexSignature:case c.W.ConstructorSignature:case c.W.Parameter:case c.W.TypeLiteral:case c.W.TypeParameter:case c.W.GetSignature:case c.W.SetSignature:case c.W.ObjectLiteral:break;case c.W.TypeAlias:return Zt;case c.W.Reference:}throw new Error(`Missing component for reflection: ${e.kindString}`)}),[e.kind]);return o.createElement(r,{reflection:e,headless:n})}},7390:(t,e,n)=>{let o;n.d(e,{W:()=>o}),function(t){t[t.Project=1]="Project",t[t.Module=2]="Module",t[t.Namespace=4]="Namespace",t[t.Enum=8]="Enum",t[t.EnumMember=16]="EnumMember",t[t.Variable=32]="Variable",t[t.Function=64]="Function",t[t.Class=128]="Class",t[t.Interface=256]="Interface",t[t.Constructor=512]="Constructor",t[t.Property=1024]="Property",t[t.Method=2048]="Method",t[t.CallSignature=4096]="CallSignature",t[t.IndexSignature=8192]="IndexSignature",t[t.ConstructorSignature=16384]="ConstructorSignature",t[t.Parameter=32768]="Parameter",t[t.TypeLiteral=65536]="TypeLiteral",t[t.TypeParameter=131072]="TypeParameter",t[t.Accessor=262144]="Accessor",t[t.GetSignature=524288]="GetSignature",t[t.SetSignature=1048576]="SetSignature",t[t.ObjectLiteral=2097152]="ObjectLiteral",t[t.TypeAlias=4194304]="TypeAlias",t[t.Reference=8388608]="Reference"}(o||(o={}))},8617:(t,e,n)=>{n.d(e,{Gr:()=>l,RU:()=>p,gs:()=>r,in:()=>a,rG:()=>s});var o=n(2784);const c=o.createContext({lookup:{},urlLookup:{}});function r(t){let{children:e,lookup:n,urlLookup:r}=t;return o.createElement(c.Provider,{value:{lookup:n,urlLookup:r}},e)}function p(t){const{lookup:e}=(0,o.useContext)(c);return e[t]}function a(){const{lookup:t}=(0,o.useContext)(c);return e=>{if("number"==typeof(null==e?void 0:e.project))return t[e.project][e.id]}}function s(){const{urlLookup:t,lookup:e}=(0,o.useContext)(c);return n=>{var o;const c=t[n];return c?(null==(o=e[c.projectId])?void 0:o[c.id])??null:null}}function l(t){if(t)return t.href}},68:(t,e,n)=>{n.d(e,{Ld:()=>a,Y0:()=>p,s2:()=>s});var o=n(2784),c=n(822);const r=o.createContext(null);function p(t){let{children:e}=t;const n=(0,c.p)(),p=(0,o.useMemo)((()=>function(t,e){const{plain:n}=t,o=Object.create(null),c=t.styles.reduce(((t,n)=>{const{languages:o,style:c}=n;return o&&!o.includes(e)||n.types.forEach((e=>{t[e]={...t[e],...c}})),t}),o);return c.root=n,c.plain={...n,backgroundColor:null},c}(n,"typescript")),[n]);return o.createElement(r.Provider,{value:p},e)}function a(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return{className:`token ${t}`,style:e[t]??e.plain}}function s(t){void 0===t&&(t="plain");const e=(0,o.useContext)(r);return e[t]??e.plain}},7708:(t,e,n)=>{n.d(e,{It:()=>m,Wy:()=>i,mN:()=>u});var o=n(2784),c=n(1263),r=n(9741);const p="api-filters",a=c.Z.canUseDOM?localStorage.getItem(p):null,s=a?JSON.parse(a):{inherited:!0,private:!1},l=o.createContext([s,()=>{}]);function i(t){let{children:e}=t;const[n,c]=(0,o.useState)(s),a=(0,r.Z)();return o.createElement(l.Provider,{value:[n,t=>{a&&localStorage.setItem(p,JSON.stringify(t)),c(t)}]},e)}function u(){return(0,o.useContext)(l)}function m(t,e){var n,o;const c=(null==(n=e.flags)?void 0:n.isPrivate)||(null==(o=e.flags)?void 0:o.isProtected);if(!t.private&&c)return!1;const r=!!e.inheritedFrom;return!(!t.inherited&&r)}},6412:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>m});var o=n(7896),c=(n(2784),n(876)),r=n(8442),p=n(8128),a=n(2072);const s={sidebar_position:2,slug:"/hierarchy"},l="Scene hierarchy",i={unversionedId:"getting-started/hierarchy",id:"getting-started/hierarchy",title:"Scene hierarchy",description:"Scenes are collections of nodes displayed in your animation. They're organized",source:"@site/docs/getting-started/hierarchy.mdx",sourceDirName:"getting-started",slug:"/hierarchy",permalink:"/docs/hierarchy",draft:!1,editUrl:"https://github.com/motion-canvas/motion-canvas/blob/main/docs/getting-started/hierarchy.mdx",tags:[],version:"current",lastUpdatedBy:"Jacob",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"/hierarchy"},sidebar:"docs",previous:{title:"Animation flow",permalink:"/docs/flow"},next:{title:"Signals",permalink:"/docs/signals"}},u={},m=[{value:"<code>Node.add</code>",id:"nodeadd",level:2},{value:"<code>Node.insert</code>",id:"nodeinsert",level:2},{value:"<code>Node.remove</code>",id:"noderemove",level:2},{value:"<code>Node.moveUp</code>",id:"nodemoveup",level:2},{value:"<code>Node.moveDown</code>",id:"nodemovedown",level:2},{value:"<code>Node.moveToTop</code>",id:"nodemovetotop",level:2},{value:"<code>Node.moveToBottom</code>",id:"nodemovetobottom",level:2},{value:"<code>Node.removeChildren</code>",id:"noderemovechildren",level:2}],d={toc:m};function h(t){let{components:e,...n}=t;return(0,c.kt)("wrapper",(0,o.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,c.kt)("h1",{id:"scene-hierarchy"},"Scene hierarchy"),(0,c.kt)("p",null,"Scenes are collections of nodes displayed in your animation. They're organized\nin a tree hierarchy, with the scene view at its root. This concept is similar to\nthe Document Object Model used ot represent HTML and XML documents."),(0,c.kt)("p",null,"Here's an example of a simple scene hierarchy together with its object\nrepresentation:"),(0,c.kt)("div",{className:"row margin-bottom--md"},(0,c.kt)("div",{className:"col col--6"},(0,c.kt)(p.Z,{language:"tsx",mdxType:"CodeBlock"},"view.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Text>Hi</Text>\n    </Layout>\n  </>,\n);")),(0,c.kt)("div",{className:"col col--6"},(0,c.kt)(r.Z,{value:"graph TD;\n  view[Scene View]\n  circle([Circle])\n  layout([Layout])\n  rect([Rect])\n  text([text 'Hi'])\n    view--\x3ecircle;\n    view--\x3elayout;\n    layout--\x3erect;\n    layout--\x3etext;",mdxType:"Mermaid"}))),(0,c.kt)("p",null,"Each node is an instance of a class extending the base ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,c.kt)("inlineCode",{parentName:"a"},"Node"))," class. To\nmake the code more readable, Motion Canvas uses a custom\n",(0,c.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/introducing-jsx.html"},"JSX")," runtime. This way, instead\nof instantiating the nodes ourselves, we can write an XML-like markup. Note that\nMotion Canvas does ",(0,c.kt)("strong",{parentName:"p"},"not")," use React itself, only JSX. There's no virtual DOM or\nreconciliation and the JSX tags are mapped directly to Node instances. These two\ncode snippets are equivalent:"),(0,c.kt)("div",{className:"row"},(0,c.kt)("div",{className:"col col--6"},(0,c.kt)(p.Z,{language:"tsx",mdxType:"CodeBlock"},"// JSX\nview.add(\n  <>\n    <Circle />\n    <Layout>\n      <Rect />\n      <Text>Hi</Text>\n    </Layout>\n  </>,\n);")),(0,c.kt)("div",{className:"col col--6"},(0,c.kt)(p.Z,{language:"tsx",mdxType:"CodeBlock"},"// No JSX\nview.add([\n  new Circle({}),\n  new Layout({\n    children: [\n      new Rect({}),\n      new Text({text: 'Hi'})\n    ]\n  })\n]);"," "))),(0,c.kt)("p",null,"Just like with DOM, it's possible to add, remove, and rearrange nodes at any\ntime. The ",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node"},(0,c.kt)("inlineCode",{parentName:"a"},"Node"))," class contains the\n",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#children"},(0,c.kt)("inlineCode",{parentName:"a"},"children"))," and\n",(0,c.kt)("a",{parentName:"p",href:"/api/2d/components/Node#parent"},(0,c.kt)("inlineCode",{parentName:"a"},"parent"))," properties that can be used to\ntraverse the tree. But in order to modify it, it's recommended to use the\nfollowing helper methods:"),(0,c.kt)("h2",{id:"nodeadd"},(0,c.kt)("inlineCode",{parentName:"h2"},"Node.add")),(0,c.kt)(a.Z,{url:"/api/2d/components/Node#add",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"nodeinsert"},(0,c.kt)("inlineCode",{parentName:"h2"},"Node.insert")),(0,c.kt)(a.Z,{url:"/api/2d/components/Node#insert",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"noderemove"},(0,c.kt)("inlineCode",{parentName:"h2"},"Node.remove")),(0,c.kt)(a.Z,{url:"/api/2d/components/Node#remove",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"nodemoveup"},(0,c.kt)("inlineCode",{parentName:"h2"},"Node.moveUp")),(0,c.kt)(a.Z,{url:"/api/2d/components/Node#moveUp",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"nodemovedown"},(0,c.kt)("inlineCode",{parentName:"h2"},"Node.moveDown")),(0,c.kt)(a.Z,{url:"/api/2d/components/Node#moveDown",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"nodemovetotop"},(0,c.kt)("inlineCode",{parentName:"h2"},"Node.moveToTop")),(0,c.kt)(a.Z,{url:"/api/2d/components/Node#moveToTop",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"nodemovetobottom"},(0,c.kt)("inlineCode",{parentName:"h2"},"Node.moveToBottom")),(0,c.kt)(a.Z,{url:"/api/2d/components/Node#moveToBottom",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null),(0,c.kt)("h2",{id:"noderemovechildren"},(0,c.kt)("inlineCode",{parentName:"h2"},"Node.removeChildren")),(0,c.kt)(a.Z,{url:"/api/2d/components/Node#removeChildren",mdxType:"ApiSnippet"}),(0,c.kt)("hr",null))}h.isMDXComponent=!0}}]);
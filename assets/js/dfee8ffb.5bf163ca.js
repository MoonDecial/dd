"use strict";(self.webpackChunk_motion_canvas_docs=self.webpackChunk_motion_canvas_docs||[]).push([[4625],{876:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(2784);function p(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function c(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function r(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?c(Object(e),!0).forEach((function(n){p(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):c(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,o,p=function(t,n){if(null==t)return{};var e,o,p={},c=Object.keys(t);for(o=0;o<c.length;o++)e=c[o],n.indexOf(e)>=0||(p[e]=t[e]);return p}(t,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(t);for(o=0;o<c.length;o++)e=c[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(p[e]=t[e])}return p}var a=o.createContext({}),i=function(t){var n=o.useContext(a),e=n;return t&&(e="function"==typeof t?t(n):r(r({},n),t)),e},l=function(t){var n=i(t.components);return o.createElement(a.Provider,{value:n},t.children)},u="mdxType",m={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,p=t.mdxType,c=t.originalType,a=t.parentName,l=s(t,["components","mdxType","originalType","parentName"]),u=i(e),d=p,h=u["".concat(a,".").concat(d)]||u[d]||m[d]||c;return e?o.createElement(h,r(r({ref:n},l),{},{components:e})):o.createElement(h,r({ref:n},l))}));function h(t,n){var e=arguments,p=n&&n.mdxType;if("string"==typeof t||p){var c=e.length,r=new Array(c);r[0]=d;var s={};for(var a in n)hasOwnProperty.call(n,a)&&(s[a]=n[a]);s.originalType=t,s[u]="string"==typeof t?t:p,r[1]=s;for(var i=2;i<c;i++)r[i]=e[i];return o.createElement.apply(null,r)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},3440:(t,n,e)=>{e.r(n),e.d(n,{default:()=>DP});var o=e(7896),p=(e(2784),e(876));const c={toc:[]};function r(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},c,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Property decorators."))}r.isMDXComponent=!0;const s={toc:[]};function a(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscriptions and triggering of events."))}a.isMDXComponent=!0;const i={toc:[]};function l(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},i,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher#dispatch"},(0,p.kt)("inlineCode",{parentName:"a"},"dispatch"))," method returns a promise that resolves when all the\nhandlers resolve."))}l.isMDXComponent=!0;const u={toc:[]};function m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new AsyncEventDispatcher<number>();\n\n  private async dispatchExample() {\n    // dispatching returns a Promise.\n    await this.value.dispatch(0);\n  }\n}\n")))}m.isMDXComponent=!0;const d={toc:[]};function h(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},d,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches an asynchronous ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}h.isMDXComponent=!0;const y={toc:[]};function k(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}k.isMDXComponent=!0;const f={toc:[]};function D(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},f,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}D.isMDXComponent=!0;const M={toc:[]};function _(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},M,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}_.isMDXComponent=!0;const X={toc:[]};function w(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},X,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}w.isMDXComponent=!0;const T={toc:[]};function C(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},T,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}C.isMDXComponent=!0;const x={toc:[]};function g(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},x,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}g.isMDXComponent=!0;const L={toc:[]};function Z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},L,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}Z.isMDXComponent=!0;const b={toc:[]};function v(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},b,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new EventDispatcher<number>();\n\n  private dispatchExample() {\n    // dispatching will notify all subscribers.\n    this.value.dispatch(0);\n  }\n}\n")))}v.isMDXComponent=!0;const N={toc:[]};function S(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},N,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableEvent")),"."))}S.isMDXComponent=!0;const A={toc:[]};function G(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},A,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}G.isMDXComponent=!0;const P={toc:[]};function R(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},P,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}R.isMDXComponent=!0;const E={toc:[]};function I(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},E,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}I.isMDXComponent=!0;const W={toc:[]};function U(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},W,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}U.isMDXComponent=!0;const j={toc:[]};function z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},j,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}z.isMDXComponent=!0;const F={toc:[]};function O(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},F,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}O.isMDXComponent=!0;const q={toc:[]};function V(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},q,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value argument to subscribers."))}V.isMDXComponent=!0;const B={toc:[]};function H(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},B,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A base for dispatching ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/Subscribable"},(0,p.kt)("inlineCode",{parentName:"a"},"Subscribable")),"s."))}H.isMDXComponent=!0;const Y={toc:[]};function J(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}J.isMDXComponent=!0;const K={toc:[]};function Q(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},K,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Q.isMDXComponent=!0;const $={toc:[]};function tt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}tt.isMDXComponent=!0;const nt={toc:[]};function et(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}et.isMDXComponent=!0;const ot={toc:[]};function pt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ot,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}pt.isMDXComponent=!0;const ct={toc:[]};function rt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ct,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}rt.isMDXComponent=!0;const st={toc:[]};function at(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},st,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}at.isMDXComponent=!0;const it={toc:[]};function lt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},it,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}lt.isMDXComponent=!0;const ut={toc:[]};function mt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ut,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribers are notified only when the flag is set.\nSubsequent calls to ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher#raise"},(0,p.kt)("inlineCode",{parentName:"a"},"raise"))," don't trigger anything.\nAny handlers added while the flag is raised are immediately invoked."),(0,p.kt)("p",null,"Resetting the flag doesn't notify the subscribers, but raising it again does."))}mt.isMDXComponent=!0;const dt={toc:[]};function ht(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onChanged {\n    return this.flag.subscribable;\n  }\n  // create a private dispatcher\n  private flag = new FlagDispatcher();\n\n  private dispatchExample() {\n    // setting the flag will notify all subscribers\n    this.flag.raise();\n  }\n}\n")))}ht.isMDXComponent=!0;const yt={toc:[]};function kt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events#SubscribableFlagEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableFlagEvent")),"."))}kt.isMDXComponent=!0;const ft={toc:[]};function Dt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ft,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}Dt.isMDXComponent=!0;const Mt={toc:[]};function _t(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Are subscribers being notified?"))}_t.isMDXComponent=!0;const Xt={toc:[]};function wt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Notify all current and future subscribers."))}wt.isMDXComponent=!0;const Tt={toc:[]};function Ct(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stop notifying future subscribers."))}Ct.isMDXComponent=!0;const xt={toc:[]};function gt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}gt.isMDXComponent=!0;const Lt={toc:[]};function Zt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}Zt.isMDXComponent=!0;const bt={toc:[]};function vt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}vt.isMDXComponent=!0;const Nt={toc:[]};function St(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}St.isMDXComponent=!0;const At={toc:[]};function Gt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},At,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Gt.isMDXComponent=!0;const Pt={toc:[]};function Rt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}Rt.isMDXComponent=!0;const Et={toc:[]};function It(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Et,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcherBase"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcherBase")),"."))}It.isMDXComponent=!0;const Wt={toc:[]};function Ut(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A callback function that cancels the subscription."))}Ut.isMDXComponent=!0;const jt={toc:[]};function zt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."))}zt.isMDXComponent=!0;const Ft={toc:[]};function Ot(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ft,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Ot.isMDXComponent=!0;const qt={toc:[]};function Vt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Vt.isMDXComponent=!0;const Bt={toc:[]};function Ht(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Ht.isMDXComponent=!0;const Yt={toc:[]};function Jt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}Jt.isMDXComponent=!0;const Kt={toc:[]};function Qt(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kt,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the callback function."))}Qt.isMDXComponent=!0;const $t={toc:[]};function tn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$t,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}tn.isMDXComponent=!0;const nn={toc:[]};function en(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/ValueDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"ValueDispatcher")),"."))}en.isMDXComponent=!0;const on={toc:[]};function pn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},on,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}pn.isMDXComponent=!0;const cn={toc:[]};function rn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}rn.isMDXComponent=!0;const sn={toc:[]};function an(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}an.isMDXComponent=!0;const ln={toc:[]};function un(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ln,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}un.isMDXComponent=!0;const mn={toc:[]};function dn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}dn.isMDXComponent=!0;const hn={toc:[]};function yn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}yn.isMDXComponent=!0;const kn={toc:[]};function fn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}fn.isMDXComponent=!0;const Dn={toc:[]};function Mn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Mn.isMDXComponent=!0;const _n={toc:[]};function Xn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_n,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}Xn.isMDXComponent=!0;const wn={toc:[]};function Tn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}Tn.isMDXComponent=!0;const Cn={toc:[]};function xn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changing the value stored by a value dispatcher will immediately notify all\nits subscribers."))}xn.isMDXComponent=!0;const gn={toc:[]};function Ln(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  // expose the event to external classes\n  public get onValueChanged {\n    return this.value.subscribable;\n  }\n  // create a private dispatcher\n  private value = new ValueDispatcher(0);\n\n  private changingValueExample() {\n    // changing the value will notify all subscribers.\n    this.value.current = 7;\n  }\n}\n")))}Ln.isMDXComponent=!0;const Zn={toc:[]};function bn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Dispatches a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/SubscribableValueEvent"},(0,p.kt)("inlineCode",{parentName:"a"},"SubscribableValueEvent"))))}bn.isMDXComponent=!0;const vn={toc:[]};function Nn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value."))}Nn.isMDXComponent=!0;const Sn={toc:[]};function An(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the most recent value of this dispatcher."))}An.isMDXComponent=!0;const Gn={toc:[]};function Pn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Setting the value will immediately notify all subscribers."))}Pn.isMDXComponent=!0;const Rn={toc:[]};function En(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set the current value of this dispatcher."))}En.isMDXComponent=!0;const In={toc:[]};function Wn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},In,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new value."))}Wn.isMDXComponent=!0;const Un={toc:[]};function jn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Un,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe all subscribers from the event."))}jn.isMDXComponent=!0;const zn={toc:[]};function Fn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Callback function that cancels the subscription."))}Fn.isMDXComponent=!0;const On={toc:[]};function qn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},On,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Subscribe to the event."),(0,p.kt)("p",null,"Subscribing will immediately invoke the handler with the most recent value."))}qn.isMDXComponent=!0;const Vn={toc:[]};function Bn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to invoke when the event occurs."))}Bn.isMDXComponent=!0;const Hn={toc:[]};function Yn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the handler should be immediately\ninvoked with the most recent value."))}Yn.isMDXComponent=!0;const Jn={toc:[]};function Kn(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unsubscribe from the event."))}Kn.isMDXComponent=!0;const Qn={toc:[]};function $n(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qn,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The handler to unsubscribe."))}$n.isMDXComponent=!0;const te={toc:[]};function ne(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},te,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the value passed to subscribers."))}ne.isMDXComponent=!0;const ee={toc:[]};function oe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ee,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}oe.isMDXComponent=!0;const pe={toc:[]};function ce(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/AsyncEventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"AsyncEventDispatcher")),"."))}ce.isMDXComponent=!0;const re={toc:[]};function se(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},re,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}se.isMDXComponent=!0;const ae={toc:[]};function ie(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ae,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ie.isMDXComponent=!0;const le={toc:[]};function ue(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},le,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/EventDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"EventDispatcher")),"."))}ue.isMDXComponent=!0;const me={toc:[]};function de(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},me,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the argument passed to subscribers."))}de.isMDXComponent=!0;const he={toc:[]};function ye(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},he,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"External classes can use it to subscribe to an event without being able to\ndispatch it."))}ye.isMDXComponent=!0;const ke={toc:[]};function fe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ke,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provides safe access to the public interface of ",(0,p.kt)("a",{parentName:"p",href:"/api/core/events/FlagDispatcher"},(0,p.kt)("inlineCode",{parentName:"a"},"FlagDispatcher")),"."))}fe.isMDXComponent=!0;const De={toc:[]};function Me(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},De,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Utilities for controlling the flow and timing of an animation."))}Me.isMDXComponent=!0;const _e={toc:[]};function Xe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_e,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of times the timer has ticked."))}Xe.isMDXComponent=!0;const we={toc:[]};function Te(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},we,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator responsible for running this timer."))}Te.isMDXComponent=!0;const Ce={toc:[]};function xe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ce,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the timer ticks."))}xe.isMDXComponent=!0;const ge={toc:[]};function Le(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ge,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current iteration index."))}Le.isMDXComponent=!0;const Ze={toc:[]};function be(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ze,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* all(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 2s\n")))}be.isMDXComponent=!0;const ve={toc:[]};function Ne(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ve,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for all of them to finish."))}Ne.isMDXComponent=!0;const Se={toc:[]};function Ae(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Se,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}Ae.isMDXComponent=!0;const Ge={toc:[]};function Pe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ge,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* any(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 1s\n")))}Pe.isMDXComponent=!0;const Re={toc:[]};function Ee(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Re,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run all tasks concurrently and wait for any of them to finish."))}Ee.isMDXComponent=!0;const Ie={toc:[]};function We(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ie,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}We.isMDXComponent=!0;const Ue={toc:[]};function je(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ue,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* chain(\n  rect.fill('#ff0000', 2),\n  rect.opacity(1, 1),\n);\n// current time: 3s\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* rect.fill('#ff0000', 2),\nyield* rect.opacity(1, 1),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"chain")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.corenerRadius(20, 3),\n  chain(\n    rect.fill('#ff0000', 2),\n    rect.opacity(1, 1),\n  ),\n);\n")))}je.isMDXComponent=!0;const ze={toc:[]};function Fe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ze,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run tasks one after another."))}Fe.isMDXComponent=!0;const Oe={toc:[]};function qe(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Oe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to run."))}qe.isMDXComponent=!0;const Ve={toc:[]};function Be(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ve,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* delay(1, rect.fill('#ff0000', 2));\n")),(0,p.kt)("p",null,"Note that the same animation can be written as:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* waitFor(1),\nyield* rect.fill('#ff0000', 2),\n")),(0,p.kt)("p",null,"The reason ",(0,p.kt)("inlineCode",{parentName:"p"},"delay")," exists is to make it easier to pass it to other flow\nfunctions. For example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* all(\n  rect.opacity(1, 3),\n  delay(1, rect.fill('#ff0000', 2));\n);\n")))}Be.isMDXComponent=!0;const He={toc:[]};function Ye(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},He,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator or callback after a specific amount of time."))}Ye.isMDXComponent=!0;const Je={toc:[]};function Ke(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Je,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay in seconds"))}Ke.isMDXComponent=!0;const Qe={toc:[]};function $e(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qe,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task or callback to run after the delay."))}$e.isMDXComponent=!0;const to={toc:[]};function no(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},to,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const timer = every(2, time => console.log(time));\nyield timer.runner;\n\n// current time: 0s\nyield* waitFor(5);\n// current time: 5s\nyield* timer.sync();\n// current time: 6s\n")))}no.isMDXComponent=!0;const eo={toc:[]};function oo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Call the given callback every N seconds."))}oo.isMDXComponent=!0;const po={toc:[]};function co(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},po,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interval between subsequent calls."))}co.isMDXComponent=!0;const ro={toc:[]};function so(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ro,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to be called."))}so.isMDXComponent=!0;const ao={toc:[]};function io(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ao,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each time iteration waits until the previous one is completed."))}io.isMDXComponent=!0;const lo={toc:[]};function uo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const colors = [\n  '#ff6470',\n  '#ffc66d',\n  '#68abdf',\n  '#99c47a',\n];\n\nyield* loop(\n  colors.length,\n  i => rect.fill(colors[i], 2),\n});\n")))}uo.isMDXComponent=!0;const mo={toc:[]};function ho(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Run the given generator N times."))}ho.isMDXComponent=!0;const yo={toc:[]};function ko(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The number of iterations."))}ko.isMDXComponent=!0;const fo={toc:[]};function Do(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function creating the generator to run. Because generators\ncan't be reset, a new generator is created on each iteration."))}Do.isMDXComponent=!0;const Mo={toc:[]};function _o(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Do nothing."))}_o.isMDXComponent=!0;const Xo={toc:[]};function wo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}wo.isMDXComponent=!0;const To={toc:[]};function Co(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},To,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}Co.isMDXComponent=!0;const xo={toc:[]};function go(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}go.isMDXComponent=!0;const Lo={toc:[]};function Zo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield run(function* () {\n  // do things\n});\n")))}Zo.isMDXComponent=!0;const bo={toc:[]};function vo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Turn the given generator function into a threadable generator."))}vo.isMDXComponent=!0;const No={toc:[]};function So(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},No,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional name used when displaying this generator in the UI."))}So.isMDXComponent=!0;const Ao={toc:[]};function Go(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ao,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a factory that creates the generator."))}Go.isMDXComponent=!0;const Po={toc:[]};function Ro(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Po,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function doesn't wait until the previous task in the sequence has\nfinished. Once the delay has passed, the next task will start even if\nthe previous is still running."))}Ro.isMDXComponent=!0;const Eo={toc:[]};function Io(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* sequence(\n  0.1,\n  ...rects.map(rect => rect.x(100, 1))\n);\n")))}Io.isMDXComponent=!0;const Wo={toc:[]};function Uo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Start all tasks one after another with a constant delay between."))}Uo.isMDXComponent=!0;const jo={toc:[]};function zo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The delay between each of the tasks."))}zo.isMDXComponent=!0;const Fo={toc:[]};function Oo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to be run in a sequence."))}Oo.isMDXComponent=!0;const qo={toc:[]};function Vo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield waitFor(2);\n// current time: 2s\nyield waitFor(3);\n// current time: 5s\n")))}Vo.isMDXComponent=!0;const Bo={toc:[]};function Ho(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for the given amount of time."))}Ho.isMDXComponent=!0;const Yo={toc:[]};function Jo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yo,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The relative time in seconds."))}Jo.isMDXComponent=!0;const Ko={toc:[]};function Qo(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ko,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}Qo.isMDXComponent=!0;const $o={toc:[]};function tp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$o,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time events are displayed on the timeline and can be edited to adjust the\ndelay. By default, an event happens immediately - without any delay."))}tp.isMDXComponent=!0;const np={toc:[]};function ep(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},np,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield waitUntil('event');\n")))}ep.isMDXComponent=!0;const op={toc:[]};function pp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},op,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait until the given time event."))}pp.isMDXComponent=!0;const cp={toc:[]};function rp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the time event."))}rp.isMDXComponent=!0;const sp={toc:[]};function ap(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An optional task to be run after the function completes."))}ap.isMDXComponent=!0;const ip={toc:[]};function lp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ip,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Main Motion Canvas classes."))}lp.isMDXComponent=!0;const up={toc:[]};function mp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},up,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when a new message is logged."))}mp.isMDXComponent=!0;const dp={toc:[]};function hp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the meta file of a given entity."))}hp.isMDXComponent=!0;const yp={toc:[]};function kp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when metadata changes."))}kp.isMDXComponent=!0;const fp={toc:[]};function Dp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Load new metadata from a file."))}Dp.isMDXComponent=!0;const Mp={toc:[]};function _p(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New metadata."))}_p.isMDXComponent=!0;const Xp={toc:[]};function wp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any possible errors will be logged to the console."))}wp.isMDXComponent=!0;const Tp={toc:[]};function Cp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set data without waiting for confirmation."))}Cp.isMDXComponent=!0;const xp={toc:[]};function gp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"New data."))}gp.isMDXComponent=!0;const Lp={toc:[]};function Zp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the data stored in the meta file."))}Zp.isMDXComponent=!0;const bp={toc:[]};function vp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/core/index#makeProject"},(0,p.kt)("inlineCode",{parentName:"a"},"makeProject"))," instead."))}vp.isMDXComponent=!0;const Np={toc:[]};function Sp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Np,e,{components:n,mdxType:"MDXLayout"}))}Sp.isMDXComponent=!0;const Ap={toc:[]};function Gp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ap,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The project configuration."))}Gp.isMDXComponent=!0;const Pp={toc:[]};function Rp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the current scene changes."))}Rp.isMDXComponent=!0;const Ep={toc:[]};function Ip(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ep,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after any of the scenes were reloaded."))}Ip.isMDXComponent=!0;const Wp={toc:[]};function Up(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after the scenes were recalculated."))}Up.isMDXComponent=!0;const jp={toc:[]};function zp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}zp.isMDXComponent=!0;const Fp={toc:[]};function Op(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Multi-media management."))}Op.isMDXComponent=!0;const qp={toc:[]};function Vp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"true")," if the audio successfully started playing."))}Vp.isMDXComponent=!0;const Bp={toc:[]};function Hp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause/resume the audio."))}Hp.isMDXComponent=!0;const Yp={toc:[]};function Jp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the audio should be paused or resumed."))}Jp.isMDXComponent=!0;const Kp={toc:[]};function Qp(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kp,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The absolute biggest value from the peaks array."))}Qp.isMDXComponent=!0;const $p={toc:[]};function tc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$p,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The amount of samples taken."))}tc.isMDXComponent=!0;const nc={toc:[]};function ec(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"An array of minimum and maximum waveform data points, interleaved.\nEach value is in range of -1 to 1."))}ec.isMDXComponent=!0;const oc={toc:[]};function pc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Samples per seconds."))}pc.isMDXComponent=!0;const cc={toc:[]};function rc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Playback control."))}rc.isMDXComponent=!0;const sc={toc:[]};function ac(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Abstract scene representations and related utilities."))}ac.isMDXComponent=!0;const ic={toc:[]};function lc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ic,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Signifies the various stages of a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene")),"'s render lifecycle."))}lc.isMDXComponent=!0;const uc={toc:[]};function mc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs after a render ends."))}mc.isMDXComponent=!0;const dc={toc:[]};function hc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs before the render starts when the Scene transitions are applied."))}hc.isMDXComponent=!0;const yc={toc:[]};function kc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the beginning of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContext"},(0,p.kt)("inlineCode",{parentName:"a"},"useContext"))," handlers are applied."))}kc.isMDXComponent=!0;const fc={toc:[]};function Dc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Occurs at the end of a render when the Scene's\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/utils#useContextAfter"},(0,p.kt)("inlineCode",{parentName:"a"},"useContextAfter"))," handlers are applied."))}Dc.isMDXComponent=!0;const Mc={toc:[]};function _c(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes the state of a scene."))}_c.isMDXComponent=!0;const Xc={toc:[]};function wc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the Project that the previous scene is no longer necessary and can\nbe disposed of."))}wc.isMDXComponent=!0;const Tc={toc:[]};function Cc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished transitioning in."))}Cc.isMDXComponent=!0;const xc={toc:[]};function gc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Informs the project that the next scene can begin.\nThe ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," method will still be invoked until the next scene\nenters ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn")),"."))}gc.isMDXComponent=!0;const Lc={toc:[]};function Zc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene is ready to transition out."))}Zc.isMDXComponent=!0;const bc={toc:[]};function vc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoking ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#next"},(0,p.kt)("inlineCode",{parentName:"a"},"next"))," won't have any effect."))}vc.isMDXComponent=!0;const Nc={toc:[]};function Sc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has finished."))}Sc.isMDXComponent=!0;const Ac={toc:[]};function Gc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ac,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene has just been created/reset."))}Gc.isMDXComponent=!0;const Pc={toc:[]};function Rc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The default implementation of the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface."),(0,p.kt)("p",null,"Uses generators to control the animation."))}Rc.isMDXComponent=!0;const Ec={toc:[]};function Ic(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ec,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}Ic.isMDXComponent=!0;const Wc={toc:[]};function Uc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Uc.isMDXComponent=!0;const jc={toc:[]};function zc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}zc.isMDXComponent=!0;const Fc={toc:[]};function Oc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Oc.isMDXComponent=!0;const qc={toc:[]};function Vc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}Vc.isMDXComponent=!0;const Bc={toc:[]};function Hc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}Hc.isMDXComponent=!0;const Yc={toc:[]};function Jc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Jc.isMDXComponent=!0;const Kc={toc:[]};function Qc(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kc,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Qc.isMDXComponent=!0;const $c={toc:[]};function tr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$c,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}tr.isMDXComponent=!0;const nr={toc:[]};function er(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}er.isMDXComponent=!0;const or={toc:[]};function pr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},or,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}pr.isMDXComponent=!0;const cr={toc:[]};function rr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}rr.isMDXComponent=!0;const sr={toc:[]};function ar(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ar.isMDXComponent=!0;const ir={toc:[]};function lr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ir,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}lr.isMDXComponent=!0;const ur={toc:[]};function mr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ur,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}mr.isMDXComponent=!0;const dr={toc:[]};function hr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}hr.isMDXComponent=!0;const yr={toc:[]};function kr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}kr.isMDXComponent=!0;const fr={toc:[]};function Dr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}Dr.isMDXComponent=!0;const Mr={toc:[]};function _r(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}_r.isMDXComponent=!0;const Xr={toc:[]};function wr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}wr.isMDXComponent=!0;const Tr={toc:[]};function Cr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}Cr.isMDXComponent=!0;const xr={toc:[]};function gr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}gr.isMDXComponent=!0;const Lr={toc:[]};function Zr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}Zr.isMDXComponent=!0;const br={toc:[]};function vr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},br,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}vr.isMDXComponent=!0;const Nr={toc:[]};function Sr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}Sr.isMDXComponent=!0;const Ar={toc:[]};function Gr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ar,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}Gr.isMDXComponent=!0;const Pr={toc:[]};function Rr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Rr.isMDXComponent=!0;const Er={toc:[]};function Ir(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Er,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}Ir.isMDXComponent=!0;const Wr={toc:[]};function Ur(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Ur.isMDXComponent=!0;const jr={toc:[]};function zr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}zr.isMDXComponent=!0;const Fr={toc:[]};function Or(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Lifecycle events for ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," that are cleared on every reset."))}Or.isMDXComponent=!0;const qr={toc:[]};function Vr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A random number generator based on\n",(0,p.kt)("a",{parentName:"p",href:"https://gist.github.com/tommyettinger/46a874533244883189143505d203312c"},(0,p.kt)("inlineCode",{parentName:"a"},"Mulberry32")),"."))}Vr.isMDXComponent=!0;const Br={toc:[]};function Hr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Br,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random floats in the given range."))}Hr.isMDXComponent=!0;const Yr={toc:[]};function Jr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."))}Jr.isMDXComponent=!0;const Kr={toc:[]};function Qr(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kr,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}Qr.isMDXComponent=!0;const $r={toc:[]};function ts(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$r,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}ts.isMDXComponent=!0;const ns={toc:[]};function es(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ns,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get an array filled with random integers in the given range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"}),(0,p.kt)("li",{parentName:"ul"})))}es.isMDXComponent=!0;const os={toc:[]};function ps(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},os,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The size of the array."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}ps.isMDXComponent=!0;const cs={toc:[]};function rs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"})))}rs.isMDXComponent=!0;const ss={toc:[]};function as(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ss,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}as.isMDXComponent=!0;const is={toc:[]};function ls(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},is,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random float in the given range."))}ls.isMDXComponent=!0;const us={toc:[]};function ms(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},us,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ms.isMDXComponent=!0;const ds={toc:[]};function hs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ds,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range."))}hs.isMDXComponent=!0;const ys={toc:[]};function ks(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ys,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the next random integer in the given range."))}ks.isMDXComponent=!0;const fs={toc:[]};function Ds(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}Ds.isMDXComponent=!0;const Ms={toc:[]};function _s(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ms,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. Exclusive."))}_s.isMDXComponent=!0;const Xs={toc:[]};function ws(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a new independent generator."))}ws.isMDXComponent=!0;const Ts={toc:[]};function Cs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ts,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Manages time events for a given scene."))}Cs.isMDXComponent=!0;const xs={toc:[]};function gs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when time events change."))}gs.isMDXComponent=!0;const Ls={toc:[]};function Zs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ls,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Change the time offset of the given event."))}Zs.isMDXComponent=!0;const bs={toc:[]};function vs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The name of the event."))}vs.isMDXComponent=!0;const Ns={toc:[]};function Ss(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ns,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The time offset in seconds."))}Ss.isMDXComponent=!0;const As={toc:[]};function Gs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},As,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the timing of the consecutive events should be\npreserved. When set to ",(0,p.kt)("inlineCode",{parentName:"p"},"true")," their offsets will be\nadjusted to keep them in place."))}Gs.isMDXComponent=!0;const Ps={toc:[]};function Rs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ps,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes cached information about the timing of a scene."))}Rs.isMDXComponent=!0;const Es={toc:[]};function Is(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Es,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a complete scene together with the meta file."))}Is.isMDXComponent=!0;const Ws={toc:[]};function Us(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ws,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Us.isMDXComponent=!0;const js={toc:[]};function zs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},js,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}zs.isMDXComponent=!0;const Fs={toc:[]};function Os(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Os.isMDXComponent=!0;const qs={toc:[]};function Vs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Vs.isMDXComponent=!0;const Bs={toc:[]};function Hs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bs,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to make their components\ninspectable through the UI."))}Hs.isMDXComponent=!0;const Ys={toc:[]};function Js(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ys,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to overlay additional information about an\nelement on top of the animation."))}Js.isMDXComponent=!0;const Ks={toc:[]};function Qs(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ks,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for the inspected element."))}Qs.isMDXComponent=!0;const $s={toc:[]};function ta(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$s,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element for which to draw an overlay."))}ta.isMDXComponent=!0;const na={toc:[]};function ea(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},na,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}ea.isMDXComponent=!0;const oa={toc:[]};function pa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}pa.isMDXComponent=!0;const ca={toc:[]};function ra(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ca,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,'This information will be displayed in the "Properties" panel.'))}ra.isMDXComponent=!0;const sa={toc:[]};function aa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Return the attributes of the inspected element."))}aa.isMDXComponent=!0;const ia={toc:[]};function la(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ia,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to inspect."))}la.isMDXComponent=!0;const ua={toc:[]};function ma(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ua,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a possible element to inspect at a given position."))}ma.isMDXComponent=!0;const da={toc:[]};function ha(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},da,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The x coordinate."))}ha.isMDXComponent=!0;const ya={toc:[]};function ka(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ya,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The y coordinate."))}ka.isMDXComponent=!0;const fa={toc:[]};function Da(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If a scene destroys and recreates its components upon every reset, the\nreference may no longer be valid. Even though the component is still\npresent. This method should check that and return a new reference."))}Da.isMDXComponent=!0;const Ma={toc:[]};function _a(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ma,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the inspected element is still valid."))}_a.isMDXComponent=!0;const Xa={toc:[]};function wa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The element to validate."))}wa.isMDXComponent=!0;const Ta={toc:[]};function Ca(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ta,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event stored in a meta file."))}Ca.isMDXComponent=!0;const xa={toc:[]};function ga(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any class implementing this interface should have a constructor matching\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneConstructor"},(0,p.kt)("inlineCode",{parentName:"a"},"SceneConstructor")),"."))}ga.isMDXComponent=!0;const La={toc:[]};function Za(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},La,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main interface for scenes."))}Za.isMDXComponent=!0;const ba={toc:[]};function va(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ba,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Will be passed as the second argument to the constructor."))}va.isMDXComponent=!0;const Na={toc:[]};function Sa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Na,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the scene."))}Sa.isMDXComponent=!0;const Aa={toc:[]};function Ga(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Aa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reference to the project."))}Ga.isMDXComponent=!0;const Pa={toc:[]};function Ra(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene's ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/LifecycleEvents"},(0,p.kt)("inlineCode",{parentName:"a"},"LifecycleEvents")),"."))}Ra.isMDXComponent=!0;const Ea={toc:[]};function Ia(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ea,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene starts."))}Ia.isMDXComponent=!0;const Wa={toc:[]};function Ua(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The frame at which this scene ends."))}Ua.isMDXComponent=!0;const ja={toc:[]};function za(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ja,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the cached data changes."))}za.isMDXComponent=!0;const Fa={toc:[]};function Oa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered after scene is recalculated."))}Oa.isMDXComponent=!0;const qa={toc:[]};function Va(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qa,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reloaded."))}Va.isMDXComponent=!0;const Ba={toc:[]};function Ha(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ba,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered at various stages of the render lifecycle with an event title and a Context2D."))}Ha.isMDXComponent=!0;const Ya={toc:[]};function Ja(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ya,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the scene is reset."))}Ja.isMDXComponent=!0;const Ka={toc:[]};function Qa(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ka,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The scene directly before this scene, or null if omitted for performance."))}Qa.isMDXComponent=!0;const $a={toc:[]};function ti(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$a,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state?"))}ti.isMDXComponent=!0;const ni={toc:[]};function ei(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ni,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state."))}ei.isMDXComponent=!0;const oi={toc:[]};function pi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Enter the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#CanTransitionOut"},(0,p.kt)("inlineCode",{parentName:"a"},"CanTransitionOut"))," state."))}pi.isMDXComponent=!0;const ci={toc:[]};function ri(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ci,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the size of this scene."),(0,p.kt)("p",null,"Usually return ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.getSize()"),"."))}ri.isMDXComponent=!0;const si={toc:[]};function ai(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},si,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#AfterTransitionIn"},(0,p.kt)("inlineCode",{parentName:"a"},"AfterTransitionIn"))," state?"))}ai.isMDXComponent=!0;const ii={toc:[]};function li(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ii,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene cached?"),(0,p.kt)("p",null,"Used only by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/GeneratorScene"},(0,p.kt)("inlineCode",{parentName:"a"},"GeneratorScene")),". Seeking through a project that\ncontains at least one uncached scene will log a warning to the console."),(0,p.kt)("p",null,"Should always return ",(0,p.kt)("inlineCode",{parentName:"p"},"true"),"."))}li.isMDXComponent=!0;const ui={toc:[]};function mi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ui,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Is this scene in the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneState#Finished"},(0,p.kt)("inlineCode",{parentName:"a"},"Finished"))," state?"))}mi.isMDXComponent=!0;const di={toc:[]};function hi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},di,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress this scene one frame forward."))}hi.isMDXComponent=!0;const yi={toc:[]};function ki(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The task of this method is to calculate new timings stored in the cache.\nWhen this method is invoked, ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," is set to the frame at\nwhich this scene should start (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#firstFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"firstFrame")),")."),(0,p.kt)("p",null,"At the end of execution, this method should set ",(0,p.kt)("inlineCode",{parentName:"p"},"this.project.frame")," to the\nframe at which this scene ends (",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#lastFrame"},(0,p.kt)("inlineCode",{parentName:"a"},"lastFrame")),")."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onRecalculated"},(0,p.kt)("inlineCode",{parentName:"a"},"onRecalculated")),"."))}ki.isMDXComponent=!0;const fi={toc:[]};function Di(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Recalculate the scene."))}Di.isMDXComponent=!0;const Mi={toc:[]};function _i(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called whenever something related to this scene has changed:\ntime events, source code, metadata, etc."),(0,p.kt)("p",null,"Should trigger ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene#onReloaded"},(0,p.kt)("inlineCode",{parentName:"a"},"onReloaded")),"."))}_i.isMDXComponent=!0;const Xi={toc:[]};function wi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reload the scene."))}wi.isMDXComponent=!0;const Ti={toc:[]};function Ci(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ti,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, a new configuration object."))}Ci.isMDXComponent=!0;const xi={toc:[]};function gi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render the scene onto a canvas."))}gi.isMDXComponent=!0;const Li={toc:[]};function Zi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Li,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to used when rendering."))}Zi.isMDXComponent=!0;const bi={toc:[]};function vi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset this scene to its initial state."))}vi.isMDXComponent=!0;const Ni={toc:[]};function Si(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ni,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If present, the previous scene."))}Si.isMDXComponent=!0;const Ai={toc:[]};function Gi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ai,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Gi.isMDXComponent=!0;const Pi={toc:[]};function Ri(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Each class implementing the ",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/Scene"},(0,p.kt)("inlineCode",{parentName:"a"},"Scene"))," interface should have a matching\nconstructor."))}Ri.isMDXComponent=!0;const Ei={toc:[]};function Ii(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ei,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The constructor used when creating new scenes."))}Ii.isMDXComponent=!0;const Wi={toc:[]};function Ui(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object. This object will be\npassed to the constructor from\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/scenes/SceneDescription#config"},(0,p.kt)("inlineCode",{parentName:"a"},"config")),"."))}Ui.isMDXComponent=!0;const ji={toc:[]};function zi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ji,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Describes a scene exposed by scene files."))}zi.isMDXComponent=!0;const Fi={toc:[]};function Oi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Configuration object."))}Oi.isMDXComponent=!0;const qi={toc:[]};function Vi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The class used to instantiate the scene."))}Vi.isMDXComponent=!0;const Bi={toc:[]};function Hi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The stack trace at the moment of creation."))}Hi.isMDXComponent=!0;const Yi={toc:[]};function Ji(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yi,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type of the configuration object."))}Ji.isMDXComponent=!0;const Ki={toc:[]};function Qi(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ki,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents the contents of a meta file."))}Qi.isMDXComponent=!0;const $i={toc:[]};function tl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$i,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This interface is only useful when a scene uses thread generators to run."))}tl.isMDXComponent=!0;const nl={toc:[]};function el(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Scenes can implement this interface to display their thread hierarchy in the\nUI."))}el.isMDXComponent=!0;const ol={toc:[]};function pl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ol,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Triggered when the main thread changes."))}pl.isMDXComponent=!0;const cl={toc:[]};function rl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a time event at runtime."))}rl.isMDXComponent=!0;const sl={toc:[]};function al(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"In other words, the moment at which ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitUntil"},(0,p.kt)("inlineCode",{parentName:"a"},"waitUntil"))," for this event\nwas invoked."))}al.isMDXComponent=!0;const il={toc:[]};function ll(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},il,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nwas registered."))}ll.isMDXComponent=!0;const ul={toc:[]};function ml(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ul,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Name of the event."))}ml.isMDXComponent=!0;const dl={toc:[]};function hl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Duration of the event in seconds."))}hl.isMDXComponent=!0;const yl={toc:[]};function kl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Stack trace at the moment of registration."))}kl.isMDXComponent=!0;const fl={toc:[]};function Dl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Time in seconds, relative to the beginning of the scene, at which the event\nshould end."))}Dl.isMDXComponent=!0;const Ml={toc:[]};function _l(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ml,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents attributes of an inspected element."))}_l.isMDXComponent=!0;const Xl={toc:[]};function wl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The type is not important because the UI does not interact with it.\nIt serves as a key that will be passed back to an Inspectable scene to\nreceive more information about said element."))}wl.isMDXComponent=!0;const Tl={toc:[]};function Cl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents an element to inspect."))}Cl.isMDXComponent=!0;const xl={toc:[]};function gl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Value wrappers for easy dependency tracking and cache invalidation."))}gl.isMDXComponent=!0;const Ll={toc:[]};function Zl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ll,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Zl.isMDXComponent=!0;const bl={toc:[]};function vl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}vl.isMDXComponent=!0;const Nl={toc:[]};function Sl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Sl.isMDXComponent=!0;const Al={toc:[]};function Gl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Al,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Gl.isMDXComponent=!0;const Pl={toc:[]};function Rl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Rl.isMDXComponent=!0;const El={toc:[]};function Il(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},El,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}Il.isMDXComponent=!0;const Wl={toc:[]};function Ul(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}Ul.isMDXComponent=!0;const jl={toc:[]};function zl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}zl.isMDXComponent=!0;const Fl={toc:[]};function Ol(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}Ol.isMDXComponent=!0;const ql={toc:[]};function Vl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ql,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}Vl.isMDXComponent=!0;const Bl={toc:[]};function Hl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}Hl.isMDXComponent=!0;const Yl={toc:[]};function Jl(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}Jl.isMDXComponent=!0;const Kl={toc:[]};function Ql(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kl,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}Ql.isMDXComponent=!0;const $l={toc:[]};function tu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$l,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}tu.isMDXComponent=!0;const nu={toc:[]};function eu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}eu.isMDXComponent=!0;const ou={toc:[]};function pu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ou,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}pu.isMDXComponent=!0;const cu={toc:[]};function ru(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}ru.isMDXComponent=!0;const su={toc:[]};function au(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},su,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}au.isMDXComponent=!0;const iu={toc:[]};function lu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},iu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}lu.isMDXComponent=!0;const uu={toc:[]};function mu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread management."))}mu.isMDXComponent=!0;const du={toc:[]};function hu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},du,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Thread is a wrapper for a generator that can be executed concurrently."),(0,p.kt)("p",null,"Aside from the main thread, all threads need to have a parent.\nIf a parent finishes execution, all of its child threads are terminated."))}hu.isMDXComponent=!0;const yu={toc:[]};function ku(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A class representing an individual thread."))}ku.isMDXComponent=!0;const fu={toc:[]};function Du(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}Du.isMDXComponent=!0;const Mu={toc:[]};function _u(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The generator wrapped by this thread."))}_u.isMDXComponent=!0;const Xu={toc:[]};function wu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Used by ",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor"))," and other time-based functions to properly\nsupport durations shorter than one frame."))}wu.isMDXComponent=!0;const Tu={toc:[]};function Cu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The current time of this thread."))}Cu.isMDXComponent=!0;const xu={toc:[]};function gu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The next value to be passed to the wrapped generator."))}gu.isMDXComponent=!0;const Lu={toc:[]};function Zu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if this thread or any of its ancestors has been canceled."))}Zu.isMDXComponent=!0;const bu={toc:[]};function vu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Progress the wrapped generator once."))}vu.isMDXComponent=!0;const Nu={toc:[]};function Su(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the thread for the next update cycle."))}Su.isMDXComponent=!0;const Au={toc:[]};function Gu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Au,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A generator function or a normal function that returns a generator."))}Gu.isMDXComponent=!0;const Pu={toc:[]};function Ru(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Yielded values can be used to control the flow of animation:"),(0,p.kt)("p",null,"Progress to the next frame:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield;\n")),(0,p.kt)("p",null,"Run another generator synchronously:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"yield* generatorFunction();\n")),(0,p.kt)("p",null,"Run another generator concurrently:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n")),(0,p.kt)("p",null,"Await a Promise:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const result = yield asyncFunction();\n")))}Ru.isMDXComponent=!0;const Eu={toc:[]};function Iu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The main generator type produced by all generator functions in Motion Canvas."))}Iu.isMDXComponent=!0;const Wu={toc:[]};function Uu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Cancel all listed tasks."),(0,p.kt)("p",null,"Example:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* cancel(task);\n")))}Uu.isMDXComponent=!0;const ju={toc:[]};function zu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ju,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to cancel."))}zu.isMDXComponent=!0;const Fu={toc:[]};function Ou(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ","[Promise][promise]","."))}Ou.isMDXComponent=!0;const qu={toc:[]};function Vu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise"},"Promise"),"."))}Vu.isMDXComponent=!0;const Bu={toc:[]};function Hu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Check if the given value is a ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Hu.isMDXComponent=!0;const Yu={toc:[]};function Ju(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yu,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A possible thread ",(0,p.kt)("a",{parentName:"p",href:"/api/core/threading#ThreadGenerator"},(0,p.kt)("inlineCode",{parentName:"a"},"ThreadGenerator")),"."))}Ju.isMDXComponent=!0;const Ku={toc:[]};function Qu(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ku,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const task = yield generatorFunction();\n\n// do something concurrently\n\nyield* join(task);\n")))}Qu.isMDXComponent=!0;const $u={toc:[]};function tm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$u,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until all listed tasks are finished."))}tm.isMDXComponent=!0;const nm={toc:[]};function em(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}em.isMDXComponent=!0;const om={toc:[]};function pm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},om,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const taskA = yield generatorFunctionA();\nconst taskB = yield generatorFunctionB();\n\n// do something concurrently\n\n// await any of the tasks\nyield* join(false, taskA, taskB);\n")))}pm.isMDXComponent=!0;const cm={toc:[]};function rm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Pause the current generator until listed tasks are finished."))}rm.isMDXComponent=!0;const sm={toc:[]};function am(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether we should wait for all tasks or for at least one."))}am.isMDXComponent=!0;const im={toc:[]};function lm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},im,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A list of tasks to join."))}lm.isMDXComponent=!0;const um={toc:[]};function mm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},um,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"From the perspective of the external generator, ",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," is executed\nsynchronously. By default, each scene generator is wrapped in its own\n",(0,p.kt)("inlineCode",{parentName:"p"},"threads")," generator."))}mm.isMDXComponent=!0;const dm={toc:[]};function hm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// first\n\nyield* threads(function* () {\n  const task = yield generatorFunction();\n  // second\n}); // <- `task` will be terminated here because the scope\n    //    of this `threads` generator has ended\n\n// third\n")))}hm.isMDXComponent=!0;const ym={toc:[]};function km(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ym,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a context in which generators can be run concurrently."))}km.isMDXComponent=!0;const fm={toc:[]};function Dm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A function that returns the generator to run."))}Dm.isMDXComponent=!0;const Mm={toc:[]};function _m(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Called whenever threads are created, canceled or finished.\nUsed for debugging purposes."))}_m.isMDXComponent=!0;const Xm={toc:[]};function wm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transitions between scenes."))}wm.isMDXComponent=!0;const Tm={toc:[]};function Cm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Transition to the current scene by altering the Context2D before scenes are rendered."))}Cm.isMDXComponent=!0;const xm={toc:[]};function gm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the current scene is rendered."))}gm.isMDXComponent=!0;const Lm={toc:[]};function Zm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The callback to use before the previous scene is rendered."))}Zm.isMDXComponent=!0;const bm={toc:[]};function vm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolation and timing of tweens."))}vm.isMDXComponent=!0;const Nm={toc:[]};function Sm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Any old key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," will be removed immediately once value is\nnot 0. Any new key that is missing in ",(0,p.kt)("inlineCode",{parentName:"p"},"from")," will be added once value reaches"),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"})))}Sm.isMDXComponent=!0;const Am={toc:[]};function Gm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Am,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Gm.isMDXComponent=!0;const Pm={toc:[]};function Rm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two Records, including objects and Maps, even with\nmismatched keys."))}Rm.isMDXComponent=!0;const Em={toc:[]};function Im(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Em,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Im.isMDXComponent=!0;const Wm={toc:[]};function Um(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Um.isMDXComponent=!0;const jm={toc:[]};function zm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}zm.isMDXComponent=!0;const Fm={toc:[]};function Om(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A value matching the structure of from and to."))}Om.isMDXComponent=!0;const qm={toc:[]};function Vm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Interpolate between any two values, including objects, arrays, and Maps."))}Vm.isMDXComponent=!0;const Bm={toc:[]};function Hm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bm,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 0."))}Hm.isMDXComponent=!0;const Ym={toc:[]};function Jm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ym,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The input to favor when value is 1."))}Jm.isMDXComponent=!0;const Km={toc:[]};function Qm(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Km,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"On a scale between 0 and 1, how closely to favor from vs to."))}Qm.isMDXComponent=!0;const $m={toc:[]};function td(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$m,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Complex types used in animations."))}td.isMDXComponent=!0;const nd={toc:[]};function ed(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Represents a two-dimensional vector."))}ed.isMDXComponent=!0;const od={toc:[]};function pd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},od,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n")))}pd.isMDXComponent=!0;const cd={toc:[]};function rd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The unclipped RGB components."))}rd.isMDXComponent=!0;const sd={toc:[]};function ad(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma.hcl(50, 40, 20).clipped() === true\n")))}ad.isMDXComponent=!0;const id={toc:[]};function ld(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},id,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Test if a color has been clipped or not.\nColors generated from CIELab color space may have their RGB\nchannels clipped to the range of ","[0..255]",".\nColors outside that range may exist in nature but are not\ndisplayable on RGB monitors (such as ultraviolet)."))}ld.isMDXComponent=!0;const ud={toc:[]};function md(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ud,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}md.isMDXComponent=!0;const dd={toc:[]};function hd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned\narray."))}hd.isMDXComponent=!0;const yd={toc:[]};function kd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('33cc00').gl() === [0.2,0.8,0,1]\n")))}kd.isMDXComponent=!0;const fd={toc:[]};function Dd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the cyan, magenta, yellow, and key (black)\ncomponents, each as a normalized value between 0 and 1."))}Dd.isMDXComponent=!0;const Md={toc:[]};function _d(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Md,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').hcl() === [235.11,25.94,79.21]\n")))}_d.isMDXComponent=!0;const Xd={toc:[]};function wd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Alias of ",(0,p.kt)("a",{parentName:"p",href:"#color-lch"},"lch"),", but with the components in reverse\norder."))}wd.isMDXComponent=!0;const Td={toc:[]};function Cd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Td,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsi() === [39.64,1,0.55]\nchroma('white').hsi() === [NaN,0,1]\n")))}Cd.isMDXComponent=!0;const xd={toc:[]};function gd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"intensity"),"\ncomponents, each as number between 0 and 255. Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}gd.isMDXComponent=!0;const Ld={toc:[]};function Zd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ld,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsl() === [38.82,1,0.5,1]\nchroma('white').hsl() === [NaN,0,1,1]\n")))}Zd.isMDXComponent=!0;const bd={toc:[]};function vd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"lightness"),"\ncomponent. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"), saturation\nand lightness are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less colors\n(black, white, and grays), the hue component will be NaN."))}vd.isMDXComponent=!0;const Nd={toc:[]};function Sd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hsv() === [38.82,1,1]\nchroma('white').hsv() === [NaN,0,1]\n")))}Sd.isMDXComponent=!0;const Ad={toc:[]};function Gd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ad,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("inlineCode",{parentName:"p"},"hue"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"saturation"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"value"),"\ncomponents. Hue is the color angle in degree (",(0,p.kt)("inlineCode",{parentName:"p"},"0..360"),"),\nsaturation and value are within ",(0,p.kt)("inlineCode",{parentName:"p"},"0..1"),". Note that for hue-less\ncolors (black, white, and grays), the hue component will be NaN."))}Gd.isMDXComponent=!0;const Pd={toc:[]};function Rd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').lab() === [74.94,23.93,78.95]\n")))}Rd.isMDXComponent=!0;const Ed={toc:[]};function Id(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ed,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"L"),", ",(0,p.kt)("strong",{parentName:"p"},"a"),", and ",(0,p.kt)("strong",{parentName:"p"},"b")," components."))}Id.isMDXComponent=!0;const Wd={toc:[]};function Ud(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('skyblue').lch() === [79.21,25.94,235.11]\n")))}Ud.isMDXComponent=!0;const jd={toc:[]};function zd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the ",(0,p.kt)("strong",{parentName:"p"},"Lightness"),", ",(0,p.kt)("strong",{parentName:"p"},"chroma"),", and ",(0,p.kt)("strong",{parentName:"p"},"hue"),"\ncomponents."))}zd.isMDXComponent=!0;const Fd={toc:[]};function Od(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgb() === [255,165,0]\nchroma('orange').darken().rgb() === [198,118,0]\nchroma('orange').darken().rgb(false) === [198.05,118.11,0]\n")))}Od.isMDXComponent=!0;const qd={toc:[]};function Vd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns an array with the red, green, and blue component, each as\nnumber within the range 0..255. Chroma internally stores RGB\nchannels as floats but rounds the numbers before returning them.\nYou can pass false to prevent the rounding."))}Vd.isMDXComponent=!0;const Bd={toc:[]};function Hd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').rgba() === [255,165,0,1]\nchroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n")))}Hd.isMDXComponent=!0;const Yd={toc:[]};function Jd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Just like color.rgb but adds the alpha channel to the returned array."))}Jd.isMDXComponent=!0;const Kd={toc:[]};function Qd(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kd,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get and set the color opacity."))}Qd.isMDXComponent=!0;const $d={toc:[]};function th(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$d,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\nmode defaults to ",(0,p.kt)("code",null,"'rgb'")))}th.isMDXComponent=!0;const nh={toc:[]};function eh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Similar to saturate, but the opposite direction."))}eh.isMDXComponent=!0;const oh={toc:[]};function ph(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"set"))}ph.isMDXComponent=!0;const ch={toc:[]};function rh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ch,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns a single channel value.\nAlso"))}rh.isMDXComponent=!0;const sh={toc:[]};function ah(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('orange').hex() === '#ffa500'\nchroma('orange').alpha(0.5).hex() === '#ffa50080'\nchroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n")))}ah.isMDXComponent=!0;const ih={toc:[]};function lh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ih,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get color as hexadecimal string."))}lh.isMDXComponent=!0;const uh={toc:[]};function mh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"auto")," - string will include alpha channel only if it's less than 1.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgb"),"  - string will not include alpha channel.\n",(0,p.kt)("inlineCode",{parentName:"p"},"rgba")," - string will include alpha channel."))}mh.isMDXComponent=!0;const dh={toc:[]};function hh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Relative brightness, according to the\n","[WCAG][`http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef`]","(",(0,p.kt)("a",{parentName:"p",href:"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"},"http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef"),") definition. Normalized to\n0 for darkest black and 1 for lightest white."))}hh.isMDXComponent=!0;const yh={toc:[]};function kh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\nThe color space used defaults to RGB."))}kh.isMDXComponent=!0;const fh={toc:[]};function Dh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present."))}Dh.isMDXComponent=!0;const Mh={toc:[]};function _h(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"chroma('#000000').num() === 0\nchroma('#0000ff').num() === 255\nchroma('#00ff00').num() === 65280\nchroma('#ff0000').num() === 16711680\n")))}_h.isMDXComponent=!0;const Xh={toc:[]};function wh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Returns the numeric representation of the hexadecimal RGB color."))}wh.isMDXComponent=!0;const Th={toc:[]};function Ch(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Th,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes the saturation of a color by manipulating the Lch chromacity."))}Ch.isMDXComponent=!0;const xh={toc:[]};function gh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// half Lab lightness\nchroma('orangered').set('lab.l', '*0.5')\n")))}gh.isMDXComponent=!0;const Lh={toc:[]};function Zh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// double Lch saturation\nchroma('darkseagreen').set('lch.c', '*2')\n")))}Zh.isMDXComponent=!0;const bh={toc:[]};function vh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Changes a single channel and returns the result a new chroma object."))}vh.isMDXComponent=!0;const Nh={toc:[]};function Sh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n","[temperature gradient][`ChromaStatic.temperature`]","(undefined) above."))}Sh.isMDXComponent=!0;const Ah={toc:[]};function Gh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ah,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const bottomRight = originToOffset(Origin.TopRight);\n// bottomRight = {x: 1, y: -1}\n")))}Gh.isMDXComponent=!0;const Ph={toc:[]};function Rh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ph,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Convert the given origin to a vector representing its offset."))}Rh.isMDXComponent=!0;const Eh={toc:[]};function Ih(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Eh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The origin to convert."))}Ih.isMDXComponent=!0;const Wh={toc:[]};function Uh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"General utilities and helper functions."))}Uh.isMDXComponent=!0;const jh={toc:[]};function zh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("a",{parentName:"p",href:"https://v8.dev/docs/stack-trace-api#customizing-stack-traces"},"https://v8.dev/docs/stack-trace-api#customizing-stack-traces")))}zh.isMDXComponent=!0;const Fh={toc:[]};function Oh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Optional override for formatting stack traces"))}Oh.isMDXComponent=!0;const qh={toc:[]};function Vh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create .stack property on a target object"))}Vh.isMDXComponent=!0;const Bh={toc:[]};function Hh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Invoke the reference instead."))}Hh.isMDXComponent=!0;const Yh={toc:[]};function Jh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yh,e,{components:n,mdxType:"MDXLayout"}))}Jh.isMDXComponent=!0;const Kh={toc:[]};function Qh(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kh,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Mark the given function as deprecated."))}Qh.isMDXComponent=!0;const $h={toc:[]};function ty(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$h,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function to deprecate."))}ty.isMDXComponent=!0;const ny={toc:[]};function ey(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ny,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The log message."))}ey.isMDXComponent=!0;const oy={toc:[]};function py(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},oy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The optional log remarks."))}py.isMDXComponent=!0;const cy={toc:[]};function ry(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3); // [0, 1, 2]\n")))}ry.isMDXComponent=!0;const sy={toc:[]};function ay(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}ay.isMDXComponent=!0;const iy={toc:[]};function ly(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},iy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The length of the array."))}ly.isMDXComponent=!0;const uy={toc:[]};function my(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const array = range(3, 7); // [3, 4, 5, 6]\n")))}my.isMDXComponent=!0;const dy={toc:[]};function hy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an array containing a range of numbers."))}hy.isMDXComponent=!0;const yy={toc:[]};function ky(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The start of the range."))}ky.isMDXComponent=!0;const fy={toc:[]};function Dy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The end of the range. ",(0,p.kt)("inlineCode",{parentName:"p"},"to")," itself is not included in the result."))}Dy.isMDXComponent=!0;const My={toc:[]};function _y(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},My,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D before the scene is rendered."))}_y.isMDXComponent=!0;const Xy={toc:[]};function wy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context before render."))}wy.isMDXComponent=!0;const Ty={toc:[]};function Cy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ty,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Provide a function to access the Context2D after the scene is rendered."))}Cy.isMDXComponent=!0;const xy={toc:[]};function gy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The function that will be provided the context after render."))}gy.isMDXComponent=!0;const Ly={toc:[]};function Zy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ly,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current project."))}Zy.isMDXComponent=!0;const by={toc:[]};function vy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},by,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the current scene."))}vy.isMDXComponent=!0;const Ny={toc:[]};function Sy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ny,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the random number generator for the given seed."))}Sy.isMDXComponent=!0;const Ay={toc:[]};function Gy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ay,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The seed for the generator."))}Gy.isMDXComponent=!0;const Py={toc:[]};function Ry(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Py,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the seed should be fixed. Fixed seeds remain\nthe same even when the main scene seed changes."))}Ry.isMDXComponent=!0;const Ey={toc:[]};function Iy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ey,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current scene."))}Iy.isMDXComponent=!0;const Wy={toc:[]};function Uy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a reference to the current thread."))}Uy.isMDXComponent=!0;const jy={toc:[]};function zy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned value accounts for offsets caused by functions such as\n",(0,p.kt)("a",{parentName:"p",href:"/api/core/flow#waitFor"},(0,p.kt)("inlineCode",{parentName:"a"},"waitFor")),"."))}zy.isMDXComponent=!0;const Fy={toc:[]};function Oy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"// current time: 0s\nyield* waitFor(0.02);\n\n// current time: 0.016(6)s\n// real time: 0.02s\nconst realTime = useTime();\n")))}Oy.isMDXComponent=!0;const qy={toc:[]};function Vy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the real time since the start of the animation."))}Vy.isMDXComponent=!0;const By={toc:[]};function Hy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},By,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Hy.isMDXComponent=!0;const Yy={toc:[]};function Jy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yy,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}Jy.isMDXComponent=!0;const Ky={toc:[]};function Qy(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ky,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Qy.isMDXComponent=!0;const $y={toc:[]};function tk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$y,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}tk.isMDXComponent=!0;const nk={toc:[]};function ek(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}ek.isMDXComponent=!0;const ok={toc:[]};function pk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ok,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}pk.isMDXComponent=!0;const ck={toc:[]};function rk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ck,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}rk.isMDXComponent=!0;const sk={toc:[]};function ak(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}ak.isMDXComponent=!0;const ik={toc:[]};function lk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ik,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}lk.isMDXComponent=!0;const uk={toc:[]};function mk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},uk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}mk.isMDXComponent=!0;const dk={toc:[]};function hk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},dk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}hk.isMDXComponent=!0;const yk={toc:[]};function kk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},yk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}kk.isMDXComponent=!0;const fk={toc:[]};function Dk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},fk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Dk.isMDXComponent=!0;const Mk={toc:[]};function _k(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Mk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}_k.isMDXComponent=!0;const Xk={toc:[]};function wk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Xk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}wk.isMDXComponent=!0;const Tk={toc:[]};function Ck(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Tk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}Ck.isMDXComponent=!0;const xk={toc:[]};function gk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},xk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}gk.isMDXComponent=!0;const Lk={toc:[]};function Zk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Lk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Zk.isMDXComponent=!0;const bk={toc:[]};function vk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},bk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}vk.isMDXComponent=!0;const Nk={toc:[]};function Sk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Nk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Sk.isMDXComponent=!0;const Ak={toc:[]};function Gk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ak,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Gk.isMDXComponent=!0;const Pk={toc:[]};function Rk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Pk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}Rk.isMDXComponent=!0;const Ek={toc:[]};function Ik(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ek,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Ik.isMDXComponent=!0;const Wk={toc:[]};function Uk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Wk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}Uk.isMDXComponent=!0;const jk={toc:[]};function zk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},jk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}zk.isMDXComponent=!0;const Fk={toc:[]};function Ok(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Fk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Ok.isMDXComponent=!0;const qk={toc:[]};function Vk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},qk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Vk.isMDXComponent=!0;const Bk={toc:[]};function Hk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Bk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Hk.isMDXComponent=!0;const Yk={toc:[]};function Jk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Yk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Jk.isMDXComponent=!0;const Kk={toc:[]};function Qk(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Kk,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}Qk.isMDXComponent=!0;const $k={toc:[]};function tf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},$k,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}tf.isMDXComponent=!0;const nf={toc:[]};function ef(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},nf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}ef.isMDXComponent=!0;const of={toc:[]};function pf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},of,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}pf.isMDXComponent=!0;const cf={toc:[]};function rf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},cf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}rf.isMDXComponent=!0;const sf={toc:[]};function af(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},sf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}af.isMDXComponent=!0;const lf={toc:[]};function uf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}uf.isMDXComponent=!0;const mf={toc:[]};function df(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}df.isMDXComponent=!0;const hf={toc:[]};function yf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Circle#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}yf.isMDXComponent=!0;const kf={toc:[]};function ff(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ff.isMDXComponent=!0;const Df={toc:[]};function Mf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Df,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Mf.isMDXComponent=!0;const _f={toc:[]};function Xf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_f,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Xf.isMDXComponent=!0;const wf={toc:[]};function Tf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Tf.isMDXComponent=!0;const Cf={toc:[]};function xf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}xf.isMDXComponent=!0;const gf={toc:[]};function Lf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Lf.isMDXComponent=!0;const Zf={toc:[]};function bf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}bf.isMDXComponent=!0;const vf={toc:[]};function Nf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Nf.isMDXComponent=!0;const Sf={toc:[]};function Af(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Af.isMDXComponent=!0;const Gf={toc:[]};function Pf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Pf.isMDXComponent=!0;const Rf={toc:[]};function Ef(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Ef.isMDXComponent=!0;const If={toc:[]};function Wf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},If,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Wf.isMDXComponent=!0;const Uf={toc:[]};function jf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}jf.isMDXComponent=!0;const zf={toc:[]};function Ff(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Ff.isMDXComponent=!0;const Of={toc:[]};function qf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Of,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}qf.isMDXComponent=!0;const Vf={toc:[]};function Bf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Bf.isMDXComponent=!0;const Hf={toc:[]};function Yf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Yf.isMDXComponent=!0;const Jf={toc:[]};function Kf(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Kf.isMDXComponent=!0;const Qf={toc:[]};function $f(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qf,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}$f.isMDXComponent=!0;const tD={toc:[]};function nD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}nD.isMDXComponent=!0;const eD={toc:[]};function oD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}oD.isMDXComponent=!0;const pD={toc:[]};function cD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}cD.isMDXComponent=!0;const rD={toc:[]};function sD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}sD.isMDXComponent=!0;const aD={toc:[]};function iD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}iD.isMDXComponent=!0;const lD={toc:[]};function uD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}uD.isMDXComponent=!0;const mD={toc:[]};function dD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}dD.isMDXComponent=!0;const hD={toc:[]};function yD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}yD.isMDXComponent=!0;const kD={toc:[]};function fD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}fD.isMDXComponent=!0;const DD={toc:[]};function MD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}MD.isMDXComponent=!0;const _D={toc:[]};function XD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_D,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}XD.isMDXComponent=!0;const wD={toc:[]};function TD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}TD.isMDXComponent=!0;const CD={toc:[]};function xD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}xD.isMDXComponent=!0;const gD={toc:[]};function LD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}LD.isMDXComponent=!0;const ZD={toc:[]};function bD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}bD.isMDXComponent=!0;const vD={toc:[]};function ND(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}ND.isMDXComponent=!0;const SD={toc:[]};function AD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}AD.isMDXComponent=!0;const GD={toc:[]};function PD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}PD.isMDXComponent=!0;const RD={toc:[]};function ED(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}ED.isMDXComponent=!0;const ID={toc:[]};function WD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ID,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}WD.isMDXComponent=!0;const UD={toc:[]};function jD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}jD.isMDXComponent=!0;const zD={toc:[]};function FD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}FD.isMDXComponent=!0;const OD={toc:[]};function qD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}qD.isMDXComponent=!0;const VD={toc:[]};function BD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Grid#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}BD.isMDXComponent=!0;const HD={toc:[]};function YD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}YD.isMDXComponent=!0;const JD={toc:[]};function KD(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}KD.isMDXComponent=!0;const QD={toc:[]};function $D(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QD,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}$D.isMDXComponent=!0;const tM={toc:[]};function nM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}nM.isMDXComponent=!0;const eM={toc:[]};function oM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}oM.isMDXComponent=!0;const pM={toc:[]};function cM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}cM.isMDXComponent=!0;const rM={toc:[]};function sM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}sM.isMDXComponent=!0;const aM={toc:[]};function iM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}iM.isMDXComponent=!0;const lM={toc:[]};function uM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}uM.isMDXComponent=!0;const mM={toc:[]};function dM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}dM.isMDXComponent=!0;const hM={toc:[]};function yM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}yM.isMDXComponent=!0;const kM={toc:[]};function fM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}fM.isMDXComponent=!0;const DM={toc:[]};function MM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}MM.isMDXComponent=!0;const _M={toc:[]};function XM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_M,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}XM.isMDXComponent=!0;const wM={toc:[]};function TM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}TM.isMDXComponent=!0;const CM={toc:[]};function xM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}xM.isMDXComponent=!0;const gM={toc:[]};function LM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}LM.isMDXComponent=!0;const ZM={toc:[]};function bM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}bM.isMDXComponent=!0;const vM={toc:[]};function NM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}NM.isMDXComponent=!0;const SM={toc:[]};function AM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}AM.isMDXComponent=!0;const GM={toc:[]};function PM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}PM.isMDXComponent=!0;const RM={toc:[]};function EM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}EM.isMDXComponent=!0;const IM={toc:[]};function WM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}WM.isMDXComponent=!0;const UM={toc:[]};function jM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}jM.isMDXComponent=!0;const zM={toc:[]};function FM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}FM.isMDXComponent=!0;const OM={toc:[]};function qM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}qM.isMDXComponent=!0;const VM={toc:[]};function BM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}BM.isMDXComponent=!0;const HM={toc:[]};function YM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}YM.isMDXComponent=!0;const JM={toc:[]};function KM(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}KM.isMDXComponent=!0;const QM={toc:[]};function $M(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QM,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}$M.isMDXComponent=!0;const t_={toc:[]};function n_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},t_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}n_.isMDXComponent=!0;const e_={toc:[]};function o_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},e_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}o_.isMDXComponent=!0;const p_={toc:[]};function c_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},p_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}c_.isMDXComponent=!0;const r_={toc:[]};function s_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},r_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}s_.isMDXComponent=!0;const a_={toc:[]};function i_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},a_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}i_.isMDXComponent=!0;const l_={toc:[]};function u_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},l_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}u_.isMDXComponent=!0;const m_={toc:[]};function d_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},m_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}d_.isMDXComponent=!0;const h_={toc:[]};function y_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},h_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}y_.isMDXComponent=!0;const k_={toc:[]};function f_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},k_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}f_.isMDXComponent=!0;const D_={toc:[]};function M_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},D_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}M_.isMDXComponent=!0;const __={toc:[]};function X_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},__,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}X_.isMDXComponent=!0;const w_={toc:[]};function T_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},w_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}T_.isMDXComponent=!0;const C_={toc:[]};function x_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},C_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Image#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}x_.isMDXComponent=!0;const g_={toc:[]};function L_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},g_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}L_.isMDXComponent=!0;const Z_={toc:[]};function b_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Z_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}b_.isMDXComponent=!0;const v_={toc:[]};function N_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},v_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}N_.isMDXComponent=!0;const S_={toc:[]};function A_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},S_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}A_.isMDXComponent=!0;const G_={toc:[]};function P_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},G_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}P_.isMDXComponent=!0;const R_={toc:[]};function E_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},R_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}E_.isMDXComponent=!0;const I_={toc:[]};function W_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},I_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}W_.isMDXComponent=!0;const U_={toc:[]};function j_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},U_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}j_.isMDXComponent=!0;const z_={toc:[]};function F_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},z_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}F_.isMDXComponent=!0;const O_={toc:[]};function q_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},O_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}q_.isMDXComponent=!0;const V_={toc:[]};function B_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},V_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}B_.isMDXComponent=!0;const H_={toc:[]};function Y_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},H_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Y_.isMDXComponent=!0;const J_={toc:[]};function K_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},J_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}K_.isMDXComponent=!0;const Q_={toc:[]};function $_(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Q_,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}$_.isMDXComponent=!0;const tX={toc:[]};function nX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nX.isMDXComponent=!0;const eX={toc:[]};function oX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}oX.isMDXComponent=!0;const pX={toc:[]};function cX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}cX.isMDXComponent=!0;const rX={toc:[]};function sX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}sX.isMDXComponent=!0;const aX={toc:[]};function iX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}iX.isMDXComponent=!0;const lX={toc:[]};function uX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}uX.isMDXComponent=!0;const mX={toc:[]};function dX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}dX.isMDXComponent=!0;const hX={toc:[]};function yX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}yX.isMDXComponent=!0;const kX={toc:[]};function fX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}fX.isMDXComponent=!0;const DX={toc:[]};function MX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}MX.isMDXComponent=!0;const _X={toc:[]};function XX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_X,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}XX.isMDXComponent=!0;const wX={toc:[]};function TX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}TX.isMDXComponent=!0;const CX={toc:[]};function xX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}xX.isMDXComponent=!0;const gX={toc:[]};function LX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}LX.isMDXComponent=!0;const ZX={toc:[]};function bX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}bX.isMDXComponent=!0;const vX={toc:[]};function NX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}NX.isMDXComponent=!0;const SX={toc:[]};function AX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}AX.isMDXComponent=!0;const GX={toc:[]};function PX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}PX.isMDXComponent=!0;const RX={toc:[]};function EX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}EX.isMDXComponent=!0;const IX={toc:[]};function WX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}WX.isMDXComponent=!0;const UX={toc:[]};function jX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}jX.isMDXComponent=!0;const zX={toc:[]};function FX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}FX.isMDXComponent=!0;const OX={toc:[]};function qX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}qX.isMDXComponent=!0;const VX={toc:[]};function BX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}BX.isMDXComponent=!0;const HX={toc:[]};function YX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}YX.isMDXComponent=!0;const JX={toc:[]};function KX(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}KX.isMDXComponent=!0;const QX={toc:[]};function $X(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QX,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}$X.isMDXComponent=!0;const tw={toc:[]};function nw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}nw.isMDXComponent=!0;const ew={toc:[]};function ow(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ew,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Layout#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}ow.isMDXComponent=!0;const pw={toc:[]};function cw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}cw.isMDXComponent=!0;const rw={toc:[]};function sw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}sw.isMDXComponent=!0;const aw={toc:[]};function iw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}iw.isMDXComponent=!0;const lw={toc:[]};function uw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}uw.isMDXComponent=!0;const mw={toc:[]};function dw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}dw.isMDXComponent=!0;const hw={toc:[]};function yw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}yw.isMDXComponent=!0;const kw={toc:[]};function fw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}fw.isMDXComponent=!0;const Dw={toc:[]};function Mw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Mw.isMDXComponent=!0;const _w={toc:[]};function Xw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_w,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Xw.isMDXComponent=!0;const ww={toc:[]};function Tw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ww,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Tw.isMDXComponent=!0;const Cw={toc:[]};function xw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}xw.isMDXComponent=!0;const gw={toc:[]};function Lw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Lw.isMDXComponent=!0;const Zw={toc:[]};function bw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}bw.isMDXComponent=!0;const vw={toc:[]};function Nw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Nw.isMDXComponent=!0;const Sw={toc:[]};function Aw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Aw.isMDXComponent=!0;const Gw={toc:[]};function Pw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Pw.isMDXComponent=!0;const Rw={toc:[]};function Ew(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Ew.isMDXComponent=!0;const Iw={toc:[]};function Ww(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Iw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Ww.isMDXComponent=!0;const Uw={toc:[]};function jw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}jw.isMDXComponent=!0;const zw={toc:[]};function Fw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Fw.isMDXComponent=!0;const Ow={toc:[]};function qw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ow,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}qw.isMDXComponent=!0;const Vw={toc:[]};function Bw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Bw.isMDXComponent=!0;const Hw={toc:[]};function Yw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Yw.isMDXComponent=!0;const Jw={toc:[]};function Kw(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Kw.isMDXComponent=!0;const Qw={toc:[]};function $w(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qw,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}$w.isMDXComponent=!0;const tT={toc:[]};function nT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}nT.isMDXComponent=!0;const eT={toc:[]};function oT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}oT.isMDXComponent=!0;const pT={toc:[]};function cT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}cT.isMDXComponent=!0;const rT={toc:[]};function sT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}sT.isMDXComponent=!0;const aT={toc:[]};function iT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}iT.isMDXComponent=!0;const lT={toc:[]};function uT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}uT.isMDXComponent=!0;const mT={toc:[]};function dT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}dT.isMDXComponent=!0;const hT={toc:[]};function yT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}yT.isMDXComponent=!0;const kT={toc:[]};function fT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fT.isMDXComponent=!0;const DT={toc:[]};function MT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}MT.isMDXComponent=!0;const _T={toc:[]};function XT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_T,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}XT.isMDXComponent=!0;const wT={toc:[]};function TT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}TT.isMDXComponent=!0;const CT={toc:[]};function xT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}xT.isMDXComponent=!0;const gT={toc:[]};function LT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}LT.isMDXComponent=!0;const ZT={toc:[]};function bT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}bT.isMDXComponent=!0;const vT={toc:[]};function NT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}NT.isMDXComponent=!0;const ST={toc:[]};function AT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ST,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}AT.isMDXComponent=!0;const GT={toc:[]};function PT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Line#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}PT.isMDXComponent=!0;const RT={toc:[]};function ET(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ET.isMDXComponent=!0;const IT={toc:[]};function WT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}WT.isMDXComponent=!0;const UT={toc:[]};function jT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}jT.isMDXComponent=!0;const zT={toc:[]};function FT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}FT.isMDXComponent=!0;const OT={toc:[]};function qT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}qT.isMDXComponent=!0;const VT={toc:[]};function BT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}BT.isMDXComponent=!0;const HT={toc:[]};function YT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}YT.isMDXComponent=!0;const JT={toc:[]};function KT(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}KT.isMDXComponent=!0;const QT={toc:[]};function $T(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QT,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}$T.isMDXComponent=!0;const tC={toc:[]};function nC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}nC.isMDXComponent=!0;const eC={toc:[]};function oC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}oC.isMDXComponent=!0;const pC={toc:[]};function cC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}cC.isMDXComponent=!0;const rC={toc:[]};function sC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}sC.isMDXComponent=!0;const aC={toc:[]};function iC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}iC.isMDXComponent=!0;const lC={toc:[]};function uC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}uC.isMDXComponent=!0;const mC={toc:[]};function dC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}dC.isMDXComponent=!0;const hC={toc:[]};function yC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}yC.isMDXComponent=!0;const kC={toc:[]};function fC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}fC.isMDXComponent=!0;const DC={toc:[]};function MC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}MC.isMDXComponent=!0;const _C={toc:[]};function XC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_C,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}XC.isMDXComponent=!0;const wC={toc:[]};function TC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}TC.isMDXComponent=!0;const CC={toc:[]};function xC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}xC.isMDXComponent=!0;const gC={toc:[]};function LC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}LC.isMDXComponent=!0;const ZC={toc:[]};function bC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}bC.isMDXComponent=!0;const vC={toc:[]};function NC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}NC.isMDXComponent=!0;const SC={toc:[]};function AC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}AC.isMDXComponent=!0;const GC={toc:[]};function PC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}PC.isMDXComponent=!0;const RC={toc:[]};function EC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}EC.isMDXComponent=!0;const IC={toc:[]};function WC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}WC.isMDXComponent=!0;const UC={toc:[]};function jC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}jC.isMDXComponent=!0;const zC={toc:[]};function FC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}FC.isMDXComponent=!0;const OC={toc:[]};function qC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}qC.isMDXComponent=!0;const VC={toc:[]};function BC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}BC.isMDXComponent=!0;const HC={toc:[]};function YC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}YC.isMDXComponent=!0;const JC={toc:[]};function KC(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}KC.isMDXComponent=!0;const QC={toc:[]};function $C(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QC,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}$C.isMDXComponent=!0;const tx={toc:[]};function nx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Node#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}nx.isMDXComponent=!0;const ex={toc:[]};function ox(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ex,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ox.isMDXComponent=!0;const px={toc:[]};function cx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},px,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}cx.isMDXComponent=!0;const rx={toc:[]};function sx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}sx.isMDXComponent=!0;const ax={toc:[]};function ix(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ax,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}ix.isMDXComponent=!0;const lx={toc:[]};function ux(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}ux.isMDXComponent=!0;const mx={toc:[]};function dx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}dx.isMDXComponent=!0;const hx={toc:[]};function yx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}yx.isMDXComponent=!0;const kx={toc:[]};function fx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}fx.isMDXComponent=!0;const Dx={toc:[]};function Mx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Mx.isMDXComponent=!0;const _x={toc:[]};function Xx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_x,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}Xx.isMDXComponent=!0;const wx={toc:[]};function Tx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}Tx.isMDXComponent=!0;const Cx={toc:[]};function xx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}xx.isMDXComponent=!0;const gx={toc:[]};function Lx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}Lx.isMDXComponent=!0;const Zx={toc:[]};function bx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}bx.isMDXComponent=!0;const vx={toc:[]};function Nx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Nx.isMDXComponent=!0;const Sx={toc:[]};function Ax(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Ax.isMDXComponent=!0;const Gx={toc:[]};function Px(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Px.isMDXComponent=!0;const Rx={toc:[]};function Ex(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}Ex.isMDXComponent=!0;const Ix={toc:[]};function Wx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ix,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Wx.isMDXComponent=!0;const Ux={toc:[]};function jx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ux,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}jx.isMDXComponent=!0;const zx={toc:[]};function Fx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Fx.isMDXComponent=!0;const Ox={toc:[]};function qx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ox,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}qx.isMDXComponent=!0;const Vx={toc:[]};function Bx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Bx.isMDXComponent=!0;const Hx={toc:[]};function Yx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Yx.isMDXComponent=!0;const Jx={toc:[]};function Kx(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Kx.isMDXComponent=!0;const Qx={toc:[]};function $x(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qx,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}$x.isMDXComponent=!0;const tg={toc:[]};function ng(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ng.isMDXComponent=!0;const eg={toc:[]};function og(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}og.isMDXComponent=!0;const pg={toc:[]};function cg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}cg.isMDXComponent=!0;const rg={toc:[]};function sg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}sg.isMDXComponent=!0;const ag={toc:[]};function ig(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ag,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}ig.isMDXComponent=!0;const lg={toc:[]};function ug(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}ug.isMDXComponent=!0;const mg={toc:[]};function dg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dg.isMDXComponent=!0;const hg={toc:[]};function yg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}yg.isMDXComponent=!0;const kg={toc:[]};function fg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}fg.isMDXComponent=!0;const Dg={toc:[]};function Mg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}Mg.isMDXComponent=!0;const _g={toc:[]};function Xg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_g,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Xg.isMDXComponent=!0;const wg={toc:[]};function Tg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Tg.isMDXComponent=!0;const Cg={toc:[]};function xg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}xg.isMDXComponent=!0;const gg={toc:[]};function Lg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Lg.isMDXComponent=!0;const Zg={toc:[]};function bg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}bg.isMDXComponent=!0;const vg={toc:[]};function Ng(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Rect#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}Ng.isMDXComponent=!0;const Sg={toc:[]};function Ag(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Ag.isMDXComponent=!0;const Gg={toc:[]};function Pg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Pg.isMDXComponent=!0;const Rg={toc:[]};function Eg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Eg.isMDXComponent=!0;const Ig={toc:[]};function Wg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ig,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Wg.isMDXComponent=!0;const Ug={toc:[]};function jg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ug,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}jg.isMDXComponent=!0;const zg={toc:[]};function Fg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}Fg.isMDXComponent=!0;const Og={toc:[]};function qg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Og,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}qg.isMDXComponent=!0;const Vg={toc:[]};function Bg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Bg.isMDXComponent=!0;const Hg={toc:[]};function Yg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Yg.isMDXComponent=!0;const Jg={toc:[]};function Kg(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}Kg.isMDXComponent=!0;const Qg={toc:[]};function $g(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qg,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}$g.isMDXComponent=!0;const tL={toc:[]};function nL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}nL.isMDXComponent=!0;const eL={toc:[]};function oL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}oL.isMDXComponent=!0;const pL={toc:[]};function cL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}cL.isMDXComponent=!0;const rL={toc:[]};function sL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}sL.isMDXComponent=!0;const aL={toc:[]};function iL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}iL.isMDXComponent=!0;const lL={toc:[]};function uL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}uL.isMDXComponent=!0;const mL={toc:[]};function dL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}dL.isMDXComponent=!0;const hL={toc:[]};function yL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}yL.isMDXComponent=!0;const kL={toc:[]};function fL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}fL.isMDXComponent=!0;const DL={toc:[]};function ML(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}ML.isMDXComponent=!0;const _L={toc:[]};function XL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_L,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}XL.isMDXComponent=!0;const wL={toc:[]};function TL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}TL.isMDXComponent=!0;const CL={toc:[]};function xL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}xL.isMDXComponent=!0;const gL={toc:[]};function LL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}LL.isMDXComponent=!0;const ZL={toc:[]};function bL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}bL.isMDXComponent=!0;const vL={toc:[]};function NL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}NL.isMDXComponent=!0;const SL={toc:[]};function AL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}AL.isMDXComponent=!0;const GL={toc:[]};function PL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}PL.isMDXComponent=!0;const RL={toc:[]};function EL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}EL.isMDXComponent=!0;const IL={toc:[]};function WL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}WL.isMDXComponent=!0;const UL={toc:[]};function jL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}jL.isMDXComponent=!0;const zL={toc:[]};function FL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}FL.isMDXComponent=!0;const OL={toc:[]};function qL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}qL.isMDXComponent=!0;const VL={toc:[]};function BL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}BL.isMDXComponent=!0;const HL={toc:[]};function YL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}YL.isMDXComponent=!0;const JL={toc:[]};function KL(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}KL.isMDXComponent=!0;const QL={toc:[]};function $L(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QL,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}$L.isMDXComponent=!0;const tZ={toc:[]};function nZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}nZ.isMDXComponent=!0;const eZ={toc:[]};function oZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}oZ.isMDXComponent=!0;const pZ={toc:[]};function cZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}cZ.isMDXComponent=!0;const rZ={toc:[]};function sZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}sZ.isMDXComponent=!0;const aZ={toc:[]};function iZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Shape#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}iZ.isMDXComponent=!0;const lZ={toc:[]};function uZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}uZ.isMDXComponent=!0;const mZ={toc:[]};function dZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}dZ.isMDXComponent=!0;const hZ={toc:[]};function yZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}yZ.isMDXComponent=!0;const kZ={toc:[]};function fZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}fZ.isMDXComponent=!0;const DZ={toc:[]};function MZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}MZ.isMDXComponent=!0;const _Z={toc:[]};function XZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_Z,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}XZ.isMDXComponent=!0;const wZ={toc:[]};function TZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}TZ.isMDXComponent=!0;const CZ={toc:[]};function xZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}xZ.isMDXComponent=!0;const gZ={toc:[]};function LZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}LZ.isMDXComponent=!0;const ZZ={toc:[]};function bZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}bZ.isMDXComponent=!0;const vZ={toc:[]};function NZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}NZ.isMDXComponent=!0;const SZ={toc:[]};function AZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}AZ.isMDXComponent=!0;const GZ={toc:[]};function PZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}PZ.isMDXComponent=!0;const RZ={toc:[]};function EZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}EZ.isMDXComponent=!0;const IZ={toc:[]};function WZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}WZ.isMDXComponent=!0;const UZ={toc:[]};function jZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}jZ.isMDXComponent=!0;const zZ={toc:[]};function FZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}FZ.isMDXComponent=!0;const OZ={toc:[]};function qZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}qZ.isMDXComponent=!0;const VZ={toc:[]};function BZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}BZ.isMDXComponent=!0;const HZ={toc:[]};function YZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}YZ.isMDXComponent=!0;const JZ={toc:[]};function KZ(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}KZ.isMDXComponent=!0;const QZ={toc:[]};function $Z(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QZ,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}$Z.isMDXComponent=!0;const tb={toc:[]};function nb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}nb.isMDXComponent=!0;const eb={toc:[]};function ob(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}ob.isMDXComponent=!0;const pb={toc:[]};function cb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}cb.isMDXComponent=!0;const rb={toc:[]};function sb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}sb.isMDXComponent=!0;const ab={toc:[]};function ib(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ab,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}ib.isMDXComponent=!0;const lb={toc:[]};function ub(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}ub.isMDXComponent=!0;const mb={toc:[]};function db(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}db.isMDXComponent=!0;const hb={toc:[]};function yb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}yb.isMDXComponent=!0;const kb={toc:[]};function fb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}fb.isMDXComponent=!0;const Db={toc:[]};function Mb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Db,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Mb.isMDXComponent=!0;const _b={toc:[]};function Xb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_b,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}Xb.isMDXComponent=!0;const wb={toc:[]};function Tb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}Tb.isMDXComponent=!0;const Cb={toc:[]};function xb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}xb.isMDXComponent=!0;const gb={toc:[]};function Lb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Lb.isMDXComponent=!0;const Zb={toc:[]};function bb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}bb.isMDXComponent=!0;const vb={toc:[]};function Nb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}Nb.isMDXComponent=!0;const Sb={toc:[]};function Ab(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}Ab.isMDXComponent=!0;const Gb={toc:[]};function Pb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}Pb.isMDXComponent=!0;const Rb={toc:[]};function Eb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}Eb.isMDXComponent=!0;const Ib={toc:[]};function Wb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ib,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}Wb.isMDXComponent=!0;const Ub={toc:[]};function jb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ub,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Text#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}jb.isMDXComponent=!0;const zb={toc:[]};function Fb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}Fb.isMDXComponent=!0;const Ob={toc:[]};function qb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ob,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}qb.isMDXComponent=!0;const Vb={toc:[]};function Bb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}Bb.isMDXComponent=!0;const Hb={toc:[]};function Yb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}Yb.isMDXComponent=!0;const Jb={toc:[]};function Kb(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}Kb.isMDXComponent=!0;const Qb={toc:[]};function $b(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qb,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}$b.isMDXComponent=!0;const tv={toc:[]};function nv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}nv.isMDXComponent=!0;const ev={toc:[]};function ov(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ev,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}ov.isMDXComponent=!0;const pv={toc:[]};function cv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}cv.isMDXComponent=!0;const rv={toc:[]};function sv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}sv.isMDXComponent=!0;const av={toc:[]};function iv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},av,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}iv.isMDXComponent=!0;const lv={toc:[]};function uv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}uv.isMDXComponent=!0;const mv={toc:[]};function dv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}dv.isMDXComponent=!0;const hv={toc:[]};function yv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}yv.isMDXComponent=!0;const kv={toc:[]};function fv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}fv.isMDXComponent=!0;const Dv={toc:[]};function Mv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Dv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}Mv.isMDXComponent=!0;const _v={toc:[]};function Xv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_v,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}Xv.isMDXComponent=!0;const wv={toc:[]};function Tv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}Tv.isMDXComponent=!0;const Cv={toc:[]};function xv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Cv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}xv.isMDXComponent=!0;const gv={toc:[]};function Lv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Lv.isMDXComponent=!0;const Zv={toc:[]};function bv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Zv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}bv.isMDXComponent=!0;const vv={toc:[]};function Nv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}Nv.isMDXComponent=!0;const Sv={toc:[]};function Av(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Sv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}Av.isMDXComponent=!0;const Gv={toc:[]};function Pv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Gv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}Pv.isMDXComponent=!0;const Rv={toc:[]};function Ev(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Rv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}Ev.isMDXComponent=!0;const Iv={toc:[]};function Wv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Iv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}Wv.isMDXComponent=!0;const Uv={toc:[]};function jv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Uv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}jv.isMDXComponent=!0;const zv={toc:[]};function Fv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}Fv.isMDXComponent=!0;const Ov={toc:[]};function qv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Ov,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}qv.isMDXComponent=!0;const Vv={toc:[]};function Bv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Vv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}Bv.isMDXComponent=!0;const Hv={toc:[]};function Yv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Hv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}Yv.isMDXComponent=!0;const Jv={toc:[]};function Kv(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Jv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}Kv.isMDXComponent=!0;const Qv={toc:[]};function $v(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},Qv,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}$v.isMDXComponent=!0;const tN={toc:[]};function nN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}nN.isMDXComponent=!0;const eN={toc:[]};function oN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}oN.isMDXComponent=!0;const pN={toc:[]};function cN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}cN.isMDXComponent=!0;const rN={toc:[]};function sN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}sN.isMDXComponent=!0;const aN={toc:[]};function iN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}iN.isMDXComponent=!0;const lN={toc:[]};function uN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}uN.isMDXComponent=!0;const mN={toc:[]};function dN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}dN.isMDXComponent=!0;const hN={toc:[]};function yN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}yN.isMDXComponent=!0;const kN={toc:[]};function fN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}fN.isMDXComponent=!0;const DN={toc:[]};function MN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/Video#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}MN.isMDXComponent=!0;const _N={toc:[]};function XN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_N,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}XN.isMDXComponent=!0;const wN={toc:[]};function TN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}TN.isMDXComponent=!0;const CN={toc:[]};function xN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}xN.isMDXComponent=!0;const gN={toc:[]};function LN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}LN.isMDXComponent=!0;const ZN={toc:[]};function bN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}bN.isMDXComponent=!0;const vN={toc:[]};function NN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node as well\nas its children."))}NN.isMDXComponent=!0;const SN={toc:[]};function AN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a cache canvas with the contents of this node rendered onto it."))}AN.isMDXComponent=!0;const GN={toc:[]};function PN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}PN.isMDXComponent=!0;const RN={toc:[]};function EN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}EN.isMDXComponent=!0;const IN={toc:[]};function WN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Collect all asynchronous resources used by this node."))}WN.isMDXComponent=!0;const UN={toc:[]};function jN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain effects such as blur and shadows ignore the current transformation.\nThis matrix can be used to transform their parameters so that the effect\nappears relative to the closes composite root."))}jN.isMDXComponent=!0;const zN={toc:[]};function FN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A matrix mapping composite space to world space."))}FN.isMDXComponent=!0;const ON={toc:[]};function qN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ON,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is used when drawing directly onto the screen as well as onto\nthe cache canvas.\nIt assumes that the context have already been transformed to local space."))}qN.isMDXComponent=!0;const VN={toc:[]};function BN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw this node onto the canvas."))}BN.isMDXComponent=!0;const HN={toc:[]};function YN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}YN.isMDXComponent=!0;const JN={toc:[]};function KN(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The overlay for the currently inspected node is displayed on top of the\ncanvas."),(0,p.kt)("p",null,"The provided context is in screen space. The local-to-screen matrix can be\nused to transform all shapes that need to be displayed.\nThis approach allows to keep the line widths and gizmo sizes consistent,\nno matter how zoomed-in the view is."))}KN.isMDXComponent=!0;const QN={toc:[]};function $N(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QN,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Draw an overlay for this node."))}$N.isMDXComponent=!0;const tS={toc:[]};function nS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}nS.isMDXComponent=!0;const eS={toc:[]};function oS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A local-to-screen matrix."))}oS.isMDXComponent=!0;const pS={toc:[]};function cS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}cS.isMDXComponent=!0;const rS={toc:[]};function sS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node (including\neffects applied after caching)."))}sS.isMDXComponent=!0;const aS={toc:[]};function iS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The returned rectangle should be in local space."))}iS.isMDXComponent=!0;const lS={toc:[]};function uS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get a rectangle encapsulating the contents rendered by this node."))}uS.isMDXComponent=!0;const mS={toc:[]};function dS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Try to find a node intersecting the given position."))}dS.isMDXComponent=!0;const hS={toc:[]};function yS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The searched position."))}yS.isMDXComponent=!0;const kS={toc:[]};function fS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an instance of this node's class."))}fS.isMDXComponent=!0;const DS={toc:[]};function MS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to pass to the constructor."))}MS.isMDXComponent=!0;const _S={toc:[]};function XS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_S,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When the mode is ",(0,p.kt)("inlineCode",{parentName:"p"},"null"),", its value will be inherited from the parent."),(0,p.kt)("p",null,"Use ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#layout"},(0,p.kt)("inlineCode",{parentName:"a"},"layout"))," to get the raw mode set for this node (without\ninheritance)."))}XS.isMDXComponent=!0;const wS={toc:[]};function TS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the resolved layout mode of this node."))}TS.isMDXComponent=!0;const CS={toc:[]};function xS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the offset of this node and adjust the position to keep it in the\nsame place."))}xS.isMDXComponent=!0;const gS={toc:[]};function LS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The new offset."))}LS.isMDXComponent=!0;const ZS={toc:[]};function bS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A reactive copy has all its properties dynamically updated to match the\nsource node."))}bS.isMDXComponent=!0;const vS={toc:[]};function NS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a reactive copy of this node."))}NS.isMDXComponent=!0;const SS={toc:[]};function AS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}AS.isMDXComponent=!0;const GS={toc:[]};function PS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Render this node onto the given canvas."))}PS.isMDXComponent=!0;const RS={toc:[]};function ES(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context to draw with."))}ES.isMDXComponent=!0;const IS={toc:[]};function WS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new font changes to this node and all of its ancestors."))}WS.isMDXComponent=!0;const US={toc:[]};function jS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},US,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Find the closest layout root and apply any new layout changes."))}jS.isMDXComponent=!0;const zS={toc:[]};function FS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether this node should be cached or not."))}FS.isMDXComponent=!0;const OS={toc:[]};function qS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method is called before the contents of the cache canvas are drawn\non the screen. It can be used to apply effects to the entire node together\nwith its children, instead of applying them individually.\nEffects such as transparency, shadows, and filters use this technique."),(0,p.kt)("p",null,"Whether the node is cached is decided by the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#requiresCache"},(0,p.kt)("inlineCode",{parentName:"a"},"requiresCache"))," method."))}qS.isMDXComponent=!0;const VS={toc:[]};function BS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Prepare the given context for drawing a cached node onto it."))}BS.isMDXComponent=!0;const HS={toc:[]};function YS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The context using which the cache will be drawn."))}YS.isMDXComponent=!0;const JS={toc:[]};function KS(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Unlike ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/components/View2D#clone"},(0,p.kt)("inlineCode",{parentName:"a"},"clone")),", a snapshot clone calculates any reactive properties\nat the moment of cloning and passes the raw values to the copy."))}KS.isMDXComponent=!0;const QS={toc:[]};function $S(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QS,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a copy of this node."))}$S.isMDXComponent=!0;const tA={toc:[]};function nA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Properties to override."))}nA.isMDXComponent=!0;const eA={toc:[]};function oA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Apply any new layout changes to this node and its children."))}oA.isMDXComponent=!0;const pA={toc:[]};function cA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Certain resources like images are always loaded asynchronously.\nAwaiting this method makes sure that all such resources are done loading\nbefore continuing the animation."))}cA.isMDXComponent=!0;const rA={toc:[]};function sA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Wait for any asynchronous resources that this node or its children have."))}sA.isMDXComponent=!0;const aA={toc:[]};function iA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"If the signal was provided with a factory function, the function itself\nwill be returned, without invoking it."),(0,p.kt)("p",null,"This method can be used to create copies of signals."))}iA.isMDXComponent=!0;const lA={toc:[]};function uA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const a = createSignal(2);\nconst b = createSignal(() => a);\n// b() == 2\n\nconst bClone = createSignal(b.raw());\n// bClone() == 2\n\na(4);\n// b() == 4\n// bClone() == 4\n")))}uA.isMDXComponent=!0;const mA={toc:[]};function dA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Get the raw value of this signal."))}dA.isMDXComponent=!0;const hA={toc:[]};function yA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"const signal = createSignal(7);\n\nsignal.reset();\n// same as:\nsignal(7);\n")))}yA.isMDXComponent=!0;const kA={toc:[]};function fA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Reset the signal to its initial value (if one has been set)."))}fA.isMDXComponent=!0;const DA={toc:[]};function MA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This method can be used to stop the signal from updating while keeping its\ncurrent value."))}MA.isMDXComponent=!0;const _A={toc:[]};function XA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_A,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"signal.save();\n// same as:\nsignal(signal());\n")))}XA.isMDXComponent=!0;const wA={toc:[]};function TA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Compute the current value of the signal and immediately set it."))}TA.isMDXComponent=!0;const CA={toc:[]};function xA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be copied over when\ncloning the node."),(0,p.kt)("p",null,"By default, any property is cloneable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}xA.isMDXComponent=!0;const gA={toc:[]};function LA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@clone(false)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}LA.isMDXComponent=!0;const ZA={toc:[]};function bA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a cloneable property decorator."))}bA.isMDXComponent=!0;const vA={toc:[]};function NA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be cloneable."))}NA.isMDXComponent=!0;const SA={toc:[]};function AA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns a given property into a signal consisting of one or more\nnested signals."))}AA.isMDXComponent=!0;const GA={toc:[]};function PA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@compound({x: 'scaleX', y: 'scaleY'})\n  public declare readonly scale: Signal<Vector2, this>;\n\n  public setScale() {\n    this.scale({x: 7, y: 3});\n    // same as:\n    this.scale.x(7).scale.y(3);\n  }\n}\n")))}PA.isMDXComponent=!0;const RA={toc:[]};function EA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a compound property decorator."))}EA.isMDXComponent=!0;const IA={toc:[]};function WA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A record mapping the property in the compound object to the\ncorresponding property on the owner node."))}WA.isMDXComponent=!0;const UA={toc:[]};function jA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given method into a computed value.\nSee ",(0,p.kt)("a",{parentName:"p",href:"/api/core/signals#createComputed"},(0,p.kt)("inlineCode",{parentName:"a"},"createComputed"))," for more information."))}jA.isMDXComponent=!0;const zA={toc:[]};function FA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a computed method decorator."))}FA.isMDXComponent=!0;const OA={toc:[]};function qA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the initial value of a property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}qA.isMDXComponent=!0;const VA={toc:[]};function BA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@initial(1)\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}BA.isMDXComponent=!0;const HA={toc:[]};function YA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an initial signal value decorator."))}YA.isMDXComponent=!0;const JA={toc:[]};function KA(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The initial value of the property."))}KA.isMDXComponent=!0;const QA={toc:[]};function $A(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QA,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies whether the property should be visible in the\ninspector."),(0,p.kt)("p",null,"By default, any property is inspectable."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}$A.isMDXComponent=!0;const tG={toc:[]};function nG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@inspectable(false)\n  \\@property()\n  public declare hiddenLength: Signal<number, this>;\n}\n")))}nG.isMDXComponent=!0;const eG={toc:[]};function oG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an inspectable property decorator."))}oG.isMDXComponent=!0;const pG={toc:[]};function cG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Whether the property should be inspectable."))}cG.isMDXComponent=!0;const rG={toc:[]};function sG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the interpolation function of a property.\nThe interpolation function is used when tweening between different values."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}sG.isMDXComponent=!0;const aG={toc:[]};function iG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@interpolation(textLerp)\n  \\@property()\n  public declare text: Signal<string, this>;\n}\n")))}iG.isMDXComponent=!0;const lG={toc:[]};function uG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal interpolation function decorator."))}uG.isMDXComponent=!0;const mG={toc:[]};function dG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The interpolation function for the property."))}dG.isMDXComponent=!0;const hG={toc:[]};function yG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator specifies the parser of a property.\nInstead of returning the raw value, its passed as the first parameter to the\nparser and the resulting value is returned."),(0,p.kt)("p",null,"If the wrapper class has a method called ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp")," it will be set as the\ndefault interpolation function for the property."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}yG.isMDXComponent=!0;const kG={toc:[]};function fG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}fG.isMDXComponent=!0;const DG={toc:[]};function MG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},DG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal parser decorator."))}MG.isMDXComponent=!0;const _G={toc:[]};function XG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},_G,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}XG.isMDXComponent=!0;const wG={toc:[]};function TG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},wG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This decorator turns the given property into a signal."),(0,p.kt)("p",null,"The class using this decorator can implement the following methods:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property getter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"get[PropertyName]")," - A property setter."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("inlineCode",{parentName:"li"},"tween[PropertyName]")," - A tween provider.")))}TG.isMDXComponent=!0;const CG={toc:[]};function xG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},CG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@property()\n  public declare length: Signal<number, this>;\n}\n")))}xG.isMDXComponent=!0;const gG={toc:[]};function LG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},gG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal decorator."))}LG.isMDXComponent=!0;const ZG={toc:[]};function bG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},ZG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"This is a shortcut decorator for setting both the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#parser"},(0,p.kt)("inlineCode",{parentName:"a"},"parser"))," and\n",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#interpolation"},(0,p.kt)("inlineCode",{parentName:"a"},"interpolation")),"."),(0,p.kt)("p",null,"The interpolation function will be set only if the wrapper class has a method\ncalled ",(0,p.kt)("inlineCode",{parentName:"p"},"lerp"),", which will be used as said function."),(0,p.kt)("p",null,"Must be specified before the ",(0,p.kt)("a",{parentName:"p",href:"/api/2d/decorators#signal"},(0,p.kt)("inlineCode",{parentName:"a"},"signal"))," decorator."))}bG.isMDXComponent=!0;const vG={toc:[]};function NG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},vG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-ts"},"class Example {\n  \\@wrapper(Vector2)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n\n  // same as:\n  \\@parser(value => new Vector2(value))\n  \\@interpolation(Vector2.lerp)\n  \\@property()\n  public declare offset: Signal<Vector2, this>;\n}\n")))}NG.isMDXComponent=!0;const SG={toc:[]};function AG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},SG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a signal wrapper decorator."))}AG.isMDXComponent=!0;const GG={toc:[]};function PG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},GG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The wrapper class for the property."))}PG.isMDXComponent=!0;const RG={toc:[]};function EG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},RG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"A unified abstraction for all CSS filters."))}EG.isMDXComponent=!0;const IG={toc:[]};function WG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},IG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur"},(0,p.kt)("inlineCode",{parentName:"a"},"blur"))," filter."))}WG.isMDXComponent=!0;const UG={toc:[]};function jG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},UG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in pixels."))}jG.isMDXComponent=!0;const zG={toc:[]};function FG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},zG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness"},(0,p.kt)("inlineCode",{parentName:"a"},"brightness"))," filter."))}FG.isMDXComponent=!0;const OG={toc:[]};function qG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},OG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}qG.isMDXComponent=!0;const VG={toc:[]};function BG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},VG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast"},(0,p.kt)("inlineCode",{parentName:"a"},"contrast"))," filter."))}BG.isMDXComponent=!0;const HG={toc:[]};function YG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},HG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}YG.isMDXComponent=!0;const JG={toc:[]};function KG(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},JG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale"},(0,p.kt)("inlineCode",{parentName:"a"},"grayscale"))," filter."))}KG.isMDXComponent=!0;const QG={toc:[]};function $G(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},QG,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}$G.isMDXComponent=!0;const tP={toc:[]};function nP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},tP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate"},(0,p.kt)("inlineCode",{parentName:"a"},"hue"))," filter."))}nP.isMDXComponent=!0;const eP={toc:[]};function oP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},eP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter in degrees."))}oP.isMDXComponent=!0;const pP={toc:[]};function cP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},pP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create an ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert"},(0,p.kt)("inlineCode",{parentName:"a"},"invert"))," filter."))}cP.isMDXComponent=!0;const rP={toc:[]};function sP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},rP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}sP.isMDXComponent=!0;const aP={toc:[]};function iP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},aP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate"},(0,p.kt)("inlineCode",{parentName:"a"},"saturate"))," filter."))}iP.isMDXComponent=!0;const lP={toc:[]};function uP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},lP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}uP.isMDXComponent=!0;const mP={toc:[]};function dP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},mP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Create a ",(0,p.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia"},(0,p.kt)("inlineCode",{parentName:"a"},"sepia"))," filter."))}dP.isMDXComponent=!0;const hP={toc:[]};function yP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},hP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"The value of the filter."))}yP.isMDXComponent=!0;const kP={toc:[]};function fP(t){let{components:n,...e}=t;return(0,p.kt)("wrapper",(0,o.Z)({},kP,e,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"Update the view."),(0,p.kt)("p",null,"Invoked after each step of the main generator.\nCan be used for calculating layout."),(0,p.kt)("p",null,"Can modify the state of the view."))}fP.isMDXComponent=!0;const DP={content_0_0:r,content_0_1:a,content_0_2:l,content_0_3:m,content_0_4:h,content_0_5:k,content_0_6:D,content_0_7:_,content_0_8:w,content_0_9:C,content_0_10:g,content_0_11:Z,content_0_12:v,content_0_13:S,content_0_14:G,content_0_15:R,content_0_16:I,content_0_17:U,content_0_18:z,content_0_19:O,content_0_20:V,content_0_21:H,content_0_22:J,content_0_23:Q,content_0_24:tt,content_0_25:et,content_0_26:pt,content_0_27:rt,content_0_28:at,content_0_29:lt,content_0_30:mt,content_0_31:ht,content_0_32:kt,content_0_33:Dt,content_0_34:_t,content_0_35:wt,content_0_36:Ct,content_0_37:gt,content_0_38:Zt,content_0_39:vt,content_0_40:St,content_0_41:Gt,content_0_42:Rt,content_0_43:It,content_0_44:Ut,content_0_45:zt,content_0_46:Ot,content_0_47:Vt,content_0_48:Ht,content_0_49:Jt,content_0_50:Qt,content_0_51:tn,content_0_52:en,content_0_53:pn,content_0_54:rn,content_0_55:an,content_0_56:un,content_0_57:dn,content_0_58:yn,content_0_59:fn,content_0_60:Mn,content_0_61:Xn,content_0_62:Tn,content_0_63:xn,content_0_64:Ln,content_0_65:bn,content_0_66:Nn,content_0_67:An,content_0_68:Pn,content_0_69:En,content_0_70:Wn,content_0_71:jn,content_0_72:Fn,content_0_73:qn,content_0_74:Bn,content_0_75:Yn,content_0_76:Kn,content_0_77:$n,content_0_78:ne,content_0_79:oe,content_0_80:ce,content_0_81:se,content_0_82:ie,content_0_83:ue,content_0_84:de,content_0_85:ye,content_0_86:fe,content_0_87:Me,content_0_88:Xe,content_0_89:Te,content_0_90:xe,content_0_91:Le,content_0_92:be,content_0_93:Ne,content_0_94:Ae,content_0_95:Pe,content_0_96:Ee,content_0_97:We,content_0_98:je,content_0_99:Fe,content_0_100:qe,content_0_101:Be,content_0_102:Ye,content_0_103:Ke,content_0_104:$e,content_0_105:no,content_0_106:oo,content_0_107:co,content_0_108:so,content_0_109:io,content_0_110:uo,content_0_111:ho,content_0_112:ko,content_0_113:Do,content_0_114:_o,content_0_115:wo,content_0_116:Co,content_0_117:go,content_0_118:Zo,content_0_119:vo,content_0_120:So,content_0_121:Go,content_0_122:Ro,content_0_123:Io,content_0_124:Uo,content_0_125:zo,content_0_126:Oo,content_0_127:Vo,content_0_128:Ho,content_0_129:Jo,content_0_130:Qo,content_0_131:tp,content_0_132:ep,content_0_133:pp,content_0_134:rp,content_0_135:ap,content_0_136:lp,content_0_137:mp,content_0_138:hp,content_0_139:kp,content_0_140:Dp,content_0_141:_p,content_0_142:wp,content_0_143:Cp,content_0_144:gp,content_0_145:Zp,content_0_146:vp,content_0_147:Sp,content_0_148:Gp,content_0_149:Rp,content_0_150:Ip,content_0_151:Up,content_0_152:zp,content_0_153:Op,content_0_154:Vp,content_0_155:Hp,content_0_156:Jp,content_0_157:Qp,content_0_158:tc,content_0_159:ec,content_0_160:pc,content_0_161:rc,content_0_162:ac,content_0_163:lc,content_0_164:mc,content_0_165:hc,content_0_166:kc,content_0_167:Dc,content_0_168:_c,content_0_169:wc,content_0_170:Cc,content_0_171:gc,content_0_172:Zc,content_0_173:vc,content_0_174:Sc,content_0_175:Gc,content_0_176:Rc,content_0_177:Ic,content_0_178:Uc,content_0_179:zc,content_0_180:Oc,content_0_181:Vc,content_0_182:Hc,content_0_183:Jc,content_0_184:Qc,content_0_185:tr,content_0_186:er,content_0_187:pr,content_0_188:rr,content_0_189:ar,content_0_190:lr,content_0_191:mr,content_0_192:hr,content_0_193:kr,content_0_194:Dr,content_0_195:_r,content_0_196:wr,content_0_197:Cr,content_0_198:gr,content_0_199:Zr,content_0_200:vr,content_0_201:Sr,content_0_202:Gr,content_0_203:Rr,content_0_204:Ir,content_0_205:Ur,content_0_206:zr,content_0_207:Or,content_0_208:Vr,content_0_209:Hr,content_0_210:Jr,content_0_211:Qr,content_0_212:ts,content_0_213:es,content_0_214:ps,content_0_215:rs,content_0_216:as,content_0_217:ls,content_0_218:ms,content_0_219:hs,content_0_220:ks,content_0_221:Ds,content_0_222:_s,content_0_223:ws,content_0_224:Cs,content_0_225:gs,content_0_226:Zs,content_0_227:vs,content_0_228:Ss,content_0_229:Gs,content_0_230:Rs,content_0_231:Is,content_0_232:Us,content_0_233:zs,content_0_234:Os,content_0_235:Vs,content_0_236:Hs,content_0_237:Js,content_0_238:Qs,content_0_239:ta,content_0_240:ea,content_0_241:pa,content_0_242:ra,content_0_243:aa,content_0_244:la,content_0_245:ma,content_0_246:ha,content_0_247:ka,content_0_248:Da,content_0_249:_a,content_0_250:wa,content_0_251:Ca,content_0_252:ga,content_0_253:Za,content_0_254:va,content_0_255:Sa,content_0_256:Ga,content_0_257:Ra,content_0_258:Ia,content_0_259:Ua,content_0_260:za,content_0_261:Oa,content_0_262:Va,content_0_263:Ha,content_0_264:Ja,content_0_265:Qa,content_0_266:ti,content_0_267:ei,content_0_268:pi,content_0_269:ri,content_0_270:ai,content_0_271:li,content_0_272:mi,content_0_273:hi,content_0_274:ki,content_0_275:Di,content_0_276:_i,content_0_277:wi,content_0_278:Ci,content_0_279:gi,content_0_280:Zi,content_0_281:vi,content_0_282:Si,content_0_283:Gi,content_0_284:Ri,content_0_285:Ii,content_0_286:Ui,content_0_287:zi,content_0_288:Oi,content_0_289:Vi,content_0_290:Hi,content_0_291:Ji,content_0_292:Qi,content_0_293:tl,content_0_294:el,content_0_295:pl,content_0_296:rl,content_0_297:al,content_0_298:ll,content_0_299:ml,content_0_300:hl,content_0_301:kl,content_0_302:Dl,content_0_303:_l,content_0_304:wl,content_0_305:Cl,content_0_306:gl,content_0_307:Zl,content_0_308:vl,content_0_309:Sl,content_0_310:Gl,content_0_311:Rl,content_0_312:Il,content_0_313:Ul,content_0_314:zl,content_0_315:Ol,content_0_316:Vl,content_0_317:Hl,content_0_318:Jl,content_0_319:Ql,content_0_320:tu,content_0_321:eu,content_0_322:pu,content_0_323:ru,content_0_324:au,content_0_325:lu,content_0_326:mu,content_0_327:hu,content_0_328:ku,content_0_329:Du,content_0_330:_u,content_0_331:wu,content_0_332:Cu,content_0_333:gu,content_0_334:Zu,content_0_335:vu,content_0_336:Su,content_0_337:Gu,content_0_338:Ru,content_0_339:Iu,content_0_340:Uu,content_0_341:zu,content_0_342:Ou,content_0_343:Vu,content_0_344:Hu,content_0_345:Ju,content_0_346:Qu,content_0_347:tm,content_0_348:em,content_0_349:pm,content_0_350:rm,content_0_351:am,content_0_352:lm,content_0_353:mm,content_0_354:hm,content_0_355:km,content_0_356:Dm,content_0_357:_m,content_0_358:wm,content_0_359:Cm,content_0_360:gm,content_0_361:Zm,content_0_362:vm,content_0_363:Sm,content_0_364:Gm,content_0_365:Rm,content_0_366:Im,content_0_367:Um,content_0_368:zm,content_0_369:Om,content_0_370:Vm,content_0_371:Hm,content_0_372:Jm,content_0_373:Qm,content_0_374:td,content_0_375:ed,content_0_376:pd,content_0_377:rd,content_0_378:ad,content_0_379:ld,content_0_380:md,content_0_381:hd,content_0_382:kd,content_0_383:Dd,content_0_384:_d,content_0_385:wd,content_0_386:Cd,content_0_387:gd,content_0_388:Zd,content_0_389:vd,content_0_390:Sd,content_0_391:Gd,content_0_392:Rd,content_0_393:Id,content_0_394:Ud,content_0_395:zd,content_0_396:Od,content_0_397:Vd,content_0_398:Hd,content_0_399:Jd,content_0_400:Qd,content_0_401:th,content_0_402:eh,content_0_403:ph,content_0_404:rh,content_0_405:ah,content_0_406:lh,content_0_407:mh,content_0_408:hh,content_0_409:kh,content_0_410:Dh,content_0_411:_h,content_0_412:wh,content_0_413:Ch,content_0_414:gh,content_0_415:Zh,content_0_416:vh,content_0_417:Sh,content_0_418:Gh,content_0_419:Rh,content_0_420:Ih,content_0_421:Uh,content_0_422:zh,content_0_423:Oh,content_0_424:Vh,content_0_425:Hh,content_0_426:Jh,content_0_427:Qh,content_0_428:ty,content_0_429:ey,content_0_430:py,content_0_431:ry,content_0_432:ay,content_0_433:ly,content_0_434:my,content_0_435:hy,content_0_436:ky,content_0_437:Dy,content_0_438:_y,content_0_439:wy,content_0_440:Cy,content_0_441:gy,content_0_442:Zy,content_0_443:vy,content_0_444:Sy,content_0_445:Gy,content_0_446:Ry,content_0_447:Iy,content_0_448:Uy,content_0_449:zy,content_0_450:Oy,content_0_451:Vy,content_2116_0:Hy,content_2116_1:Jy,content_2116_2:Qy,content_2116_3:tk,content_2116_4:ek,content_2116_5:pk,content_2116_6:rk,content_2116_7:ak,content_2116_8:lk,content_2116_9:mk,content_2116_10:hk,content_2116_11:kk,content_2116_12:Dk,content_2116_13:_k,content_2116_14:wk,content_2116_15:Ck,content_2116_16:gk,content_2116_17:Zk,content_2116_18:vk,content_2116_19:Sk,content_2116_20:Gk,content_2116_21:Rk,content_2116_22:Ik,content_2116_23:Uk,content_2116_24:zk,content_2116_25:Ok,content_2116_26:Vk,content_2116_27:Hk,content_2116_28:Jk,content_2116_29:Qk,content_2116_30:tf,content_2116_31:ef,content_2116_32:pf,content_2116_33:rf,content_2116_34:af,content_2116_35:uf,content_2116_36:df,content_2116_37:yf,content_2116_38:ff,content_2116_39:Mf,content_2116_40:Xf,content_2116_41:Tf,content_2116_42:xf,content_2116_43:Lf,content_2116_44:bf,content_2116_45:Nf,content_2116_46:Af,content_2116_47:Pf,content_2116_48:Ef,content_2116_49:Wf,content_2116_50:jf,content_2116_51:Ff,content_2116_52:qf,content_2116_53:Bf,content_2116_54:Yf,content_2116_55:Kf,content_2116_56:$f,content_2116_57:nD,content_2116_58:oD,content_2116_59:cD,content_2116_60:sD,content_2116_61:iD,content_2116_62:uD,content_2116_63:dD,content_2116_64:yD,content_2116_65:fD,content_2116_66:MD,content_2116_67:XD,content_2116_68:TD,content_2116_69:xD,content_2116_70:LD,content_2116_71:bD,content_2116_72:ND,content_2116_73:AD,content_2116_74:PD,content_2116_75:ED,content_2116_76:WD,content_2116_77:jD,content_2116_78:FD,content_2116_79:qD,content_2116_80:BD,content_2116_81:YD,content_2116_82:KD,content_2116_83:$D,content_2116_84:nM,content_2116_85:oM,content_2116_86:cM,content_2116_87:sM,content_2116_88:iM,content_2116_89:uM,content_2116_90:dM,content_2116_91:yM,content_2116_92:fM,content_2116_93:MM,content_2116_94:XM,content_2116_95:TM,content_2116_96:xM,content_2116_97:LM,content_2116_98:bM,content_2116_99:NM,content_2116_100:AM,content_2116_101:PM,content_2116_102:EM,content_2116_103:WM,content_2116_104:jM,content_2116_105:FM,content_2116_106:qM,content_2116_107:BM,content_2116_108:YM,content_2116_109:KM,content_2116_110:$M,content_2116_111:n_,content_2116_112:o_,content_2116_113:c_,content_2116_114:s_,content_2116_115:i_,content_2116_116:u_,content_2116_117:d_,content_2116_118:y_,content_2116_119:f_,content_2116_120:M_,content_2116_121:X_,content_2116_122:T_,content_2116_123:x_,content_2116_124:L_,content_2116_125:b_,content_2116_126:N_,content_2116_127:A_,content_2116_128:P_,content_2116_129:E_,content_2116_130:W_,content_2116_131:j_,content_2116_132:F_,content_2116_133:q_,content_2116_134:B_,content_2116_135:Y_,content_2116_136:K_,content_2116_137:$_,content_2116_138:nX,content_2116_139:oX,content_2116_140:cX,content_2116_141:sX,content_2116_142:iX,content_2116_143:uX,content_2116_144:dX,content_2116_145:yX,content_2116_146:fX,content_2116_147:MX,content_2116_148:XX,content_2116_149:TX,content_2116_150:xX,content_2116_151:LX,content_2116_152:bX,content_2116_153:NX,content_2116_154:AX,content_2116_155:PX,content_2116_156:EX,content_2116_157:WX,content_2116_158:jX,content_2116_159:FX,content_2116_160:qX,content_2116_161:BX,content_2116_162:YX,content_2116_163:KX,content_2116_164:$X,content_2116_165:nw,content_2116_166:ow,content_2116_167:cw,content_2116_168:sw,content_2116_169:iw,content_2116_170:uw,content_2116_171:dw,content_2116_172:yw,content_2116_173:fw,content_2116_174:Mw,content_2116_175:Xw,content_2116_176:Tw,content_2116_177:xw,content_2116_178:Lw,content_2116_179:bw,content_2116_180:Nw,content_2116_181:Aw,content_2116_182:Pw,content_2116_183:Ew,content_2116_184:Ww,content_2116_185:jw,content_2116_186:Fw,content_2116_187:qw,content_2116_188:Bw,content_2116_189:Yw,content_2116_190:Kw,content_2116_191:$w,content_2116_192:nT,content_2116_193:oT,content_2116_194:cT,content_2116_195:sT,content_2116_196:iT,content_2116_197:uT,content_2116_198:dT,content_2116_199:yT,content_2116_200:fT,content_2116_201:MT,content_2116_202:XT,content_2116_203:TT,content_2116_204:xT,content_2116_205:LT,content_2116_206:bT,content_2116_207:NT,content_2116_208:AT,content_2116_209:PT,content_2116_210:ET,content_2116_211:WT,content_2116_212:jT,content_2116_213:FT,content_2116_214:qT,content_2116_215:BT,content_2116_216:YT,content_2116_217:KT,content_2116_218:$T,content_2116_219:nC,content_2116_220:oC,content_2116_221:cC,content_2116_222:sC,content_2116_223:iC,content_2116_224:uC,content_2116_225:dC,content_2116_226:yC,content_2116_227:fC,content_2116_228:MC,content_2116_229:XC,content_2116_230:TC,content_2116_231:xC,content_2116_232:LC,content_2116_233:bC,content_2116_234:NC,content_2116_235:AC,content_2116_236:PC,content_2116_237:EC,content_2116_238:WC,content_2116_239:jC,content_2116_240:FC,content_2116_241:qC,content_2116_242:BC,content_2116_243:YC,content_2116_244:KC,content_2116_245:$C,content_2116_246:nx,content_2116_247:ox,content_2116_248:cx,content_2116_249:sx,content_2116_250:ix,content_2116_251:ux,content_2116_252:dx,content_2116_253:yx,content_2116_254:fx,content_2116_255:Mx,content_2116_256:Xx,content_2116_257:Tx,content_2116_258:xx,content_2116_259:Lx,content_2116_260:bx,content_2116_261:Nx,content_2116_262:Ax,content_2116_263:Px,content_2116_264:Ex,content_2116_265:Wx,content_2116_266:jx,content_2116_267:Fx,content_2116_268:qx,content_2116_269:Bx,content_2116_270:Yx,content_2116_271:Kx,content_2116_272:$x,content_2116_273:ng,content_2116_274:og,content_2116_275:cg,content_2116_276:sg,content_2116_277:ig,content_2116_278:ug,content_2116_279:dg,content_2116_280:yg,content_2116_281:fg,content_2116_282:Mg,content_2116_283:Xg,content_2116_284:Tg,content_2116_285:xg,content_2116_286:Lg,content_2116_287:bg,content_2116_288:Ng,content_2116_289:Ag,content_2116_290:Pg,content_2116_291:Eg,content_2116_292:Wg,content_2116_293:jg,content_2116_294:Fg,content_2116_295:qg,content_2116_296:Bg,content_2116_297:Yg,content_2116_298:Kg,content_2116_299:$g,content_2116_300:nL,content_2116_301:oL,content_2116_302:cL,content_2116_303:sL,content_2116_304:iL,content_2116_305:uL,content_2116_306:dL,content_2116_307:yL,content_2116_308:fL,content_2116_309:ML,content_2116_310:XL,content_2116_311:TL,content_2116_312:xL,content_2116_313:LL,content_2116_314:bL,content_2116_315:NL,content_2116_316:AL,content_2116_317:PL,content_2116_318:EL,content_2116_319:WL,content_2116_320:jL,content_2116_321:FL,content_2116_322:qL,content_2116_323:BL,content_2116_324:YL,content_2116_325:KL,content_2116_326:$L,content_2116_327:nZ,content_2116_328:oZ,content_2116_329:cZ,content_2116_330:sZ,content_2116_331:iZ,content_2116_332:uZ,content_2116_333:dZ,content_2116_334:yZ,content_2116_335:fZ,content_2116_336:MZ,content_2116_337:XZ,content_2116_338:TZ,content_2116_339:xZ,content_2116_340:LZ,content_2116_341:bZ,content_2116_342:NZ,content_2116_343:AZ,content_2116_344:PZ,content_2116_345:EZ,content_2116_346:WZ,content_2116_347:jZ,content_2116_348:FZ,content_2116_349:qZ,content_2116_350:BZ,content_2116_351:YZ,content_2116_352:KZ,content_2116_353:$Z,content_2116_354:nb,content_2116_355:ob,content_2116_356:cb,content_2116_357:sb,content_2116_358:ib,content_2116_359:ub,content_2116_360:db,content_2116_361:yb,content_2116_362:fb,content_2116_363:Mb,content_2116_364:Xb,content_2116_365:Tb,content_2116_366:xb,content_2116_367:Lb,content_2116_368:bb,content_2116_369:Nb,content_2116_370:Ab,content_2116_371:Pb,content_2116_372:Eb,content_2116_373:Wb,content_2116_374:jb,content_2116_375:Fb,content_2116_376:qb,content_2116_377:Bb,content_2116_378:Yb,content_2116_379:Kb,content_2116_380:$b,content_2116_381:nv,content_2116_382:ov,content_2116_383:cv,content_2116_384:sv,content_2116_385:iv,content_2116_386:uv,content_2116_387:dv,content_2116_388:yv,content_2116_389:fv,content_2116_390:Mv,content_2116_391:Xv,content_2116_392:Tv,content_2116_393:xv,content_2116_394:Lv,content_2116_395:bv,content_2116_396:Nv,content_2116_397:Av,content_2116_398:Pv,content_2116_399:Ev,content_2116_400:Wv,content_2116_401:jv,content_2116_402:Fv,content_2116_403:qv,content_2116_404:Bv,content_2116_405:Yv,content_2116_406:Kv,content_2116_407:$v,content_2116_408:nN,content_2116_409:oN,content_2116_410:cN,content_2116_411:sN,content_2116_412:iN,content_2116_413:uN,content_2116_414:dN,content_2116_415:yN,content_2116_416:fN,content_2116_417:MN,content_2116_418:XN,content_2116_419:TN,content_2116_420:xN,content_2116_421:LN,content_2116_422:bN,content_2116_423:NN,content_2116_424:AN,content_2116_425:PN,content_2116_426:EN,content_2116_427:WN,content_2116_428:jN,content_2116_429:FN,content_2116_430:qN,content_2116_431:BN,content_2116_432:YN,content_2116_433:KN,content_2116_434:$N,content_2116_435:nS,content_2116_436:oS,content_2116_437:cS,content_2116_438:sS,content_2116_439:iS,content_2116_440:uS,content_2116_441:dS,content_2116_442:yS,content_2116_443:fS,content_2116_444:MS,content_2116_445:XS,content_2116_446:TS,content_2116_447:xS,content_2116_448:LS,content_2116_449:bS,content_2116_450:NS,content_2116_451:AS,content_2116_452:PS,content_2116_453:ES,content_2116_454:WS,content_2116_455:jS,content_2116_456:FS,content_2116_457:qS,content_2116_458:BS,content_2116_459:YS,content_2116_460:KS,content_2116_461:$S,content_2116_462:nA,content_2116_463:oA,content_2116_464:cA,content_2116_465:sA,content_2116_466:iA,content_2116_467:uA,content_2116_468:dA,content_2116_469:yA,content_2116_470:fA,content_2116_471:MA,content_2116_472:XA,content_2116_473:TA,content_2116_474:xA,content_2116_475:LA,content_2116_476:bA,content_2116_477:NA,content_2116_478:AA,content_2116_479:PA,content_2116_480:EA,content_2116_481:WA,content_2116_482:jA,content_2116_483:FA,content_2116_484:qA,content_2116_485:BA,content_2116_486:YA,content_2116_487:KA,content_2116_488:$A,content_2116_489:nG,content_2116_490:oG,content_2116_491:cG,content_2116_492:sG,content_2116_493:iG,content_2116_494:uG,content_2116_495:dG,content_2116_496:yG,content_2116_497:fG,content_2116_498:MG,content_2116_499:XG,content_2116_500:TG,content_2116_501:xG,content_2116_502:LG,content_2116_503:bG,content_2116_504:NG,content_2116_505:AG,content_2116_506:PG,content_2116_507:EG,content_2116_508:WG,content_2116_509:jG,content_2116_510:FG,content_2116_511:qG,content_2116_512:BG,content_2116_513:YG,content_2116_514:KG,content_2116_515:$G,content_2116_516:nP,content_2116_517:oP,content_2116_518:cP,content_2116_519:sP,content_2116_520:iP,content_2116_521:uP,content_2116_522:dP,content_2116_523:yP,content_2116_524:fP}}}]);